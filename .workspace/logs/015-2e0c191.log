=== 任务 015-2e0c191 执行日志 ===
时间: 2025-09-21 20:19:23.416075
Prompt:
请在 .workspace 内，依据 .workspace/todolist/todolist-015-2e0c191.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/015-2e0c191/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："015-2e0c191：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 015-2e0c191

=== 输出 ===
[2025-09-21T12:12:19] OpenAI Codex v0.39.0 (research preview)
--------
workdir: /Users/jqwang/104-CommitLens-codex/.workspace
model: gpt-5-codex-high
provider: codex
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
--------
[2025-09-21T12:12:19] User instructions:
请在 .workspace 内，依据 .workspace/todolist/todolist-015-2e0c191.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/015-2e0c191/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："015-2e0c191：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 015-2e0c191

[2025-09-21T12:12:24] thinking

**Preparing to gather project info**
[2025-09-21T12:12:24] exec bash -lc 'ls -la' in /Users/jqwang/104-CommitLens-codex/.workspace/.workspace
[2025-09-21T12:12:24] bash -lc 'ls -la' exited -1 in 0ms:
No such file or directory (os error 2)
[2025-09-21T12:12:24] tokens used: 851

[2025-09-21T12:12:26] thinking

**Adjusting workdir to absolute path**
[2025-09-21T12:12:27] exec bash -lc 'ls -la' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T12:12:27] bash -lc 'ls -la' succeeded in 14ms:
total 6176
drwxr-xr-x@  9 jqwang  staff      288 Sep 21 15:57 .
drwxr-xr-x@ 29 jqwang  staff      928 Sep 21 07:49 ..
-rw-r--r--@  1 jqwang  staff      103 Sep 21 20:12 codex_error.txt
-rw-r--r--@  1 jqwang  staff  3113247 Sep 21 20:12 codex_output.txt
-rw-r--r--@  1 jqwang  staff        7 Sep 21 20:12 codex_status.txt
drwxr-xr-x@ 22 jqwang  staff      704 Sep 21 19:31 logs
drwxr-xr-x@ 12 jqwang  staff      384 Sep 21 19:41 rust-project
-rw-r--r--@  1 jqwang  staff      383 Sep 21 20:12 task_status.json
drwxr-xr-x@  5 jqwang  staff      160 Sep 21 20:12 todolist
[2025-09-21T12:12:27] tokens used: 1,114

[2025-09-21T12:12:29] thinking

**Opening report file with cat**
[2025-09-21T12:12:29] exec bash -lc 'cat todolist/todolist-015-2e0c191.tex' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T12:12:29] bash -lc 'cat todolist/todolist-015-2e0c191.tex' succeeded in 12ms:
\section{提交考古：015-2e0c191}

\subsection*{Commit 元信息}
\begin{itemize}
  \item 标题：handle remote branches, exclude branches that require no column
  \item 作者：Martin Lange <\texttt{martin\_lange\_@gmx.net}>
  \item 日期：2020-12-20T22:17:16+01:00
\end{itemize}

\subsection*{变更摘要（阅读提示）}
\begin{verbatim}
HEAD:   src/graph.rs | +is_remote 字段；远程分支名称截取；列分配过滤空范围
        src/main.rs  | 打印调整（range 简化、列缺省处理）
        src/settings.rs | include_remote 默认改为 true
HEAD-1: 引入 assign_branch_columns；支持 include_remote 标志（默认 false）
HEAD-2: 建立分支追踪与 range 计算；git_flow 配置与排序基线
\end{verbatim}

\subsection*{差异解读（证据）}
\begin{itemize}
[2025-09-21T12:12:29] tokens used: 1,599

[2025-09-21T12:12:33] thinking

**Preparing to reconstruct source files**
[2025-09-21T12:12:33] exec bash -lc 'ls -R todolist/figs/015-2e0c191' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T12:12:33] bash -lc 'ls -R todolist/figs/015-2e0c191' exited 1 in 35ms:
ls: todolist/figs/015-2e0c191: No such file or directory
[2025-09-21T12:12:33] tokens used: 3,465

[2025-09-21T12:12:36] thinking

**Checking existing workspace files**
[2025-09-21T12:12:36] exec bash -lc 'ls -R' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:12:36] bash -lc 'ls -R' succeeded in 15ms:
Cargo.lock
Cargo.toml
LICENSE
README.md
scripts
src
target

./scripts:
linearize-history.sh

./src:
graph.rs
lib.rs
main.rs
settings.rs
text.rs

./target:
CACHEDIR.TAG
[2025-09-21T12:12:36] tokens used: 3,672

[2025-09-21T12:12:38] thinking

**Checking src/graph.rs content**
[2025-09-21T12:12:38] exec bash -lc "sed -n '1,200p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:12:38] bash -lc "sed -n '1,200p' src/graph.rs" succeeded in 31ms:
use crate::settings::{BranchSettings, Settings};
use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
use std::collections::{BTreeMap, HashMap};

pub struct CommitInfo {
    pub id: Oid,
    pub parent_ids: Vec<Oid>,
    pub branches: Vec<usize>,
    pub branch_trace: Option<usize>,
}

pub struct BranchInfo {
    pub name: String,
    pub target: Oid,
    pub target_index: usize,
    pub order_group: usize,
    pub range: Option<(usize, usize)>,
    pub deleted: bool,
    pub column: Option<usize>,
}
[2025-09-21T12:12:38] tokens used: 4,467

[2025-09-21T12:12:40] thinking

**Requesting more of the file**
[2025-09-21T12:12:41] exec bash -lc "sed -n '200,400p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:12:41] bash -lc "sed -n '200,400p' src/graph.rs" succeeded in 33ms:
            Some(trace) if trace == branch_index => break,
            Some(_) => {}
            None => {
                commits[index].branch_trace = Some(branch_index);
                any_assigned = true;
                range_end = index;
            }
        }

        let parent_index = commits[index]
            .parent_ids
            .iter()
            .filter_map(|oid| indices.get(oid))
            .copied()
            .next();

        current = parent_index;
    }

    if any_assigned {
[2025-09-21T12:12:41] tokens used: 6,188

[2025-09-21T12:12:43] thinking

**Identifying necessary updates in source file**
[2025-09-21T12:12:43] exec bash -lc 'cat src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:12:43] bash -lc 'cat src/main.rs' succeeded in 35ms:
use git2::{Error, Oid};
use git_graph::{
    graph::{BranchInfo, CommitInfo, GitGraph},
    settings::Settings,
};
use itertools::Itertools;

fn main() -> Result<(), Error> {
    let settings = Settings::git_flow();
    run(".", &settings)
}

fn run(path: &str, settings: &Settings) -> Result<(), Error> {
    let graph = GitGraph::new(path, settings)?;

    for info in graph.commits() {
        print_commit_short(&graph, info)?;
    }

    Ok(())
[2025-09-21T12:12:43] tokens used: 7,069

[2025-09-21T12:12:45] thinking

**Checking src/settings.rs**
[2025-09-21T12:12:45] exec bash -lc 'cat src/settings.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:12:45] bash -lc 'cat src/settings.rs' succeeded in 32ms:
#[derive(Debug)]
pub struct Settings {
    pub include_remote: bool,
    pub branches: BranchSettings,
}

impl Default for Settings {
    fn default() -> Self {
        Self::git_flow()
    }
}

impl Settings {
    /// Returns settings tuned for the conventional git-flow branch layout.
    pub fn git_flow() -> Self {
        Self {
            include_remote: false,
            branches: BranchSettings::git_flow(),
        }
    }
[2025-09-21T12:12:45] tokens used: 8,168

[2025-09-21T12:14:00] thinking

**Planning branch info and logic updates**
**Interpreting branch range traversal fix**
[2025-09-21T12:14:00] codex
**Interpreting branch range traversal fix**
[2025-09-21T12:14:00] exec bash -lc ls in /Users/jqwang/104-CommitLens-codex/.workspace/todolist
[2025-09-21T12:14:00] bash -lc ls succeeded in 31ms:
figs
task_meta.json
todolist-015-2e0c191.tex
[2025-09-21T12:14:00] tokens used: 13,136

[2025-09-21T12:14:02] thinking

**Checking for zipped figs folder**
[2025-09-21T12:14:02] exec bash -lc 'ls -R figs' in /Users/jqwang/104-CommitLens-codex/.workspace/todolist
[2025-09-21T12:14:02] bash -lc 'ls -R figs' succeeded in 31ms:
algorithm_flow.puml
architecture.puml
[2025-09-21T12:14:02] tokens used: 13,348

[2025-09-21T12:14:07] thinking

**Checking for architecture files**
[2025-09-21T12:14:07] exec bash -lc 'cat figs/algorithm_flow.puml' in /Users/jqwang/104-CommitLens-codex/.workspace/todolist
[2025-09-21T12:14:07] bash -lc 'cat figs/algorithm_flow.puml' succeeded in 29ms:
@startuml
title 分支提取与列分配流程（处理远程分支）
skinparam dpi 180
skinparam shadowing false

start
:遍历 repository.branches(filter);
if (include_remote?) then (是)
  :`filter = None`;
else (否)
  :`filter = Local`;
endif

:对每个 (branch, tp) 取 name;
if (tp == Remote?) then (是)
  :start_index = 13;\nname = n[13..];\nis_remote = true;
else (否)
  :start_index = 11;\nname = n[11..];\nis_remote = false;
endif

[2025-09-21T12:14:07] tokens used: 13,547

[2025-09-21T12:14:09] thinking

**Identifying needs for architecture diagram**
[2025-09-21T12:14:09] exec bash -lc 'cat figs/architecture.puml' in /Users/jqwang/104-CommitLens-codex/.workspace/todolist
[2025-09-21T12:14:09] bash -lc 'cat figs/architecture.puml' succeeded in 8ms:
@startuml
title 处理远程分支与列分配调整
skinparam dpi 180
skinparam shadowing false
skinparam ArrowColor #555555
skinparam RectangleBorderColor #777777
skinparam RectangleBackgroundColor #F8F8F8

package "graph.rs" {
  class BranchInfo {
    + target: Oid
    + target_index: Option<usize>
    + name: String
    + is_remote: bool <<added>>
    + order_group: usize
    + column: Option<usize>
    + deleted: bool
    + range: (Option<usize>, Option<usize>)
  }

[2025-09-21T12:14:09] tokens used: 14,034

[2025-09-21T12:14:46] thinking

**Analyzing BranchInfo and range logic**
[2025-09-21T12:14:47] exec bash -lc 'cargo run --quiet' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:14:57] bash -lc 'cargo run --quiet' exited 124 in 10.01s:

[2025-09-21T12:14:57] tokens used: 17,027

[2025-09-21T12:15:01] thinking

**Adjusting timeout for cargo run**
[2025-09-21T12:15:02] exec bash -lc 'cargo run --quiet' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:15:12] bash -lc 'cargo run --quiet' exited -1 in 0ms:
error: failed to download from `https://static.crates.io/crates/git2/0.13.25/download`

Caused by:
  [6] Couldn't resolve host name (Could not resolve host: static.crates.io)
[2025-09-21T12:15:12] tokens used: 17,277

[2025-09-21T12:15:17] thinking

**Handling offline build constraints**

I’m thinking through how to deal with the network restrictions blocking dependency downloads for building or running the crate. Since cargo run tries to fetch missing libs and fails, I can’t rely on a fresh build or running tests. I’ll focus on code modifications and checking related modules like `text.rs` that might reference `branch_info` fields, keeping within the given constraints.
[2025-09-21T12:15:18] exec bash -lc "sed -n '1,160p' src/text.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:15:18] bash -lc "sed -n '1,160p' src/text.rs" succeeded in 20ms:
use lazy_static::lazy_static;
use regex::Regex;

lazy_static! {
    static ref MERGE_GITLAB: Regex =
        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
    static ref MERGE_GIT_DEFAULT: Regex =
        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
    static ref MERGE_GIT_SOURCE_ONLY: Regex =
        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
    static ref MERGE_GITHUB: Regex =
        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
    static ref MERGE_BITBUCKET: Regex =
        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
}

pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
    let summary = summary.trim();

    if let Some(captures) = MERGE_GITLAB.captures(summary) {
[2025-09-21T12:15:18] tokens used: 17,744

[2025-09-21T12:15:20] thinking

**Checking for modifications in lib.rs**
[2025-09-21T12:15:20] exec bash -lc 'cat src/lib.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:15:20] bash -lc 'cat src/lib.rs' succeeded in 32ms:
pub mod graph;
pub mod settings;
pub mod text;
[2025-09-21T12:15:20] tokens used: 18,902

[2025-09-21T12:16:18] thinking

**Outlining detailed branch-related code changes**
[2025-09-21T12:16:31] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -15,2 +15,3 @@
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
@@ -101,2 +102,3 @@
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
@@ -109,8 +111,10 @@
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
@@ -151,3 +155,3 @@
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
@@ -164,3 +168,3 @@
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| branch_info(branch, branch_type, indices, &settings.branches))
         .collect::<Vec<_>>();
[2025-09-21T12:16:31] apply_patch(auto_approved=true) exited 0 in 28ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T12:16:31] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..6013a6d86ef38838305579339a5cded9de88bd32
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -149,7 +153,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +166,7 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| branch_info(branch, branch_type, indices, &settings.branches))
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {

[2025-09-21T12:16:31] tokens used: 23,565
[2025-09-21T12:16:31] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..6013a6d86ef38838305579339a5cded9de88bd32
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -149,7 +153,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +166,7 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| branch_info(branch, branch_type, indices, &settings.branches))
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {


[2025-09-21T12:16:39] thinking

**Updating branch_short_name and related logic**

I’m focusing on fixing the mismatch in the `branch_short_name` function signature by adding the `branch_type` parameter to align with its calls and updating related functions like `branch_order` and `branch_info`. There’s also consideration for handling remote HEAD branches and ensuring we skip or normalize certain branches properly, plus tweaking several other functions to use the new normalized branch names consistently.
[2025-09-21T12:16:43] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -184,7 +184,11 @@
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
[2025-09-21T12:16:43] apply_patch(auto_approved=true) exited 0 in 21ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T12:16:43] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..4dd4a3ebbaaf670e06803f9517ddfcc4a087a62b
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -149,7 +153,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +166,7 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| branch_info(branch, branch_type, indices, &settings.branches))
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +182,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(

[2025-09-21T12:16:43] tokens used: 25,131
[2025-09-21T12:16:43] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..4dd4a3ebbaaf670e06803f9517ddfcc4a087a62b
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -149,7 +153,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +166,7 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| branch_info(branch, branch_type, indices, &settings.branches))
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +182,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(


[2025-09-21T12:16:53] thinking

**Revising branch name normalization**

I'm exploring how to handle remote branch names by normalizing them, particularly stripping the "origin/" prefix for consistency in sorting. This involves updating functions like `branch_order` and `branch_persistence` to use a helper that normalizes names, carefully considering that only `origin/` should be stripped and other remotes might remain untouched. It's a bit tricky because local branch names may contain slashes, so I can't just remove everything before the first slash. I'll adjust the sorting logic accordingly.
[2025-09-21T12:16:54] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -127,2 +127,3 @@
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
@@ -135,2 +136,3 @@
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
@@ -144,2 +146,6 @@
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
[2025-09-21T12:16:54] apply_patch(auto_approved=true) exited 0 in 27ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T12:16:54] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..0cb274eb0c8fcb5ed0918b312d4a4e263d0a6ebf
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,7 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| branch_info(branch, branch_type, indices, &settings.branches))
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +188,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(

[2025-09-21T12:16:54] tokens used: 26,343
[2025-09-21T12:16:54] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..0cb274eb0c8fcb5ed0918b312d4a4e263d0a6ebf
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,7 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| branch_info(branch, branch_type, indices, &settings.branches))
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +188,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(


[2025-09-21T12:16:58] thinking

**Updating branch assignment logic**
[2025-09-21T12:16:59] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -252,2 +252,6 @@
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
[2025-09-21T12:16:59] apply_patch(auto_approved=true) exited 0 in 28ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T12:16:59] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..9cb3ef359f98c6624cb88b6a6f5d42e3842c3197
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,7 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| branch_info(branch, branch_type, indices, &settings.branches))
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +188,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -236,6 +250,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }

[2025-09-21T12:16:59] tokens used: 26,974
[2025-09-21T12:16:59] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..9cb3ef359f98c6624cb88b6a6f5d42e3842c3197
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,7 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| branch_info(branch, branch_type, indices, &settings.branches))
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +188,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -236,6 +250,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }


[2025-09-21T12:17:23] thinking

**Modifying range validation in trace_branch**
[2025-09-21T12:17:25] tokens used: 28,902
[2025-09-21T12:17:25] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..9cb3ef359f98c6624cb88b6a6f5d42e3842c3197
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,7 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| branch_info(branch, branch_type, indices, &settings.branches))
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +188,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -236,6 +250,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }


[2025-09-21T12:17:28] thinking

**Fixing patch application directory**
[2025-09-21T12:17:31] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -210,2 +210,3 @@
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
@@ -229,2 +230,9 @@
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
@@ -232,3 +240,3 @@
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
[2025-09-21T12:17:31] apply_patch(auto_approved=true) exited 0 in 24ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T12:17:31] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..52d9f134b443a66836b4bfbb3216d6629d2006fb
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,7 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| branch_info(branch, branch_type, indices, &settings.branches))
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +188,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +208,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +228,17 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +258,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }

[2025-09-21T12:17:31] tokens used: 29,723
[2025-09-21T12:17:31] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..52d9f134b443a66836b4bfbb3216d6629d2006fb
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,7 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| branch_info(branch, branch_type, indices, &settings.branches))
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +188,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +208,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +228,17 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +258,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }


[2025-09-21T12:17:37] thinking

**Adding clarifying comment to range check**
[2025-09-21T12:17:38] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -232,2 +232,3 @@
             if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
                 range_valid = false;
[2025-09-21T12:17:38] apply_patch(auto_approved=true) exited 0 in 41ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T12:17:38] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..d4cd4e5784888225ba1d536b17c122eb05cb8bca
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,7 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| branch_info(branch, branch_type, indices, &settings.branches))
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +188,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +208,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +228,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +259,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }

[2025-09-21T12:17:38] tokens used: 30,542
[2025-09-21T12:17:38] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..d4cd4e5784888225ba1d536b17c122eb05cb8bca
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,7 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| branch_info(branch, branch_type, indices, &settings.branches))
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +188,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +208,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +228,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +259,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }


[2025-09-21T12:17:51] thinking

**Adjusting branch display and sorting**

I'm making sure the branch sorting and display logic aligns with recent changes—like skipping branches without ranges and removing range outputs in the branch descriptions. I'll update `describe_branch` to simplify the display, handle optional columns gracefully, and possibly include remote or short commit info, keeping indent and column handling consistent.
[2025-09-21T12:17:54] tokens used: 32,040
[2025-09-21T12:17:54] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..d4cd4e5784888225ba1d536b17c122eb05cb8bca
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,7 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| branch_info(branch, branch_type, indices, &settings.branches))
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +188,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +208,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +228,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +259,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }


[2025-09-21T12:17:56] thinking

**Correcting working directory and re-running**
[2025-09-21T12:17:59] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -54,25 +54,6 @@
 
-    let (end_idx, start_idx) = branch
-        .range
-        .map(|(end, start)| (Some(end), Some(start)))
-        .unwrap_or((None, Some(branch.target_index)));
-
-    let start_label = start_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
-    let end_label = end_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column_suffix = branch
-        .column
-        .map(|col| format!(" (col {})", col))
-        .unwrap_or_default();
+    let column = branch.column.unwrap_or(99);
 
-    format!(
-        "{}[{}-{}] {}{}{}",
-        indent, end_label, start_label, branch.name, deleted_suffix, column_suffix
-    )
+    format!("{}{} (col {}){}", indent, branch.name, column, deleted_suffix)
 }
[2025-09-21T12:17:59] apply_patch(auto_approved=true) exited 0 in 29ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T12:17:59] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..d4cd4e5784888225ba1d536b17c122eb05cb8bca
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,7 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| branch_info(branch, branch_type, indices, &settings.branches))
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +188,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +208,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +228,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +259,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }
diff --git a/src/main.rs b/src/main.rs
index 18e204eaa38a32e82323456f8a1511657aef1059..e458348e1987f323ee5d13ccbfeac58e5dcc9dbe
--- a/src/main.rs
+++ b/src/main.rs
@@ -52,29 +52,10 @@
     let branch = &graph.branches()[index];
     let indent = indent_for_branch(branch);
 
-    let (end_idx, start_idx) = branch
-        .range
-        .map(|(end, start)| (Some(end), Some(start)))
-        .unwrap_or((None, Some(branch.target_index)));
-
-    let start_label = start_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
-    let end_label = end_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column_suffix = branch
-        .column
-        .map(|col| format!(" (col {})", col))
-        .unwrap_or_default();
+    let column = branch.column.unwrap_or(99);
 
-    format!(
-        "{}[{}-{}] {}{}{}",
-        indent, end_label, start_label, branch.name, deleted_suffix, column_suffix
-    )
+    format!("{}{} (col {}){}", indent, branch.name, column, deleted_suffix)
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {

[2025-09-21T12:17:59] tokens used: 33,003
[2025-09-21T12:17:59] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..d4cd4e5784888225ba1d536b17c122eb05cb8bca
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,7 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| branch_info(branch, branch_type, indices, &settings.branches))
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +188,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +208,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +228,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +259,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }
diff --git a/src/main.rs b/src/main.rs
index 18e204eaa38a32e82323456f8a1511657aef1059..e458348e1987f323ee5d13ccbfeac58e5dcc9dbe
--- a/src/main.rs
+++ b/src/main.rs
@@ -52,29 +52,10 @@
     let branch = &graph.branches()[index];
     let indent = indent_for_branch(branch);
 
-    let (end_idx, start_idx) = branch
-        .range
-        .map(|(end, start)| (Some(end), Some(start)))
-        .unwrap_or((None, Some(branch.target_index)));
-
-    let start_label = start_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
-    let end_label = end_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column_suffix = branch
-        .column
-        .map(|col| format!(" (col {})", col))
-        .unwrap_or_default();
+    let column = branch.column.unwrap_or(99);
 
-    format!(
-        "{}[{}-{}] {}{}{}",
-        indent, end_label, start_label, branch.name, deleted_suffix, column_suffix
-    )
+    format!("{}{} (col {}){}", indent, branch.name, column, deleted_suffix)
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {


[2025-09-21T12:18:02] thinking

**Checking for unused function usage**
[2025-09-21T12:18:02] exec bash -lc 'rg "short_id_from_index" -n' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src
[2025-09-21T12:18:02] bash -lc 'rg "short_id_from_index" -n' succeeded in 14ms:
main.rs:84:fn short_id_from_index(graph: &GitGraph, index: usize) -> Option<String> {
[2025-09-21T12:18:02] tokens used: 33,562
[2025-09-21T12:18:02] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..d4cd4e5784888225ba1d536b17c122eb05cb8bca
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,7 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| branch_info(branch, branch_type, indices, &settings.branches))
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +188,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +208,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +228,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +259,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }
diff --git a/src/main.rs b/src/main.rs
index 18e204eaa38a32e82323456f8a1511657aef1059..e458348e1987f323ee5d13ccbfeac58e5dcc9dbe
--- a/src/main.rs
+++ b/src/main.rs
@@ -52,29 +52,10 @@
     let branch = &graph.branches()[index];
     let indent = indent_for_branch(branch);
 
-    let (end_idx, start_idx) = branch
-        .range
-        .map(|(end, start)| (Some(end), Some(start)))
-        .unwrap_or((None, Some(branch.target_index)));
-
-    let start_label = start_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
-    let end_label = end_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column_suffix = branch
-        .column
-        .map(|col| format!(" (col {})", col))
-        .unwrap_or_default();
+    let column = branch.column.unwrap_or(99);
 
-    format!(
-        "{}[{}-{}] {}{}{}",
-        indent, end_label, start_label, branch.name, deleted_suffix, column_suffix
-    )
+    format!("{}{} (col {}){}", indent, branch.name, column, deleted_suffix)
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {


[2025-09-21T12:18:07] thinking

**Removing unused function**
[2025-09-21T12:18:09] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -82,5 +82 @@
 }
-
-fn short_id_from_index(graph: &GitGraph, index: usize) -> Option<String> {
-    graph.commits().get(index).map(|info| short_id(info.id))
-}
[2025-09-21T12:18:09] apply_patch(auto_approved=true) exited 0 in 33ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T12:18:09] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..d4cd4e5784888225ba1d536b17c122eb05cb8bca
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,7 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| branch_info(branch, branch_type, indices, &settings.branches))
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +188,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +208,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +228,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +259,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }
diff --git a/src/main.rs b/src/main.rs
index 18e204eaa38a32e82323456f8a1511657aef1059..2d45ea3f3a0c4dd2b98af881706bba601b24680d
--- a/src/main.rs
+++ b/src/main.rs
@@ -52,29 +52,10 @@
     let branch = &graph.branches()[index];
     let indent = indent_for_branch(branch);
 
-    let (end_idx, start_idx) = branch
-        .range
-        .map(|(end, start)| (Some(end), Some(start)))
-        .unwrap_or((None, Some(branch.target_index)));
-
-    let start_label = start_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
-    let end_label = end_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column_suffix = branch
-        .column
-        .map(|col| format!(" (col {})", col))
-        .unwrap_or_default();
+    let column = branch.column.unwrap_or(99);
 
-    format!(
-        "{}[{}-{}] {}{}{}",
-        indent, end_label, start_label, branch.name, deleted_suffix, column_suffix
-    )
+    format!("{}{} (col {}){}", indent, branch.name, column, deleted_suffix)
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {
@@ -98,8 +79,4 @@
     let mut id = oid.to_string();
     id.truncate(7);
     id
-}
-
-fn short_id_from_index(graph: &GitGraph, index: usize) -> Option<String> {
-    graph.commits().get(index).map(|info| short_id(info.id))
 }

[2025-09-21T12:18:09] tokens used: 33,882
[2025-09-21T12:18:09] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..d4cd4e5784888225ba1d536b17c122eb05cb8bca
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,7 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| branch_info(branch, branch_type, indices, &settings.branches))
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +188,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +208,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +228,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +259,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }
diff --git a/src/main.rs b/src/main.rs
index 18e204eaa38a32e82323456f8a1511657aef1059..2d45ea3f3a0c4dd2b98af881706bba601b24680d
--- a/src/main.rs
+++ b/src/main.rs
@@ -52,29 +52,10 @@
     let branch = &graph.branches()[index];
     let indent = indent_for_branch(branch);
 
-    let (end_idx, start_idx) = branch
-        .range
-        .map(|(end, start)| (Some(end), Some(start)))
-        .unwrap_or((None, Some(branch.target_index)));
-
-    let start_label = start_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
-    let end_label = end_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column_suffix = branch
-        .column
-        .map(|col| format!(" (col {})", col))
-        .unwrap_or_default();
+    let column = branch.column.unwrap_or(99);
 
-    format!(
-        "{}[{}-{}] {}{}{}",
-        indent, end_label, start_label, branch.name, deleted_suffix, column_suffix
-    )
+    format!("{}{} (col {}){}", indent, branch.name, column, deleted_suffix)
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {
@@ -98,8 +79,4 @@
     let mut id = oid.to_string();
     id.truncate(7);
     id
-}
-
-fn short_id_from_index(graph: &GitGraph, index: usize) -> Option<String> {
-    graph.commits().get(index).map(|info| short_id(info.id))
 }


[2025-09-21T12:18:13] thinking

**Reviewing Settings and short_id usage**
[2025-09-21T12:18:14] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/settings.rs
@@ -16,3 +16,3 @@
         Self {
-            include_remote: false,
+            include_remote: true,
             branches: BranchSettings::git_flow(),
[2025-09-21T12:18:14] apply_patch(auto_approved=true) exited 0 in 34ms:
Success. Updated the following files:
M src/settings.rs
[2025-09-21T12:18:14] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..d4cd4e5784888225ba1d536b17c122eb05cb8bca
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,7 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| branch_info(branch, branch_type, indices, &settings.branches))
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +188,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +208,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +228,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +259,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }
diff --git a/src/main.rs b/src/main.rs
index 18e204eaa38a32e82323456f8a1511657aef1059..2d45ea3f3a0c4dd2b98af881706bba601b24680d
--- a/src/main.rs
+++ b/src/main.rs
@@ -52,29 +52,10 @@
     let branch = &graph.branches()[index];
     let indent = indent_for_branch(branch);
 
-    let (end_idx, start_idx) = branch
-        .range
-        .map(|(end, start)| (Some(end), Some(start)))
-        .unwrap_or((None, Some(branch.target_index)));
-
-    let start_label = start_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
-    let end_label = end_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column_suffix = branch
-        .column
-        .map(|col| format!(" (col {})", col))
-        .unwrap_or_default();
+    let column = branch.column.unwrap_or(99);
 
-    format!(
-        "{}[{}-{}] {}{}{}",
-        indent, end_label, start_label, branch.name, deleted_suffix, column_suffix
-    )
+    format!("{}{} (col {}){}", indent, branch.name, column, deleted_suffix)
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {
@@ -98,8 +79,4 @@
     let mut id = oid.to_string();
     id.truncate(7);
     id
-}
-
-fn short_id_from_index(graph: &GitGraph, index: usize) -> Option<String> {
-    graph.commits().get(index).map(|info| short_id(info.id))
 }
diff --git a/src/settings.rs b/src/settings.rs
index 4288428a4057c9cc6bc9fd5bdc6a2c3e163751f3..b25f1cec3dcfa4d21a1a1d4571e99379ec987969
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -14,7 +14,7 @@
     /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
-            include_remote: false,
+            include_remote: true,
             branches: BranchSettings::git_flow(),
         }
     }

[2025-09-21T12:18:14] tokens used: 34,345
[2025-09-21T12:18:14] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..d4cd4e5784888225ba1d536b17c122eb05cb8bca
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,7 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| branch_info(branch, branch_type, indices, &settings.branches))
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +188,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +208,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +228,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +259,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }
diff --git a/src/main.rs b/src/main.rs
index 18e204eaa38a32e82323456f8a1511657aef1059..2d45ea3f3a0c4dd2b98af881706bba601b24680d
--- a/src/main.rs
+++ b/src/main.rs
@@ -52,29 +52,10 @@
     let branch = &graph.branches()[index];
     let indent = indent_for_branch(branch);
 
-    let (end_idx, start_idx) = branch
-        .range
-        .map(|(end, start)| (Some(end), Some(start)))
-        .unwrap_or((None, Some(branch.target_index)));
-
-    let start_label = start_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
-    let end_label = end_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column_suffix = branch
-        .column
-        .map(|col| format!(" (col {})", col))
-        .unwrap_or_default();
+    let column = branch.column.unwrap_or(99);
 
-    format!(
-        "{}[{}-{}] {}{}{}",
-        indent, end_label, start_label, branch.name, deleted_suffix, column_suffix
-    )
+    format!("{}{} (col {}){}", indent, branch.name, column, deleted_suffix)
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {
@@ -98,8 +79,4 @@
     let mut id = oid.to_string();
     id.truncate(7);
     id
-}
-
-fn short_id_from_index(graph: &GitGraph, index: usize) -> Option<String> {
-    graph.commits().get(index).map(|info| short_id(info.id))
 }
diff --git a/src/settings.rs b/src/settings.rs
index 4288428a4057c9cc6bc9fd5bdc6a2c3e163751f3..b25f1cec3dcfa4d21a1a1d4571e99379ec987969
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -14,7 +14,7 @@
     /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
-            include_remote: false,
+            include_remote: true,
             branches: BranchSettings::git_flow(),
         }
     }


[2025-09-21T12:18:20] thinking

**Verifying usage of BranchInfo field**
[2025-09-21T12:18:20] exec bash -lc 'rg "BranchInfo" -n' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src
[2025-09-21T12:18:20] bash -lc 'rg "BranchInfo" -n' succeeded in 14ms:
main.rs:3:    graph::{BranchInfo, CommitInfo, GitGraph},
main.rs:69:fn indent_for_branch(branch: &BranchInfo) -> String {
graph.rs:12:pub struct BranchInfo {
graph.rs:26:    branches: Vec<BranchInfo>,
graph.rs:68:    ) -> Result<Vec<BranchInfo>, git2::Error> {
graph.rs:92:    pub fn branches(&self) -> &[BranchInfo] {
graph.rs:106:) -> Option<BranchInfo> {
graph.rs:115:    Some(BranchInfo {
graph.rs:155:) -> Result<Vec<BranchInfo>, git2::Error> {
graph.rs:205:    branch: &mut BranchInfo,
graph.rs:253:    branches: &mut [BranchInfo],
graph.rs:320:fn branch_interval(branch: &BranchInfo) -> (usize, usize) {
[2025-09-21T12:18:20] tokens used: 34,731
[2025-09-21T12:18:20] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..d4cd4e5784888225ba1d536b17c122eb05cb8bca
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,7 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| branch_info(branch, branch_type, indices, &settings.branches))
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +188,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +208,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +228,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +259,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }
diff --git a/src/main.rs b/src/main.rs
index 18e204eaa38a32e82323456f8a1511657aef1059..2d45ea3f3a0c4dd2b98af881706bba601b24680d
--- a/src/main.rs
+++ b/src/main.rs
@@ -52,29 +52,10 @@
     let branch = &graph.branches()[index];
     let indent = indent_for_branch(branch);
 
-    let (end_idx, start_idx) = branch
-        .range
-        .map(|(end, start)| (Some(end), Some(start)))
-        .unwrap_or((None, Some(branch.target_index)));
-
-    let start_label = start_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
-    let end_label = end_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column_suffix = branch
-        .column
-        .map(|col| format!(" (col {})", col))
-        .unwrap_or_default();
+    let column = branch.column.unwrap_or(99);
 
-    format!(
-        "{}[{}-{}] {}{}{}",
-        indent, end_label, start_label, branch.name, deleted_suffix, column_suffix
-    )
+    format!("{}{} (col {}){}", indent, branch.name, column, deleted_suffix)
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {
@@ -98,8 +79,4 @@
     let mut id = oid.to_string();
     id.truncate(7);
     id
-}
-
-fn short_id_from_index(graph: &GitGraph, index: usize) -> Option<String> {
-    graph.commits().get(index).map(|info| short_id(info.id))
 }
diff --git a/src/settings.rs b/src/settings.rs
index 4288428a4057c9cc6bc9fd5bdc6a2c3e163751f3..b25f1cec3dcfa4d21a1a1d4571e99379ec987969
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -14,7 +14,7 @@
     /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
-            include_remote: false,
+            include_remote: true,
             branches: BranchSettings::git_flow(),
         }
     }


[2025-09-21T12:18:28] thinking

**Evaluating BranchInfo and remote handling**

I’m assessing how the new `is_remote` field in `BranchInfo` is currently unused but might be needed for sorting or displaying remote branches differently; meanwhile, I want to ensure filtering of remote branches in `extract_branches` properly skips remote HEAD branches like `origin/HEAD`. I’m also considering running `cargo fmt` to keep code style consistent even though it’s not explicitly requested.
[2025-09-21T12:18:28] exec bash -lc 'cargo fmt' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:18:28] bash -lc 'cargo fmt' succeeded in 71ms:

[2025-09-21T12:18:28] tokens used: 35,482
[2025-09-21T12:18:28] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..982924ca97e4ce3ef4764cbf2ccc4d1bd4122343
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,9 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +190,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +210,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +230,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +261,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }
diff --git a/src/main.rs b/src/main.rs
index 18e204eaa38a32e82323456f8a1511657aef1059..6e320e9bd9209afaaf06b86efe9caf12162a0a09
--- a/src/main.rs
+++ b/src/main.rs
@@ -52,28 +52,12 @@
     let branch = &graph.branches()[index];
     let indent = indent_for_branch(branch);
 
-    let (end_idx, start_idx) = branch
-        .range
-        .map(|(end, start)| (Some(end), Some(start)))
-        .unwrap_or((None, Some(branch.target_index)));
-
-    let start_label = start_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
-    let end_label = end_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column_suffix = branch
-        .column
-        .map(|col| format!(" (col {})", col))
-        .unwrap_or_default();
+    let column = branch.column.unwrap_or(99);
 
     format!(
-        "{}[{}-{}] {}{}{}",
-        indent, end_label, start_label, branch.name, deleted_suffix, column_suffix
+        "{}{} (col {}){}",
+        indent, branch.name, column, deleted_suffix
     )
 }
 
@@ -98,8 +82,4 @@
     let mut id = oid.to_string();
     id.truncate(7);
     id
-}
-
-fn short_id_from_index(graph: &GitGraph, index: usize) -> Option<String> {
-    graph.commits().get(index).map(|info| short_id(info.id))
 }
diff --git a/src/settings.rs b/src/settings.rs
index 4288428a4057c9cc6bc9fd5bdc6a2c3e163751f3..b25f1cec3dcfa4d21a1a1d4571e99379ec987969
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -14,7 +14,7 @@
     /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
-            include_remote: false,
+            include_remote: true,
             branches: BranchSettings::git_flow(),
         }
     }


[2025-09-21T12:18:33] thinking

**Attempting offline build with Cargo**
[2025-09-21T12:18:34] exec bash -lc 'cargo build --offline' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:18:34] bash -lc 'cargo build --offline' exited -1 in 0ms:
error: failed to download `git2 v0.13.25`

Caused by:
  attempting to make an HTTP request, but --offline was specified
[2025-09-21T12:18:34] tokens used: 35,818
[2025-09-21T12:18:34] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..982924ca97e4ce3ef4764cbf2ccc4d1bd4122343
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,9 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +190,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +210,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +230,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +261,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }
diff --git a/src/main.rs b/src/main.rs
index 18e204eaa38a32e82323456f8a1511657aef1059..6e320e9bd9209afaaf06b86efe9caf12162a0a09
--- a/src/main.rs
+++ b/src/main.rs
@@ -52,28 +52,12 @@
     let branch = &graph.branches()[index];
     let indent = indent_for_branch(branch);
 
-    let (end_idx, start_idx) = branch
-        .range
-        .map(|(end, start)| (Some(end), Some(start)))
-        .unwrap_or((None, Some(branch.target_index)));
-
-    let start_label = start_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
-    let end_label = end_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column_suffix = branch
-        .column
-        .map(|col| format!(" (col {})", col))
-        .unwrap_or_default();
+    let column = branch.column.unwrap_or(99);
 
     format!(
-        "{}[{}-{}] {}{}{}",
-        indent, end_label, start_label, branch.name, deleted_suffix, column_suffix
+        "{}{} (col {}){}",
+        indent, branch.name, column, deleted_suffix
     )
 }
 
@@ -98,8 +82,4 @@
     let mut id = oid.to_string();
     id.truncate(7);
     id
-}
-
-fn short_id_from_index(graph: &GitGraph, index: usize) -> Option<String> {
-    graph.commits().get(index).map(|info| short_id(info.id))
 }
diff --git a/src/settings.rs b/src/settings.rs
index 4288428a4057c9cc6bc9fd5bdc6a2c3e163751f3..b25f1cec3dcfa4d21a1a1d4571e99379ec987969
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -14,7 +14,7 @@
     /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
-            include_remote: false,
+            include_remote: true,
             branches: BranchSettings::git_flow(),
         }
     }


[2025-09-21T12:18:36] thinking

**Checking git status before reporting build issue**
[2025-09-21T12:18:37] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:18:37] bash -lc 'git status -sb' succeeded in 26ms:
## main
 M src/graph.rs
 M src/main.rs
 M src/settings.rs
[2025-09-21T12:18:37] tokens used: 36,045
[2025-09-21T12:18:37] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..982924ca97e4ce3ef4764cbf2ccc4d1bd4122343
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,9 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +190,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +210,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +230,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +261,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }
diff --git a/src/main.rs b/src/main.rs
index 18e204eaa38a32e82323456f8a1511657aef1059..6e320e9bd9209afaaf06b86efe9caf12162a0a09
--- a/src/main.rs
+++ b/src/main.rs
@@ -52,28 +52,12 @@
     let branch = &graph.branches()[index];
     let indent = indent_for_branch(branch);
 
-    let (end_idx, start_idx) = branch
-        .range
-        .map(|(end, start)| (Some(end), Some(start)))
-        .unwrap_or((None, Some(branch.target_index)));
-
-    let start_label = start_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
-    let end_label = end_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column_suffix = branch
-        .column
-        .map(|col| format!(" (col {})", col))
-        .unwrap_or_default();
+    let column = branch.column.unwrap_or(99);
 
     format!(
-        "{}[{}-{}] {}{}{}",
-        indent, end_label, start_label, branch.name, deleted_suffix, column_suffix
+        "{}{} (col {}){}",
+        indent, branch.name, column, deleted_suffix
     )
 }
 
@@ -98,8 +82,4 @@
     let mut id = oid.to_string();
     id.truncate(7);
     id
-}
-
-fn short_id_from_index(graph: &GitGraph, index: usize) -> Option<String> {
-    graph.commits().get(index).map(|info| short_id(info.id))
 }
diff --git a/src/settings.rs b/src/settings.rs
index 4288428a4057c9cc6bc9fd5bdc6a2c3e163751f3..b25f1cec3dcfa4d21a1a1d4571e99379ec987969
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -14,7 +14,7 @@
     /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
-            include_remote: false,
+            include_remote: true,
             branches: BranchSettings::git_flow(),
         }
     }


[2025-09-21T12:18:40] thinking

**Reviewing source file changes**
[2025-09-21T12:18:40] exec bash -lc "sed -n '1,220p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:18:40] bash -lc "sed -n '1,220p' src/graph.rs" succeeded in 10ms:
use crate::settings::{BranchSettings, Settings};
use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
use std::collections::{BTreeMap, HashMap};

pub struct CommitInfo {
    pub id: Oid,
    pub parent_ids: Vec<Oid>,
    pub branches: Vec<usize>,
    pub branch_trace: Option<usize>,
}

pub struct BranchInfo {
    pub name: String,
    pub target: Oid,
    pub target_index: usize,
    pub is_remote: bool,
    pub order_group: usize,
    pub range: Option<(usize, usize)>,
    pub deleted: bool,
    pub column: Option<usize>,
[2025-09-21T12:18:40] tokens used: 36,277
[2025-09-21T12:18:40] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..982924ca97e4ce3ef4764cbf2ccc4d1bd4122343
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,9 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +190,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +210,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +230,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +261,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }
diff --git a/src/main.rs b/src/main.rs
index 18e204eaa38a32e82323456f8a1511657aef1059..6e320e9bd9209afaaf06b86efe9caf12162a0a09
--- a/src/main.rs
+++ b/src/main.rs
@@ -52,28 +52,12 @@
     let branch = &graph.branches()[index];
     let indent = indent_for_branch(branch);
 
-    let (end_idx, start_idx) = branch
-        .range
-        .map(|(end, start)| (Some(end), Some(start)))
-        .unwrap_or((None, Some(branch.target_index)));
-
-    let start_label = start_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
-    let end_label = end_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column_suffix = branch
-        .column
-        .map(|col| format!(" (col {})", col))
-        .unwrap_or_default();
+    let column = branch.column.unwrap_or(99);
 
     format!(
-        "{}[{}-{}] {}{}{}",
-        indent, end_label, start_label, branch.name, deleted_suffix, column_suffix
+        "{}{} (col {}){}",
+        indent, branch.name, column, deleted_suffix
     )
 }
 
@@ -98,8 +82,4 @@
     let mut id = oid.to_string();
     id.truncate(7);
     id
-}
-
-fn short_id_from_index(graph: &GitGraph, index: usize) -> Option<String> {
-    graph.commits().get(index).map(|info| short_id(info.id))
 }
diff --git a/src/settings.rs b/src/settings.rs
index 4288428a4057c9cc6bc9fd5bdc6a2c3e163751f3..b25f1cec3dcfa4d21a1a1d4571e99379ec987969
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -14,7 +14,7 @@
     /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
-            include_remote: false,
+            include_remote: true,
             branches: BranchSettings::git_flow(),
         }
     }


[2025-09-21T12:18:42] thinking

**Continuing patch verification**
[2025-09-21T12:18:42] exec bash -lc "sed -n '220,440p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:18:42] bash -lc "sed -n '220,440p' src/graph.rs" succeeded in 10ms:
                commits[index].branch_trace = Some(branch_index);
                any_assigned = true;
                range_end = index;
            }
        }

        let parent_index = commits[index]
            .parent_ids
            .iter()
            .filter_map(|oid| indices.get(oid))
            .copied()
            .next();

        if let Some(parent_index) = parent_index {
            if parent_index < range_end {
                // Jumping forward indicates a non-contiguous range; skip column assignment.
                range_valid = false;
                break;
            }
        }
[2025-09-21T12:18:42] tokens used: 38,239
[2025-09-21T12:18:42] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..982924ca97e4ce3ef4764cbf2ccc4d1bd4122343
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,9 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +190,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +210,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +230,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +261,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }
diff --git a/src/main.rs b/src/main.rs
index 18e204eaa38a32e82323456f8a1511657aef1059..6e320e9bd9209afaaf06b86efe9caf12162a0a09
--- a/src/main.rs
+++ b/src/main.rs
@@ -52,28 +52,12 @@
     let branch = &graph.branches()[index];
     let indent = indent_for_branch(branch);
 
-    let (end_idx, start_idx) = branch
-        .range
-        .map(|(end, start)| (Some(end), Some(start)))
-        .unwrap_or((None, Some(branch.target_index)));
-
-    let start_label = start_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
-    let end_label = end_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column_suffix = branch
-        .column
-        .map(|col| format!(" (col {})", col))
-        .unwrap_or_default();
+    let column = branch.column.unwrap_or(99);
 
     format!(
-        "{}[{}-{}] {}{}{}",
-        indent, end_label, start_label, branch.name, deleted_suffix, column_suffix
+        "{}{} (col {}){}",
+        indent, branch.name, column, deleted_suffix
     )
 }
 
@@ -98,8 +82,4 @@
     let mut id = oid.to_string();
     id.truncate(7);
     id
-}
-
-fn short_id_from_index(graph: &GitGraph, index: usize) -> Option<String> {
-    graph.commits().get(index).map(|info| short_id(info.id))
 }
diff --git a/src/settings.rs b/src/settings.rs
index 4288428a4057c9cc6bc9fd5bdc6a2c3e163751f3..b25f1cec3dcfa4d21a1a1d4571e99379ec987969
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -14,7 +14,7 @@
     /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
-            include_remote: false,
+            include_remote: true,
             branches: BranchSettings::git_flow(),
         }
     }


[2025-09-21T12:18:47] thinking

**Preparing final code checks**
[2025-09-21T12:18:47] exec bash -lc 'git diff' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:18:47] bash -lc 'git diff' succeeded in 33ms:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d..982924c 100644
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@ pub struct BranchInfo {
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@ impl GitGraph {
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
[2025-09-21T12:18:47] tokens used: 39,412
[2025-09-21T12:18:47] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..982924ca97e4ce3ef4764cbf2ccc4d1bd4122343
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,9 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +190,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +210,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +230,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +261,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }
diff --git a/src/main.rs b/src/main.rs
index 18e204eaa38a32e82323456f8a1511657aef1059..6e320e9bd9209afaaf06b86efe9caf12162a0a09
--- a/src/main.rs
+++ b/src/main.rs
@@ -52,28 +52,12 @@
     let branch = &graph.branches()[index];
     let indent = indent_for_branch(branch);
 
-    let (end_idx, start_idx) = branch
-        .range
-        .map(|(end, start)| (Some(end), Some(start)))
-        .unwrap_or((None, Some(branch.target_index)));
-
-    let start_label = start_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
-    let end_label = end_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column_suffix = branch
-        .column
-        .map(|col| format!(" (col {})", col))
-        .unwrap_or_default();
+    let column = branch.column.unwrap_or(99);
 
     format!(
-        "{}[{}-{}] {}{}{}",
-        indent, end_label, start_label, branch.name, deleted_suffix, column_suffix
+        "{}{} (col {}){}",
+        indent, branch.name, column, deleted_suffix
     )
 }
 
@@ -98,8 +82,4 @@
     let mut id = oid.to_string();
     id.truncate(7);
     id
-}
-
-fn short_id_from_index(graph: &GitGraph, index: usize) -> Option<String> {
-    graph.commits().get(index).map(|info| short_id(info.id))
 }
diff --git a/src/settings.rs b/src/settings.rs
index 4288428a4057c9cc6bc9fd5bdc6a2c3e163751f3..b25f1cec3dcfa4d21a1a1d4571e99379ec987969
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -14,7 +14,7 @@
     /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
-            include_remote: false,
+            include_remote: true,
             branches: BranchSettings::git_flow(),
         }
     }


[2025-09-21T12:18:52] thinking

**Cleaning up unused code and imports**
[2025-09-21T12:18:52] exec bash -lc 'git add -A' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:18:52] bash -lc 'git add -A' succeeded in 38ms:

[2025-09-21T12:18:52] tokens used: 41,597
[2025-09-21T12:18:52] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..982924ca97e4ce3ef4764cbf2ccc4d1bd4122343
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,9 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +190,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +210,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +230,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +261,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }
diff --git a/src/main.rs b/src/main.rs
index 18e204eaa38a32e82323456f8a1511657aef1059..6e320e9bd9209afaaf06b86efe9caf12162a0a09
--- a/src/main.rs
+++ b/src/main.rs
@@ -52,28 +52,12 @@
     let branch = &graph.branches()[index];
     let indent = indent_for_branch(branch);
 
-    let (end_idx, start_idx) = branch
-        .range
-        .map(|(end, start)| (Some(end), Some(start)))
-        .unwrap_or((None, Some(branch.target_index)));
-
-    let start_label = start_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
-    let end_label = end_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column_suffix = branch
-        .column
-        .map(|col| format!(" (col {})", col))
-        .unwrap_or_default();
+    let column = branch.column.unwrap_or(99);
 
     format!(
-        "{}[{}-{}] {}{}{}",
-        indent, end_label, start_label, branch.name, deleted_suffix, column_suffix
+        "{}{} (col {}){}",
+        indent, branch.name, column, deleted_suffix
     )
 }
 
@@ -98,8 +82,4 @@
     let mut id = oid.to_string();
     id.truncate(7);
     id
-}
-
-fn short_id_from_index(graph: &GitGraph, index: usize) -> Option<String> {
-    graph.commits().get(index).map(|info| short_id(info.id))
 }
diff --git a/src/settings.rs b/src/settings.rs
index 4288428a4057c9cc6bc9fd5bdc6a2c3e163751f3..b25f1cec3dcfa4d21a1a1d4571e99379ec987969
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -14,7 +14,7 @@
     /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
-            include_remote: false,
+            include_remote: true,
             branches: BranchSettings::git_flow(),
         }
     }

[2025-09-21T12:18:55] exec bash -lc 'git commit -m "015-2e0c191：复现提交代码内容。"' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:18:55] bash -lc 'git commit -m "015-2e0c191：复现提交代码内容。"' succeeded in 49ms:
[main 80b0f1b] 015-2e0c191：复现提交代码内容。
 3 files changed, 43 insertions(+), 34 deletions(-)
[2025-09-21T12:18:55] tokens used: 41,827
[2025-09-21T12:18:55] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..982924ca97e4ce3ef4764cbf2ccc4d1bd4122343
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,9 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +190,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +210,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +230,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +261,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }
diff --git a/src/main.rs b/src/main.rs
index 18e204eaa38a32e82323456f8a1511657aef1059..6e320e9bd9209afaaf06b86efe9caf12162a0a09
--- a/src/main.rs
+++ b/src/main.rs
@@ -52,28 +52,12 @@
     let branch = &graph.branches()[index];
     let indent = indent_for_branch(branch);
 
-    let (end_idx, start_idx) = branch
-        .range
-        .map(|(end, start)| (Some(end), Some(start)))
-        .unwrap_or((None, Some(branch.target_index)));
-
-    let start_label = start_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
-    let end_label = end_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column_suffix = branch
-        .column
-        .map(|col| format!(" (col {})", col))
-        .unwrap_or_default();
+    let column = branch.column.unwrap_or(99);
 
     format!(
-        "{}[{}-{}] {}{}{}",
-        indent, end_label, start_label, branch.name, deleted_suffix, column_suffix
+        "{}{} (col {}){}",
+        indent, branch.name, column, deleted_suffix
     )
 }
 
@@ -98,8 +82,4 @@
     let mut id = oid.to_string();
     id.truncate(7);
     id
-}
-
-fn short_id_from_index(graph: &GitGraph, index: usize) -> Option<String> {
-    graph.commits().get(index).map(|info| short_id(info.id))
 }
diff --git a/src/settings.rs b/src/settings.rs
index 4288428a4057c9cc6bc9fd5bdc6a2c3e163751f3..b25f1cec3dcfa4d21a1a1d4571e99379ec987969
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -14,7 +14,7 @@
     /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
-            include_remote: false,
+            include_remote: true,
             branches: BranchSettings::git_flow(),
         }
     }


[2025-09-21T12:18:57] thinking

**Checking commit status**
[2025-09-21T12:18:57] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:18:57] bash -lc 'git status -sb' succeeded in 37ms:
## main
[2025-09-21T12:18:57] tokens used: 42,072
[2025-09-21T12:18:57] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..982924ca97e4ce3ef4764cbf2ccc4d1bd4122343
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,9 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +190,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +210,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +230,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +261,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }
diff --git a/src/main.rs b/src/main.rs
index 18e204eaa38a32e82323456f8a1511657aef1059..6e320e9bd9209afaaf06b86efe9caf12162a0a09
--- a/src/main.rs
+++ b/src/main.rs
@@ -52,28 +52,12 @@
     let branch = &graph.branches()[index];
     let indent = indent_for_branch(branch);
 
-    let (end_idx, start_idx) = branch
-        .range
-        .map(|(end, start)| (Some(end), Some(start)))
-        .unwrap_or((None, Some(branch.target_index)));
-
-    let start_label = start_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
-    let end_label = end_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column_suffix = branch
-        .column
-        .map(|col| format!(" (col {})", col))
-        .unwrap_or_default();
+    let column = branch.column.unwrap_or(99);
 
     format!(
-        "{}[{}-{}] {}{}{}",
-        indent, end_label, start_label, branch.name, deleted_suffix, column_suffix
+        "{}{} (col {}){}",
+        indent, branch.name, column, deleted_suffix
     )
 }
 
@@ -98,8 +82,4 @@
     let mut id = oid.to_string();
     id.truncate(7);
     id
-}
-
-fn short_id_from_index(graph: &GitGraph, index: usize) -> Option<String> {
-    graph.commits().get(index).map(|info| short_id(info.id))
 }
diff --git a/src/settings.rs b/src/settings.rs
index 4288428a4057c9cc6bc9fd5bdc6a2c3e163751f3..b25f1cec3dcfa4d21a1a1d4571e99379ec987969
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -14,7 +14,7 @@
     /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
-            include_remote: false,
+            include_remote: true,
             branches: BranchSettings::git_flow(),
         }
     }


[2025-09-21T12:19:01] thinking

**Preparing modification summary with line references**
[2025-09-21T12:19:01] exec bash -lc "nl -ba src/graph.rs | sed -n '1,220p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:19:01] bash -lc "nl -ba src/graph.rs | sed -n '1,220p'" succeeded in 23ms:
     1	use crate::settings::{BranchSettings, Settings};
     2	use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
     3	use std::collections::{BTreeMap, HashMap};
     4	
     5	pub struct CommitInfo {
     6	    pub id: Oid,
     7	    pub parent_ids: Vec<Oid>,
     8	    pub branches: Vec<usize>,
     9	    pub branch_trace: Option<usize>,
    10	}
    11	
    12	pub struct BranchInfo {
    13	    pub name: String,
    14	    pub target: Oid,
    15	    pub target_index: usize,
    16	    pub is_remote: bool,
    17	    pub order_group: usize,
    18	    pub range: Option<(usize, usize)>,
    19	    pub deleted: bool,
    20	    pub column: Option<usize>,
[2025-09-21T12:19:01] tokens used: 42,354
[2025-09-21T12:19:01] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..982924ca97e4ce3ef4764cbf2ccc4d1bd4122343
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,9 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +190,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +210,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +230,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +261,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }
diff --git a/src/main.rs b/src/main.rs
index 18e204eaa38a32e82323456f8a1511657aef1059..6e320e9bd9209afaaf06b86efe9caf12162a0a09
--- a/src/main.rs
+++ b/src/main.rs
@@ -52,28 +52,12 @@
     let branch = &graph.branches()[index];
     let indent = indent_for_branch(branch);
 
-    let (end_idx, start_idx) = branch
-        .range
-        .map(|(end, start)| (Some(end), Some(start)))
-        .unwrap_or((None, Some(branch.target_index)));
-
-    let start_label = start_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
-    let end_label = end_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column_suffix = branch
-        .column
-        .map(|col| format!(" (col {})", col))
-        .unwrap_or_default();
+    let column = branch.column.unwrap_or(99);
 
     format!(
-        "{}[{}-{}] {}{}{}",
-        indent, end_label, start_label, branch.name, deleted_suffix, column_suffix
+        "{}{} (col {}){}",
+        indent, branch.name, column, deleted_suffix
     )
 }
 
@@ -98,8 +82,4 @@
     let mut id = oid.to_string();
     id.truncate(7);
     id
-}
-
-fn short_id_from_index(graph: &GitGraph, index: usize) -> Option<String> {
-    graph.commits().get(index).map(|info| short_id(info.id))
 }
diff --git a/src/settings.rs b/src/settings.rs
index 4288428a4057c9cc6bc9fd5bdc6a2c3e163751f3..b25f1cec3dcfa4d21a1a1d4571e99379ec987969
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -14,7 +14,7 @@
     /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
-            include_remote: false,
+            include_remote: true,
             branches: BranchSettings::git_flow(),
         }
     }


[2025-09-21T12:19:04] thinking

**Waiting for more context**
[2025-09-21T12:19:04] exec bash -lc "nl -ba src/graph.rs | sed -n '220,420p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:19:04] bash -lc "nl -ba src/graph.rs | sed -n '220,420p'" succeeded in 17ms:
   220	                commits[index].branch_trace = Some(branch_index);
   221	                any_assigned = true;
   222	                range_end = index;
   223	            }
   224	        }
   225	
   226	        let parent_index = commits[index]
   227	            .parent_ids
   228	            .iter()
   229	            .filter_map(|oid| indices.get(oid))
   230	            .copied()
   231	            .next();
   232	
   233	        if let Some(parent_index) = parent_index {
   234	            if parent_index < range_end {
   235	                // Jumping forward indicates a non-contiguous range; skip column assignment.
   236	                range_valid = false;
   237	                break;
   238	            }
   239	        }
[2025-09-21T12:19:04] tokens used: 45,150
[2025-09-21T12:19:04] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..982924ca97e4ce3ef4764cbf2ccc4d1bd4122343
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,9 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +190,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +210,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +230,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +261,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }
diff --git a/src/main.rs b/src/main.rs
index 18e204eaa38a32e82323456f8a1511657aef1059..6e320e9bd9209afaaf06b86efe9caf12162a0a09
--- a/src/main.rs
+++ b/src/main.rs
@@ -52,28 +52,12 @@
     let branch = &graph.branches()[index];
     let indent = indent_for_branch(branch);
 
-    let (end_idx, start_idx) = branch
-        .range
-        .map(|(end, start)| (Some(end), Some(start)))
-        .unwrap_or((None, Some(branch.target_index)));
-
-    let start_label = start_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
-    let end_label = end_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column_suffix = branch
-        .column
-        .map(|col| format!(" (col {})", col))
-        .unwrap_or_default();
+    let column = branch.column.unwrap_or(99);
 
     format!(
-        "{}[{}-{}] {}{}{}",
-        indent, end_label, start_label, branch.name, deleted_suffix, column_suffix
+        "{}{} (col {}){}",
+        indent, branch.name, column, deleted_suffix
     )
 }
 
@@ -98,8 +82,4 @@
     let mut id = oid.to_string();
     id.truncate(7);
     id
-}
-
-fn short_id_from_index(graph: &GitGraph, index: usize) -> Option<String> {
-    graph.commits().get(index).map(|info| short_id(info.id))
 }
diff --git a/src/settings.rs b/src/settings.rs
index 4288428a4057c9cc6bc9fd5bdc6a2c3e163751f3..b25f1cec3dcfa4d21a1a1d4571e99379ec987969
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -14,7 +14,7 @@
     /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
-            include_remote: false,
+            include_remote: true,
             branches: BranchSettings::git_flow(),
         }
     }


[2025-09-21T12:19:06] thinking

**Requesting line numbers in source file**
[2025-09-21T12:19:06] exec bash -lc 'nl -ba src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:19:06] bash -lc 'nl -ba src/main.rs' succeeded in 14ms:
     1	use git2::{Error, Oid};
     2	use git_graph::{
     3	    graph::{BranchInfo, CommitInfo, GitGraph},
     4	    settings::Settings,
     5	};
     6	use itertools::Itertools;
     7	
     8	fn main() -> Result<(), Error> {
     9	    let settings = Settings::git_flow();
    10	    run(".", &settings)
    11	}
    12	
    13	fn run(path: &str, settings: &Settings) -> Result<(), Error> {
    14	    let graph = GitGraph::new(path, settings)?;
    15	
    16	    for info in graph.commits() {
    17	        print_commit_short(&graph, info)?;
    18	    }
    19	
    20	    Ok(())
[2025-09-21T12:19:06] tokens used: 46,571
[2025-09-21T12:19:06] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..982924ca97e4ce3ef4764cbf2ccc4d1bd4122343
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,9 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +190,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +210,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +230,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +261,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }
diff --git a/src/main.rs b/src/main.rs
index 18e204eaa38a32e82323456f8a1511657aef1059..6e320e9bd9209afaaf06b86efe9caf12162a0a09
--- a/src/main.rs
+++ b/src/main.rs
@@ -52,28 +52,12 @@
     let branch = &graph.branches()[index];
     let indent = indent_for_branch(branch);
 
-    let (end_idx, start_idx) = branch
-        .range
-        .map(|(end, start)| (Some(end), Some(start)))
-        .unwrap_or((None, Some(branch.target_index)));
-
-    let start_label = start_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
-    let end_label = end_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column_suffix = branch
-        .column
-        .map(|col| format!(" (col {})", col))
-        .unwrap_or_default();
+    let column = branch.column.unwrap_or(99);
 
     format!(
-        "{}[{}-{}] {}{}{}",
-        indent, end_label, start_label, branch.name, deleted_suffix, column_suffix
+        "{}{} (col {}){}",
+        indent, branch.name, column, deleted_suffix
     )
 }
 
@@ -98,8 +82,4 @@
     let mut id = oid.to_string();
     id.truncate(7);
     id
-}
-
-fn short_id_from_index(graph: &GitGraph, index: usize) -> Option<String> {
-    graph.commits().get(index).map(|info| short_id(info.id))
 }
diff --git a/src/settings.rs b/src/settings.rs
index 4288428a4057c9cc6bc9fd5bdc6a2c3e163751f3..b25f1cec3dcfa4d21a1a1d4571e99379ec987969
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -14,7 +14,7 @@
     /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
-            include_remote: false,
+            include_remote: true,
             branches: BranchSettings::git_flow(),
         }
     }


[2025-09-21T12:19:09] thinking

**Locating settings.rs line numbers**
[2025-09-21T12:19:09] exec bash -lc 'nl -ba src/settings.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:19:09] bash -lc 'nl -ba src/settings.rs' succeeded in 19ms:
     1	#[derive(Debug)]
     2	pub struct Settings {
     3	    pub include_remote: bool,
     4	    pub branches: BranchSettings,
     5	}
     6	
     7	impl Default for Settings {
     8	    fn default() -> Self {
     9	        Self::git_flow()
    10	    }
    11	}
    12	
    13	impl Settings {
    14	    /// Returns settings tuned for the conventional git-flow branch layout.
    15	    pub fn git_flow() -> Self {
    16	        Self {
    17	            include_remote: true,
    18	            branches: BranchSettings::git_flow(),
    19	        }
    20	    }
[2025-09-21T12:19:09] tokens used: 47,799
[2025-09-21T12:19:09] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..982924ca97e4ce3ef4764cbf2ccc4d1bd4122343
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,9 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +190,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +210,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +230,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +261,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }
diff --git a/src/main.rs b/src/main.rs
index 18e204eaa38a32e82323456f8a1511657aef1059..6e320e9bd9209afaaf06b86efe9caf12162a0a09
--- a/src/main.rs
+++ b/src/main.rs
@@ -52,28 +52,12 @@
     let branch = &graph.branches()[index];
     let indent = indent_for_branch(branch);
 
-    let (end_idx, start_idx) = branch
-        .range
-        .map(|(end, start)| (Some(end), Some(start)))
-        .unwrap_or((None, Some(branch.target_index)));
-
-    let start_label = start_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
-    let end_label = end_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column_suffix = branch
-        .column
-        .map(|col| format!(" (col {})", col))
-        .unwrap_or_default();
+    let column = branch.column.unwrap_or(99);
 
     format!(
-        "{}[{}-{}] {}{}{}",
-        indent, end_label, start_label, branch.name, deleted_suffix, column_suffix
+        "{}{} (col {}){}",
+        indent, branch.name, column, deleted_suffix
     )
 }
 
@@ -98,8 +82,4 @@
     let mut id = oid.to_string();
     id.truncate(7);
     id
-}
-
-fn short_id_from_index(graph: &GitGraph, index: usize) -> Option<String> {
-    graph.commits().get(index).map(|info| short_id(info.id))
 }
diff --git a/src/settings.rs b/src/settings.rs
index 4288428a4057c9cc6bc9fd5bdc6a2c3e163751f3..b25f1cec3dcfa4d21a1a1d4571e99379ec987969
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -14,7 +14,7 @@
     /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
-            include_remote: false,
+            include_remote: true,
             branches: BranchSettings::git_flow(),
         }
     }


[2025-09-21T12:19:18] thinking

**Summarizing final changes and build attempt**

I’m organizing a detailed final message that explains the remote handling changes with line references, notes the failed offline build attempt due to network issues, and highlights key assumptions like default remote branch column values and `trace_branch` logic. I’ll include the commit and formatting steps and structure the summary with clear headers and bullet points to meet the format requirements.
[2025-09-21T12:19:19] codex

**复现内容**
- 在 `BranchInfo` 中新增远程标记并在分支解析阶段带入 `BranchType`，构建时对 `refs/heads/` 与 `refs/remotes/` 分别截取短名、同步写入 `is_remote`（`src/graph.rs:12-125`）。
- 调整排序辅助函数以忽略 `origin/` 前缀，使远程与本地分支共用排序与持久度规则（`src/graph.rs:127-149`）。
- 远程分支采集改为保留 `(Branch, BranchType)`，列分配仅处理具备 `range` 的分支，避免空范围占列（`src/graph.rs:151-320`）。
- `trace_branch` 检测回溯过程的前向跳跃，一旦区间不连续则放弃列分配，确保图形布局稳定（`src/graph.rs:204-250`）。
- 终端输出版块去除区间打印并对缺失列号使用 `unwrap_or(99)` 补齐显示，兼容被过滤列的分支（`src/main.rs:51-61`）。
- 默认启用远程分支展示，对应 `Settings::git_flow()` 将 `include_remote` 设为 `true`（`src/settings.rs:15-20`）。

**验证**
- `cargo build --offline`（失败：依赖 `git2 v0.13.25` 需联网下载，受限于无网络环境）。

**备注**
- 依据报告中的 PlantUML 流程与差异描述实现远程分支截取和列过滤；`trace_branch` 的“不连续即弃用”依据报告描述做了最小化实现，如需进一步佐证需在可构建环境下观察实际仓库输出。
[2025-09-21T12:19:23] tokens used: 49,309
[2025-09-21T12:19:23] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 6ffb89d51fff35c60ed9129f6e9a161a860ee315..982924ca97e4ce3ef4764cbf2ccc4d1bd4122343
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -13,6 +13,7 @@
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
+    pub is_remote: bool,
     pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
@@ -99,6 +100,7 @@
 
 fn branch_info(
     branch: Branch,
+    branch_type: BranchType,
     indices: &HashMap<Oid, usize>,
     settings: &BranchSettings,
 ) -> Option<BranchInfo> {
@@ -107,12 +109,14 @@
     let target = reference.target()?;
 
     let target_index = indices.get(&target).copied()?;
-    let order_group = branch_order(branch_short_name(name), settings);
+    let short_name = branch_short_name(name, branch_type);
+    let order_group = branch_order(short_name, settings);
 
     Some(BranchInfo {
-        name: branch_short_name(name).to_string(),
+        name: short_name.to_string(),
         target,
         target_index,
+        is_remote: branch_type == BranchType::Remote,
         order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
@@ -121,6 +125,7 @@
 }
 
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .persistence
         .iter()
@@ -129,6 +134,7 @@
 }
 
 fn branch_order(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
     settings
         .order
         .iter()
@@ -138,6 +144,10 @@
         .unwrap_or(settings.order.len())
 }
 
+fn normalized_branch_name(name: &str) -> &str {
+    name.strip_prefix("origin/").unwrap_or(name)
+}
+
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
@@ -149,7 +159,7 @@
         let mut iter = repo.branches(Some(branch_type))?;
         while let Some(branch_result) = iter.next() {
             let (branch, _) = branch_result?;
-            branches.push(branch);
+            branches.push((branch, branch_type));
         }
         Ok(())
     };
@@ -162,7 +172,9 @@
 
     let mut branch_infos = branches
         .into_iter()
-        .filter_map(|branch| branch_info(branch, indices, &settings.branches))
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
         .collect::<Vec<_>>();
 
     branch_infos.sort_by(|left, right| {
@@ -178,11 +190,15 @@
     Ok(branch_infos)
 }
 
-fn branch_short_name(reference_name: &str) -> &str {
-    reference_name
-        .strip_prefix("refs/heads/")
-        .or_else(|| reference_name.strip_prefix("refs/remotes/"))
-        .unwrap_or(reference_name)
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
 }
 
 fn trace_branch(
@@ -194,6 +210,7 @@
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_end = branch.target_index;
+    let mut range_valid = true;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
@@ -213,10 +230,18 @@
             .copied()
             .next();
 
+        if let Some(parent_index) = parent_index {
+            if parent_index < range_end {
+                // Jumping forward indicates a non-contiguous range; skip column assignment.
+                range_valid = false;
+                break;
+            }
+        }
+
         current = parent_index;
     }
 
-    if any_assigned {
+    if any_assigned && range_valid {
         branch.range = Some((range_end, branch.target_index));
     } else {
         branch.range = None;
@@ -236,6 +261,10 @@
 
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
+        if branch.range.is_none() {
+            continue;
+        }
+
         // Group index may exceed configured order length; keep as-is for stable layout.
         groups.entry(branch.order_group).or_default().push(index);
     }
diff --git a/src/main.rs b/src/main.rs
index 18e204eaa38a32e82323456f8a1511657aef1059..6e320e9bd9209afaaf06b86efe9caf12162a0a09
--- a/src/main.rs
+++ b/src/main.rs
@@ -52,28 +52,12 @@
     let branch = &graph.branches()[index];
     let indent = indent_for_branch(branch);
 
-    let (end_idx, start_idx) = branch
-        .range
-        .map(|(end, start)| (Some(end), Some(start)))
-        .unwrap_or((None, Some(branch.target_index)));
-
-    let start_label = start_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
-    let end_label = end_idx
-        .and_then(|idx| short_id_from_index(graph, idx))
-        .unwrap_or_else(|| "n/a".to_string());
-
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column_suffix = branch
-        .column
-        .map(|col| format!(" (col {})", col))
-        .unwrap_or_default();
+    let column = branch.column.unwrap_or(99);
 
     format!(
-        "{}[{}-{}] {}{}{}",
-        indent, end_label, start_label, branch.name, deleted_suffix, column_suffix
+        "{}{} (col {}){}",
+        indent, branch.name, column, deleted_suffix
     )
 }
 
@@ -98,8 +82,4 @@
     let mut id = oid.to_string();
     id.truncate(7);
     id
-}
-
-fn short_id_from_index(graph: &GitGraph, index: usize) -> Option<String> {
-    graph.commits().get(index).map(|info| short_id(info.id))
 }
diff --git a/src/settings.rs b/src/settings.rs
index 4288428a4057c9cc6bc9fd5bdc6a2c3e163751f3..b25f1cec3dcfa4d21a1a1d4571e99379ec987969
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -14,7 +14,7 @@
     /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
-            include_remote: false,
+            include_remote: true,
             branches: BranchSettings::git_flow(),
         }
     }


=== 错误 ===
2025-09-21T12:12:24.244283Z ERROR codex_core::exec: exec error: No such file or directory (os error 2)

=== 最终状态 ===
返回码: 0
状态: ✅ 执行成功
