=== 任务 016-f620960 执行日志 ===
时间: 2025-09-21 20:28:24.144347
Prompt:
请在 .workspace 内，依据 .workspace/todolist/todolist-016-f620960.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/016-f620960/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："016-f620960：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 016-f620960

=== 输出 ===
[2025-09-21T12:19:29] OpenAI Codex v0.39.0 (research preview)
--------
workdir: /Users/jqwang/104-CommitLens-codex/.workspace
model: gpt-5-codex-high
provider: codex
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
--------
[2025-09-21T12:19:29] User instructions:
请在 .workspace 内，依据 .workspace/todolist/todolist-016-f620960.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/016-f620960/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："016-f620960：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 016-f620960

[2025-09-21T12:19:39] thinking

**Considering approach to planning and environment setup**
[2025-09-21T12:19:39] exec bash -lc 'ls -la' in /Users/jqwang/104-CommitLens-codex/.workspace/.workspace
[2025-09-21T12:19:39] bash -lc 'ls -la' exited -1 in 0ms:
No such file or directory (os error 2)
[2025-09-21T12:19:39] tokens used: 1,223

[2025-09-21T12:19:44] thinking

**Clarifying working directory path**
[2025-09-21T12:19:45] exec bash -lc 'ls -la' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T12:19:45] bash -lc 'ls -la' succeeded in 22ms:
total 8224
drwxr-xr-x@  9 jqwang  staff      288 Sep 21 15:57 .
drwxr-xr-x@ 29 jqwang  staff      928 Sep 21 07:49 ..
-rw-r--r--@  1 jqwang  staff      103 Sep 21 20:19 codex_error.txt
-rw-r--r--@  1 jqwang  staff  3333211 Sep 21 20:19 codex_output.txt
-rw-r--r--@  1 jqwang  staff        7 Sep 21 20:19 codex_status.txt
drwxr-xr-x@ 22 jqwang  staff      704 Sep 21 19:31 logs
drwxr-xr-x@ 12 jqwang  staff      384 Sep 21 19:41 rust-project
-rw-r--r--@  1 jqwang  staff      402 Sep 21 20:19 task_status.json
drwxr-xr-x@  5 jqwang  staff      160 Sep 21 20:19 todolist
[2025-09-21T12:19:45] tokens used: 1,534

[2025-09-21T12:19:48] thinking

**Previewing todo list file**
[2025-09-21T12:19:48] exec bash -lc "sed -n '1,160p' todolist/todolist-016-f620960.tex" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T12:19:48] bash -lc "sed -n '1,160p' todolist/todolist-016-f620960.tex" succeeded in 21ms:
% 明确说明（非常重要），tex必须以\section开头，不能有其他内容，不能使用begin「document」
\section{提交考古：016-f620960}

\subsection*{Commit 元信息}
\begin{itemize}
  \item 标题：fix branch columns and range issues, assign colors
  \item 作者：Martin Lange <martin\_lange\_@gmx.net>
  \item 日期：2020-12-21T19:29:54+01:00
\end{itemize}

\subsection*{变更摘要（阅读提示）}
\begin{verbatim}
HEAD:   src/graph.rs    | 140 +++++++++++++++++++++++++++++++++++++++++++-------------
       src/main.rs     |  16 ++++---
       src/settings.rs |  12 +++++
       3 files changed, 128 insertions(+), 40 deletions(-)
HEAD-1: src/graph.rs    | 30 +++++++++++++++++++++++++-----
       src/main.rs     | 11 +++++++----
       src/settings.rs |  2 +-
       3 files changed, 33 insertions(+), 10 deletions(-)
[2025-09-21T12:19:48] tokens used: 3,403

[2025-09-21T12:19:50] thinking

**Continuing file inspection**
[2025-09-21T12:19:51] exec bash -lc "sed -n '160,320p' todolist/todolist-016-f620960.tex" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T12:19:51] bash -lc "sed -n '160,320p' todolist/todolist-016-f620960.tex" succeeded in 8ms:

[2025-09-21T12:19:51] tokens used: 5,222

[2025-09-21T12:19:56] thinking

**Checking project repository state**
[2025-09-21T12:19:57] exec bash -lc 'ls -R' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:19:57] bash -lc 'ls -R' succeeded in 15ms:
Cargo.lock
Cargo.toml
LICENSE
README.md
scripts
src
target

./scripts:
linearize-history.sh

./src:
graph.rs
lib.rs
main.rs
settings.rs
text.rs

./target:
CACHEDIR.TAG
[2025-09-21T12:19:57] tokens used: 8,984

[2025-09-21T12:19:59] thinking

**Verifying source files for alignment**
[2025-09-21T12:20:00] exec bash -lc "sed -n '1,200p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:20:00] bash -lc "sed -n '1,200p' src/graph.rs" succeeded in 20ms:
use crate::settings::{BranchSettings, Settings};
use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
use std::collections::{BTreeMap, HashMap};

pub struct CommitInfo {
    pub id: Oid,
    pub parent_ids: Vec<Oid>,
    pub branches: Vec<usize>,
    pub branch_trace: Option<usize>,
}

pub struct BranchInfo {
    pub name: String,
    pub target: Oid,
    pub target_index: usize,
    pub is_remote: bool,
    pub order_group: usize,
    pub range: Option<(usize, usize)>,
    pub deleted: bool,
    pub column: Option<usize>,
[2025-09-21T12:20:00] tokens used: 12,118

[2025-09-21T12:20:02] thinking

**Continuing exploration**
[2025-09-21T12:20:02] exec bash -lc "sed -n '200,400p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:20:02] bash -lc "sed -n '200,400p' src/graph.rs" succeeded in 11ms:
            .unwrap_or(reference_name),
    }
}

fn trace_branch(
    commits: &mut [CommitInfo],
    indices: &HashMap<Oid, usize>,
    branch: &mut BranchInfo,
    branch_index: usize,
) -> bool {
    let mut current = Some(branch.target_index);
    let mut any_assigned = false;
    let mut range_end = branch.target_index;
    let mut range_valid = true;

    while let Some(index) = current {
        match commits[index].branch_trace {
            Some(trace) if trace == branch_index => break,
            Some(_) => {}
            None => {
[2025-09-21T12:20:02] tokens used: 13,857

[2025-09-21T12:20:05] thinking

**Verifying file version and completeness**
[2025-09-21T12:20:05] exec bash -lc "sed -n '400,800p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:20:05] bash -lc "sed -n '400,800p' src/graph.rs" succeeded in 20ms:

[2025-09-21T12:20:05] tokens used: 17,717

[2025-09-21T12:20:09] thinking

**Assessing file sizes for modifications**
[2025-09-21T12:20:09] exec bash -lc "sed -n '1,160p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:20:09] bash -lc "sed -n '1,160p' src/main.rs" succeeded in 22ms:
use git2::{Error, Oid};
use git_graph::{
    graph::{BranchInfo, CommitInfo, GitGraph},
    settings::Settings,
};
use itertools::Itertools;

fn main() -> Result<(), Error> {
    let settings = Settings::git_flow();
    run(".", &settings)
}

fn run(path: &str, settings: &Settings) -> Result<(), Error> {
    let graph = GitGraph::new(path, settings)?;

    for info in graph.commits() {
        print_commit_short(&graph, info)?;
    }

    Ok(())
[2025-09-21T12:20:09] tokens used: 18,997

[2025-09-21T12:20:11] thinking

**Checking for settings.rs**
[2025-09-21T12:20:11] exec bash -lc "sed -n '1,200p' src/settings.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:20:11] bash -lc "sed -n '1,200p' src/settings.rs" succeeded in 11ms:
#[derive(Debug)]
pub struct Settings {
    pub include_remote: bool,
    pub branches: BranchSettings,
}

impl Default for Settings {
    fn default() -> Self {
        Self::git_flow()
    }
}

impl Settings {
    /// Returns settings tuned for the conventional git-flow branch layout.
    pub fn git_flow() -> Self {
        Self {
            include_remote: true,
            branches: BranchSettings::git_flow(),
        }
    }
[2025-09-21T12:20:11] tokens used: 19,911

[2025-09-21T12:21:14] thinking

**Reconstructing final commit structure and logic**

This is a big design task where I need to reconstruct all final code details from the textual description alone. I'll carefully interpret the instructions to redesign data structures like `BranchVis` and `BranchInfo`, add `children` to commits with an `assign_children` function, update `trace_branch` to handle merges and index types properly, extend config settings with branch color mapping, and ensure main output goes to stderr with new info. Since I lack direct diffs or network access, I'll piece together a plausible, coherent implementation that fits the feature descriptions and integrates them thoughtfully.
**Designing enhanced branch tracing and column assignment**

I'm working through detailed logic to revise `trace_branch` for proper merge handling by tracking commit children and adjusting branch ranges accordingly, ensuring type-safe index conversions, and updating `assign_branch_columns` to use new `BranchVis` fields like `order_group` and `column`. This also involves integrating branch color groups in settings and refining the branching data structures to fit the sophisticated merge-aware traversal and display layout described.
**Planning commit and branch data restructuring**

I’m mapping out how to add color groups to branch settings and restructure commit data to store parent and child indices directly as usize for efficiency, updating branch assignment to rely on these new fields. Also, I’m outlining the necessary steps to adjust commit printing to stderr, include branch columns, ranges, and merge markers, and preparing for a major refactor in graph.rs to integrate these changes cleanly.
**Revising trace_branch parameters and commit struct**

I'm considering removing the indices parameter from trace_branch since commits now store parent indices directly, and planning to call assign_parent_indices and assign_children after building commits. Also thinking about possibly dropping parent_ids from CommitInfo if unused elsewhere to simplify the structure.
[2025-09-21T12:23:06] codex
**Designing enhanced branch tracing and column assignment**

I'm working through detailed logic to revise `trace_branch` for proper merge handling by tracking commit children and adjusting branch ranges accordingly, ensuring type-safe index conversions, and updating `assign_branch_columns` to use new `BranchVis` fields like `order_group` and `column`. This also involves integrating branch color groups in settings and refining the branching data structures to fit the sophisticated merge-aware traversal and display layout described.
[2025-09-21T12:23:06] codex
**Planning commit and branch data restructuring**

I’m mapping out how to add color groups to branch settings and restructure commit data to store parent and child indices directly as usize for efficiency, updating branch assignment to rely on these new fields. Also, I’m outlining the necessary steps to adjust commit printing to stderr, include branch columns, ranges, and merge markers, and preparing for a major refactor in graph.rs to integrate these changes cleanly.
[2025-09-21T12:23:06] codex
**Revising trace_branch parameters and commit struct**

I'm considering removing the indices parameter from trace_branch since commits now store parent indices directly, and planning to call assign_parent_indices and assign_children after building commits. Also thinking about possibly dropping parent_ids from CommitInfo if unused elsewhere to simplify the structure.
[2025-09-21T12:23:07] exec bash -lc 'rg "parent_ids" -n' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:23:07] bash -lc 'rg "parent_ids" -n' succeeded in 16ms:
src/graph.rs:7:    pub parent_ids: Vec<Oid>,
src/graph.rs:41:            let parent_ids = commit.parent_ids().collect();
src/graph.rs:45:                parent_ids,
src/graph.rs:227:            .parent_ids
[2025-09-21T12:23:07] tokens used: 44,029

[2025-09-21T12:23:13] thinking

**Evaluating field usage and dependencies**
[2025-09-21T12:23:13] exec bash -lc 'rg "parent_ids" -n ..' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:23:13] bash -lc 'rg "parent_ids" -n ..' succeeded in 28ms:
../logs/005-19d4a97.log:232:    pub parent_ids: Vec<Oid>,
../rust-project/src/graph.rs:7:    pub parent_ids: Vec<Oid>,
../rust-project/src/graph.rs:41:            let parent_ids = commit.parent_ids().collect();
../rust-project/src/graph.rs:45:                parent_ids,
../rust-project/src/graph.rs:227:            .parent_ids
../logs/014-39e562c.log:177:    pub parent_ids: Vec<Oid>,
../logs/014-39e562c.log:3583:     7	    pub parent_ids: Vec<Oid>,
../logs/006-a228ea1.log:211:    pub parent_ids: Vec<Oid>,
../logs/006-a228ea1.log:436:    pub parent_ids: Vec<Oid>,
../logs/006-a228ea1.log:458:            let parent_ids = commit.parent_ids().collect();
../logs/006-a228ea1.log:462:                parent_ids,
../logs/006-a228ea1.log:508:    pub parent_ids: Vec<Oid>,
../logs/006-a228ea1.log:530:            let parent_ids = commit.parent_ids().collect();
../logs/006-a228ea1.log:534:                parent_ids,
../logs/006-a228ea1.log:848:     6	    pub parent_ids: Vec<Oid>,
../logs/013-3091f5b.log:187:    pub parent_ids: Vec<Oid>,
../logs/013-3091f5b.log:502:    pub parent_ids: Vec<Oid>,
../logs/013-3091f5b.log:2218:    pub parent_ids: Vec<Oid>,
../logs/013-3091f5b.log:4413:     7	    pub parent_ids: Vec<Oid>,
../logs/004-2c4b178.log:163:    pub parent_ids: Vec<Oid>,
[2025-09-21T12:23:13] tokens used: 62,384

[2025-09-21T12:23:44] thinking

**Reworking parent link handling and branch tracing**

I'm figuring out how to manage commit parent IDs and indices by storing parent OIDs temporarily and converting them to indices after processing all commits. This approach keeps `parent_ids` for conversion but uses a new `parents` field for indices, enabling accurate branch tracing—including handling merges—by updating `trace_branch` and related functions to respect this structure. I'm planning helper functions like `assign_parent_indices` and `merge_range_anchor` to support this, while ensuring branch ranges are valid and correctly computed.
[2025-09-21T12:23:45] exec bash -lc "sed -n '1,200p' src/lib.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:23:45] bash -lc "sed -n '1,200p' src/lib.rs" succeeded in 8ms:
pub mod graph;
pub mod settings;
pub mod text;
[2025-09-21T12:23:45] tokens used: 67,532

[2025-09-21T12:24:47] thinking

**Planning extensive GitGraph refactor**

I’m drafting a comprehensive rewrite of `src/graph.rs` focused on improving commit and branch tracking with new structs like `BranchVis` for visual info and adding color grouping in branch settings. I need to carefully tweak branch assignment, parent/child linking, and branch column calculations, all while ensuring compatibility and that `Cargo.toml` stays untouched. Next, I’ll produce detailed implementations for these parts, integrating the new color group logic and updating all related functions accordingly.
**Executing GitGraph rewrite and output updates**

I’m preparing to fully replace `src/graph.rs` with the new code crafted earlier, ensuring proper commit of changes. I’ll then update printing functions in `main.rs` to include branch color, column, and range details in commit summaries, switching output to stderr with structured formatting. This step wraps up core graph logic and enhances CLI output with the new branch visualization data.
**Integrating branch color settings and refining indentation logic**

I’m expanding `settings.rs` to add branch color groups alongside existing order and persistence, updating branch-related structs and functions to use these color mappings. I’ll adjust indentation and branch description logic in `main.rs` to incorporate new color info, ensuring consistent references to updated branch fields throughout. Finally, I’ll rewrite `src/graph.rs` completely to reflect these consolidated changes.
[2025-09-21T12:25:48] codex
**Executing GitGraph rewrite and output updates**

I’m preparing to fully replace `src/graph.rs` with the new code crafted earlier, ensuring proper commit of changes. I’ll then update printing functions in `main.rs` to include branch color, column, and range details in commit summaries, switching output to stderr with structured formatting. This step wraps up core graph logic and enhances CLI output with the new branch visualization data.
[2025-09-21T12:25:48] codex
**Integrating branch color settings and refining indentation logic**

I’m expanding `settings.rs` to add branch color groups alongside existing order and persistence, updating branch-related structs and functions to use these color mappings. I’ll adjust indentation and branch description logic in `main.rs` to incorporate new color info, ensuring consistent references to updated branch fields throughout. Finally, I’ll rewrite `src/graph.rs` completely to reflect these consolidated changes.
[2025-09-21T12:25:48] apply_patch auto_approved=true:
D /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
use crate::settings::{BranchSettings, Settings};
use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
use std::collections::{BTreeMap, HashMap};

pub struct CommitInfo {
    pub id: Oid,
    pub parent_ids: Vec<Oid>,
    pub branches: Vec<usize>,
    pub branch_trace: Option<usize>,
}

pub struct BranchInfo {
    pub name: String,
    pub target: Oid,
    pub target_index: usize,
    pub is_remote: bool,
    pub order_group: usize,
    pub range: Option<(usize, usize)>,
    pub deleted: bool,
    pub column: Option<usize>,
}

pub struct GitGraph {
    repo: Repository,
    commits: Vec<CommitInfo>,
    branches: Vec<BranchInfo>,
}

impl GitGraph {
    pub fn new(path: &str, settings: &Settings) -> Result<Self, git2::Error> {
        let repo = Repository::open(path)?;
        let mut revwalk = repo.revwalk()?;
        revwalk.set_sorting(Sort::TOPOLOGICAL | Sort::TIME);
        revwalk.push_head()?;

        let mut commits = Vec::new();
        let mut indices = HashMap::new();
        for (index, oid_result) in revwalk.enumerate() {
            let oid = oid_result?;
            let commit = repo.find_commit(oid)?;
            let parent_ids = commit.parent_ids().collect();
            indices.insert(oid, index);
            commits.push(CommitInfo {
                id: oid,
                parent_ids,
                branches: Vec::new(),
                branch_trace: None,
            });
        }

        let mut graph = GitGraph {
            repo,
            commits,
            branches: Vec::new(),
        };

        let branches = graph.assign_branches(&indices, settings)?;
        graph.branches = branches;
        assign_branch_columns(&graph.commits, &mut graph.branches, settings);

        Ok(graph)
    }

    fn assign_branches(
        &mut self,
        indices: &HashMap<Oid, usize>,
        settings: &Settings,
    ) -> Result<Vec<BranchInfo>, git2::Error> {
        let branch_infos = extract_branches(&self.repo, indices, settings)?;

        let mut result = Vec::new();
        for mut info in branch_infos {
            let branch_index = result.len();
            let assigned_any = trace_branch(&mut self.commits, indices, &mut info, branch_index);

            if !info.deleted {
                self.commits[info.target_index].branches.push(branch_index);
            }

            if assigned_any || !info.deleted {
                result.push(info);
            }
        }

        Ok(result)
    }

    pub fn commits(&self) -> &[CommitInfo] {
        &self.commits
    }

    pub fn branches(&self) -> &[BranchInfo] {
        &self.branches
    }

    pub fn commit(&self, info: &CommitInfo) -> Result<Commit, git2::Error> {
        self.repo.find_commit(info.id)
    }
}

fn branch_info(
    branch: Branch,
    branch_type: BranchType,
    indices: &HashMap<Oid, usize>,
    settings: &BranchSettings,
) -> Option<BranchInfo> {
    let reference = branch.into_reference();
    let name = reference.name()?;
    let target = reference.target()?;

    let target_index = indices.get(&target).copied()?;
    let short_name = branch_short_name(name, branch_type);
    let order_group = branch_order(short_name, settings);

    Some(BranchInfo {
        name: short_name.to_string(),
        target,
        target_index,
        is_remote: branch_type == BranchType::Remote,
        order_group,
        range: None,
        deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
        column: None,
    })
}

fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
    let name = normalized_branch_name(name);
    settings
        .persistence
        .iter()
        .position(|candidate| name.starts_with(candidate))
        .unwrap_or(settings.persistence.len())
}

fn branch_order(name: &str, settings: &BranchSettings) -> usize {
    let name = normalized_branch_name(name);
    settings
        .order
        .iter()
        .enumerate()
        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
        .map(|(index, _)| index)
        .unwrap_or(settings.order.len())
}

fn normalized_branch_name(name: &str) -> &str {
    name.strip_prefix("origin/").unwrap_or(name)
}

fn extract_branches(
    repo: &Repository,
    indices: &HashMap<Oid, usize>,
    settings: &Settings,
) -> Result<Vec<BranchInfo>, git2::Error> {
    let mut branches = Vec::new();

    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
        let mut iter = repo.branches(Some(branch_type))?;
        while let Some(branch_result) = iter.next() {
            let (branch, _) = branch_result?;
            branches.push((branch, branch_type));
        }
        Ok(())
    };

    push_branches(BranchType::Local)?;

    if settings.include_remote {
        push_branches(BranchType::Remote)?;
    }

    let mut branch_infos = branches
        .into_iter()
        .filter_map(|(branch, branch_type)| {
            branch_info(branch, branch_type, indices, &settings.branches)
        })
        .collect::<Vec<_>>();

    branch_infos.sort_by(|left, right| {
        left.order_group
            .cmp(&right.order_group)
            .then(
                branch_persistence(&left.name, &settings.branches)
                    .cmp(&branch_persistence(&right.name, &settings.branches)),
            )
            .then(left.name.cmp(&right.name))
    });

    Ok(branch_infos)
}

fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
    match branch_type {
        BranchType::Local => reference_name
            .strip_prefix("refs/heads/")
            .unwrap_or(reference_name),
        BranchType::Remote => reference_name
            .strip_prefix("refs/remotes/")
            .unwrap_or(reference_name),
    }
}

fn trace_branch(
    commits: &mut [CommitInfo],
    indices: &HashMap<Oid, usize>,
    branch: &mut BranchInfo,
    branch_index: usize,
) -> bool {
    let mut current = Some(branch.target_index);
    let mut any_assigned = false;
    let mut range_end = branch.target_index;
    let mut range_valid = true;

    while let Some(index) = current {
        match commits[index].branch_trace {
            Some(trace) if trace == branch_index => break,
            Some(_) => {}
            None => {
                commits[index].branch_trace = Some(branch_index);
                any_assigned = true;
                range_end = index;
            }
        }

        let parent_index = commits[index]
            .parent_ids
            .iter()
            .filter_map(|oid| indices.get(oid))
            .copied()
            .next();

        if let Some(parent_index) = parent_index {
            if parent_index < range_end {
                // Jumping forward indicates a non-contiguous range; skip column assignment.
                range_valid = false;
                break;
            }
        }

        current = parent_index;
    }

    if any_assigned && range_valid {
        branch.range = Some((range_end, branch.target_index));
    } else {
        branch.range = None;
    }

    any_assigned
}

fn assign_branch_columns(
    _commits: &[CommitInfo],
    branches: &mut [BranchInfo],
    _settings: &Settings,
) {
    if branches.is_empty() {
        return;
    }

    let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
    for (index, branch) in branches.iter().enumerate() {
        if branch.range.is_none() {
            continue;
        }

        // Group index may exceed configured order length; keep as-is for stable layout.
        groups.entry(branch.order_group).or_default().push(index);
    }

    let mut offset = 0;
    for (_group, mut indices) in groups.into_iter() {
        indices.sort_by(|left, right| {
            let left_branch = &branches[*left];
            let right_branch = &branches[*right];
            let (left_start, left_end) = branch_interval(left_branch);
            let (right_start, right_end) = branch_interval(right_branch);

            left_start
                .cmp(&right_start)
                .then(left_end.cmp(&right_end))
                .then(left_branch.name.cmp(&right_branch.name))
        });

        let mut occupied: Vec<Option<usize>> = Vec::new();
        let mut assignments: Vec<(usize, usize)> = Vec::with_capacity(indices.len());

        for &branch_index in &indices {
            let (start, end) = branch_interval(&branches[branch_index]);

            for slot in &mut occupied {
                if let Some(occupied_until) = slot {
                    if *occupied_until < start {
                        *slot = None;
                    }
                }
            }

            let column = if let Some(position) = occupied.iter_mut().position(|slot| slot.is_none())
            {
                occupied[position] = Some(end);
                position
            } else {
                occupied.push(Some(end));
                occupied.len() - 1
            };

            assignments.push((branch_index, column));
        }

        let group_width = occupied.len();

        for (branch_index, column) in assignments {
            branches[branch_index].column = Some(column + offset);
        }

        offset += group_width;
    }
}

fn branch_interval(branch: &BranchInfo) -> (usize, usize) {
    branch
        .range
        .map(|(start, end)| (start.min(end), start.max(end)))
        .unwrap_or_else(|| (branch.target_index, branch.target_index))
}
[2025-09-21T12:25:48] apply_patch(auto_approved=true) exited 0 in 22ms:
Success. Updated the following files:
D src/graph.rs
[2025-09-21T12:25:48] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
deleted file mode 100644
index 982924ca97e4ce3ef4764cbf2ccc4d1bd4122343..0000000000000000000000000000000000000000
--- a/src/graph.rs
+++ /dev/null
@@ -1,327 +0,0 @@
-use crate::settings::{BranchSettings, Settings};
-use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
-use std::collections::{BTreeMap, HashMap};
-
-pub struct CommitInfo {
-    pub id: Oid,
-    pub parent_ids: Vec<Oid>,
-    pub branches: Vec<usize>,
-    pub branch_trace: Option<usize>,
-}
-
-pub struct BranchInfo {
-    pub name: String,
-    pub target: Oid,
-    pub target_index: usize,
-    pub is_remote: bool,
-    pub order_group: usize,
-    pub range: Option<(usize, usize)>,
-    pub deleted: bool,
-    pub column: Option<usize>,
-}
-
-pub struct GitGraph {
-    repo: Repository,
-    commits: Vec<CommitInfo>,
-    branches: Vec<BranchInfo>,
-}
-
-impl GitGraph {
-    pub fn new(path: &str, settings: &Settings) -> Result<Self, git2::Error> {
-        let repo = Repository::open(path)?;
-        let mut revwalk = repo.revwalk()?;
-        revwalk.set_sorting(Sort::TOPOLOGICAL | Sort::TIME);
-        revwalk.push_head()?;
-
-        let mut commits = Vec::new();
-        let mut indices = HashMap::new();
-        for (index, oid_result) in revwalk.enumerate() {
-            let oid = oid_result?;
-            let commit = repo.find_commit(oid)?;
-            let parent_ids = commit.parent_ids().collect();
-            indices.insert(oid, index);
-            commits.push(CommitInfo {
-                id: oid,
-                parent_ids,
-                branches: Vec::new(),
-                branch_trace: None,
-            });
-        }
-
-        let mut graph = GitGraph {
-            repo,
-            commits,
-            branches: Vec::new(),
-        };
-
-        let branches = graph.assign_branches(&indices, settings)?;
-        graph.branches = branches;
-        assign_branch_columns(&graph.commits, &mut graph.branches, settings);
-
-        Ok(graph)
-    }
-
-    fn assign_branches(
-        &mut self,
-        indices: &HashMap<Oid, usize>,
-        settings: &Settings,
-    ) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, indices, settings)?;
-
-        let mut result = Vec::new();
-        for mut info in branch_infos {
-            let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, indices, &mut info, branch_index);
-
-            if !info.deleted {
-                self.commits[info.target_index].branches.push(branch_index);
-            }
-
-            if assigned_any || !info.deleted {
-                result.push(info);
-            }
-        }
-
-        Ok(result)
-    }
-
-    pub fn commits(&self) -> &[CommitInfo] {
-        &self.commits
-    }
-
-    pub fn branches(&self) -> &[BranchInfo] {
-        &self.branches
-    }
-
-    pub fn commit(&self, info: &CommitInfo) -> Result<Commit, git2::Error> {
-        self.repo.find_commit(info.id)
-    }
-}
-
-fn branch_info(
-    branch: Branch,
-    branch_type: BranchType,
-    indices: &HashMap<Oid, usize>,
-    settings: &BranchSettings,
-) -> Option<BranchInfo> {
-    let reference = branch.into_reference();
-    let name = reference.name()?;
-    let target = reference.target()?;
-
-    let target_index = indices.get(&target).copied()?;
-    let short_name = branch_short_name(name, branch_type);
-    let order_group = branch_order(short_name, settings);
-
-    Some(BranchInfo {
-        name: short_name.to_string(),
-        target,
-        target_index,
-        is_remote: branch_type == BranchType::Remote,
-        order_group,
-        range: None,
-        deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
-        column: None,
-    })
-}
-
-fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
-    let name = normalized_branch_name(name);
-    settings
-        .persistence
-        .iter()
-        .position(|candidate| name.starts_with(candidate))
-        .unwrap_or(settings.persistence.len())
-}
-
-fn branch_order(name: &str, settings: &BranchSettings) -> usize {
-    let name = normalized_branch_name(name);
-    settings
-        .order
-        .iter()
-        .enumerate()
-        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
-        .map(|(index, _)| index)
-        .unwrap_or(settings.order.len())
-}
-
-fn normalized_branch_name(name: &str) -> &str {
-    name.strip_prefix("origin/").unwrap_or(name)
-}
-
-fn extract_branches(
-    repo: &Repository,
-    indices: &HashMap<Oid, usize>,
-    settings: &Settings,
-) -> Result<Vec<BranchInfo>, git2::Error> {
-    let mut branches = Vec::new();
-
-    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
-        let mut iter = repo.branches(Some(branch_type))?;
-        while let Some(branch_result) = iter.next() {
-            let (branch, _) = branch_result?;
-            branches.push((branch, branch_type));
-        }
-        Ok(())
-    };
-
-    push_branches(BranchType::Local)?;
-
-    if settings.include_remote {
-        push_branches(BranchType::Remote)?;
-    }
-
-    let mut branch_infos = branches
-        .into_iter()
-        .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
-        })
-        .collect::<Vec<_>>();
-
-    branch_infos.sort_by(|left, right| {
-        left.order_group
-            .cmp(&right.order_group)
-            .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
-            )
-            .then(left.name.cmp(&right.name))
-    });
-
-    Ok(branch_infos)
-}
-
-fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
-    match branch_type {
-        BranchType::Local => reference_name
-            .strip_prefix("refs/heads/")
-            .unwrap_or(reference_name),
-        BranchType::Remote => reference_name
-            .strip_prefix("refs/remotes/")
-            .unwrap_or(reference_name),
-    }
-}
-
-fn trace_branch(
-    commits: &mut [CommitInfo],
-    indices: &HashMap<Oid, usize>,
-    branch: &mut BranchInfo,
-    branch_index: usize,
-) -> bool {
-    let mut current = Some(branch.target_index);
-    let mut any_assigned = false;
-    let mut range_end = branch.target_index;
-    let mut range_valid = true;
-
-    while let Some(index) = current {
-        match commits[index].branch_trace {
-            Some(trace) if trace == branch_index => break,
-            Some(_) => {}
-            None => {
-                commits[index].branch_trace = Some(branch_index);
-                any_assigned = true;
-                range_end = index;
-            }
-        }
-
-        let parent_index = commits[index]
-            .parent_ids
-            .iter()
-            .filter_map(|oid| indices.get(oid))
-            .copied()
-            .next();
-
-        if let Some(parent_index) = parent_index {
-            if parent_index < range_end {
-                // Jumping forward indicates a non-contiguous range; skip column assignment.
-                range_valid = false;
-                break;
-            }
-        }
-
-        current = parent_index;
-    }
-
-    if any_assigned && range_valid {
-        branch.range = Some((range_end, branch.target_index));
-    } else {
-        branch.range = None;
-    }
-
-    any_assigned
-}
-
-fn assign_branch_columns(
-    _commits: &[CommitInfo],
-    branches: &mut [BranchInfo],
-    _settings: &Settings,
-) {
-    if branches.is_empty() {
-        return;
-    }
-
-    let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
-    for (index, branch) in branches.iter().enumerate() {
-        if branch.range.is_none() {
-            continue;
-        }
-
-        // Group index may exceed configured order length; keep as-is for stable layout.
-        groups.entry(branch.order_group).or_default().push(index);
-    }
-
-    let mut offset = 0;
-    for (_group, mut indices) in groups.into_iter() {
-        indices.sort_by(|left, right| {
-            let left_branch = &branches[*left];
-            let right_branch = &branches[*right];
-            let (left_start, left_end) = branch_interval(left_branch);
-            let (right_start, right_end) = branch_interval(right_branch);
-
-            left_start
-                .cmp(&right_start)
-                .then(left_end.cmp(&right_end))
-                .then(left_branch.name.cmp(&right_branch.name))
-        });
-
-        let mut occupied: Vec<Option<usize>> = Vec::new();
-        let mut assignments: Vec<(usize, usize)> = Vec::with_capacity(indices.len());
-
-        for &branch_index in &indices {
-            let (start, end) = branch_interval(&branches[branch_index]);
-
-            for slot in &mut occupied {
-                if let Some(occupied_until) = slot {
-                    if *occupied_until < start {
-                        *slot = None;
-                    }
-                }
-            }
-
-            let column = if let Some(position) = occupied.iter_mut().position(|slot| slot.is_none())
-            {
-                occupied[position] = Some(end);
-                position
-            } else {
-                occupied.push(Some(end));
-                occupied.len() - 1
-            };
-
-            assignments.push((branch_index, column));
-        }
-
-        let group_width = occupied.len();
-
-        for (branch_index, column) in assignments {
-            branches[branch_index].column = Some(column + offset);
-        }
-
-        offset += group_width;
-    }
-}
-
-fn branch_interval(branch: &BranchInfo) -> (usize, usize) {
-    branch
-        .range
-        .map(|(start, end)| (start.min(end), start.max(end)))
-        .unwrap_or_else(|| (branch.target_index, branch.target_index))
-}

[2025-09-21T12:25:48] tokens used: 78,414
[2025-09-21T12:25:48] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
deleted file mode 100644
index 982924ca97e4ce3ef4764cbf2ccc4d1bd4122343..0000000000000000000000000000000000000000
--- a/src/graph.rs
+++ /dev/null
@@ -1,327 +0,0 @@
-use crate::settings::{BranchSettings, Settings};
-use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
-use std::collections::{BTreeMap, HashMap};
-
-pub struct CommitInfo {
-    pub id: Oid,
-    pub parent_ids: Vec<Oid>,
-    pub branches: Vec<usize>,
-    pub branch_trace: Option<usize>,
-}
-
-pub struct BranchInfo {
-    pub name: String,
-    pub target: Oid,
-    pub target_index: usize,
-    pub is_remote: bool,
-    pub order_group: usize,
-    pub range: Option<(usize, usize)>,
-    pub deleted: bool,
-    pub column: Option<usize>,
-}
-
-pub struct GitGraph {
-    repo: Repository,
-    commits: Vec<CommitInfo>,
-    branches: Vec<BranchInfo>,
-}
-
-impl GitGraph {
-    pub fn new(path: &str, settings: &Settings) -> Result<Self, git2::Error> {
-        let repo = Repository::open(path)?;
-        let mut revwalk = repo.revwalk()?;
-        revwalk.set_sorting(Sort::TOPOLOGICAL | Sort::TIME);
-        revwalk.push_head()?;
-
-        let mut commits = Vec::new();
-        let mut indices = HashMap::new();
-        for (index, oid_result) in revwalk.enumerate() {
-            let oid = oid_result?;
-            let commit = repo.find_commit(oid)?;
-            let parent_ids = commit.parent_ids().collect();
-            indices.insert(oid, index);
-            commits.push(CommitInfo {
-                id: oid,
-                parent_ids,
-                branches: Vec::new(),
-                branch_trace: None,
-            });
-        }
-
-        let mut graph = GitGraph {
-            repo,
-            commits,
-            branches: Vec::new(),
-        };
-
-        let branches = graph.assign_branches(&indices, settings)?;
-        graph.branches = branches;
-        assign_branch_columns(&graph.commits, &mut graph.branches, settings);
-
-        Ok(graph)
-    }
-
-    fn assign_branches(
-        &mut self,
-        indices: &HashMap<Oid, usize>,
-        settings: &Settings,
-    ) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, indices, settings)?;
-
-        let mut result = Vec::new();
-        for mut info in branch_infos {
-            let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, indices, &mut info, branch_index);
-
-            if !info.deleted {
-                self.commits[info.target_index].branches.push(branch_index);
-            }
-
-            if assigned_any || !info.deleted {
-                result.push(info);
-            }
-        }
-
-        Ok(result)
-    }
-
-    pub fn commits(&self) -> &[CommitInfo] {
-        &self.commits
-    }
-
-    pub fn branches(&self) -> &[BranchInfo] {
-        &self.branches
-    }
-
-    pub fn commit(&self, info: &CommitInfo) -> Result<Commit, git2::Error> {
-        self.repo.find_commit(info.id)
-    }
-}
-
-fn branch_info(
-    branch: Branch,
-    branch_type: BranchType,
-    indices: &HashMap<Oid, usize>,
-    settings: &BranchSettings,
-) -> Option<BranchInfo> {
-    let reference = branch.into_reference();
-    let name = reference.name()?;
-    let target = reference.target()?;
-
-    let target_index = indices.get(&target).copied()?;
-    let short_name = branch_short_name(name, branch_type);
-    let order_group = branch_order(short_name, settings);
-
-    Some(BranchInfo {
-        name: short_name.to_string(),
-        target,
-        target_index,
-        is_remote: branch_type == BranchType::Remote,
-        order_group,
-        range: None,
-        deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
-        column: None,
-    })
-}
-
-fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
-    let name = normalized_branch_name(name);
-    settings
-        .persistence
-        .iter()
-        .position(|candidate| name.starts_with(candidate))
-        .unwrap_or(settings.persistence.len())
-}
-
-fn branch_order(name: &str, settings: &BranchSettings) -> usize {
-    let name = normalized_branch_name(name);
-    settings
-        .order
-        .iter()
-        .enumerate()
-        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
-        .map(|(index, _)| index)
-        .unwrap_or(settings.order.len())
-}
-
-fn normalized_branch_name(name: &str) -> &str {
-    name.strip_prefix("origin/").unwrap_or(name)
-}
-
-fn extract_branches(
-    repo: &Repository,
-    indices: &HashMap<Oid, usize>,
-    settings: &Settings,
-) -> Result<Vec<BranchInfo>, git2::Error> {
-    let mut branches = Vec::new();
-
-    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
-        let mut iter = repo.branches(Some(branch_type))?;
-        while let Some(branch_result) = iter.next() {
-            let (branch, _) = branch_result?;
-            branches.push((branch, branch_type));
-        }
-        Ok(())
-    };
-
-    push_branches(BranchType::Local)?;
-
-    if settings.include_remote {
-        push_branches(BranchType::Remote)?;
-    }
-
-    let mut branch_infos = branches
-        .into_iter()
-        .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
-        })
-        .collect::<Vec<_>>();
-
-    branch_infos.sort_by(|left, right| {
-        left.order_group
-            .cmp(&right.order_group)
-            .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
-            )
-            .then(left.name.cmp(&right.name))
-    });
-
-    Ok(branch_infos)
-}
-
-fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
-    match branch_type {
-        BranchType::Local => reference_name
-            .strip_prefix("refs/heads/")
-            .unwrap_or(reference_name),
-        BranchType::Remote => reference_name
-            .strip_prefix("refs/remotes/")
-            .unwrap_or(reference_name),
-    }
-}
-
-fn trace_branch(
-    commits: &mut [CommitInfo],
-    indices: &HashMap<Oid, usize>,
-    branch: &mut BranchInfo,
-    branch_index: usize,
-) -> bool {
-    let mut current = Some(branch.target_index);
-    let mut any_assigned = false;
-    let mut range_end = branch.target_index;
-    let mut range_valid = true;
-
-    while let Some(index) = current {
-        match commits[index].branch_trace {
-            Some(trace) if trace == branch_index => break,
-            Some(_) => {}
-            None => {
-                commits[index].branch_trace = Some(branch_index);
-                any_assigned = true;
-                range_end = index;
-            }
-        }
-
-        let parent_index = commits[index]
-            .parent_ids
-            .iter()
-            .filter_map(|oid| indices.get(oid))
-            .copied()
-            .next();
-
-        if let Some(parent_index) = parent_index {
-            if parent_index < range_end {
-                // Jumping forward indicates a non-contiguous range; skip column assignment.
-                range_valid = false;
-                break;
-            }
-        }
-
-        current = parent_index;
-    }
-
-    if any_assigned && range_valid {
-        branch.range = Some((range_end, branch.target_index));
-    } else {
-        branch.range = None;
-    }
-
-    any_assigned
-}
-
-fn assign_branch_columns(
-    _commits: &[CommitInfo],
-    branches: &mut [BranchInfo],
-    _settings: &Settings,
-) {
-    if branches.is_empty() {
-        return;
-    }
-
-    let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
-    for (index, branch) in branches.iter().enumerate() {
-        if branch.range.is_none() {
-            continue;
-        }
-
-        // Group index may exceed configured order length; keep as-is for stable layout.
-        groups.entry(branch.order_group).or_default().push(index);
-    }
-
-    let mut offset = 0;
-    for (_group, mut indices) in groups.into_iter() {
-        indices.sort_by(|left, right| {
-            let left_branch = &branches[*left];
-            let right_branch = &branches[*right];
-            let (left_start, left_end) = branch_interval(left_branch);
-            let (right_start, right_end) = branch_interval(right_branch);
-
-            left_start
-                .cmp(&right_start)
-                .then(left_end.cmp(&right_end))
-                .then(left_branch.name.cmp(&right_branch.name))
-        });
-
-        let mut occupied: Vec<Option<usize>> = Vec::new();
-        let mut assignments: Vec<(usize, usize)> = Vec::with_capacity(indices.len());
-
-        for &branch_index in &indices {
-            let (start, end) = branch_interval(&branches[branch_index]);
-
-            for slot in &mut occupied {
-                if let Some(occupied_until) = slot {
-                    if *occupied_until < start {
-                        *slot = None;
-                    }
-                }
-            }
-
-            let column = if let Some(position) = occupied.iter_mut().position(|slot| slot.is_none())
-            {
-                occupied[position] = Some(end);
-                position
-            } else {
-                occupied.push(Some(end));
-                occupied.len() - 1
-            };
-
-            assignments.push((branch_index, column));
-        }
-
-        let group_width = occupied.len();
-
-        for (branch_index, column) in assignments {
-            branches[branch_index].column = Some(column + offset);
-        }
-
-        offset += group_width;
-    }
-}
-
-fn branch_interval(branch: &BranchInfo) -> (usize, usize) {
-    branch
-        .range
-        .map(|(start, end)| (start.min(end), start.max(end)))
-        .unwrap_or_else(|| (branch.target_index, branch.target_index))
-}


[2025-09-21T12:25:50] thinking

**Creating new source file with cat**
[2025-09-21T12:26:09] exec bash -lc "cat <<'EOF' > src/graph.rs
use crate::settings::{BranchSettings, Settings};
use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
use std::collections::{BTreeMap, HashMap};

pub struct CommitInfo {
    pub id: Oid,
    pub parent_ids: Vec<Oid>,
    pub parents: Vec<usize>,
    pub children: Vec<usize>,
    pub branches: Vec<usize>,
    pub branch_trace: Option<usize>,
}

pub struct BranchVis {
    pub order_group: usize,
    pub color_group: usize,
    pub column: Option<usize>,
}

pub struct BranchInfo {
    pub name: String,
    pub target: Oid,
    pub target_index: usize,
    pub is_remote: bool,
    pub range: Option<(usize, usize)>,
    pub deleted: bool,
    pub visual: BranchVis,
}

pub struct GitGraph {
    repo: Repository,
    commits: Vec<CommitInfo>,
    branches: Vec<BranchInfo>,
}

impl GitGraph {
    pub fn new(path: &str, settings: &Settings) -> Result<Self, git2::Error> {
        let repo = Repository::open(path)?;
        let mut revwalk = repo.revwalk()?;
        revwalk.set_sorting(Sort::TOPOLOGICAL | Sort::TIME);
        revwalk.push_head()?;

        let mut commits = Vec::new();
        let mut indices = HashMap::new();

        for (index, oid_result) in revwalk.enumerate() {
            let oid = oid_result?;
            let commit = repo.find_commit(oid)?;
            let parent_ids = commit.parent_ids().collect();

            indices.insert(oid, index);
            commits.push(CommitInfo {
                id: oid,
                parent_ids,
                parents: Vec::new(),
                children: Vec::new(),
                branches: Vec::new(),
                branch_trace: None,
            });
        }

        let mut graph = GitGraph {
            repo,
            commits,
            branches: Vec::new(),
        };

        assign_parent_indices(&mut graph.commits, &indices);
        assign_children(&mut graph.commits);

        let branches = graph.assign_branches(&indices, settings)?;
        graph.branches = branches;

        assign_branch_columns(&graph.commits, &mut graph.branches, settings);

        Ok(graph)
    }

    fn assign_branches(
        &mut self,
        indices: &HashMap<Oid, usize>,
        settings: &Settings,
    ) -> Result<Vec<BranchInfo>, git2::Error> {
        let branch_infos = extract_branches(&self.repo, indices, settings)?;

        let mut result = Vec::new();
        for mut info in branch_infos {
            let branch_index = result.len();
            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);

            if "'!info.deleted {
                self.commits[info.target_index]
                    .branches
                    .push(branch_index);
            }

            if assigned_any || !info.deleted {
                result.push(info);
            }
        }

        Ok(result)
    }

    pub fn commits(&self) -> &[CommitInfo] {
        &self.commits
    }

    pub fn branches(&self) -> &[BranchInfo] {
        &self.branches
    }

    pub fn commit(&self, info: &CommitInfo) -> Result<Commit, git2::Error> {
        self.repo.find_commit(info.id)
    }
}

fn extract_branches(
    repo: &Repository,
    indices: &HashMap<Oid, usize>,
    settings: &Settings,
) -> Result<Vec<BranchInfo>, git2::Error> {
    let mut branches = Vec::new();

    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
        let mut iter = repo.branches(Some(branch_type))?;
        while let Some(branch_result) = iter.next() {
            let (branch, _) = branch_result?;
            branches.push((branch, branch_type));
        }
        Ok(())
    };

    push_branches(BranchType::Local)?;

    if settings.include_remote {
        push_branches(BranchType::Remote)?;
    }

    let mut branch_infos = branches
        .into_iter()
        .filter_map(|(branch, branch_type)| {
            branch_info(branch, branch_type, indices, &settings.branches)
        })
        .collect::<Vec<_>>();

    branch_infos.sort_by(|left, right| {
        left.visual
            .order_group
            .cmp(&right.visual.order_group)
            .then(
                branch_persistence(&left.name, &settings.branches)
                    .cmp(&branch_persistence(&right.name, &settings.branches)),
            )
            .then(left.name.cmp(&right.name))
    });

    Ok(branch_infos)
}

fn branch_info(
    branch: Branch,
    branch_type: BranchType,
    indices: &HashMap<Oid, usize>,
    settings: &BranchSettings,
) -> Option<BranchInfo> {
    let reference = branch.into_reference();
    let name = reference.name()?;
    let target = reference.target()?;

    let target_index = indices.get(&target).copied()?;
    let short_name = branch_short_name(name, branch_type);
    let order_group = branch_order(short_name, settings);
    let color_group = branch_color(short_name, settings);

    Some(BranchInfo {
        name: short_name.to_string(),
        target,
        target_index,
        is_remote: branch_type == BranchType::Remote,
        range: None,
        deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
        visual: BranchVis {
            order_group,
            color_group,
            column: None,
        },
    })
}

fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
    match branch_type {
        BranchType::Local => reference_name
            .strip_prefix("refs/heads/")
            .unwrap_or(reference_name),
        BranchType::Remote => reference_name
            .strip_prefix("refs/remotes/")
            .unwrap_or(reference_name),
    }
}

fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
    let name = normalized_branch_name(name);
    settings
        .persistence
        .iter()
        .position(|candidate| name.starts_with(candidate))
        .unwrap_or(settings.persistence.len())
}

fn branch_order(name: &str, settings: &BranchSettings) -> usize {
    let name = normalized_branch_name(name);
    settings
        .order
        .iter()
        .enumerate()
        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
        .map(|(index, _)| index)
        .unwrap_or(settings.order.len())
}

fn branch_color(name: &str, settings: &BranchSettings) -> usize {
    let name = normalized_branch_name(name);
    settings
        .color
        .iter()
        .enumerate()
        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
        .map(|(index, _)| index)
        .unwrap_or(settings.color.len())
}

fn normalized_branch_name(name: &str) -> &str {
    name.strip_prefix("origin/").unwrap_or(name)
}

fn assign_parent_indices(commits: &mut [CommitInfo], indices: &HashMap<Oid, usize>) {
    for info in commits.iter_mut() {
        info.parents.clear();
        for oid in &info.parent_ids {
            if let Some(index) = indices.get(oid) {
                info.parents.push(*index);
            }
        }
    }
}

fn assign_children(commits: &mut [CommitInfo]) {
    for commit in commits.iter_mut() {
        commit.children.clear();
    }

    for child_index in 0..commits.len() {
        for &parent_index in &commits[child_index].parents {
            if let Some(parent) = commits.get_mut(parent_index) {
                parent.children.push(child_index);
            }
        }
    }
}

fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
    let mut current = Some(branch.target_index);
    let mut any_assigned = false;
    let mut range_tail = branch.target_index;
    let mut range_valid = true;
    let mut previous = None;
    let mut merge_anchor = None;

    while let Some(index) = current {
        match commits[index].branch_trace {
            Some(trace) if trace == branch_index => break,
            Some(_) => {
                if let Some(child_index) = previous {
                    merge_anchor = merge_anchor.or_else(|| merge_start(commits, index, child_index));
                }
                break;
            }
            None => {
                commits[index].branch_trace = Some(branch_index);
                any_assigned = true;
                range_tail = index;
            }
        }

        let parent_index = commits[index].parents.first().copied();

        if let Some(parent_index) = parent_index {
            if parent_index < range_tail {
                range_valid = false;
                break;
            }
        }

        previous = Some(index);
        current = parent_index;
    }

    if any_assigned && range_valid {
        let mut start = range_tail;
        if let Some(anchor) = merge_anchor {
            start = start.max(anchor);
        }
        branch.range = Some((start, branch.target_index));
    } else {
        branch.range = None;
    }

    any_assigned
}

fn merge_start(commits: &[CommitInfo], parent_index: usize, child_index: usize) -> Option<usize> {
    let children = commits
        .get(parent_index)
        .map(|info| info.children.as_slice())
        .unwrap_or(&[]);

    if children.len() <= 1 {
        return None;
    }

    let anchor = children.iter().copied().max()?;
    Some(anchor.max(child_index))
}

fn assign_branch_columns(
    _commits: &[CommitInfo],
    branches: &mut [BranchInfo],
    _settings: &Settings,
) {
    if branches.is_empty() {
        return;
    }

    for branch in branches.iter_mut() {
        branch.visual.column = None;
    }

    let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
    for (index, branch) in branches.iter().enumerate() {
        if branch.range.is_none() {
            continue;
        }

        groups
            .entry(branch.visual.order_group)
            .or_default()
            .push(index);
    }

    let mut offset = 0;
    for (_group, mut indices) in groups.into_iter() {
        indices.sort_by(|left, right| {
            let left_branch = &branches[*left];
            let right_branch = &branches[*right];
            let (left_start, left_end) = branch_interval(left_branch);
            let (right_start, right_end) = branch_interval(right_branch);

            left_start
                .cmp(&right_start)
                .then(left_end.cmp(&right_end))
                .then(left_branch.name.cmp(&right_branch.name))
        });

        let mut occupied: Vec<Option<usize>> = Vec::new();
        let mut assignments: Vec<(usize, usize)> = Vec::with_capacity(indices.len());

        for &branch_index in &indices {
            let (start, end) = branch_interval(&branches[branch_index]);

            for slot in &mut occupied {
                if let Some(occupied_until) = slot {
                    if *occupied_until < start {
                        *slot = None;
                    }
                }
            }

            let column = if let Some(position) = occupied.iter_mut().position(|slot| slot.is_none())
            {
                occupied[position] = Some(end);
                position
            } else {
                occupied.push(Some(end));
                occupied.len() - 1
            };

            assignments.push((branch_index, column));
        }

        let group_width = occupied.len();

        for (branch_index, column) in assignments {
            branches[branch_index].visual.column = Some(column + offset);
        }

        offset += group_width;
    }
}

fn branch_interval(branch: &BranchInfo) -> (usize, usize) {
    branch
        .range
        .map(|(start, end)| (start.min(end), start.max(end)))
        .unwrap_or_else(|| (branch.target_index, branch.target_index))
}
EOF
' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:26:09] bash -lc "cat <<'EOF' > src/graph.rs
use crate::settings::{BranchSettings, Settings};
use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
use std::collections::{BTreeMap, HashMap};

pub struct CommitInfo {
    pub id: Oid,
    pub parent_ids: Vec<Oid>,
    pub parents: Vec<usize>,
    pub children: Vec<usize>,
    pub branches: Vec<usize>,
    pub branch_trace: Option<usize>,
}

pub struct BranchVis {
    pub order_group: usize,
    pub color_group: usize,
    pub column: Option<usize>,
}

pub struct BranchInfo {
    pub name: String,
    pub target: Oid,
    pub target_index: usize,
    pub is_remote: bool,
    pub range: Option<(usize, usize)>,
    pub deleted: bool,
    pub visual: BranchVis,
}

pub struct GitGraph {
    repo: Repository,
    commits: Vec<CommitInfo>,
    branches: Vec<BranchInfo>,
}

impl GitGraph {
    pub fn new(path: &str, settings: &Settings) -> Result<Self, git2::Error> {
        let repo = Repository::open(path)?;
        let mut revwalk = repo.revwalk()?;
        revwalk.set_sorting(Sort::TOPOLOGICAL | Sort::TIME);
        revwalk.push_head()?;

        let mut commits = Vec::new();
        let mut indices = HashMap::new();

        for (index, oid_result) in revwalk.enumerate() {
            let oid = oid_result?;
            let commit = repo.find_commit(oid)?;
            let parent_ids = commit.parent_ids().collect();

            indices.insert(oid, index);
            commits.push(CommitInfo {
                id: oid,
                parent_ids,
                parents: Vec::new(),
                children: Vec::new(),
                branches: Vec::new(),
                branch_trace: None,
            });
        }

        let mut graph = GitGraph {
            repo,
            commits,
            branches: Vec::new(),
        };

        assign_parent_indices(&mut graph.commits, &indices);
        assign_children(&mut graph.commits);

        let branches = graph.assign_branches(&indices, settings)?;
        graph.branches = branches;

        assign_branch_columns(&graph.commits, &mut graph.branches, settings);

        Ok(graph)
    }

    fn assign_branches(
        &mut self,
        indices: &HashMap<Oid, usize>,
        settings: &Settings,
    ) -> Result<Vec<BranchInfo>, git2::Error> {
        let branch_infos = extract_branches(&self.repo, indices, settings)?;

        let mut result = Vec::new();
        for mut info in branch_infos {
            let branch_index = result.len();
            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);

            if "'!info.deleted {
                self.commits[info.target_index]
                    .branches
                    .push(branch_index);
            }

            if assigned_any || !info.deleted {
                result.push(info);
            }
        }

        Ok(result)
    }

    pub fn commits(&self) -> &[CommitInfo] {
        &self.commits
    }

    pub fn branches(&self) -> &[BranchInfo] {
        &self.branches
    }

    pub fn commit(&self, info: &CommitInfo) -> Result<Commit, git2::Error> {
        self.repo.find_commit(info.id)
    }
}

fn extract_branches(
    repo: &Repository,
    indices: &HashMap<Oid, usize>,
    settings: &Settings,
) -> Result<Vec<BranchInfo>, git2::Error> {
    let mut branches = Vec::new();

    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
        let mut iter = repo.branches(Some(branch_type))?;
        while let Some(branch_result) = iter.next() {
            let (branch, _) = branch_result?;
            branches.push((branch, branch_type));
        }
        Ok(())
    };

    push_branches(BranchType::Local)?;

    if settings.include_remote {
        push_branches(BranchType::Remote)?;
    }

    let mut branch_infos = branches
        .into_iter()
        .filter_map(|(branch, branch_type)| {
            branch_info(branch, branch_type, indices, &settings.branches)
        })
        .collect::<Vec<_>>();

    branch_infos.sort_by(|left, right| {
        left.visual
            .order_group
            .cmp(&right.visual.order_group)
            .then(
                branch_persistence(&left.name, &settings.branches)
                    .cmp(&branch_persistence(&right.name, &settings.branches)),
            )
            .then(left.name.cmp(&right.name))
    });

    Ok(branch_infos)
}

fn branch_info(
    branch: Branch,
    branch_type: BranchType,
    indices: &HashMap<Oid, usize>,
    settings: &BranchSettings,
) -> Option<BranchInfo> {
    let reference = branch.into_reference();
    let name = reference.name()?;
    let target = reference.target()?;

    let target_index = indices.get(&target).copied()?;
    let short_name = branch_short_name(name, branch_type);
    let order_group = branch_order(short_name, settings);
    let color_group = branch_color(short_name, settings);

    Some(BranchInfo {
        name: short_name.to_string(),
        target,
        target_index,
        is_remote: branch_type == BranchType::Remote,
        range: None,
        deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
        visual: BranchVis {
            order_group,
            color_group,
            column: None,
        },
    })
}

fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
    match branch_type {
        BranchType::Local => reference_name
            .strip_prefix("refs/heads/")
            .unwrap_or(reference_name),
        BranchType::Remote => reference_name
            .strip_prefix("refs/remotes/")
            .unwrap_or(reference_name),
    }
}

fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
    let name = normalized_branch_name(name);
    settings
        .persistence
        .iter()
        .position(|candidate| name.starts_with(candidate))
        .unwrap_or(settings.persistence.len())
}

fn branch_order(name: &str, settings: &BranchSettings) -> usize {
    let name = normalized_branch_name(name);
    settings
        .order
        .iter()
        .enumerate()
        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
        .map(|(index, _)| index)
        .unwrap_or(settings.order.len())
}

fn branch_color(name: &str, settings: &BranchSettings) -> usize {
    let name = normalized_branch_name(name);
    settings
        .color
        .iter()
        .enumerate()
        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
        .map(|(index, _)| index)
        .unwrap_or(settings.color.len())
}

fn normalized_branch_name(name: &str) -> &str {
    name.strip_prefix("origin/").unwrap_or(name)
}

fn assign_parent_indices(commits: &mut [CommitInfo], indices: &HashMap<Oid, usize>) {
    for info in commits.iter_mut() {
        info.parents.clear();
        for oid in &info.parent_ids {
            if let Some(index) = indices.get(oid) {
                info.parents.push(*index);
            }
        }
    }
}

fn assign_children(commits: &mut [CommitInfo]) {
    for commit in commits.iter_mut() {
        commit.children.clear();
    }

    for child_index in 0..commits.len() {
        for &parent_index in &commits[child_index].parents {
            if let Some(parent) = commits.get_mut(parent_index) {
                parent.children.push(child_index);
            }
        }
    }
}

fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
    let mut current = Some(branch.target_index);
    let mut any_assigned = false;
    let mut range_tail = branch.target_index;
    let mut range_valid = true;
    let mut previous = None;
    let mut merge_anchor = None;

    while let Some(index) = current {
        match commits[index].branch_trace {
            Some(trace) if trace == branch_index => break,
            Some(_) => {
                if let Some(child_index) = previous {
                    merge_anchor = merge_anchor.or_else(|| merge_start(commits, index, child_index));
                }
                break;
            }
            None => {
                commits[index].branch_trace = Some(branch_index);
                any_assigned = true;
                range_tail = index;
            }
        }

        let parent_index = commits[index].parents.first().copied();

        if let Some(parent_index) = parent_index {
            if parent_index < range_tail {
                range_valid = false;
                break;
            }
        }

        previous = Some(index);
        current = parent_index;
    }

    if any_assigned && range_valid {
        let mut start = range_tail;
        if let Some(anchor) = merge_anchor {
            start = start.max(anchor);
        }
        branch.range = Some((start, branch.target_index));
    } else {
        branch.range = None;
    }

    any_assigned
}

fn merge_start(commits: &[CommitInfo], parent_index: usize, child_index: usize) -> Option<usize> {
    let children = commits
        .get(parent_index)
        .map(|info| info.children.as_slice())
        .unwrap_or(&[]);

    if children.len() <= 1 {
        return None;
    }

    let anchor = children.iter().copied().max()?;
    Some(anchor.max(child_index))
}

fn assign_branch_columns(
    _commits: &[CommitInfo],
    branches: &mut [BranchInfo],
    _settings: &Settings,
) {
    if branches.is_empty() {
        return;
    }

    for branch in branches.iter_mut() {
        branch.visual.column = None;
    }

    let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
    for (index, branch) in branches.iter().enumerate() {
        if branch.range.is_none() {
            continue;
        }

        groups
            .entry(branch.visual.order_group)
            .or_default()
            .push(index);
    }

    let mut offset = 0;
    for (_group, mut indices) in groups.into_iter() {
        indices.sort_by(|left, right| {
            let left_branch = &branches[*left];
            let right_branch = &branches[*right];
            let (left_start, left_end) = branch_interval(left_branch);
            let (right_start, right_end) = branch_interval(right_branch);

            left_start
                .cmp(&right_start)
                .then(left_end.cmp(&right_end))
                .then(left_branch.name.cmp(&right_branch.name))
        });

        let mut occupied: Vec<Option<usize>> = Vec::new();
        let mut assignments: Vec<(usize, usize)> = Vec::with_capacity(indices.len());

        for &branch_index in &indices {
            let (start, end) = branch_interval(&branches[branch_index]);

            for slot in &mut occupied {
                if let Some(occupied_until) = slot {
                    if *occupied_until < start {
                        *slot = None;
                    }
                }
            }

            let column = if let Some(position) = occupied.iter_mut().position(|slot| slot.is_none())
            {
                occupied[position] = Some(end);
                position
            } else {
                occupied.push(Some(end));
                occupied.len() - 1
            };

            assignments.push((branch_index, column));
        }

        let group_width = occupied.len();

        for (branch_index, column) in assignments {
            branches[branch_index].visual.column = Some(column + offset);
        }

        offset += group_width;
    }
}

fn branch_interval(branch: &BranchInfo) -> (usize, usize) {
    branch
        .range
        .map(|(start, end)| (start.min(end), start.max(end)))
        .unwrap_or_else(|| (branch.target_index, branch.target_index))
}
EOF
' succeeded in 27ms:

[2025-09-21T12:26:09] tokens used: 81,750
[2025-09-21T12:26:09] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 982924ca97e4ce3ef4764cbf2ccc4d1bd4122343..97e24f5edacb42f0feb2d409f19c60449527401c
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,19 +5,26 @@
 pub struct CommitInfo {
     pub id: Oid,
     pub parent_ids: Vec<Oid>,
+    pub parents: Vec<usize>,
+    pub children: Vec<usize>,
     pub branches: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
+pub struct BranchVis {
+    pub order_group: usize,
+    pub color_group: usize,
+    pub column: Option<usize>,
+}
+
 pub struct BranchInfo {
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
     pub is_remote: bool,
-    pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
-    pub column: Option<usize>,
+    pub visual: BranchVis,
 }
 
 pub struct GitGraph {
@@ -35,14 +42,18 @@
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
+
         for (index, oid_result) in revwalk.enumerate() {
             let oid = oid_result?;
             let commit = repo.find_commit(oid)?;
             let parent_ids = commit.parent_ids().collect();
+
             indices.insert(oid, index);
             commits.push(CommitInfo {
                 id: oid,
                 parent_ids,
+                parents: Vec::new(),
+                children: Vec::new(),
                 branches: Vec::new(),
                 branch_trace: None,
             });
@@ -54,8 +65,12 @@
             branches: Vec::new(),
         };
 
+        assign_parent_indices(&mut graph.commits, &indices);
+        assign_children(&mut graph.commits);
+
         let branches = graph.assign_branches(&indices, settings)?;
         graph.branches = branches;
+
         assign_branch_columns(&graph.commits, &mut graph.branches, settings);
 
         Ok(graph)
@@ -71,10 +86,12 @@
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, indices, &mut info, branch_index);
+            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
 
             if !info.deleted {
-                self.commits[info.target_index].branches.push(branch_index);
+                self.commits[info.target_index]
+                    .branches
+                    .push(branch_index);
             }
 
             if assigned_any || !info.deleted {
@@ -98,6 +115,49 @@
     }
 }
 
+fn extract_branches(
+    repo: &Repository,
+    indices: &HashMap<Oid, usize>,
+    settings: &Settings,
+) -> Result<Vec<BranchInfo>, git2::Error> {
+    let mut branches = Vec::new();
+
+    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
+        let mut iter = repo.branches(Some(branch_type))?;
+        while let Some(branch_result) = iter.next() {
+            let (branch, _) = branch_result?;
+            branches.push((branch, branch_type));
+        }
+        Ok(())
+    };
+
+    push_branches(BranchType::Local)?;
+
+    if settings.include_remote {
+        push_branches(BranchType::Remote)?;
+    }
+
+    let mut branch_infos = branches
+        .into_iter()
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
+        .collect::<Vec<_>>();
+
+    branch_infos.sort_by(|left, right| {
+        left.visual
+            .order_group
+            .cmp(&right.visual.order_group)
+            .then(
+                branch_persistence(&left.name, &settings.branches)
+                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+            )
+            .then(left.name.cmp(&right.name))
+    });
+
+    Ok(branch_infos)
+}
+
 fn branch_info(
     branch: Branch,
     branch_type: BranchType,
@@ -111,19 +171,34 @@
     let target_index = indices.get(&target).copied()?;
     let short_name = branch_short_name(name, branch_type);
     let order_group = branch_order(short_name, settings);
+    let color_group = branch_color(short_name, settings);
 
     Some(BranchInfo {
         name: short_name.to_string(),
         target,
         target_index,
         is_remote: branch_type == BranchType::Remote,
-        order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
-        column: None,
+        visual: BranchVis {
+            order_group,
+            color_group,
+            column: None,
+        },
     })
 }
 
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
+}
+
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
     let name = normalized_branch_name(name);
     settings
@@ -144,105 +219,89 @@
         .unwrap_or(settings.order.len())
 }
 
+fn branch_color(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
+    settings
+        .color
+        .iter()
+        .enumerate()
+        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
+        .map(|(index, _)| index)
+        .unwrap_or(settings.color.len())
+}
+
 fn normalized_branch_name(name: &str) -> &str {
     name.strip_prefix("origin/").unwrap_or(name)
 }
 
-fn extract_branches(
-    repo: &Repository,
-    indices: &HashMap<Oid, usize>,
-    settings: &Settings,
-) -> Result<Vec<BranchInfo>, git2::Error> {
-    let mut branches = Vec::new();
-
-    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
-        let mut iter = repo.branches(Some(branch_type))?;
-        while let Some(branch_result) = iter.next() {
-            let (branch, _) = branch_result?;
-            branches.push((branch, branch_type));
+fn assign_parent_indices(commits: &mut [CommitInfo], indices: &HashMap<Oid, usize>) {
+    for info in commits.iter_mut() {
+        info.parents.clear();
+        for oid in &info.parent_ids {
+            if let Some(index) = indices.get(oid) {
+                info.parents.push(*index);
+            }
         }
-        Ok(())
-    };
-
-    push_branches(BranchType::Local)?;
+    }
+}
 
-    if settings.include_remote {
-        push_branches(BranchType::Remote)?;
+fn assign_children(commits: &mut [CommitInfo]) {
+    for commit in commits.iter_mut() {
+        commit.children.clear();
     }
 
-    let mut branch_infos = branches
-        .into_iter()
-        .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
-        })
-        .collect::<Vec<_>>();
-
-    branch_infos.sort_by(|left, right| {
-        left.order_group
-            .cmp(&right.order_group)
-            .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
-            )
-            .then(left.name.cmp(&right.name))
-    });
-
-    Ok(branch_infos)
-}
-
-fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
-    match branch_type {
-        BranchType::Local => reference_name
-            .strip_prefix("refs/heads/")
-            .unwrap_or(reference_name),
-        BranchType::Remote => reference_name
-            .strip_prefix("refs/remotes/")
-            .unwrap_or(reference_name),
+    for child_index in 0..commits.len() {
+        for &parent_index in &commits[child_index].parents {
+            if let Some(parent) = commits.get_mut(parent_index) {
+                parent.children.push(child_index);
+            }
+        }
     }
 }
 
-fn trace_branch(
-    commits: &mut [CommitInfo],
-    indices: &HashMap<Oid, usize>,
-    branch: &mut BranchInfo,
-    branch_index: usize,
-) -> bool {
+fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
-    let mut range_end = branch.target_index;
+    let mut range_tail = branch.target_index;
     let mut range_valid = true;
+    let mut previous = None;
+    let mut merge_anchor = None;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
             Some(trace) if trace == branch_index => break,
-            Some(_) => {}
+            Some(_) => {
+                if let Some(child_index) = previous {
+                    merge_anchor = merge_anchor.or_else(|| merge_start(commits, index, child_index));
+                }
+                break;
+            }
             None => {
                 commits[index].branch_trace = Some(branch_index);
                 any_assigned = true;
-                range_end = index;
+                range_tail = index;
             }
         }
 
-        let parent_index = commits[index]
-            .parent_ids
-            .iter()
-            .filter_map(|oid| indices.get(oid))
-            .copied()
-            .next();
+        let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
-            if parent_index < range_end {
-                // Jumping forward indicates a non-contiguous range; skip column assignment.
+            if parent_index < range_tail {
                 range_valid = false;
                 break;
             }
         }
 
+        previous = Some(index);
         current = parent_index;
     }
 
     if any_assigned && range_valid {
-        branch.range = Some((range_end, branch.target_index));
+        let mut start = range_tail;
+        if let Some(anchor) = merge_anchor {
+            start = start.max(anchor);
+        }
+        branch.range = Some((start, branch.target_index));
     } else {
         branch.range = None;
     }
@@ -250,6 +309,20 @@
     any_assigned
 }
 
+fn merge_start(commits: &[CommitInfo], parent_index: usize, child_index: usize) -> Option<usize> {
+    let children = commits
+        .get(parent_index)
+        .map(|info| info.children.as_slice())
+        .unwrap_or(&[]);
+
+    if children.len() <= 1 {
+        return None;
+    }
+
+    let anchor = children.iter().copied().max()?;
+    Some(anchor.max(child_index))
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
@@ -259,14 +332,20 @@
         return;
     }
 
+    for branch in branches.iter_mut() {
+        branch.visual.column = None;
+    }
+
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
         if branch.range.is_none() {
             continue;
         }
 
-        // Group index may exceed configured order length; keep as-is for stable layout.
-        groups.entry(branch.order_group).or_default().push(index);
+        groups
+            .entry(branch.visual.order_group)
+            .or_default()
+            .push(index);
     }
 
     let mut offset = 0;
@@ -312,7 +391,7 @@
         let group_width = occupied.len();
 
         for (branch_index, column) in assignments {
-            branches[branch_index].column = Some(column + offset);
+            branches[branch_index].visual.column = Some(column + offset);
         }
 
         offset += group_width;


[2025-09-21T12:26:33] thinking

**Updating main.rs with enhanced commit display**
[2025-09-21T12:26:50] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -26,2 +26,3 @@
     let symbol = if commit.parent_count() > 1 { "o" } else { "*" };
+    let merge_marker = if commit.parent_count() > 1 { 'M' } else { '.' };
     let short_id = short_id(commit.id());
@@ -29,2 +30,4 @@
 
+    let (column, span) = branch_metrics(graph, info);
+
     let branch_details = info
@@ -42,5 +45,5 @@
     let summary = commit.summary().unwrap_or("---");
-    println!(
-        "{}{} {}{} {}",
-        indent, symbol, short_id, branch_str, summary
+    eprintln!(
+        "{}{}{} {} [{} | {}]{} {}",
+        indent, merge_marker, symbol, short_id, column, span, branch_str, summary
     );
@@ -55,7 +58,17 @@
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column = branch.column.unwrap_or(99);
+    let column = branch
+        .visual
+        .column
+        .map(|value| value.to_string())
+        .unwrap_or_else(|| "-".to_string());
+    let range = format_range(branch.range);
 
     format!(
-        "{}{} (col {}){}",
-        indent, branch.name, column, deleted_suffix
+        "{}{} (col {} | range {} | color {}){}",
+        indent,
+        branch.name,
+        column,
+        range,
+        branch.visual.color_group,
+        deleted_suffix
     )
@@ -66,3 +79,3 @@
         .and_then(|index| graph.branches().get(index))
-        .and_then(|branch| branch.column)
+        .and_then(|branch| branch.visual.column)
         .map(indent_for_column)
@@ -72,3 +85,7 @@
 fn indent_for_branch(branch: &BranchInfo) -> String {
-    branch.column.map(indent_for_column).unwrap_or_default()
+    branch
+        .visual
+        .column
+        .map(indent_for_column)
+        .unwrap_or_default()
 }
@@ -85 +102,22 @@
 }
+
+fn branch_metrics(graph: &GitGraph, info: &CommitInfo) -> (String, String) {
+    info
+        .branch_trace
+        .and_then(|index| graph.branches().get(index))
+        .map(|branch| {
+            let column = branch
+                .visual
+                .column
+                .map(|value| value.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            (column, format_range(branch.range))
+        })
+        .unwrap_or_else(|| ("-".to_string(), "-".to_string()))
+}
+
+fn format_range(range: Option<(usize, usize)>) -> String {
+    range
+        .map(|(start, end)| format!("{}..{}", start.min(end), start.max(end)))
+        .unwrap_or_else(|| "-".to_string())
+}
[2025-09-21T12:26:50] apply_patch(auto_approved=true) exited 0 in 37ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T12:26:50] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 982924ca97e4ce3ef4764cbf2ccc4d1bd4122343..97e24f5edacb42f0feb2d409f19c60449527401c
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,19 +5,26 @@
 pub struct CommitInfo {
     pub id: Oid,
     pub parent_ids: Vec<Oid>,
+    pub parents: Vec<usize>,
+    pub children: Vec<usize>,
     pub branches: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
+pub struct BranchVis {
+    pub order_group: usize,
+    pub color_group: usize,
+    pub column: Option<usize>,
+}
+
 pub struct BranchInfo {
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
     pub is_remote: bool,
-    pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
-    pub column: Option<usize>,
+    pub visual: BranchVis,
 }
 
 pub struct GitGraph {
@@ -35,14 +42,18 @@
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
+
         for (index, oid_result) in revwalk.enumerate() {
             let oid = oid_result?;
             let commit = repo.find_commit(oid)?;
             let parent_ids = commit.parent_ids().collect();
+
             indices.insert(oid, index);
             commits.push(CommitInfo {
                 id: oid,
                 parent_ids,
+                parents: Vec::new(),
+                children: Vec::new(),
                 branches: Vec::new(),
                 branch_trace: None,
             });
@@ -54,8 +65,12 @@
             branches: Vec::new(),
         };
 
+        assign_parent_indices(&mut graph.commits, &indices);
+        assign_children(&mut graph.commits);
+
         let branches = graph.assign_branches(&indices, settings)?;
         graph.branches = branches;
+
         assign_branch_columns(&graph.commits, &mut graph.branches, settings);
 
         Ok(graph)
@@ -71,10 +86,12 @@
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, indices, &mut info, branch_index);
+            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
 
             if !info.deleted {
-                self.commits[info.target_index].branches.push(branch_index);
+                self.commits[info.target_index]
+                    .branches
+                    .push(branch_index);
             }
 
             if assigned_any || !info.deleted {
@@ -98,6 +115,49 @@
     }
 }
 
+fn extract_branches(
+    repo: &Repository,
+    indices: &HashMap<Oid, usize>,
+    settings: &Settings,
+) -> Result<Vec<BranchInfo>, git2::Error> {
+    let mut branches = Vec::new();
+
+    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
+        let mut iter = repo.branches(Some(branch_type))?;
+        while let Some(branch_result) = iter.next() {
+            let (branch, _) = branch_result?;
+            branches.push((branch, branch_type));
+        }
+        Ok(())
+    };
+
+    push_branches(BranchType::Local)?;
+
+    if settings.include_remote {
+        push_branches(BranchType::Remote)?;
+    }
+
+    let mut branch_infos = branches
+        .into_iter()
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
+        .collect::<Vec<_>>();
+
+    branch_infos.sort_by(|left, right| {
+        left.visual
+            .order_group
+            .cmp(&right.visual.order_group)
+            .then(
+                branch_persistence(&left.name, &settings.branches)
+                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+            )
+            .then(left.name.cmp(&right.name))
+    });
+
+    Ok(branch_infos)
+}
+
 fn branch_info(
     branch: Branch,
     branch_type: BranchType,
@@ -111,19 +171,34 @@
     let target_index = indices.get(&target).copied()?;
     let short_name = branch_short_name(name, branch_type);
     let order_group = branch_order(short_name, settings);
+    let color_group = branch_color(short_name, settings);
 
     Some(BranchInfo {
         name: short_name.to_string(),
         target,
         target_index,
         is_remote: branch_type == BranchType::Remote,
-        order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
-        column: None,
+        visual: BranchVis {
+            order_group,
+            color_group,
+            column: None,
+        },
     })
 }
 
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
+}
+
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
     let name = normalized_branch_name(name);
     settings
@@ -144,105 +219,89 @@
         .unwrap_or(settings.order.len())
 }
 
+fn branch_color(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
+    settings
+        .color
+        .iter()
+        .enumerate()
+        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
+        .map(|(index, _)| index)
+        .unwrap_or(settings.color.len())
+}
+
 fn normalized_branch_name(name: &str) -> &str {
     name.strip_prefix("origin/").unwrap_or(name)
 }
 
-fn extract_branches(
-    repo: &Repository,
-    indices: &HashMap<Oid, usize>,
-    settings: &Settings,
-) -> Result<Vec<BranchInfo>, git2::Error> {
-    let mut branches = Vec::new();
-
-    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
-        let mut iter = repo.branches(Some(branch_type))?;
-        while let Some(branch_result) = iter.next() {
-            let (branch, _) = branch_result?;
-            branches.push((branch, branch_type));
+fn assign_parent_indices(commits: &mut [CommitInfo], indices: &HashMap<Oid, usize>) {
+    for info in commits.iter_mut() {
+        info.parents.clear();
+        for oid in &info.parent_ids {
+            if let Some(index) = indices.get(oid) {
+                info.parents.push(*index);
+            }
         }
-        Ok(())
-    };
-
-    push_branches(BranchType::Local)?;
+    }
+}
 
-    if settings.include_remote {
-        push_branches(BranchType::Remote)?;
+fn assign_children(commits: &mut [CommitInfo]) {
+    for commit in commits.iter_mut() {
+        commit.children.clear();
     }
 
-    let mut branch_infos = branches
-        .into_iter()
-        .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
-        })
-        .collect::<Vec<_>>();
-
-    branch_infos.sort_by(|left, right| {
-        left.order_group
-            .cmp(&right.order_group)
-            .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
-            )
-            .then(left.name.cmp(&right.name))
-    });
-
-    Ok(branch_infos)
-}
-
-fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
-    match branch_type {
-        BranchType::Local => reference_name
-            .strip_prefix("refs/heads/")
-            .unwrap_or(reference_name),
-        BranchType::Remote => reference_name
-            .strip_prefix("refs/remotes/")
-            .unwrap_or(reference_name),
+    for child_index in 0..commits.len() {
+        for &parent_index in &commits[child_index].parents {
+            if let Some(parent) = commits.get_mut(parent_index) {
+                parent.children.push(child_index);
+            }
+        }
     }
 }
 
-fn trace_branch(
-    commits: &mut [CommitInfo],
-    indices: &HashMap<Oid, usize>,
-    branch: &mut BranchInfo,
-    branch_index: usize,
-) -> bool {
+fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
-    let mut range_end = branch.target_index;
+    let mut range_tail = branch.target_index;
     let mut range_valid = true;
+    let mut previous = None;
+    let mut merge_anchor = None;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
             Some(trace) if trace == branch_index => break,
-            Some(_) => {}
+            Some(_) => {
+                if let Some(child_index) = previous {
+                    merge_anchor = merge_anchor.or_else(|| merge_start(commits, index, child_index));
+                }
+                break;
+            }
             None => {
                 commits[index].branch_trace = Some(branch_index);
                 any_assigned = true;
-                range_end = index;
+                range_tail = index;
             }
         }
 
-        let parent_index = commits[index]
-            .parent_ids
-            .iter()
-            .filter_map(|oid| indices.get(oid))
-            .copied()
-            .next();
+        let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
-            if parent_index < range_end {
-                // Jumping forward indicates a non-contiguous range; skip column assignment.
+            if parent_index < range_tail {
                 range_valid = false;
                 break;
             }
         }
 
+        previous = Some(index);
         current = parent_index;
     }
 
     if any_assigned && range_valid {
-        branch.range = Some((range_end, branch.target_index));
+        let mut start = range_tail;
+        if let Some(anchor) = merge_anchor {
+            start = start.max(anchor);
+        }
+        branch.range = Some((start, branch.target_index));
     } else {
         branch.range = None;
     }
@@ -250,6 +309,20 @@
     any_assigned
 }
 
+fn merge_start(commits: &[CommitInfo], parent_index: usize, child_index: usize) -> Option<usize> {
+    let children = commits
+        .get(parent_index)
+        .map(|info| info.children.as_slice())
+        .unwrap_or(&[]);
+
+    if children.len() <= 1 {
+        return None;
+    }
+
+    let anchor = children.iter().copied().max()?;
+    Some(anchor.max(child_index))
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
@@ -259,14 +332,20 @@
         return;
     }
 
+    for branch in branches.iter_mut() {
+        branch.visual.column = None;
+    }
+
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
         if branch.range.is_none() {
             continue;
         }
 
-        // Group index may exceed configured order length; keep as-is for stable layout.
-        groups.entry(branch.order_group).or_default().push(index);
+        groups
+            .entry(branch.visual.order_group)
+            .or_default()
+            .push(index);
     }
 
     let mut offset = 0;
@@ -312,7 +391,7 @@
         let group_width = occupied.len();
 
         for (branch_index, column) in assignments {
-            branches[branch_index].column = Some(column + offset);
+            branches[branch_index].visual.column = Some(column + offset);
         }
 
         offset += group_width;
diff --git a/src/main.rs b/src/main.rs
index 6e320e9bd9209afaaf06b86efe9caf12162a0a09..cb035becd1afc90adc5869e0a5da930d9a82df95
--- a/src/main.rs
+++ b/src/main.rs
@@ -24,9 +24,12 @@
     let commit = graph.commit(info)?;
 
     let symbol = if commit.parent_count() > 1 { "o" } else { "*" };
+    let merge_marker = if commit.parent_count() > 1 { 'M' } else { '.' };
     let short_id = short_id(commit.id());
     let indent = commit_indent(graph, info);
 
+    let (column, span) = branch_metrics(graph, info);
+
     let branch_details = info
         .branches
         .iter()
@@ -40,9 +43,9 @@
     };
 
     let summary = commit.summary().unwrap_or("---");
-    println!(
-        "{}{} {}{} {}",
-        indent, symbol, short_id, branch_str, summary
+    eprintln!(
+        "{}{}{} {} [{} | {}]{} {}",
+        indent, merge_marker, symbol, short_id, column, span, branch_str, summary
     );
 
     Ok(())
@@ -53,24 +56,38 @@
     let indent = indent_for_branch(branch);
 
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column = branch.column.unwrap_or(99);
+    let column = branch
+        .visual
+        .column
+        .map(|value| value.to_string())
+        .unwrap_or_else(|| "-".to_string());
+    let range = format_range(branch.range);
 
     format!(
-        "{}{} (col {}){}",
-        indent, branch.name, column, deleted_suffix
+        "{}{} (col {} | range {} | color {}){}",
+        indent,
+        branch.name,
+        column,
+        range,
+        branch.visual.color_group,
+        deleted_suffix
     )
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {
     info.branch_trace
         .and_then(|index| graph.branches().get(index))
-        .and_then(|branch| branch.column)
+        .and_then(|branch| branch.visual.column)
         .map(indent_for_column)
         .unwrap_or_default()
 }
 
 fn indent_for_branch(branch: &BranchInfo) -> String {
-    branch.column.map(indent_for_column).unwrap_or_default()
+    branch
+        .visual
+        .column
+        .map(indent_for_column)
+        .unwrap_or_default()
 }
 
 fn indent_for_column(column: usize) -> String {
@@ -83,3 +100,24 @@
     id.truncate(7);
     id
 }
+
+fn branch_metrics(graph: &GitGraph, info: &CommitInfo) -> (String, String) {
+    info
+        .branch_trace
+        .and_then(|index| graph.branches().get(index))
+        .map(|branch| {
+            let column = branch
+                .visual
+                .column
+                .map(|value| value.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            (column, format_range(branch.range))
+        })
+        .unwrap_or_else(|| ("-".to_string(), "-".to_string()))
+}
+
+fn format_range(range: Option<(usize, usize)>) -> String {
+    range
+        .map(|(start, end)| format!("{}..{}", start.min(end), start.max(end)))
+        .unwrap_or_else(|| "-".to_string())
+}

[2025-09-21T12:26:50] tokens used: 103,551
[2025-09-21T12:26:51] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 982924ca97e4ce3ef4764cbf2ccc4d1bd4122343..97e24f5edacb42f0feb2d409f19c60449527401c
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,19 +5,26 @@
 pub struct CommitInfo {
     pub id: Oid,
     pub parent_ids: Vec<Oid>,
+    pub parents: Vec<usize>,
+    pub children: Vec<usize>,
     pub branches: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
+pub struct BranchVis {
+    pub order_group: usize,
+    pub color_group: usize,
+    pub column: Option<usize>,
+}
+
 pub struct BranchInfo {
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
     pub is_remote: bool,
-    pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
-    pub column: Option<usize>,
+    pub visual: BranchVis,
 }
 
 pub struct GitGraph {
@@ -35,14 +42,18 @@
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
+
         for (index, oid_result) in revwalk.enumerate() {
             let oid = oid_result?;
             let commit = repo.find_commit(oid)?;
             let parent_ids = commit.parent_ids().collect();
+
             indices.insert(oid, index);
             commits.push(CommitInfo {
                 id: oid,
                 parent_ids,
+                parents: Vec::new(),
+                children: Vec::new(),
                 branches: Vec::new(),
                 branch_trace: None,
             });
@@ -54,8 +65,12 @@
             branches: Vec::new(),
         };
 
+        assign_parent_indices(&mut graph.commits, &indices);
+        assign_children(&mut graph.commits);
+
         let branches = graph.assign_branches(&indices, settings)?;
         graph.branches = branches;
+
         assign_branch_columns(&graph.commits, &mut graph.branches, settings);
 
         Ok(graph)
@@ -71,10 +86,12 @@
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, indices, &mut info, branch_index);
+            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
 
             if !info.deleted {
-                self.commits[info.target_index].branches.push(branch_index);
+                self.commits[info.target_index]
+                    .branches
+                    .push(branch_index);
             }
 
             if assigned_any || !info.deleted {
@@ -98,6 +115,49 @@
     }
 }
 
+fn extract_branches(
+    repo: &Repository,
+    indices: &HashMap<Oid, usize>,
+    settings: &Settings,
+) -> Result<Vec<BranchInfo>, git2::Error> {
+    let mut branches = Vec::new();
+
+    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
+        let mut iter = repo.branches(Some(branch_type))?;
+        while let Some(branch_result) = iter.next() {
+            let (branch, _) = branch_result?;
+            branches.push((branch, branch_type));
+        }
+        Ok(())
+    };
+
+    push_branches(BranchType::Local)?;
+
+    if settings.include_remote {
+        push_branches(BranchType::Remote)?;
+    }
+
+    let mut branch_infos = branches
+        .into_iter()
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
+        .collect::<Vec<_>>();
+
+    branch_infos.sort_by(|left, right| {
+        left.visual
+            .order_group
+            .cmp(&right.visual.order_group)
+            .then(
+                branch_persistence(&left.name, &settings.branches)
+                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+            )
+            .then(left.name.cmp(&right.name))
+    });
+
+    Ok(branch_infos)
+}
+
 fn branch_info(
     branch: Branch,
     branch_type: BranchType,
@@ -111,19 +171,34 @@
     let target_index = indices.get(&target).copied()?;
     let short_name = branch_short_name(name, branch_type);
     let order_group = branch_order(short_name, settings);
+    let color_group = branch_color(short_name, settings);
 
     Some(BranchInfo {
         name: short_name.to_string(),
         target,
         target_index,
         is_remote: branch_type == BranchType::Remote,
-        order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
-        column: None,
+        visual: BranchVis {
+            order_group,
+            color_group,
+            column: None,
+        },
     })
 }
 
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
+}
+
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
     let name = normalized_branch_name(name);
     settings
@@ -144,105 +219,89 @@
         .unwrap_or(settings.order.len())
 }
 
+fn branch_color(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
+    settings
+        .color
+        .iter()
+        .enumerate()
+        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
+        .map(|(index, _)| index)
+        .unwrap_or(settings.color.len())
+}
+
 fn normalized_branch_name(name: &str) -> &str {
     name.strip_prefix("origin/").unwrap_or(name)
 }
 
-fn extract_branches(
-    repo: &Repository,
-    indices: &HashMap<Oid, usize>,
-    settings: &Settings,
-) -> Result<Vec<BranchInfo>, git2::Error> {
-    let mut branches = Vec::new();
-
-    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
-        let mut iter = repo.branches(Some(branch_type))?;
-        while let Some(branch_result) = iter.next() {
-            let (branch, _) = branch_result?;
-            branches.push((branch, branch_type));
+fn assign_parent_indices(commits: &mut [CommitInfo], indices: &HashMap<Oid, usize>) {
+    for info in commits.iter_mut() {
+        info.parents.clear();
+        for oid in &info.parent_ids {
+            if let Some(index) = indices.get(oid) {
+                info.parents.push(*index);
+            }
         }
-        Ok(())
-    };
-
-    push_branches(BranchType::Local)?;
+    }
+}
 
-    if settings.include_remote {
-        push_branches(BranchType::Remote)?;
+fn assign_children(commits: &mut [CommitInfo]) {
+    for commit in commits.iter_mut() {
+        commit.children.clear();
     }
 
-    let mut branch_infos = branches
-        .into_iter()
-        .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
-        })
-        .collect::<Vec<_>>();
-
-    branch_infos.sort_by(|left, right| {
-        left.order_group
-            .cmp(&right.order_group)
-            .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
-            )
-            .then(left.name.cmp(&right.name))
-    });
-
-    Ok(branch_infos)
-}
-
-fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
-    match branch_type {
-        BranchType::Local => reference_name
-            .strip_prefix("refs/heads/")
-            .unwrap_or(reference_name),
-        BranchType::Remote => reference_name
-            .strip_prefix("refs/remotes/")
-            .unwrap_or(reference_name),
+    for child_index in 0..commits.len() {
+        for &parent_index in &commits[child_index].parents {
+            if let Some(parent) = commits.get_mut(parent_index) {
+                parent.children.push(child_index);
+            }
+        }
     }
 }
 
-fn trace_branch(
-    commits: &mut [CommitInfo],
-    indices: &HashMap<Oid, usize>,
-    branch: &mut BranchInfo,
-    branch_index: usize,
-) -> bool {
+fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
-    let mut range_end = branch.target_index;
+    let mut range_tail = branch.target_index;
     let mut range_valid = true;
+    let mut previous = None;
+    let mut merge_anchor = None;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
             Some(trace) if trace == branch_index => break,
-            Some(_) => {}
+            Some(_) => {
+                if let Some(child_index) = previous {
+                    merge_anchor = merge_anchor.or_else(|| merge_start(commits, index, child_index));
+                }
+                break;
+            }
             None => {
                 commits[index].branch_trace = Some(branch_index);
                 any_assigned = true;
-                range_end = index;
+                range_tail = index;
             }
         }
 
-        let parent_index = commits[index]
-            .parent_ids
-            .iter()
-            .filter_map(|oid| indices.get(oid))
-            .copied()
-            .next();
+        let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
-            if parent_index < range_end {
-                // Jumping forward indicates a non-contiguous range; skip column assignment.
+            if parent_index < range_tail {
                 range_valid = false;
                 break;
             }
         }
 
+        previous = Some(index);
         current = parent_index;
     }
 
     if any_assigned && range_valid {
-        branch.range = Some((range_end, branch.target_index));
+        let mut start = range_tail;
+        if let Some(anchor) = merge_anchor {
+            start = start.max(anchor);
+        }
+        branch.range = Some((start, branch.target_index));
     } else {
         branch.range = None;
     }
@@ -250,6 +309,20 @@
     any_assigned
 }
 
+fn merge_start(commits: &[CommitInfo], parent_index: usize, child_index: usize) -> Option<usize> {
+    let children = commits
+        .get(parent_index)
+        .map(|info| info.children.as_slice())
+        .unwrap_or(&[]);
+
+    if children.len() <= 1 {
+        return None;
+    }
+
+    let anchor = children.iter().copied().max()?;
+    Some(anchor.max(child_index))
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
@@ -259,14 +332,20 @@
         return;
     }
 
+    for branch in branches.iter_mut() {
+        branch.visual.column = None;
+    }
+
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
         if branch.range.is_none() {
             continue;
         }
 
-        // Group index may exceed configured order length; keep as-is for stable layout.
-        groups.entry(branch.order_group).or_default().push(index);
+        groups
+            .entry(branch.visual.order_group)
+            .or_default()
+            .push(index);
     }
 
     let mut offset = 0;
@@ -312,7 +391,7 @@
         let group_width = occupied.len();
 
         for (branch_index, column) in assignments {
-            branches[branch_index].column = Some(column + offset);
+            branches[branch_index].visual.column = Some(column + offset);
         }
 
         offset += group_width;
diff --git a/src/main.rs b/src/main.rs
index 6e320e9bd9209afaaf06b86efe9caf12162a0a09..cb035becd1afc90adc5869e0a5da930d9a82df95
--- a/src/main.rs
+++ b/src/main.rs
@@ -24,9 +24,12 @@
     let commit = graph.commit(info)?;
 
     let symbol = if commit.parent_count() > 1 { "o" } else { "*" };
+    let merge_marker = if commit.parent_count() > 1 { 'M' } else { '.' };
     let short_id = short_id(commit.id());
     let indent = commit_indent(graph, info);
 
+    let (column, span) = branch_metrics(graph, info);
+
     let branch_details = info
         .branches
         .iter()
@@ -40,9 +43,9 @@
     };
 
     let summary = commit.summary().unwrap_or("---");
-    println!(
-        "{}{} {}{} {}",
-        indent, symbol, short_id, branch_str, summary
+    eprintln!(
+        "{}{}{} {} [{} | {}]{} {}",
+        indent, merge_marker, symbol, short_id, column, span, branch_str, summary
     );
 
     Ok(())
@@ -53,24 +56,38 @@
     let indent = indent_for_branch(branch);
 
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column = branch.column.unwrap_or(99);
+    let column = branch
+        .visual
+        .column
+        .map(|value| value.to_string())
+        .unwrap_or_else(|| "-".to_string());
+    let range = format_range(branch.range);
 
     format!(
-        "{}{} (col {}){}",
-        indent, branch.name, column, deleted_suffix
+        "{}{} (col {} | range {} | color {}){}",
+        indent,
+        branch.name,
+        column,
+        range,
+        branch.visual.color_group,
+        deleted_suffix
     )
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {
     info.branch_trace
         .and_then(|index| graph.branches().get(index))
-        .and_then(|branch| branch.column)
+        .and_then(|branch| branch.visual.column)
         .map(indent_for_column)
         .unwrap_or_default()
 }
 
 fn indent_for_branch(branch: &BranchInfo) -> String {
-    branch.column.map(indent_for_column).unwrap_or_default()
+    branch
+        .visual
+        .column
+        .map(indent_for_column)
+        .unwrap_or_default()
 }
 
 fn indent_for_column(column: usize) -> String {
@@ -83,3 +100,24 @@
     id.truncate(7);
     id
 }
+
+fn branch_metrics(graph: &GitGraph, info: &CommitInfo) -> (String, String) {
+    info
+        .branch_trace
+        .and_then(|index| graph.branches().get(index))
+        .map(|branch| {
+            let column = branch
+                .visual
+                .column
+                .map(|value| value.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            (column, format_range(branch.range))
+        })
+        .unwrap_or_else(|| ("-".to_string(), "-".to_string()))
+}
+
+fn format_range(range: Option<(usize, usize)>) -> String {
+    range
+        .map(|(start, end)| format!("{}..{}", start.min(end), start.max(end)))
+        .unwrap_or_else(|| "-".to_string())
+}


[2025-09-21T12:26:57] thinking

**Adding color field to BranchSettings**
[2025-09-21T12:27:02] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/settings.rs
@@ -28,2 +28,4 @@
     pub order: Vec<Vec<&'static str>>,
+    /// Branch color group prefixes, used to map branches to palette slots.
+    pub color: Vec<Vec<&'static str>>,
 }
@@ -48,2 +50,10 @@
             ],
+            color: vec![
+                vec!["master", "main"],
+                vec!["develop", "dev"],
+                vec!["release"],
+                vec!["hotfix"],
+                vec!["feature"],
+                vec!["bugfix"],
+            ],
         }
[2025-09-21T12:27:02] apply_patch(auto_approved=true) exited 0 in 30ms:
Success. Updated the following files:
M src/settings.rs
[2025-09-21T12:27:02] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 982924ca97e4ce3ef4764cbf2ccc4d1bd4122343..97e24f5edacb42f0feb2d409f19c60449527401c
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,19 +5,26 @@
 pub struct CommitInfo {
     pub id: Oid,
     pub parent_ids: Vec<Oid>,
+    pub parents: Vec<usize>,
+    pub children: Vec<usize>,
     pub branches: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
+pub struct BranchVis {
+    pub order_group: usize,
+    pub color_group: usize,
+    pub column: Option<usize>,
+}
+
 pub struct BranchInfo {
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
     pub is_remote: bool,
-    pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
-    pub column: Option<usize>,
+    pub visual: BranchVis,
 }
 
 pub struct GitGraph {
@@ -35,14 +42,18 @@
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
+
         for (index, oid_result) in revwalk.enumerate() {
             let oid = oid_result?;
             let commit = repo.find_commit(oid)?;
             let parent_ids = commit.parent_ids().collect();
+
             indices.insert(oid, index);
             commits.push(CommitInfo {
                 id: oid,
                 parent_ids,
+                parents: Vec::new(),
+                children: Vec::new(),
                 branches: Vec::new(),
                 branch_trace: None,
             });
@@ -54,8 +65,12 @@
             branches: Vec::new(),
         };
 
+        assign_parent_indices(&mut graph.commits, &indices);
+        assign_children(&mut graph.commits);
+
         let branches = graph.assign_branches(&indices, settings)?;
         graph.branches = branches;
+
         assign_branch_columns(&graph.commits, &mut graph.branches, settings);
 
         Ok(graph)
@@ -71,10 +86,12 @@
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, indices, &mut info, branch_index);
+            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
 
             if !info.deleted {
-                self.commits[info.target_index].branches.push(branch_index);
+                self.commits[info.target_index]
+                    .branches
+                    .push(branch_index);
             }
 
             if assigned_any || !info.deleted {
@@ -98,6 +115,49 @@
     }
 }
 
+fn extract_branches(
+    repo: &Repository,
+    indices: &HashMap<Oid, usize>,
+    settings: &Settings,
+) -> Result<Vec<BranchInfo>, git2::Error> {
+    let mut branches = Vec::new();
+
+    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
+        let mut iter = repo.branches(Some(branch_type))?;
+        while let Some(branch_result) = iter.next() {
+            let (branch, _) = branch_result?;
+            branches.push((branch, branch_type));
+        }
+        Ok(())
+    };
+
+    push_branches(BranchType::Local)?;
+
+    if settings.include_remote {
+        push_branches(BranchType::Remote)?;
+    }
+
+    let mut branch_infos = branches
+        .into_iter()
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
+        .collect::<Vec<_>>();
+
+    branch_infos.sort_by(|left, right| {
+        left.visual
+            .order_group
+            .cmp(&right.visual.order_group)
+            .then(
+                branch_persistence(&left.name, &settings.branches)
+                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+            )
+            .then(left.name.cmp(&right.name))
+    });
+
+    Ok(branch_infos)
+}
+
 fn branch_info(
     branch: Branch,
     branch_type: BranchType,
@@ -111,19 +171,34 @@
     let target_index = indices.get(&target).copied()?;
     let short_name = branch_short_name(name, branch_type);
     let order_group = branch_order(short_name, settings);
+    let color_group = branch_color(short_name, settings);
 
     Some(BranchInfo {
         name: short_name.to_string(),
         target,
         target_index,
         is_remote: branch_type == BranchType::Remote,
-        order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
-        column: None,
+        visual: BranchVis {
+            order_group,
+            color_group,
+            column: None,
+        },
     })
 }
 
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
+}
+
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
     let name = normalized_branch_name(name);
     settings
@@ -144,105 +219,89 @@
         .unwrap_or(settings.order.len())
 }
 
+fn branch_color(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
+    settings
+        .color
+        .iter()
+        .enumerate()
+        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
+        .map(|(index, _)| index)
+        .unwrap_or(settings.color.len())
+}
+
 fn normalized_branch_name(name: &str) -> &str {
     name.strip_prefix("origin/").unwrap_or(name)
 }
 
-fn extract_branches(
-    repo: &Repository,
-    indices: &HashMap<Oid, usize>,
-    settings: &Settings,
-) -> Result<Vec<BranchInfo>, git2::Error> {
-    let mut branches = Vec::new();
-
-    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
-        let mut iter = repo.branches(Some(branch_type))?;
-        while let Some(branch_result) = iter.next() {
-            let (branch, _) = branch_result?;
-            branches.push((branch, branch_type));
+fn assign_parent_indices(commits: &mut [CommitInfo], indices: &HashMap<Oid, usize>) {
+    for info in commits.iter_mut() {
+        info.parents.clear();
+        for oid in &info.parent_ids {
+            if let Some(index) = indices.get(oid) {
+                info.parents.push(*index);
+            }
         }
-        Ok(())
-    };
-
-    push_branches(BranchType::Local)?;
+    }
+}
 
-    if settings.include_remote {
-        push_branches(BranchType::Remote)?;
+fn assign_children(commits: &mut [CommitInfo]) {
+    for commit in commits.iter_mut() {
+        commit.children.clear();
     }
 
-    let mut branch_infos = branches
-        .into_iter()
-        .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
-        })
-        .collect::<Vec<_>>();
-
-    branch_infos.sort_by(|left, right| {
-        left.order_group
-            .cmp(&right.order_group)
-            .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
-            )
-            .then(left.name.cmp(&right.name))
-    });
-
-    Ok(branch_infos)
-}
-
-fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
-    match branch_type {
-        BranchType::Local => reference_name
-            .strip_prefix("refs/heads/")
-            .unwrap_or(reference_name),
-        BranchType::Remote => reference_name
-            .strip_prefix("refs/remotes/")
-            .unwrap_or(reference_name),
+    for child_index in 0..commits.len() {
+        for &parent_index in &commits[child_index].parents {
+            if let Some(parent) = commits.get_mut(parent_index) {
+                parent.children.push(child_index);
+            }
+        }
     }
 }
 
-fn trace_branch(
-    commits: &mut [CommitInfo],
-    indices: &HashMap<Oid, usize>,
-    branch: &mut BranchInfo,
-    branch_index: usize,
-) -> bool {
+fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
-    let mut range_end = branch.target_index;
+    let mut range_tail = branch.target_index;
     let mut range_valid = true;
+    let mut previous = None;
+    let mut merge_anchor = None;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
             Some(trace) if trace == branch_index => break,
-            Some(_) => {}
+            Some(_) => {
+                if let Some(child_index) = previous {
+                    merge_anchor = merge_anchor.or_else(|| merge_start(commits, index, child_index));
+                }
+                break;
+            }
             None => {
                 commits[index].branch_trace = Some(branch_index);
                 any_assigned = true;
-                range_end = index;
+                range_tail = index;
             }
         }
 
-        let parent_index = commits[index]
-            .parent_ids
-            .iter()
-            .filter_map(|oid| indices.get(oid))
-            .copied()
-            .next();
+        let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
-            if parent_index < range_end {
-                // Jumping forward indicates a non-contiguous range; skip column assignment.
+            if parent_index < range_tail {
                 range_valid = false;
                 break;
             }
         }
 
+        previous = Some(index);
         current = parent_index;
     }
 
     if any_assigned && range_valid {
-        branch.range = Some((range_end, branch.target_index));
+        let mut start = range_tail;
+        if let Some(anchor) = merge_anchor {
+            start = start.max(anchor);
+        }
+        branch.range = Some((start, branch.target_index));
     } else {
         branch.range = None;
     }
@@ -250,6 +309,20 @@
     any_assigned
 }
 
+fn merge_start(commits: &[CommitInfo], parent_index: usize, child_index: usize) -> Option<usize> {
+    let children = commits
+        .get(parent_index)
+        .map(|info| info.children.as_slice())
+        .unwrap_or(&[]);
+
+    if children.len() <= 1 {
+        return None;
+    }
+
+    let anchor = children.iter().copied().max()?;
+    Some(anchor.max(child_index))
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
@@ -259,14 +332,20 @@
         return;
     }
 
+    for branch in branches.iter_mut() {
+        branch.visual.column = None;
+    }
+
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
         if branch.range.is_none() {
             continue;
         }
 
-        // Group index may exceed configured order length; keep as-is for stable layout.
-        groups.entry(branch.order_group).or_default().push(index);
+        groups
+            .entry(branch.visual.order_group)
+            .or_default()
+            .push(index);
     }
 
     let mut offset = 0;
@@ -312,7 +391,7 @@
         let group_width = occupied.len();
 
         for (branch_index, column) in assignments {
-            branches[branch_index].column = Some(column + offset);
+            branches[branch_index].visual.column = Some(column + offset);
         }
 
         offset += group_width;
diff --git a/src/main.rs b/src/main.rs
index 6e320e9bd9209afaaf06b86efe9caf12162a0a09..cb035becd1afc90adc5869e0a5da930d9a82df95
--- a/src/main.rs
+++ b/src/main.rs
@@ -24,9 +24,12 @@
     let commit = graph.commit(info)?;
 
     let symbol = if commit.parent_count() > 1 { "o" } else { "*" };
+    let merge_marker = if commit.parent_count() > 1 { 'M' } else { '.' };
     let short_id = short_id(commit.id());
     let indent = commit_indent(graph, info);
 
+    let (column, span) = branch_metrics(graph, info);
+
     let branch_details = info
         .branches
         .iter()
@@ -40,9 +43,9 @@
     };
 
     let summary = commit.summary().unwrap_or("---");
-    println!(
-        "{}{} {}{} {}",
-        indent, symbol, short_id, branch_str, summary
+    eprintln!(
+        "{}{}{} {} [{} | {}]{} {}",
+        indent, merge_marker, symbol, short_id, column, span, branch_str, summary
     );
 
     Ok(())
@@ -53,24 +56,38 @@
     let indent = indent_for_branch(branch);
 
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column = branch.column.unwrap_or(99);
+    let column = branch
+        .visual
+        .column
+        .map(|value| value.to_string())
+        .unwrap_or_else(|| "-".to_string());
+    let range = format_range(branch.range);
 
     format!(
-        "{}{} (col {}){}",
-        indent, branch.name, column, deleted_suffix
+        "{}{} (col {} | range {} | color {}){}",
+        indent,
+        branch.name,
+        column,
+        range,
+        branch.visual.color_group,
+        deleted_suffix
     )
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {
     info.branch_trace
         .and_then(|index| graph.branches().get(index))
-        .and_then(|branch| branch.column)
+        .and_then(|branch| branch.visual.column)
         .map(indent_for_column)
         .unwrap_or_default()
 }
 
 fn indent_for_branch(branch: &BranchInfo) -> String {
-    branch.column.map(indent_for_column).unwrap_or_default()
+    branch
+        .visual
+        .column
+        .map(indent_for_column)
+        .unwrap_or_default()
 }
 
 fn indent_for_column(column: usize) -> String {
@@ -83,3 +100,24 @@
     id.truncate(7);
     id
 }
+
+fn branch_metrics(graph: &GitGraph, info: &CommitInfo) -> (String, String) {
+    info
+        .branch_trace
+        .and_then(|index| graph.branches().get(index))
+        .map(|branch| {
+            let column = branch
+                .visual
+                .column
+                .map(|value| value.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            (column, format_range(branch.range))
+        })
+        .unwrap_or_else(|| ("-".to_string(), "-".to_string()))
+}
+
+fn format_range(range: Option<(usize, usize)>) -> String {
+    range
+        .map(|(start, end)| format!("{}..{}", start.min(end), start.max(end)))
+        .unwrap_or_else(|| "-".to_string())
+}
diff --git a/src/settings.rs b/src/settings.rs
index b25f1cec3dcfa4d21a1a1d4571e99379ec987969..77f4ff5ce72584c8bd6069341bab631d0ab1ebc6
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -26,6 +26,8 @@
     pub persistence: Vec<&'static str>,
     /// Branch grouping order used for indentation.
     pub order: Vec<Vec<&'static str>>,
+    /// Branch color group prefixes, used to map branches to palette slots.
+    pub color: Vec<Vec<&'static str>>,
 }
 
 impl Default for BranchSettings {
@@ -46,6 +48,14 @@
                 vec!["release", "hotfix"],
                 vec!["feature", "bugfix"],
             ],
+            color: vec![
+                vec!["master", "main"],
+                vec!["develop", "dev"],
+                vec!["release"],
+                vec!["hotfix"],
+                vec!["feature"],
+                vec!["bugfix"],
+            ],
         }
     }
 }

[2025-09-21T12:27:02] tokens used: 109,674
[2025-09-21T12:27:02] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 982924ca97e4ce3ef4764cbf2ccc4d1bd4122343..97e24f5edacb42f0feb2d409f19c60449527401c
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,19 +5,26 @@
 pub struct CommitInfo {
     pub id: Oid,
     pub parent_ids: Vec<Oid>,
+    pub parents: Vec<usize>,
+    pub children: Vec<usize>,
     pub branches: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
+pub struct BranchVis {
+    pub order_group: usize,
+    pub color_group: usize,
+    pub column: Option<usize>,
+}
+
 pub struct BranchInfo {
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
     pub is_remote: bool,
-    pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
-    pub column: Option<usize>,
+    pub visual: BranchVis,
 }
 
 pub struct GitGraph {
@@ -35,14 +42,18 @@
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
+
         for (index, oid_result) in revwalk.enumerate() {
             let oid = oid_result?;
             let commit = repo.find_commit(oid)?;
             let parent_ids = commit.parent_ids().collect();
+
             indices.insert(oid, index);
             commits.push(CommitInfo {
                 id: oid,
                 parent_ids,
+                parents: Vec::new(),
+                children: Vec::new(),
                 branches: Vec::new(),
                 branch_trace: None,
             });
@@ -54,8 +65,12 @@
             branches: Vec::new(),
         };
 
+        assign_parent_indices(&mut graph.commits, &indices);
+        assign_children(&mut graph.commits);
+
         let branches = graph.assign_branches(&indices, settings)?;
         graph.branches = branches;
+
         assign_branch_columns(&graph.commits, &mut graph.branches, settings);
 
         Ok(graph)
@@ -71,10 +86,12 @@
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, indices, &mut info, branch_index);
+            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
 
             if !info.deleted {
-                self.commits[info.target_index].branches.push(branch_index);
+                self.commits[info.target_index]
+                    .branches
+                    .push(branch_index);
             }
 
             if assigned_any || !info.deleted {
@@ -98,6 +115,49 @@
     }
 }
 
+fn extract_branches(
+    repo: &Repository,
+    indices: &HashMap<Oid, usize>,
+    settings: &Settings,
+) -> Result<Vec<BranchInfo>, git2::Error> {
+    let mut branches = Vec::new();
+
+    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
+        let mut iter = repo.branches(Some(branch_type))?;
+        while let Some(branch_result) = iter.next() {
+            let (branch, _) = branch_result?;
+            branches.push((branch, branch_type));
+        }
+        Ok(())
+    };
+
+    push_branches(BranchType::Local)?;
+
+    if settings.include_remote {
+        push_branches(BranchType::Remote)?;
+    }
+
+    let mut branch_infos = branches
+        .into_iter()
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
+        .collect::<Vec<_>>();
+
+    branch_infos.sort_by(|left, right| {
+        left.visual
+            .order_group
+            .cmp(&right.visual.order_group)
+            .then(
+                branch_persistence(&left.name, &settings.branches)
+                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+            )
+            .then(left.name.cmp(&right.name))
+    });
+
+    Ok(branch_infos)
+}
+
 fn branch_info(
     branch: Branch,
     branch_type: BranchType,
@@ -111,19 +171,34 @@
     let target_index = indices.get(&target).copied()?;
     let short_name = branch_short_name(name, branch_type);
     let order_group = branch_order(short_name, settings);
+    let color_group = branch_color(short_name, settings);
 
     Some(BranchInfo {
         name: short_name.to_string(),
         target,
         target_index,
         is_remote: branch_type == BranchType::Remote,
-        order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
-        column: None,
+        visual: BranchVis {
+            order_group,
+            color_group,
+            column: None,
+        },
     })
 }
 
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
+}
+
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
     let name = normalized_branch_name(name);
     settings
@@ -144,105 +219,89 @@
         .unwrap_or(settings.order.len())
 }
 
+fn branch_color(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
+    settings
+        .color
+        .iter()
+        .enumerate()
+        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
+        .map(|(index, _)| index)
+        .unwrap_or(settings.color.len())
+}
+
 fn normalized_branch_name(name: &str) -> &str {
     name.strip_prefix("origin/").unwrap_or(name)
 }
 
-fn extract_branches(
-    repo: &Repository,
-    indices: &HashMap<Oid, usize>,
-    settings: &Settings,
-) -> Result<Vec<BranchInfo>, git2::Error> {
-    let mut branches = Vec::new();
-
-    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
-        let mut iter = repo.branches(Some(branch_type))?;
-        while let Some(branch_result) = iter.next() {
-            let (branch, _) = branch_result?;
-            branches.push((branch, branch_type));
+fn assign_parent_indices(commits: &mut [CommitInfo], indices: &HashMap<Oid, usize>) {
+    for info in commits.iter_mut() {
+        info.parents.clear();
+        for oid in &info.parent_ids {
+            if let Some(index) = indices.get(oid) {
+                info.parents.push(*index);
+            }
         }
-        Ok(())
-    };
-
-    push_branches(BranchType::Local)?;
+    }
+}
 
-    if settings.include_remote {
-        push_branches(BranchType::Remote)?;
+fn assign_children(commits: &mut [CommitInfo]) {
+    for commit in commits.iter_mut() {
+        commit.children.clear();
     }
 
-    let mut branch_infos = branches
-        .into_iter()
-        .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
-        })
-        .collect::<Vec<_>>();
-
-    branch_infos.sort_by(|left, right| {
-        left.order_group
-            .cmp(&right.order_group)
-            .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
-            )
-            .then(left.name.cmp(&right.name))
-    });
-
-    Ok(branch_infos)
-}
-
-fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
-    match branch_type {
-        BranchType::Local => reference_name
-            .strip_prefix("refs/heads/")
-            .unwrap_or(reference_name),
-        BranchType::Remote => reference_name
-            .strip_prefix("refs/remotes/")
-            .unwrap_or(reference_name),
+    for child_index in 0..commits.len() {
+        for &parent_index in &commits[child_index].parents {
+            if let Some(parent) = commits.get_mut(parent_index) {
+                parent.children.push(child_index);
+            }
+        }
     }
 }
 
-fn trace_branch(
-    commits: &mut [CommitInfo],
-    indices: &HashMap<Oid, usize>,
-    branch: &mut BranchInfo,
-    branch_index: usize,
-) -> bool {
+fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
-    let mut range_end = branch.target_index;
+    let mut range_tail = branch.target_index;
     let mut range_valid = true;
+    let mut previous = None;
+    let mut merge_anchor = None;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
             Some(trace) if trace == branch_index => break,
-            Some(_) => {}
+            Some(_) => {
+                if let Some(child_index) = previous {
+                    merge_anchor = merge_anchor.or_else(|| merge_start(commits, index, child_index));
+                }
+                break;
+            }
             None => {
                 commits[index].branch_trace = Some(branch_index);
                 any_assigned = true;
-                range_end = index;
+                range_tail = index;
             }
         }
 
-        let parent_index = commits[index]
-            .parent_ids
-            .iter()
-            .filter_map(|oid| indices.get(oid))
-            .copied()
-            .next();
+        let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
-            if parent_index < range_end {
-                // Jumping forward indicates a non-contiguous range; skip column assignment.
+            if parent_index < range_tail {
                 range_valid = false;
                 break;
             }
         }
 
+        previous = Some(index);
         current = parent_index;
     }
 
     if any_assigned && range_valid {
-        branch.range = Some((range_end, branch.target_index));
+        let mut start = range_tail;
+        if let Some(anchor) = merge_anchor {
+            start = start.max(anchor);
+        }
+        branch.range = Some((start, branch.target_index));
     } else {
         branch.range = None;
     }
@@ -250,6 +309,20 @@
     any_assigned
 }
 
+fn merge_start(commits: &[CommitInfo], parent_index: usize, child_index: usize) -> Option<usize> {
+    let children = commits
+        .get(parent_index)
+        .map(|info| info.children.as_slice())
+        .unwrap_or(&[]);
+
+    if children.len() <= 1 {
+        return None;
+    }
+
+    let anchor = children.iter().copied().max()?;
+    Some(anchor.max(child_index))
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
@@ -259,14 +332,20 @@
         return;
     }
 
+    for branch in branches.iter_mut() {
+        branch.visual.column = None;
+    }
+
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
         if branch.range.is_none() {
             continue;
         }
 
-        // Group index may exceed configured order length; keep as-is for stable layout.
-        groups.entry(branch.order_group).or_default().push(index);
+        groups
+            .entry(branch.visual.order_group)
+            .or_default()
+            .push(index);
     }
 
     let mut offset = 0;
@@ -312,7 +391,7 @@
         let group_width = occupied.len();
 
         for (branch_index, column) in assignments {
-            branches[branch_index].column = Some(column + offset);
+            branches[branch_index].visual.column = Some(column + offset);
         }
 
         offset += group_width;
diff --git a/src/main.rs b/src/main.rs
index 6e320e9bd9209afaaf06b86efe9caf12162a0a09..cb035becd1afc90adc5869e0a5da930d9a82df95
--- a/src/main.rs
+++ b/src/main.rs
@@ -24,9 +24,12 @@
     let commit = graph.commit(info)?;
 
     let symbol = if commit.parent_count() > 1 { "o" } else { "*" };
+    let merge_marker = if commit.parent_count() > 1 { 'M' } else { '.' };
     let short_id = short_id(commit.id());
     let indent = commit_indent(graph, info);
 
+    let (column, span) = branch_metrics(graph, info);
+
     let branch_details = info
         .branches
         .iter()
@@ -40,9 +43,9 @@
     };
 
     let summary = commit.summary().unwrap_or("---");
-    println!(
-        "{}{} {}{} {}",
-        indent, symbol, short_id, branch_str, summary
+    eprintln!(
+        "{}{}{} {} [{} | {}]{} {}",
+        indent, merge_marker, symbol, short_id, column, span, branch_str, summary
     );
 
     Ok(())
@@ -53,24 +56,38 @@
     let indent = indent_for_branch(branch);
 
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column = branch.column.unwrap_or(99);
+    let column = branch
+        .visual
+        .column
+        .map(|value| value.to_string())
+        .unwrap_or_else(|| "-".to_string());
+    let range = format_range(branch.range);
 
     format!(
-        "{}{} (col {}){}",
-        indent, branch.name, column, deleted_suffix
+        "{}{} (col {} | range {} | color {}){}",
+        indent,
+        branch.name,
+        column,
+        range,
+        branch.visual.color_group,
+        deleted_suffix
     )
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {
     info.branch_trace
         .and_then(|index| graph.branches().get(index))
-        .and_then(|branch| branch.column)
+        .and_then(|branch| branch.visual.column)
         .map(indent_for_column)
         .unwrap_or_default()
 }
 
 fn indent_for_branch(branch: &BranchInfo) -> String {
-    branch.column.map(indent_for_column).unwrap_or_default()
+    branch
+        .visual
+        .column
+        .map(indent_for_column)
+        .unwrap_or_default()
 }
 
 fn indent_for_column(column: usize) -> String {
@@ -83,3 +100,24 @@
     id.truncate(7);
     id
 }
+
+fn branch_metrics(graph: &GitGraph, info: &CommitInfo) -> (String, String) {
+    info
+        .branch_trace
+        .and_then(|index| graph.branches().get(index))
+        .map(|branch| {
+            let column = branch
+                .visual
+                .column
+                .map(|value| value.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            (column, format_range(branch.range))
+        })
+        .unwrap_or_else(|| ("-".to_string(), "-".to_string()))
+}
+
+fn format_range(range: Option<(usize, usize)>) -> String {
+    range
+        .map(|(start, end)| format!("{}..{}", start.min(end), start.max(end)))
+        .unwrap_or_else(|| "-".to_string())
+}
diff --git a/src/settings.rs b/src/settings.rs
index b25f1cec3dcfa4d21a1a1d4571e99379ec987969..77f4ff5ce72584c8bd6069341bab631d0ab1ebc6
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -26,6 +26,8 @@
     pub persistence: Vec<&'static str>,
     /// Branch grouping order used for indentation.
     pub order: Vec<Vec<&'static str>>,
+    /// Branch color group prefixes, used to map branches to palette slots.
+    pub color: Vec<Vec<&'static str>>,
 }
 
 impl Default for BranchSettings {
@@ -46,6 +48,14 @@
                 vec!["release", "hotfix"],
                 vec!["feature", "bugfix"],
             ],
+            color: vec![
+                vec!["master", "main"],
+                vec!["develop", "dev"],
+                vec!["release"],
+                vec!["hotfix"],
+                vec!["feature"],
+                vec!["bugfix"],
+            ],
         }
     }
 }


[2025-09-21T12:27:11] thinking

**Verifying data structure integration and code formatting**
[2025-09-21T12:27:11] exec bash -lc 'cargo fmt' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:27:11] bash -lc 'cargo fmt' succeeded in 70ms:

[2025-09-21T12:27:11] tokens used: 111,783
[2025-09-21T12:27:11] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 982924ca97e4ce3ef4764cbf2ccc4d1bd4122343..d440daef0ddc990bb7d87ea5a4004926dbd7f28b
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,19 +5,26 @@
 pub struct CommitInfo {
     pub id: Oid,
     pub parent_ids: Vec<Oid>,
+    pub parents: Vec<usize>,
+    pub children: Vec<usize>,
     pub branches: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
+pub struct BranchVis {
+    pub order_group: usize,
+    pub color_group: usize,
+    pub column: Option<usize>,
+}
+
 pub struct BranchInfo {
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
     pub is_remote: bool,
-    pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
-    pub column: Option<usize>,
+    pub visual: BranchVis,
 }
 
 pub struct GitGraph {
@@ -35,14 +42,18 @@
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
+
         for (index, oid_result) in revwalk.enumerate() {
             let oid = oid_result?;
             let commit = repo.find_commit(oid)?;
             let parent_ids = commit.parent_ids().collect();
+
             indices.insert(oid, index);
             commits.push(CommitInfo {
                 id: oid,
                 parent_ids,
+                parents: Vec::new(),
+                children: Vec::new(),
                 branches: Vec::new(),
                 branch_trace: None,
             });
@@ -54,8 +65,12 @@
             branches: Vec::new(),
         };
 
+        assign_parent_indices(&mut graph.commits, &indices);
+        assign_children(&mut graph.commits);
+
         let branches = graph.assign_branches(&indices, settings)?;
         graph.branches = branches;
+
         assign_branch_columns(&graph.commits, &mut graph.branches, settings);
 
         Ok(graph)
@@ -71,7 +86,7 @@
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, indices, &mut info, branch_index);
+            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -98,6 +113,49 @@
     }
 }
 
+fn extract_branches(
+    repo: &Repository,
+    indices: &HashMap<Oid, usize>,
+    settings: &Settings,
+) -> Result<Vec<BranchInfo>, git2::Error> {
+    let mut branches = Vec::new();
+
+    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
+        let mut iter = repo.branches(Some(branch_type))?;
+        while let Some(branch_result) = iter.next() {
+            let (branch, _) = branch_result?;
+            branches.push((branch, branch_type));
+        }
+        Ok(())
+    };
+
+    push_branches(BranchType::Local)?;
+
+    if settings.include_remote {
+        push_branches(BranchType::Remote)?;
+    }
+
+    let mut branch_infos = branches
+        .into_iter()
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
+        .collect::<Vec<_>>();
+
+    branch_infos.sort_by(|left, right| {
+        left.visual
+            .order_group
+            .cmp(&right.visual.order_group)
+            .then(
+                branch_persistence(&left.name, &settings.branches)
+                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+            )
+            .then(left.name.cmp(&right.name))
+    });
+
+    Ok(branch_infos)
+}
+
 fn branch_info(
     branch: Branch,
     branch_type: BranchType,
@@ -111,19 +169,34 @@
     let target_index = indices.get(&target).copied()?;
     let short_name = branch_short_name(name, branch_type);
     let order_group = branch_order(short_name, settings);
+    let color_group = branch_color(short_name, settings);
 
     Some(BranchInfo {
         name: short_name.to_string(),
         target,
         target_index,
         is_remote: branch_type == BranchType::Remote,
-        order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
-        column: None,
+        visual: BranchVis {
+            order_group,
+            color_group,
+            column: None,
+        },
     })
 }
 
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
+}
+
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
     let name = normalized_branch_name(name);
     settings
@@ -144,105 +217,90 @@
         .unwrap_or(settings.order.len())
 }
 
+fn branch_color(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
+    settings
+        .color
+        .iter()
+        .enumerate()
+        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
+        .map(|(index, _)| index)
+        .unwrap_or(settings.color.len())
+}
+
 fn normalized_branch_name(name: &str) -> &str {
     name.strip_prefix("origin/").unwrap_or(name)
 }
 
-fn extract_branches(
-    repo: &Repository,
-    indices: &HashMap<Oid, usize>,
-    settings: &Settings,
-) -> Result<Vec<BranchInfo>, git2::Error> {
-    let mut branches = Vec::new();
-
-    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
-        let mut iter = repo.branches(Some(branch_type))?;
-        while let Some(branch_result) = iter.next() {
-            let (branch, _) = branch_result?;
-            branches.push((branch, branch_type));
+fn assign_parent_indices(commits: &mut [CommitInfo], indices: &HashMap<Oid, usize>) {
+    for info in commits.iter_mut() {
+        info.parents.clear();
+        for oid in &info.parent_ids {
+            if let Some(index) = indices.get(oid) {
+                info.parents.push(*index);
+            }
         }
-        Ok(())
-    };
+    }
+}
 
-    push_branches(BranchType::Local)?;
-
-    if settings.include_remote {
-        push_branches(BranchType::Remote)?;
+fn assign_children(commits: &mut [CommitInfo]) {
+    for commit in commits.iter_mut() {
+        commit.children.clear();
     }
 
-    let mut branch_infos = branches
-        .into_iter()
-        .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
-        })
-        .collect::<Vec<_>>();
-
-    branch_infos.sort_by(|left, right| {
-        left.order_group
-            .cmp(&right.order_group)
-            .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
-            )
-            .then(left.name.cmp(&right.name))
-    });
-
-    Ok(branch_infos)
-}
-
-fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
-    match branch_type {
-        BranchType::Local => reference_name
-            .strip_prefix("refs/heads/")
-            .unwrap_or(reference_name),
-        BranchType::Remote => reference_name
-            .strip_prefix("refs/remotes/")
-            .unwrap_or(reference_name),
+    for child_index in 0..commits.len() {
+        for &parent_index in &commits[child_index].parents {
+            if let Some(parent) = commits.get_mut(parent_index) {
+                parent.children.push(child_index);
+            }
+        }
     }
 }
 
-fn trace_branch(
-    commits: &mut [CommitInfo],
-    indices: &HashMap<Oid, usize>,
-    branch: &mut BranchInfo,
-    branch_index: usize,
-) -> bool {
+fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
-    let mut range_end = branch.target_index;
+    let mut range_tail = branch.target_index;
     let mut range_valid = true;
+    let mut previous = None;
+    let mut merge_anchor = None;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
             Some(trace) if trace == branch_index => break,
-            Some(_) => {}
+            Some(_) => {
+                if let Some(child_index) = previous {
+                    merge_anchor =
+                        merge_anchor.or_else(|| merge_start(commits, index, child_index));
+                }
+                break;
+            }
             None => {
                 commits[index].branch_trace = Some(branch_index);
                 any_assigned = true;
-                range_end = index;
+                range_tail = index;
             }
         }
 
-        let parent_index = commits[index]
-            .parent_ids
-            .iter()
-            .filter_map(|oid| indices.get(oid))
-            .copied()
-            .next();
+        let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
-            if parent_index < range_end {
-                // Jumping forward indicates a non-contiguous range; skip column assignment.
+            if parent_index < range_tail {
                 range_valid = false;
                 break;
             }
         }
 
+        previous = Some(index);
         current = parent_index;
     }
 
     if any_assigned && range_valid {
-        branch.range = Some((range_end, branch.target_index));
+        let mut start = range_tail;
+        if let Some(anchor) = merge_anchor {
+            start = start.max(anchor);
+        }
+        branch.range = Some((start, branch.target_index));
     } else {
         branch.range = None;
     }
@@ -250,6 +308,20 @@
     any_assigned
 }
 
+fn merge_start(commits: &[CommitInfo], parent_index: usize, child_index: usize) -> Option<usize> {
+    let children = commits
+        .get(parent_index)
+        .map(|info| info.children.as_slice())
+        .unwrap_or(&[]);
+
+    if children.len() <= 1 {
+        return None;
+    }
+
+    let anchor = children.iter().copied().max()?;
+    Some(anchor.max(child_index))
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
@@ -259,14 +331,20 @@
         return;
     }
 
+    for branch in branches.iter_mut() {
+        branch.visual.column = None;
+    }
+
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
         if branch.range.is_none() {
             continue;
         }
 
-        // Group index may exceed configured order length; keep as-is for stable layout.
-        groups.entry(branch.order_group).or_default().push(index);
+        groups
+            .entry(branch.visual.order_group)
+            .or_default()
+            .push(index);
     }
 
     let mut offset = 0;
@@ -312,7 +390,7 @@
         let group_width = occupied.len();
 
         for (branch_index, column) in assignments {
-            branches[branch_index].column = Some(column + offset);
+            branches[branch_index].visual.column = Some(column + offset);
         }
 
         offset += group_width;
diff --git a/src/main.rs b/src/main.rs
index 6e320e9bd9209afaaf06b86efe9caf12162a0a09..c2a6f05ed62b7ed7fffade0517a99a78b99f6f72
--- a/src/main.rs
+++ b/src/main.rs
@@ -24,9 +24,12 @@
     let commit = graph.commit(info)?;
 
     let symbol = if commit.parent_count() > 1 { "o" } else { "*" };
+    let merge_marker = if commit.parent_count() > 1 { 'M' } else { '.' };
     let short_id = short_id(commit.id());
     let indent = commit_indent(graph, info);
 
+    let (column, span) = branch_metrics(graph, info);
+
     let branch_details = info
         .branches
         .iter()
@@ -40,9 +43,9 @@
     };
 
     let summary = commit.summary().unwrap_or("---");
-    println!(
-        "{}{} {}{} {}",
-        indent, symbol, short_id, branch_str, summary
+    eprintln!(
+        "{}{}{} {} [{} | {}]{} {}",
+        indent, merge_marker, symbol, short_id, column, span, branch_str, summary
     );
 
     Ok(())
@@ -53,24 +56,33 @@
     let indent = indent_for_branch(branch);
 
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column = branch.column.unwrap_or(99);
+    let column = branch
+        .visual
+        .column
+        .map(|value| value.to_string())
+        .unwrap_or_else(|| "-".to_string());
+    let range = format_range(branch.range);
 
     format!(
-        "{}{} (col {}){}",
-        indent, branch.name, column, deleted_suffix
+        "{}{} (col {} | range {} | color {}){}",
+        indent, branch.name, column, range, branch.visual.color_group, deleted_suffix
     )
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {
     info.branch_trace
         .and_then(|index| graph.branches().get(index))
-        .and_then(|branch| branch.column)
+        .and_then(|branch| branch.visual.column)
         .map(indent_for_column)
         .unwrap_or_default()
 }
 
 fn indent_for_branch(branch: &BranchInfo) -> String {
-    branch.column.map(indent_for_column).unwrap_or_default()
+    branch
+        .visual
+        .column
+        .map(indent_for_column)
+        .unwrap_or_default()
 }
 
 fn indent_for_column(column: usize) -> String {
@@ -83,3 +95,23 @@
     id.truncate(7);
     id
 }
+
+fn branch_metrics(graph: &GitGraph, info: &CommitInfo) -> (String, String) {
+    info.branch_trace
+        .and_then(|index| graph.branches().get(index))
+        .map(|branch| {
+            let column = branch
+                .visual
+                .column
+                .map(|value| value.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            (column, format_range(branch.range))
+        })
+        .unwrap_or_else(|| ("-".to_string(), "-".to_string()))
+}
+
+fn format_range(range: Option<(usize, usize)>) -> String {
+    range
+        .map(|(start, end)| format!("{}..{}", start.min(end), start.max(end)))
+        .unwrap_or_else(|| "-".to_string())
+}
diff --git a/src/settings.rs b/src/settings.rs
index b25f1cec3dcfa4d21a1a1d4571e99379ec987969..77f4ff5ce72584c8bd6069341bab631d0ab1ebc6
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -26,6 +26,8 @@
     pub persistence: Vec<&'static str>,
     /// Branch grouping order used for indentation.
     pub order: Vec<Vec<&'static str>>,
+    /// Branch color group prefixes, used to map branches to palette slots.
+    pub color: Vec<Vec<&'static str>>,
 }
 
 impl Default for BranchSettings {
@@ -46,6 +48,14 @@
                 vec!["release", "hotfix"],
                 vec!["feature", "bugfix"],
             ],
+            color: vec![
+                vec!["master", "main"],
+                vec!["develop", "dev"],
+                vec!["release"],
+                vec!["hotfix"],
+                vec!["feature"],
+                vec!["bugfix"],
+            ],
         }
     }
 }


[2025-09-21T12:27:14] thinking

**Building the project**
[2025-09-21T12:27:14] exec bash -lc 'cargo build' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:27:24] bash -lc 'cargo build' exited 124 in 10.01s:
 Downloading crates ...
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: static.crates.io)
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: static.crates.io)
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: static.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: static.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: static.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: static.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: static.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: static.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: static.crates.io)
[2025-09-21T12:27:24] tokens used: 111,947
[2025-09-21T12:27:24] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 982924ca97e4ce3ef4764cbf2ccc4d1bd4122343..d440daef0ddc990bb7d87ea5a4004926dbd7f28b
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,19 +5,26 @@
 pub struct CommitInfo {
     pub id: Oid,
     pub parent_ids: Vec<Oid>,
+    pub parents: Vec<usize>,
+    pub children: Vec<usize>,
     pub branches: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
+pub struct BranchVis {
+    pub order_group: usize,
+    pub color_group: usize,
+    pub column: Option<usize>,
+}
+
 pub struct BranchInfo {
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
     pub is_remote: bool,
-    pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
-    pub column: Option<usize>,
+    pub visual: BranchVis,
 }
 
 pub struct GitGraph {
@@ -35,14 +42,18 @@
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
+
         for (index, oid_result) in revwalk.enumerate() {
             let oid = oid_result?;
             let commit = repo.find_commit(oid)?;
             let parent_ids = commit.parent_ids().collect();
+
             indices.insert(oid, index);
             commits.push(CommitInfo {
                 id: oid,
                 parent_ids,
+                parents: Vec::new(),
+                children: Vec::new(),
                 branches: Vec::new(),
                 branch_trace: None,
             });
@@ -54,8 +65,12 @@
             branches: Vec::new(),
         };
 
+        assign_parent_indices(&mut graph.commits, &indices);
+        assign_children(&mut graph.commits);
+
         let branches = graph.assign_branches(&indices, settings)?;
         graph.branches = branches;
+
         assign_branch_columns(&graph.commits, &mut graph.branches, settings);
 
         Ok(graph)
@@ -71,7 +86,7 @@
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, indices, &mut info, branch_index);
+            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -98,6 +113,49 @@
     }
 }
 
+fn extract_branches(
+    repo: &Repository,
+    indices: &HashMap<Oid, usize>,
+    settings: &Settings,
+) -> Result<Vec<BranchInfo>, git2::Error> {
+    let mut branches = Vec::new();
+
+    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
+        let mut iter = repo.branches(Some(branch_type))?;
+        while let Some(branch_result) = iter.next() {
+            let (branch, _) = branch_result?;
+            branches.push((branch, branch_type));
+        }
+        Ok(())
+    };
+
+    push_branches(BranchType::Local)?;
+
+    if settings.include_remote {
+        push_branches(BranchType::Remote)?;
+    }
+
+    let mut branch_infos = branches
+        .into_iter()
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
+        .collect::<Vec<_>>();
+
+    branch_infos.sort_by(|left, right| {
+        left.visual
+            .order_group
+            .cmp(&right.visual.order_group)
+            .then(
+                branch_persistence(&left.name, &settings.branches)
+                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+            )
+            .then(left.name.cmp(&right.name))
+    });
+
+    Ok(branch_infos)
+}
+
 fn branch_info(
     branch: Branch,
     branch_type: BranchType,
@@ -111,19 +169,34 @@
     let target_index = indices.get(&target).copied()?;
     let short_name = branch_short_name(name, branch_type);
     let order_group = branch_order(short_name, settings);
+    let color_group = branch_color(short_name, settings);
 
     Some(BranchInfo {
         name: short_name.to_string(),
         target,
         target_index,
         is_remote: branch_type == BranchType::Remote,
-        order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
-        column: None,
+        visual: BranchVis {
+            order_group,
+            color_group,
+            column: None,
+        },
     })
 }
 
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
+}
+
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
     let name = normalized_branch_name(name);
     settings
@@ -144,105 +217,90 @@
         .unwrap_or(settings.order.len())
 }
 
+fn branch_color(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
+    settings
+        .color
+        .iter()
+        .enumerate()
+        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
+        .map(|(index, _)| index)
+        .unwrap_or(settings.color.len())
+}
+
 fn normalized_branch_name(name: &str) -> &str {
     name.strip_prefix("origin/").unwrap_or(name)
 }
 
-fn extract_branches(
-    repo: &Repository,
-    indices: &HashMap<Oid, usize>,
-    settings: &Settings,
-) -> Result<Vec<BranchInfo>, git2::Error> {
-    let mut branches = Vec::new();
-
-    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
-        let mut iter = repo.branches(Some(branch_type))?;
-        while let Some(branch_result) = iter.next() {
-            let (branch, _) = branch_result?;
-            branches.push((branch, branch_type));
+fn assign_parent_indices(commits: &mut [CommitInfo], indices: &HashMap<Oid, usize>) {
+    for info in commits.iter_mut() {
+        info.parents.clear();
+        for oid in &info.parent_ids {
+            if let Some(index) = indices.get(oid) {
+                info.parents.push(*index);
+            }
         }
-        Ok(())
-    };
+    }
+}
 
-    push_branches(BranchType::Local)?;
-
-    if settings.include_remote {
-        push_branches(BranchType::Remote)?;
+fn assign_children(commits: &mut [CommitInfo]) {
+    for commit in commits.iter_mut() {
+        commit.children.clear();
     }
 
-    let mut branch_infos = branches
-        .into_iter()
-        .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
-        })
-        .collect::<Vec<_>>();
-
-    branch_infos.sort_by(|left, right| {
-        left.order_group
-            .cmp(&right.order_group)
-            .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
-            )
-            .then(left.name.cmp(&right.name))
-    });
-
-    Ok(branch_infos)
-}
-
-fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
-    match branch_type {
-        BranchType::Local => reference_name
-            .strip_prefix("refs/heads/")
-            .unwrap_or(reference_name),
-        BranchType::Remote => reference_name
-            .strip_prefix("refs/remotes/")
-            .unwrap_or(reference_name),
+    for child_index in 0..commits.len() {
+        for &parent_index in &commits[child_index].parents {
+            if let Some(parent) = commits.get_mut(parent_index) {
+                parent.children.push(child_index);
+            }
+        }
     }
 }
 
-fn trace_branch(
-    commits: &mut [CommitInfo],
-    indices: &HashMap<Oid, usize>,
-    branch: &mut BranchInfo,
-    branch_index: usize,
-) -> bool {
+fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
-    let mut range_end = branch.target_index;
+    let mut range_tail = branch.target_index;
     let mut range_valid = true;
+    let mut previous = None;
+    let mut merge_anchor = None;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
             Some(trace) if trace == branch_index => break,
-            Some(_) => {}
+            Some(_) => {
+                if let Some(child_index) = previous {
+                    merge_anchor =
+                        merge_anchor.or_else(|| merge_start(commits, index, child_index));
+                }
+                break;
+            }
             None => {
                 commits[index].branch_trace = Some(branch_index);
                 any_assigned = true;
-                range_end = index;
+                range_tail = index;
             }
         }
 
-        let parent_index = commits[index]
-            .parent_ids
-            .iter()
-            .filter_map(|oid| indices.get(oid))
-            .copied()
-            .next();
+        let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
-            if parent_index < range_end {
-                // Jumping forward indicates a non-contiguous range; skip column assignment.
+            if parent_index < range_tail {
                 range_valid = false;
                 break;
             }
         }
 
+        previous = Some(index);
         current = parent_index;
     }
 
     if any_assigned && range_valid {
-        branch.range = Some((range_end, branch.target_index));
+        let mut start = range_tail;
+        if let Some(anchor) = merge_anchor {
+            start = start.max(anchor);
+        }
+        branch.range = Some((start, branch.target_index));
     } else {
         branch.range = None;
     }
@@ -250,6 +308,20 @@
     any_assigned
 }
 
+fn merge_start(commits: &[CommitInfo], parent_index: usize, child_index: usize) -> Option<usize> {
+    let children = commits
+        .get(parent_index)
+        .map(|info| info.children.as_slice())
+        .unwrap_or(&[]);
+
+    if children.len() <= 1 {
+        return None;
+    }
+
+    let anchor = children.iter().copied().max()?;
+    Some(anchor.max(child_index))
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
@@ -259,14 +331,20 @@
         return;
     }
 
+    for branch in branches.iter_mut() {
+        branch.visual.column = None;
+    }
+
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
         if branch.range.is_none() {
             continue;
         }
 
-        // Group index may exceed configured order length; keep as-is for stable layout.
-        groups.entry(branch.order_group).or_default().push(index);
+        groups
+            .entry(branch.visual.order_group)
+            .or_default()
+            .push(index);
     }
 
     let mut offset = 0;
@@ -312,7 +390,7 @@
         let group_width = occupied.len();
 
         for (branch_index, column) in assignments {
-            branches[branch_index].column = Some(column + offset);
+            branches[branch_index].visual.column = Some(column + offset);
         }
 
         offset += group_width;
diff --git a/src/main.rs b/src/main.rs
index 6e320e9bd9209afaaf06b86efe9caf12162a0a09..c2a6f05ed62b7ed7fffade0517a99a78b99f6f72
--- a/src/main.rs
+++ b/src/main.rs
@@ -24,9 +24,12 @@
     let commit = graph.commit(info)?;
 
     let symbol = if commit.parent_count() > 1 { "o" } else { "*" };
+    let merge_marker = if commit.parent_count() > 1 { 'M' } else { '.' };
     let short_id = short_id(commit.id());
     let indent = commit_indent(graph, info);
 
+    let (column, span) = branch_metrics(graph, info);
+
     let branch_details = info
         .branches
         .iter()
@@ -40,9 +43,9 @@
     };
 
     let summary = commit.summary().unwrap_or("---");
-    println!(
-        "{}{} {}{} {}",
-        indent, symbol, short_id, branch_str, summary
+    eprintln!(
+        "{}{}{} {} [{} | {}]{} {}",
+        indent, merge_marker, symbol, short_id, column, span, branch_str, summary
     );
 
     Ok(())
@@ -53,24 +56,33 @@
     let indent = indent_for_branch(branch);
 
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column = branch.column.unwrap_or(99);
+    let column = branch
+        .visual
+        .column
+        .map(|value| value.to_string())
+        .unwrap_or_else(|| "-".to_string());
+    let range = format_range(branch.range);
 
     format!(
-        "{}{} (col {}){}",
-        indent, branch.name, column, deleted_suffix
+        "{}{} (col {} | range {} | color {}){}",
+        indent, branch.name, column, range, branch.visual.color_group, deleted_suffix
     )
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {
     info.branch_trace
         .and_then(|index| graph.branches().get(index))
-        .and_then(|branch| branch.column)
+        .and_then(|branch| branch.visual.column)
         .map(indent_for_column)
         .unwrap_or_default()
 }
 
 fn indent_for_branch(branch: &BranchInfo) -> String {
-    branch.column.map(indent_for_column).unwrap_or_default()
+    branch
+        .visual
+        .column
+        .map(indent_for_column)
+        .unwrap_or_default()
 }
 
 fn indent_for_column(column: usize) -> String {
@@ -83,3 +95,23 @@
     id.truncate(7);
     id
 }
+
+fn branch_metrics(graph: &GitGraph, info: &CommitInfo) -> (String, String) {
+    info.branch_trace
+        .and_then(|index| graph.branches().get(index))
+        .map(|branch| {
+            let column = branch
+                .visual
+                .column
+                .map(|value| value.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            (column, format_range(branch.range))
+        })
+        .unwrap_or_else(|| ("-".to_string(), "-".to_string()))
+}
+
+fn format_range(range: Option<(usize, usize)>) -> String {
+    range
+        .map(|(start, end)| format!("{}..{}", start.min(end), start.max(end)))
+        .unwrap_or_else(|| "-".to_string())
+}
diff --git a/src/settings.rs b/src/settings.rs
index b25f1cec3dcfa4d21a1a1d4571e99379ec987969..77f4ff5ce72584c8bd6069341bab631d0ab1ebc6
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -26,6 +26,8 @@
     pub persistence: Vec<&'static str>,
     /// Branch grouping order used for indentation.
     pub order: Vec<Vec<&'static str>>,
+    /// Branch color group prefixes, used to map branches to palette slots.
+    pub color: Vec<Vec<&'static str>>,
 }
 
 impl Default for BranchSettings {
@@ -46,6 +48,14 @@
                 vec!["release", "hotfix"],
                 vec!["feature", "bugfix"],
             ],
+            color: vec![
+                vec!["master", "main"],
+                vec!["develop", "dev"],
+                vec!["release"],
+                vec!["hotfix"],
+                vec!["feature"],
+                vec!["bugfix"],
+            ],
         }
     }
 }


[2025-09-21T12:27:33] thinking

**Noting build failure from network limits**
[2025-09-21T12:27:33] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:27:33] bash -lc 'git status -sb' succeeded in 20ms:
## main
 M src/graph.rs
 M src/main.rs
 M src/settings.rs
[2025-09-21T12:27:33] tokens used: 112,420
[2025-09-21T12:27:33] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 982924ca97e4ce3ef4764cbf2ccc4d1bd4122343..d440daef0ddc990bb7d87ea5a4004926dbd7f28b
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,19 +5,26 @@
 pub struct CommitInfo {
     pub id: Oid,
     pub parent_ids: Vec<Oid>,
+    pub parents: Vec<usize>,
+    pub children: Vec<usize>,
     pub branches: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
+pub struct BranchVis {
+    pub order_group: usize,
+    pub color_group: usize,
+    pub column: Option<usize>,
+}
+
 pub struct BranchInfo {
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
     pub is_remote: bool,
-    pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
-    pub column: Option<usize>,
+    pub visual: BranchVis,
 }
 
 pub struct GitGraph {
@@ -35,14 +42,18 @@
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
+
         for (index, oid_result) in revwalk.enumerate() {
             let oid = oid_result?;
             let commit = repo.find_commit(oid)?;
             let parent_ids = commit.parent_ids().collect();
+
             indices.insert(oid, index);
             commits.push(CommitInfo {
                 id: oid,
                 parent_ids,
+                parents: Vec::new(),
+                children: Vec::new(),
                 branches: Vec::new(),
                 branch_trace: None,
             });
@@ -54,8 +65,12 @@
             branches: Vec::new(),
         };
 
+        assign_parent_indices(&mut graph.commits, &indices);
+        assign_children(&mut graph.commits);
+
         let branches = graph.assign_branches(&indices, settings)?;
         graph.branches = branches;
+
         assign_branch_columns(&graph.commits, &mut graph.branches, settings);
 
         Ok(graph)
@@ -71,7 +86,7 @@
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, indices, &mut info, branch_index);
+            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -98,6 +113,49 @@
     }
 }
 
+fn extract_branches(
+    repo: &Repository,
+    indices: &HashMap<Oid, usize>,
+    settings: &Settings,
+) -> Result<Vec<BranchInfo>, git2::Error> {
+    let mut branches = Vec::new();
+
+    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
+        let mut iter = repo.branches(Some(branch_type))?;
+        while let Some(branch_result) = iter.next() {
+            let (branch, _) = branch_result?;
+            branches.push((branch, branch_type));
+        }
+        Ok(())
+    };
+
+    push_branches(BranchType::Local)?;
+
+    if settings.include_remote {
+        push_branches(BranchType::Remote)?;
+    }
+
+    let mut branch_infos = branches
+        .into_iter()
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
+        .collect::<Vec<_>>();
+
+    branch_infos.sort_by(|left, right| {
+        left.visual
+            .order_group
+            .cmp(&right.visual.order_group)
+            .then(
+                branch_persistence(&left.name, &settings.branches)
+                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+            )
+            .then(left.name.cmp(&right.name))
+    });
+
+    Ok(branch_infos)
+}
+
 fn branch_info(
     branch: Branch,
     branch_type: BranchType,
@@ -111,19 +169,34 @@
     let target_index = indices.get(&target).copied()?;
     let short_name = branch_short_name(name, branch_type);
     let order_group = branch_order(short_name, settings);
+    let color_group = branch_color(short_name, settings);
 
     Some(BranchInfo {
         name: short_name.to_string(),
         target,
         target_index,
         is_remote: branch_type == BranchType::Remote,
-        order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
-        column: None,
+        visual: BranchVis {
+            order_group,
+            color_group,
+            column: None,
+        },
     })
 }
 
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
+}
+
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
     let name = normalized_branch_name(name);
     settings
@@ -144,105 +217,90 @@
         .unwrap_or(settings.order.len())
 }
 
+fn branch_color(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
+    settings
+        .color
+        .iter()
+        .enumerate()
+        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
+        .map(|(index, _)| index)
+        .unwrap_or(settings.color.len())
+}
+
 fn normalized_branch_name(name: &str) -> &str {
     name.strip_prefix("origin/").unwrap_or(name)
 }
 
-fn extract_branches(
-    repo: &Repository,
-    indices: &HashMap<Oid, usize>,
-    settings: &Settings,
-) -> Result<Vec<BranchInfo>, git2::Error> {
-    let mut branches = Vec::new();
-
-    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
-        let mut iter = repo.branches(Some(branch_type))?;
-        while let Some(branch_result) = iter.next() {
-            let (branch, _) = branch_result?;
-            branches.push((branch, branch_type));
+fn assign_parent_indices(commits: &mut [CommitInfo], indices: &HashMap<Oid, usize>) {
+    for info in commits.iter_mut() {
+        info.parents.clear();
+        for oid in &info.parent_ids {
+            if let Some(index) = indices.get(oid) {
+                info.parents.push(*index);
+            }
         }
-        Ok(())
-    };
+    }
+}
 
-    push_branches(BranchType::Local)?;
-
-    if settings.include_remote {
-        push_branches(BranchType::Remote)?;
+fn assign_children(commits: &mut [CommitInfo]) {
+    for commit in commits.iter_mut() {
+        commit.children.clear();
     }
 
-    let mut branch_infos = branches
-        .into_iter()
-        .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
-        })
-        .collect::<Vec<_>>();
-
-    branch_infos.sort_by(|left, right| {
-        left.order_group
-            .cmp(&right.order_group)
-            .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
-            )
-            .then(left.name.cmp(&right.name))
-    });
-
-    Ok(branch_infos)
-}
-
-fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
-    match branch_type {
-        BranchType::Local => reference_name
-            .strip_prefix("refs/heads/")
-            .unwrap_or(reference_name),
-        BranchType::Remote => reference_name
-            .strip_prefix("refs/remotes/")
-            .unwrap_or(reference_name),
+    for child_index in 0..commits.len() {
+        for &parent_index in &commits[child_index].parents {
+            if let Some(parent) = commits.get_mut(parent_index) {
+                parent.children.push(child_index);
+            }
+        }
     }
 }
 
-fn trace_branch(
-    commits: &mut [CommitInfo],
-    indices: &HashMap<Oid, usize>,
-    branch: &mut BranchInfo,
-    branch_index: usize,
-) -> bool {
+fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
-    let mut range_end = branch.target_index;
+    let mut range_tail = branch.target_index;
     let mut range_valid = true;
+    let mut previous = None;
+    let mut merge_anchor = None;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
             Some(trace) if trace == branch_index => break,
-            Some(_) => {}
+            Some(_) => {
+                if let Some(child_index) = previous {
+                    merge_anchor =
+                        merge_anchor.or_else(|| merge_start(commits, index, child_index));
+                }
+                break;
+            }
             None => {
                 commits[index].branch_trace = Some(branch_index);
                 any_assigned = true;
-                range_end = index;
+                range_tail = index;
             }
         }
 
-        let parent_index = commits[index]
-            .parent_ids
-            .iter()
-            .filter_map(|oid| indices.get(oid))
-            .copied()
-            .next();
+        let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
-            if parent_index < range_end {
-                // Jumping forward indicates a non-contiguous range; skip column assignment.
+            if parent_index < range_tail {
                 range_valid = false;
                 break;
             }
         }
 
+        previous = Some(index);
         current = parent_index;
     }
 
     if any_assigned && range_valid {
-        branch.range = Some((range_end, branch.target_index));
+        let mut start = range_tail;
+        if let Some(anchor) = merge_anchor {
+            start = start.max(anchor);
+        }
+        branch.range = Some((start, branch.target_index));
     } else {
         branch.range = None;
     }
@@ -250,6 +308,20 @@
     any_assigned
 }
 
+fn merge_start(commits: &[CommitInfo], parent_index: usize, child_index: usize) -> Option<usize> {
+    let children = commits
+        .get(parent_index)
+        .map(|info| info.children.as_slice())
+        .unwrap_or(&[]);
+
+    if children.len() <= 1 {
+        return None;
+    }
+
+    let anchor = children.iter().copied().max()?;
+    Some(anchor.max(child_index))
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
@@ -259,14 +331,20 @@
         return;
     }
 
+    for branch in branches.iter_mut() {
+        branch.visual.column = None;
+    }
+
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
         if branch.range.is_none() {
             continue;
         }
 
-        // Group index may exceed configured order length; keep as-is for stable layout.
-        groups.entry(branch.order_group).or_default().push(index);
+        groups
+            .entry(branch.visual.order_group)
+            .or_default()
+            .push(index);
     }
 
     let mut offset = 0;
@@ -312,7 +390,7 @@
         let group_width = occupied.len();
 
         for (branch_index, column) in assignments {
-            branches[branch_index].column = Some(column + offset);
+            branches[branch_index].visual.column = Some(column + offset);
         }
 
         offset += group_width;
diff --git a/src/main.rs b/src/main.rs
index 6e320e9bd9209afaaf06b86efe9caf12162a0a09..c2a6f05ed62b7ed7fffade0517a99a78b99f6f72
--- a/src/main.rs
+++ b/src/main.rs
@@ -24,9 +24,12 @@
     let commit = graph.commit(info)?;
 
     let symbol = if commit.parent_count() > 1 { "o" } else { "*" };
+    let merge_marker = if commit.parent_count() > 1 { 'M' } else { '.' };
     let short_id = short_id(commit.id());
     let indent = commit_indent(graph, info);
 
+    let (column, span) = branch_metrics(graph, info);
+
     let branch_details = info
         .branches
         .iter()
@@ -40,9 +43,9 @@
     };
 
     let summary = commit.summary().unwrap_or("---");
-    println!(
-        "{}{} {}{} {}",
-        indent, symbol, short_id, branch_str, summary
+    eprintln!(
+        "{}{}{} {} [{} | {}]{} {}",
+        indent, merge_marker, symbol, short_id, column, span, branch_str, summary
     );
 
     Ok(())
@@ -53,24 +56,33 @@
     let indent = indent_for_branch(branch);
 
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column = branch.column.unwrap_or(99);
+    let column = branch
+        .visual
+        .column
+        .map(|value| value.to_string())
+        .unwrap_or_else(|| "-".to_string());
+    let range = format_range(branch.range);
 
     format!(
-        "{}{} (col {}){}",
-        indent, branch.name, column, deleted_suffix
+        "{}{} (col {} | range {} | color {}){}",
+        indent, branch.name, column, range, branch.visual.color_group, deleted_suffix
     )
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {
     info.branch_trace
         .and_then(|index| graph.branches().get(index))
-        .and_then(|branch| branch.column)
+        .and_then(|branch| branch.visual.column)
         .map(indent_for_column)
         .unwrap_or_default()
 }
 
 fn indent_for_branch(branch: &BranchInfo) -> String {
-    branch.column.map(indent_for_column).unwrap_or_default()
+    branch
+        .visual
+        .column
+        .map(indent_for_column)
+        .unwrap_or_default()
 }
 
 fn indent_for_column(column: usize) -> String {
@@ -83,3 +95,23 @@
     id.truncate(7);
     id
 }
+
+fn branch_metrics(graph: &GitGraph, info: &CommitInfo) -> (String, String) {
+    info.branch_trace
+        .and_then(|index| graph.branches().get(index))
+        .map(|branch| {
+            let column = branch
+                .visual
+                .column
+                .map(|value| value.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            (column, format_range(branch.range))
+        })
+        .unwrap_or_else(|| ("-".to_string(), "-".to_string()))
+}
+
+fn format_range(range: Option<(usize, usize)>) -> String {
+    range
+        .map(|(start, end)| format!("{}..{}", start.min(end), start.max(end)))
+        .unwrap_or_else(|| "-".to_string())
+}
diff --git a/src/settings.rs b/src/settings.rs
index b25f1cec3dcfa4d21a1a1d4571e99379ec987969..77f4ff5ce72584c8bd6069341bab631d0ab1ebc6
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -26,6 +26,8 @@
     pub persistence: Vec<&'static str>,
     /// Branch grouping order used for indentation.
     pub order: Vec<Vec<&'static str>>,
+    /// Branch color group prefixes, used to map branches to palette slots.
+    pub color: Vec<Vec<&'static str>>,
 }
 
 impl Default for BranchSettings {
@@ -46,6 +48,14 @@
                 vec!["release", "hotfix"],
                 vec!["feature", "bugfix"],
             ],
+            color: vec![
+                vec!["master", "main"],
+                vec!["develop", "dev"],
+                vec!["release"],
+                vec!["hotfix"],
+                vec!["feature"],
+                vec!["bugfix"],
+            ],
         }
     }
 }


[2025-09-21T12:27:36] thinking

**Reviewing changes before commit**
[2025-09-21T12:27:36] exec bash -lc 'git diff' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:27:36] bash -lc 'git diff' succeeded in 22ms:
diff --git a/src/graph.rs b/src/graph.rs
index 982924c..d440dae 100644
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,19 +5,26 @@ use std::collections::{BTreeMap, HashMap};
 pub struct CommitInfo {
     pub id: Oid,
     pub parent_ids: Vec<Oid>,
+    pub parents: Vec<usize>,
+    pub children: Vec<usize>,
     pub branches: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
+pub struct BranchVis {
+    pub order_group: usize,
+    pub color_group: usize,
+    pub column: Option<usize>,
+}
+
[2025-09-21T12:27:36] tokens used: 112,658
[2025-09-21T12:27:36] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 982924ca97e4ce3ef4764cbf2ccc4d1bd4122343..d440daef0ddc990bb7d87ea5a4004926dbd7f28b
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,19 +5,26 @@
 pub struct CommitInfo {
     pub id: Oid,
     pub parent_ids: Vec<Oid>,
+    pub parents: Vec<usize>,
+    pub children: Vec<usize>,
     pub branches: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
+pub struct BranchVis {
+    pub order_group: usize,
+    pub color_group: usize,
+    pub column: Option<usize>,
+}
+
 pub struct BranchInfo {
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
     pub is_remote: bool,
-    pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
-    pub column: Option<usize>,
+    pub visual: BranchVis,
 }
 
 pub struct GitGraph {
@@ -35,14 +42,18 @@
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
+
         for (index, oid_result) in revwalk.enumerate() {
             let oid = oid_result?;
             let commit = repo.find_commit(oid)?;
             let parent_ids = commit.parent_ids().collect();
+
             indices.insert(oid, index);
             commits.push(CommitInfo {
                 id: oid,
                 parent_ids,
+                parents: Vec::new(),
+                children: Vec::new(),
                 branches: Vec::new(),
                 branch_trace: None,
             });
@@ -54,8 +65,12 @@
             branches: Vec::new(),
         };
 
+        assign_parent_indices(&mut graph.commits, &indices);
+        assign_children(&mut graph.commits);
+
         let branches = graph.assign_branches(&indices, settings)?;
         graph.branches = branches;
+
         assign_branch_columns(&graph.commits, &mut graph.branches, settings);
 
         Ok(graph)
@@ -71,7 +86,7 @@
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, indices, &mut info, branch_index);
+            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -98,6 +113,49 @@
     }
 }
 
+fn extract_branches(
+    repo: &Repository,
+    indices: &HashMap<Oid, usize>,
+    settings: &Settings,
+) -> Result<Vec<BranchInfo>, git2::Error> {
+    let mut branches = Vec::new();
+
+    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
+        let mut iter = repo.branches(Some(branch_type))?;
+        while let Some(branch_result) = iter.next() {
+            let (branch, _) = branch_result?;
+            branches.push((branch, branch_type));
+        }
+        Ok(())
+    };
+
+    push_branches(BranchType::Local)?;
+
+    if settings.include_remote {
+        push_branches(BranchType::Remote)?;
+    }
+
+    let mut branch_infos = branches
+        .into_iter()
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
+        .collect::<Vec<_>>();
+
+    branch_infos.sort_by(|left, right| {
+        left.visual
+            .order_group
+            .cmp(&right.visual.order_group)
+            .then(
+                branch_persistence(&left.name, &settings.branches)
+                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+            )
+            .then(left.name.cmp(&right.name))
+    });
+
+    Ok(branch_infos)
+}
+
 fn branch_info(
     branch: Branch,
     branch_type: BranchType,
@@ -111,19 +169,34 @@
     let target_index = indices.get(&target).copied()?;
     let short_name = branch_short_name(name, branch_type);
     let order_group = branch_order(short_name, settings);
+    let color_group = branch_color(short_name, settings);
 
     Some(BranchInfo {
         name: short_name.to_string(),
         target,
         target_index,
         is_remote: branch_type == BranchType::Remote,
-        order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
-        column: None,
+        visual: BranchVis {
+            order_group,
+            color_group,
+            column: None,
+        },
     })
 }
 
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
+}
+
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
     let name = normalized_branch_name(name);
     settings
@@ -144,105 +217,90 @@
         .unwrap_or(settings.order.len())
 }
 
+fn branch_color(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
+    settings
+        .color
+        .iter()
+        .enumerate()
+        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
+        .map(|(index, _)| index)
+        .unwrap_or(settings.color.len())
+}
+
 fn normalized_branch_name(name: &str) -> &str {
     name.strip_prefix("origin/").unwrap_or(name)
 }
 
-fn extract_branches(
-    repo: &Repository,
-    indices: &HashMap<Oid, usize>,
-    settings: &Settings,
-) -> Result<Vec<BranchInfo>, git2::Error> {
-    let mut branches = Vec::new();
-
-    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
-        let mut iter = repo.branches(Some(branch_type))?;
-        while let Some(branch_result) = iter.next() {
-            let (branch, _) = branch_result?;
-            branches.push((branch, branch_type));
+fn assign_parent_indices(commits: &mut [CommitInfo], indices: &HashMap<Oid, usize>) {
+    for info in commits.iter_mut() {
+        info.parents.clear();
+        for oid in &info.parent_ids {
+            if let Some(index) = indices.get(oid) {
+                info.parents.push(*index);
+            }
         }
-        Ok(())
-    };
+    }
+}
 
-    push_branches(BranchType::Local)?;
-
-    if settings.include_remote {
-        push_branches(BranchType::Remote)?;
+fn assign_children(commits: &mut [CommitInfo]) {
+    for commit in commits.iter_mut() {
+        commit.children.clear();
     }
 
-    let mut branch_infos = branches
-        .into_iter()
-        .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
-        })
-        .collect::<Vec<_>>();
-
-    branch_infos.sort_by(|left, right| {
-        left.order_group
-            .cmp(&right.order_group)
-            .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
-            )
-            .then(left.name.cmp(&right.name))
-    });
-
-    Ok(branch_infos)
-}
-
-fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
-    match branch_type {
-        BranchType::Local => reference_name
-            .strip_prefix("refs/heads/")
-            .unwrap_or(reference_name),
-        BranchType::Remote => reference_name
-            .strip_prefix("refs/remotes/")
-            .unwrap_or(reference_name),
+    for child_index in 0..commits.len() {
+        for &parent_index in &commits[child_index].parents {
+            if let Some(parent) = commits.get_mut(parent_index) {
+                parent.children.push(child_index);
+            }
+        }
     }
 }
 
-fn trace_branch(
-    commits: &mut [CommitInfo],
-    indices: &HashMap<Oid, usize>,
-    branch: &mut BranchInfo,
-    branch_index: usize,
-) -> bool {
+fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
-    let mut range_end = branch.target_index;
+    let mut range_tail = branch.target_index;
     let mut range_valid = true;
+    let mut previous = None;
+    let mut merge_anchor = None;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
             Some(trace) if trace == branch_index => break,
-            Some(_) => {}
+            Some(_) => {
+                if let Some(child_index) = previous {
+                    merge_anchor =
+                        merge_anchor.or_else(|| merge_start(commits, index, child_index));
+                }
+                break;
+            }
             None => {
                 commits[index].branch_trace = Some(branch_index);
                 any_assigned = true;
-                range_end = index;
+                range_tail = index;
             }
         }
 
-        let parent_index = commits[index]
-            .parent_ids
-            .iter()
-            .filter_map(|oid| indices.get(oid))
-            .copied()
-            .next();
+        let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
-            if parent_index < range_end {
-                // Jumping forward indicates a non-contiguous range; skip column assignment.
+            if parent_index < range_tail {
                 range_valid = false;
                 break;
             }
         }
 
+        previous = Some(index);
         current = parent_index;
     }
 
     if any_assigned && range_valid {
-        branch.range = Some((range_end, branch.target_index));
+        let mut start = range_tail;
+        if let Some(anchor) = merge_anchor {
+            start = start.max(anchor);
+        }
+        branch.range = Some((start, branch.target_index));
     } else {
         branch.range = None;
     }
@@ -250,6 +308,20 @@
     any_assigned
 }
 
+fn merge_start(commits: &[CommitInfo], parent_index: usize, child_index: usize) -> Option<usize> {
+    let children = commits
+        .get(parent_index)
+        .map(|info| info.children.as_slice())
+        .unwrap_or(&[]);
+
+    if children.len() <= 1 {
+        return None;
+    }
+
+    let anchor = children.iter().copied().max()?;
+    Some(anchor.max(child_index))
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
@@ -259,14 +331,20 @@
         return;
     }
 
+    for branch in branches.iter_mut() {
+        branch.visual.column = None;
+    }
+
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
         if branch.range.is_none() {
             continue;
         }
 
-        // Group index may exceed configured order length; keep as-is for stable layout.
-        groups.entry(branch.order_group).or_default().push(index);
+        groups
+            .entry(branch.visual.order_group)
+            .or_default()
+            .push(index);
     }
 
     let mut offset = 0;
@@ -312,7 +390,7 @@
         let group_width = occupied.len();
 
         for (branch_index, column) in assignments {
-            branches[branch_index].column = Some(column + offset);
+            branches[branch_index].visual.column = Some(column + offset);
         }
 
         offset += group_width;
diff --git a/src/main.rs b/src/main.rs
index 6e320e9bd9209afaaf06b86efe9caf12162a0a09..c2a6f05ed62b7ed7fffade0517a99a78b99f6f72
--- a/src/main.rs
+++ b/src/main.rs
@@ -24,9 +24,12 @@
     let commit = graph.commit(info)?;
 
     let symbol = if commit.parent_count() > 1 { "o" } else { "*" };
+    let merge_marker = if commit.parent_count() > 1 { 'M' } else { '.' };
     let short_id = short_id(commit.id());
     let indent = commit_indent(graph, info);
 
+    let (column, span) = branch_metrics(graph, info);
+
     let branch_details = info
         .branches
         .iter()
@@ -40,9 +43,9 @@
     };
 
     let summary = commit.summary().unwrap_or("---");
-    println!(
-        "{}{} {}{} {}",
-        indent, symbol, short_id, branch_str, summary
+    eprintln!(
+        "{}{}{} {} [{} | {}]{} {}",
+        indent, merge_marker, symbol, short_id, column, span, branch_str, summary
     );
 
     Ok(())
@@ -53,24 +56,33 @@
     let indent = indent_for_branch(branch);
 
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column = branch.column.unwrap_or(99);
+    let column = branch
+        .visual
+        .column
+        .map(|value| value.to_string())
+        .unwrap_or_else(|| "-".to_string());
+    let range = format_range(branch.range);
 
     format!(
-        "{}{} (col {}){}",
-        indent, branch.name, column, deleted_suffix
+        "{}{} (col {} | range {} | color {}){}",
+        indent, branch.name, column, range, branch.visual.color_group, deleted_suffix
     )
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {
     info.branch_trace
         .and_then(|index| graph.branches().get(index))
-        .and_then(|branch| branch.column)
+        .and_then(|branch| branch.visual.column)
         .map(indent_for_column)
         .unwrap_or_default()
 }
 
 fn indent_for_branch(branch: &BranchInfo) -> String {
-    branch.column.map(indent_for_column).unwrap_or_default()
+    branch
+        .visual
+        .column
+        .map(indent_for_column)
+        .unwrap_or_default()
 }
 
 fn indent_for_column(column: usize) -> String {
@@ -83,3 +95,23 @@
     id.truncate(7);
     id
 }
+
+fn branch_metrics(graph: &GitGraph, info: &CommitInfo) -> (String, String) {
+    info.branch_trace
+        .and_then(|index| graph.branches().get(index))
+        .map(|branch| {
+            let column = branch
+                .visual
+                .column
+                .map(|value| value.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            (column, format_range(branch.range))
+        })
+        .unwrap_or_else(|| ("-".to_string(), "-".to_string()))
+}
+
+fn format_range(range: Option<(usize, usize)>) -> String {
+    range
+        .map(|(start, end)| format!("{}..{}", start.min(end), start.max(end)))
+        .unwrap_or_else(|| "-".to_string())
+}
diff --git a/src/settings.rs b/src/settings.rs
index b25f1cec3dcfa4d21a1a1d4571e99379ec987969..77f4ff5ce72584c8bd6069341bab631d0ab1ebc6
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -26,6 +26,8 @@
     pub persistence: Vec<&'static str>,
     /// Branch grouping order used for indentation.
     pub order: Vec<Vec<&'static str>>,
+    /// Branch color group prefixes, used to map branches to palette slots.
+    pub color: Vec<Vec<&'static str>>,
 }
 
 impl Default for BranchSettings {
@@ -46,6 +48,14 @@
                 vec!["release", "hotfix"],
                 vec!["feature", "bugfix"],
             ],
+            color: vec![
+                vec!["master", "main"],
+                vec!["develop", "dev"],
+                vec!["release"],
+                vec!["hotfix"],
+                vec!["feature"],
+                vec!["bugfix"],
+            ],
         }
     }
 }


[2025-09-21T12:27:40] thinking

**Verifying code cleanup and staging changes**
[2025-09-21T12:27:41] exec bash -lc 'git add -A' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:27:41] bash -lc 'git add -A' succeeded in 42ms:

[2025-09-21T12:27:41] tokens used: 115,397
[2025-09-21T12:27:41] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 982924ca97e4ce3ef4764cbf2ccc4d1bd4122343..d440daef0ddc990bb7d87ea5a4004926dbd7f28b
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,19 +5,26 @@
 pub struct CommitInfo {
     pub id: Oid,
     pub parent_ids: Vec<Oid>,
+    pub parents: Vec<usize>,
+    pub children: Vec<usize>,
     pub branches: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
+pub struct BranchVis {
+    pub order_group: usize,
+    pub color_group: usize,
+    pub column: Option<usize>,
+}
+
 pub struct BranchInfo {
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
     pub is_remote: bool,
-    pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
-    pub column: Option<usize>,
+    pub visual: BranchVis,
 }
 
 pub struct GitGraph {
@@ -35,14 +42,18 @@
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
+
         for (index, oid_result) in revwalk.enumerate() {
             let oid = oid_result?;
             let commit = repo.find_commit(oid)?;
             let parent_ids = commit.parent_ids().collect();
+
             indices.insert(oid, index);
             commits.push(CommitInfo {
                 id: oid,
                 parent_ids,
+                parents: Vec::new(),
+                children: Vec::new(),
                 branches: Vec::new(),
                 branch_trace: None,
             });
@@ -54,8 +65,12 @@
             branches: Vec::new(),
         };
 
+        assign_parent_indices(&mut graph.commits, &indices);
+        assign_children(&mut graph.commits);
+
         let branches = graph.assign_branches(&indices, settings)?;
         graph.branches = branches;
+
         assign_branch_columns(&graph.commits, &mut graph.branches, settings);
 
         Ok(graph)
@@ -71,7 +86,7 @@
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, indices, &mut info, branch_index);
+            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -98,6 +113,49 @@
     }
 }
 
+fn extract_branches(
+    repo: &Repository,
+    indices: &HashMap<Oid, usize>,
+    settings: &Settings,
+) -> Result<Vec<BranchInfo>, git2::Error> {
+    let mut branches = Vec::new();
+
+    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
+        let mut iter = repo.branches(Some(branch_type))?;
+        while let Some(branch_result) = iter.next() {
+            let (branch, _) = branch_result?;
+            branches.push((branch, branch_type));
+        }
+        Ok(())
+    };
+
+    push_branches(BranchType::Local)?;
+
+    if settings.include_remote {
+        push_branches(BranchType::Remote)?;
+    }
+
+    let mut branch_infos = branches
+        .into_iter()
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
+        .collect::<Vec<_>>();
+
+    branch_infos.sort_by(|left, right| {
+        left.visual
+            .order_group
+            .cmp(&right.visual.order_group)
+            .then(
+                branch_persistence(&left.name, &settings.branches)
+                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+            )
+            .then(left.name.cmp(&right.name))
+    });
+
+    Ok(branch_infos)
+}
+
 fn branch_info(
     branch: Branch,
     branch_type: BranchType,
@@ -111,19 +169,34 @@
     let target_index = indices.get(&target).copied()?;
     let short_name = branch_short_name(name, branch_type);
     let order_group = branch_order(short_name, settings);
+    let color_group = branch_color(short_name, settings);
 
     Some(BranchInfo {
         name: short_name.to_string(),
         target,
         target_index,
         is_remote: branch_type == BranchType::Remote,
-        order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
-        column: None,
+        visual: BranchVis {
+            order_group,
+            color_group,
+            column: None,
+        },
     })
 }
 
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
+}
+
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
     let name = normalized_branch_name(name);
     settings
@@ -144,105 +217,90 @@
         .unwrap_or(settings.order.len())
 }
 
+fn branch_color(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
+    settings
+        .color
+        .iter()
+        .enumerate()
+        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
+        .map(|(index, _)| index)
+        .unwrap_or(settings.color.len())
+}
+
 fn normalized_branch_name(name: &str) -> &str {
     name.strip_prefix("origin/").unwrap_or(name)
 }
 
-fn extract_branches(
-    repo: &Repository,
-    indices: &HashMap<Oid, usize>,
-    settings: &Settings,
-) -> Result<Vec<BranchInfo>, git2::Error> {
-    let mut branches = Vec::new();
-
-    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
-        let mut iter = repo.branches(Some(branch_type))?;
-        while let Some(branch_result) = iter.next() {
-            let (branch, _) = branch_result?;
-            branches.push((branch, branch_type));
+fn assign_parent_indices(commits: &mut [CommitInfo], indices: &HashMap<Oid, usize>) {
+    for info in commits.iter_mut() {
+        info.parents.clear();
+        for oid in &info.parent_ids {
+            if let Some(index) = indices.get(oid) {
+                info.parents.push(*index);
+            }
         }
-        Ok(())
-    };
+    }
+}
 
-    push_branches(BranchType::Local)?;
-
-    if settings.include_remote {
-        push_branches(BranchType::Remote)?;
+fn assign_children(commits: &mut [CommitInfo]) {
+    for commit in commits.iter_mut() {
+        commit.children.clear();
     }
 
-    let mut branch_infos = branches
-        .into_iter()
-        .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
-        })
-        .collect::<Vec<_>>();
-
-    branch_infos.sort_by(|left, right| {
-        left.order_group
-            .cmp(&right.order_group)
-            .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
-            )
-            .then(left.name.cmp(&right.name))
-    });
-
-    Ok(branch_infos)
-}
-
-fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
-    match branch_type {
-        BranchType::Local => reference_name
-            .strip_prefix("refs/heads/")
-            .unwrap_or(reference_name),
-        BranchType::Remote => reference_name
-            .strip_prefix("refs/remotes/")
-            .unwrap_or(reference_name),
+    for child_index in 0..commits.len() {
+        for &parent_index in &commits[child_index].parents {
+            if let Some(parent) = commits.get_mut(parent_index) {
+                parent.children.push(child_index);
+            }
+        }
     }
 }
 
-fn trace_branch(
-    commits: &mut [CommitInfo],
-    indices: &HashMap<Oid, usize>,
-    branch: &mut BranchInfo,
-    branch_index: usize,
-) -> bool {
+fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
-    let mut range_end = branch.target_index;
+    let mut range_tail = branch.target_index;
     let mut range_valid = true;
+    let mut previous = None;
+    let mut merge_anchor = None;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
             Some(trace) if trace == branch_index => break,
-            Some(_) => {}
+            Some(_) => {
+                if let Some(child_index) = previous {
+                    merge_anchor =
+                        merge_anchor.or_else(|| merge_start(commits, index, child_index));
+                }
+                break;
+            }
             None => {
                 commits[index].branch_trace = Some(branch_index);
                 any_assigned = true;
-                range_end = index;
+                range_tail = index;
             }
         }
 
-        let parent_index = commits[index]
-            .parent_ids
-            .iter()
-            .filter_map(|oid| indices.get(oid))
-            .copied()
-            .next();
+        let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
-            if parent_index < range_end {
-                // Jumping forward indicates a non-contiguous range; skip column assignment.
+            if parent_index < range_tail {
                 range_valid = false;
                 break;
             }
         }
 
+        previous = Some(index);
         current = parent_index;
     }
 
     if any_assigned && range_valid {
-        branch.range = Some((range_end, branch.target_index));
+        let mut start = range_tail;
+        if let Some(anchor) = merge_anchor {
+            start = start.max(anchor);
+        }
+        branch.range = Some((start, branch.target_index));
     } else {
         branch.range = None;
     }
@@ -250,6 +308,20 @@
     any_assigned
 }
 
+fn merge_start(commits: &[CommitInfo], parent_index: usize, child_index: usize) -> Option<usize> {
+    let children = commits
+        .get(parent_index)
+        .map(|info| info.children.as_slice())
+        .unwrap_or(&[]);
+
+    if children.len() <= 1 {
+        return None;
+    }
+
+    let anchor = children.iter().copied().max()?;
+    Some(anchor.max(child_index))
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
@@ -259,14 +331,20 @@
         return;
     }
 
+    for branch in branches.iter_mut() {
+        branch.visual.column = None;
+    }
+
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
         if branch.range.is_none() {
             continue;
         }
 
-        // Group index may exceed configured order length; keep as-is for stable layout.
-        groups.entry(branch.order_group).or_default().push(index);
+        groups
+            .entry(branch.visual.order_group)
+            .or_default()
+            .push(index);
     }
 
     let mut offset = 0;
@@ -312,7 +390,7 @@
         let group_width = occupied.len();
 
         for (branch_index, column) in assignments {
-            branches[branch_index].column = Some(column + offset);
+            branches[branch_index].visual.column = Some(column + offset);
         }
 
         offset += group_width;
diff --git a/src/main.rs b/src/main.rs
index 6e320e9bd9209afaaf06b86efe9caf12162a0a09..c2a6f05ed62b7ed7fffade0517a99a78b99f6f72
--- a/src/main.rs
+++ b/src/main.rs
@@ -24,9 +24,12 @@
     let commit = graph.commit(info)?;
 
     let symbol = if commit.parent_count() > 1 { "o" } else { "*" };
+    let merge_marker = if commit.parent_count() > 1 { 'M' } else { '.' };
     let short_id = short_id(commit.id());
     let indent = commit_indent(graph, info);
 
+    let (column, span) = branch_metrics(graph, info);
+
     let branch_details = info
         .branches
         .iter()
@@ -40,9 +43,9 @@
     };
 
     let summary = commit.summary().unwrap_or("---");
-    println!(
-        "{}{} {}{} {}",
-        indent, symbol, short_id, branch_str, summary
+    eprintln!(
+        "{}{}{} {} [{} | {}]{} {}",
+        indent, merge_marker, symbol, short_id, column, span, branch_str, summary
     );
 
     Ok(())
@@ -53,24 +56,33 @@
     let indent = indent_for_branch(branch);
 
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column = branch.column.unwrap_or(99);
+    let column = branch
+        .visual
+        .column
+        .map(|value| value.to_string())
+        .unwrap_or_else(|| "-".to_string());
+    let range = format_range(branch.range);
 
     format!(
-        "{}{} (col {}){}",
-        indent, branch.name, column, deleted_suffix
+        "{}{} (col {} | range {} | color {}){}",
+        indent, branch.name, column, range, branch.visual.color_group, deleted_suffix
     )
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {
     info.branch_trace
         .and_then(|index| graph.branches().get(index))
-        .and_then(|branch| branch.column)
+        .and_then(|branch| branch.visual.column)
         .map(indent_for_column)
         .unwrap_or_default()
 }
 
 fn indent_for_branch(branch: &BranchInfo) -> String {
-    branch.column.map(indent_for_column).unwrap_or_default()
+    branch
+        .visual
+        .column
+        .map(indent_for_column)
+        .unwrap_or_default()
 }
 
 fn indent_for_column(column: usize) -> String {
@@ -83,3 +95,23 @@
     id.truncate(7);
     id
 }
+
+fn branch_metrics(graph: &GitGraph, info: &CommitInfo) -> (String, String) {
+    info.branch_trace
+        .and_then(|index| graph.branches().get(index))
+        .map(|branch| {
+            let column = branch
+                .visual
+                .column
+                .map(|value| value.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            (column, format_range(branch.range))
+        })
+        .unwrap_or_else(|| ("-".to_string(), "-".to_string()))
+}
+
+fn format_range(range: Option<(usize, usize)>) -> String {
+    range
+        .map(|(start, end)| format!("{}..{}", start.min(end), start.max(end)))
+        .unwrap_or_else(|| "-".to_string())
+}
diff --git a/src/settings.rs b/src/settings.rs
index b25f1cec3dcfa4d21a1a1d4571e99379ec987969..77f4ff5ce72584c8bd6069341bab631d0ab1ebc6
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -26,6 +26,8 @@
     pub persistence: Vec<&'static str>,
     /// Branch grouping order used for indentation.
     pub order: Vec<Vec<&'static str>>,
+    /// Branch color group prefixes, used to map branches to palette slots.
+    pub color: Vec<Vec<&'static str>>,
 }
 
 impl Default for BranchSettings {
@@ -46,6 +48,14 @@
                 vec!["release", "hotfix"],
                 vec!["feature", "bugfix"],
             ],
+            color: vec![
+                vec!["master", "main"],
+                vec!["develop", "dev"],
+                vec!["release"],
+                vec!["hotfix"],
+                vec!["feature"],
+                vec!["bugfix"],
+            ],
         }
     }
 }

[2025-09-21T12:27:43] exec bash -lc 'git commit -m "016-f620960：复现提交代码内容。"' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:27:43] bash -lc 'git commit -m "016-f620960：复现提交代码内容。"' succeeded in 35ms:
[main abfc061] 016-f620960：复现提交代码内容。
 3 files changed, 200 insertions(+), 80 deletions(-)
[2025-09-21T12:27:43] tokens used: 115,590
[2025-09-21T12:27:43] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 982924ca97e4ce3ef4764cbf2ccc4d1bd4122343..d440daef0ddc990bb7d87ea5a4004926dbd7f28b
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,19 +5,26 @@
 pub struct CommitInfo {
     pub id: Oid,
     pub parent_ids: Vec<Oid>,
+    pub parents: Vec<usize>,
+    pub children: Vec<usize>,
     pub branches: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
+pub struct BranchVis {
+    pub order_group: usize,
+    pub color_group: usize,
+    pub column: Option<usize>,
+}
+
 pub struct BranchInfo {
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
     pub is_remote: bool,
-    pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
-    pub column: Option<usize>,
+    pub visual: BranchVis,
 }
 
 pub struct GitGraph {
@@ -35,14 +42,18 @@
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
+
         for (index, oid_result) in revwalk.enumerate() {
             let oid = oid_result?;
             let commit = repo.find_commit(oid)?;
             let parent_ids = commit.parent_ids().collect();
+
             indices.insert(oid, index);
             commits.push(CommitInfo {
                 id: oid,
                 parent_ids,
+                parents: Vec::new(),
+                children: Vec::new(),
                 branches: Vec::new(),
                 branch_trace: None,
             });
@@ -54,8 +65,12 @@
             branches: Vec::new(),
         };
 
+        assign_parent_indices(&mut graph.commits, &indices);
+        assign_children(&mut graph.commits);
+
         let branches = graph.assign_branches(&indices, settings)?;
         graph.branches = branches;
+
         assign_branch_columns(&graph.commits, &mut graph.branches, settings);
 
         Ok(graph)
@@ -71,7 +86,7 @@
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, indices, &mut info, branch_index);
+            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -98,6 +113,49 @@
     }
 }
 
+fn extract_branches(
+    repo: &Repository,
+    indices: &HashMap<Oid, usize>,
+    settings: &Settings,
+) -> Result<Vec<BranchInfo>, git2::Error> {
+    let mut branches = Vec::new();
+
+    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
+        let mut iter = repo.branches(Some(branch_type))?;
+        while let Some(branch_result) = iter.next() {
+            let (branch, _) = branch_result?;
+            branches.push((branch, branch_type));
+        }
+        Ok(())
+    };
+
+    push_branches(BranchType::Local)?;
+
+    if settings.include_remote {
+        push_branches(BranchType::Remote)?;
+    }
+
+    let mut branch_infos = branches
+        .into_iter()
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
+        .collect::<Vec<_>>();
+
+    branch_infos.sort_by(|left, right| {
+        left.visual
+            .order_group
+            .cmp(&right.visual.order_group)
+            .then(
+                branch_persistence(&left.name, &settings.branches)
+                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+            )
+            .then(left.name.cmp(&right.name))
+    });
+
+    Ok(branch_infos)
+}
+
 fn branch_info(
     branch: Branch,
     branch_type: BranchType,
@@ -111,19 +169,34 @@
     let target_index = indices.get(&target).copied()?;
     let short_name = branch_short_name(name, branch_type);
     let order_group = branch_order(short_name, settings);
+    let color_group = branch_color(short_name, settings);
 
     Some(BranchInfo {
         name: short_name.to_string(),
         target,
         target_index,
         is_remote: branch_type == BranchType::Remote,
-        order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
-        column: None,
+        visual: BranchVis {
+            order_group,
+            color_group,
+            column: None,
+        },
     })
 }
 
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
+}
+
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
     let name = normalized_branch_name(name);
     settings
@@ -144,105 +217,90 @@
         .unwrap_or(settings.order.len())
 }
 
+fn branch_color(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
+    settings
+        .color
+        .iter()
+        .enumerate()
+        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
+        .map(|(index, _)| index)
+        .unwrap_or(settings.color.len())
+}
+
 fn normalized_branch_name(name: &str) -> &str {
     name.strip_prefix("origin/").unwrap_or(name)
 }
 
-fn extract_branches(
-    repo: &Repository,
-    indices: &HashMap<Oid, usize>,
-    settings: &Settings,
-) -> Result<Vec<BranchInfo>, git2::Error> {
-    let mut branches = Vec::new();
-
-    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
-        let mut iter = repo.branches(Some(branch_type))?;
-        while let Some(branch_result) = iter.next() {
-            let (branch, _) = branch_result?;
-            branches.push((branch, branch_type));
+fn assign_parent_indices(commits: &mut [CommitInfo], indices: &HashMap<Oid, usize>) {
+    for info in commits.iter_mut() {
+        info.parents.clear();
+        for oid in &info.parent_ids {
+            if let Some(index) = indices.get(oid) {
+                info.parents.push(*index);
+            }
         }
-        Ok(())
-    };
+    }
+}
 
-    push_branches(BranchType::Local)?;
-
-    if settings.include_remote {
-        push_branches(BranchType::Remote)?;
+fn assign_children(commits: &mut [CommitInfo]) {
+    for commit in commits.iter_mut() {
+        commit.children.clear();
     }
 
-    let mut branch_infos = branches
-        .into_iter()
-        .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
-        })
-        .collect::<Vec<_>>();
-
-    branch_infos.sort_by(|left, right| {
-        left.order_group
-            .cmp(&right.order_group)
-            .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
-            )
-            .then(left.name.cmp(&right.name))
-    });
-
-    Ok(branch_infos)
-}
-
-fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
-    match branch_type {
-        BranchType::Local => reference_name
-            .strip_prefix("refs/heads/")
-            .unwrap_or(reference_name),
-        BranchType::Remote => reference_name
-            .strip_prefix("refs/remotes/")
-            .unwrap_or(reference_name),
+    for child_index in 0..commits.len() {
+        for &parent_index in &commits[child_index].parents {
+            if let Some(parent) = commits.get_mut(parent_index) {
+                parent.children.push(child_index);
+            }
+        }
     }
 }
 
-fn trace_branch(
-    commits: &mut [CommitInfo],
-    indices: &HashMap<Oid, usize>,
-    branch: &mut BranchInfo,
-    branch_index: usize,
-) -> bool {
+fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
-    let mut range_end = branch.target_index;
+    let mut range_tail = branch.target_index;
     let mut range_valid = true;
+    let mut previous = None;
+    let mut merge_anchor = None;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
             Some(trace) if trace == branch_index => break,
-            Some(_) => {}
+            Some(_) => {
+                if let Some(child_index) = previous {
+                    merge_anchor =
+                        merge_anchor.or_else(|| merge_start(commits, index, child_index));
+                }
+                break;
+            }
             None => {
                 commits[index].branch_trace = Some(branch_index);
                 any_assigned = true;
-                range_end = index;
+                range_tail = index;
             }
         }
 
-        let parent_index = commits[index]
-            .parent_ids
-            .iter()
-            .filter_map(|oid| indices.get(oid))
-            .copied()
-            .next();
+        let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
-            if parent_index < range_end {
-                // Jumping forward indicates a non-contiguous range; skip column assignment.
+            if parent_index < range_tail {
                 range_valid = false;
                 break;
             }
         }
 
+        previous = Some(index);
         current = parent_index;
     }
 
     if any_assigned && range_valid {
-        branch.range = Some((range_end, branch.target_index));
+        let mut start = range_tail;
+        if let Some(anchor) = merge_anchor {
+            start = start.max(anchor);
+        }
+        branch.range = Some((start, branch.target_index));
     } else {
         branch.range = None;
     }
@@ -250,6 +308,20 @@
     any_assigned
 }
 
+fn merge_start(commits: &[CommitInfo], parent_index: usize, child_index: usize) -> Option<usize> {
+    let children = commits
+        .get(parent_index)
+        .map(|info| info.children.as_slice())
+        .unwrap_or(&[]);
+
+    if children.len() <= 1 {
+        return None;
+    }
+
+    let anchor = children.iter().copied().max()?;
+    Some(anchor.max(child_index))
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
@@ -259,14 +331,20 @@
         return;
     }
 
+    for branch in branches.iter_mut() {
+        branch.visual.column = None;
+    }
+
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
         if branch.range.is_none() {
             continue;
         }
 
-        // Group index may exceed configured order length; keep as-is for stable layout.
-        groups.entry(branch.order_group).or_default().push(index);
+        groups
+            .entry(branch.visual.order_group)
+            .or_default()
+            .push(index);
     }
 
     let mut offset = 0;
@@ -312,7 +390,7 @@
         let group_width = occupied.len();
 
         for (branch_index, column) in assignments {
-            branches[branch_index].column = Some(column + offset);
+            branches[branch_index].visual.column = Some(column + offset);
         }
 
         offset += group_width;
diff --git a/src/main.rs b/src/main.rs
index 6e320e9bd9209afaaf06b86efe9caf12162a0a09..c2a6f05ed62b7ed7fffade0517a99a78b99f6f72
--- a/src/main.rs
+++ b/src/main.rs
@@ -24,9 +24,12 @@
     let commit = graph.commit(info)?;
 
     let symbol = if commit.parent_count() > 1 { "o" } else { "*" };
+    let merge_marker = if commit.parent_count() > 1 { 'M' } else { '.' };
     let short_id = short_id(commit.id());
     let indent = commit_indent(graph, info);
 
+    let (column, span) = branch_metrics(graph, info);
+
     let branch_details = info
         .branches
         .iter()
@@ -40,9 +43,9 @@
     };
 
     let summary = commit.summary().unwrap_or("---");
-    println!(
-        "{}{} {}{} {}",
-        indent, symbol, short_id, branch_str, summary
+    eprintln!(
+        "{}{}{} {} [{} | {}]{} {}",
+        indent, merge_marker, symbol, short_id, column, span, branch_str, summary
     );
 
     Ok(())
@@ -53,24 +56,33 @@
     let indent = indent_for_branch(branch);
 
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column = branch.column.unwrap_or(99);
+    let column = branch
+        .visual
+        .column
+        .map(|value| value.to_string())
+        .unwrap_or_else(|| "-".to_string());
+    let range = format_range(branch.range);
 
     format!(
-        "{}{} (col {}){}",
-        indent, branch.name, column, deleted_suffix
+        "{}{} (col {} | range {} | color {}){}",
+        indent, branch.name, column, range, branch.visual.color_group, deleted_suffix
     )
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {
     info.branch_trace
         .and_then(|index| graph.branches().get(index))
-        .and_then(|branch| branch.column)
+        .and_then(|branch| branch.visual.column)
         .map(indent_for_column)
         .unwrap_or_default()
 }
 
 fn indent_for_branch(branch: &BranchInfo) -> String {
-    branch.column.map(indent_for_column).unwrap_or_default()
+    branch
+        .visual
+        .column
+        .map(indent_for_column)
+        .unwrap_or_default()
 }
 
 fn indent_for_column(column: usize) -> String {
@@ -83,3 +95,23 @@
     id.truncate(7);
     id
 }
+
+fn branch_metrics(graph: &GitGraph, info: &CommitInfo) -> (String, String) {
+    info.branch_trace
+        .and_then(|index| graph.branches().get(index))
+        .map(|branch| {
+            let column = branch
+                .visual
+                .column
+                .map(|value| value.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            (column, format_range(branch.range))
+        })
+        .unwrap_or_else(|| ("-".to_string(), "-".to_string()))
+}
+
+fn format_range(range: Option<(usize, usize)>) -> String {
+    range
+        .map(|(start, end)| format!("{}..{}", start.min(end), start.max(end)))
+        .unwrap_or_else(|| "-".to_string())
+}
diff --git a/src/settings.rs b/src/settings.rs
index b25f1cec3dcfa4d21a1a1d4571e99379ec987969..77f4ff5ce72584c8bd6069341bab631d0ab1ebc6
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -26,6 +26,8 @@
     pub persistence: Vec<&'static str>,
     /// Branch grouping order used for indentation.
     pub order: Vec<Vec<&'static str>>,
+    /// Branch color group prefixes, used to map branches to palette slots.
+    pub color: Vec<Vec<&'static str>>,
 }
 
 impl Default for BranchSettings {
@@ -46,6 +48,14 @@
                 vec!["release", "hotfix"],
                 vec!["feature", "bugfix"],
             ],
+            color: vec![
+                vec!["master", "main"],
+                vec!["develop", "dev"],
+                vec!["release"],
+                vec!["hotfix"],
+                vec!["feature"],
+                vec!["bugfix"],
+            ],
         }
     }
 }


[2025-09-21T12:27:49] thinking

**Preparing summary with line references**
[2025-09-21T12:27:50] exec bash -lc "nl -ba src/graph.rs | sed -n '1,200p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:27:50] bash -lc "nl -ba src/graph.rs | sed -n '1,200p'" succeeded in 27ms:
     1	use crate::settings::{BranchSettings, Settings};
     2	use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
     3	use std::collections::{BTreeMap, HashMap};
     4	
     5	pub struct CommitInfo {
     6	    pub id: Oid,
     7	    pub parent_ids: Vec<Oid>,
     8	    pub parents: Vec<usize>,
     9	    pub children: Vec<usize>,
    10	    pub branches: Vec<usize>,
    11	    pub branch_trace: Option<usize>,
    12	}
    13	
    14	pub struct BranchVis {
    15	    pub order_group: usize,
    16	    pub color_group: usize,
    17	    pub column: Option<usize>,
    18	}
    19	
    20	pub struct BranchInfo {
[2025-09-21T12:27:50] tokens used: 120,153
[2025-09-21T12:27:50] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 982924ca97e4ce3ef4764cbf2ccc4d1bd4122343..d440daef0ddc990bb7d87ea5a4004926dbd7f28b
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,19 +5,26 @@
 pub struct CommitInfo {
     pub id: Oid,
     pub parent_ids: Vec<Oid>,
+    pub parents: Vec<usize>,
+    pub children: Vec<usize>,
     pub branches: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
+pub struct BranchVis {
+    pub order_group: usize,
+    pub color_group: usize,
+    pub column: Option<usize>,
+}
+
 pub struct BranchInfo {
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
     pub is_remote: bool,
-    pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
-    pub column: Option<usize>,
+    pub visual: BranchVis,
 }
 
 pub struct GitGraph {
@@ -35,14 +42,18 @@
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
+
         for (index, oid_result) in revwalk.enumerate() {
             let oid = oid_result?;
             let commit = repo.find_commit(oid)?;
             let parent_ids = commit.parent_ids().collect();
+
             indices.insert(oid, index);
             commits.push(CommitInfo {
                 id: oid,
                 parent_ids,
+                parents: Vec::new(),
+                children: Vec::new(),
                 branches: Vec::new(),
                 branch_trace: None,
             });
@@ -54,8 +65,12 @@
             branches: Vec::new(),
         };
 
+        assign_parent_indices(&mut graph.commits, &indices);
+        assign_children(&mut graph.commits);
+
         let branches = graph.assign_branches(&indices, settings)?;
         graph.branches = branches;
+
         assign_branch_columns(&graph.commits, &mut graph.branches, settings);
 
         Ok(graph)
@@ -71,7 +86,7 @@
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, indices, &mut info, branch_index);
+            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -98,6 +113,49 @@
     }
 }
 
+fn extract_branches(
+    repo: &Repository,
+    indices: &HashMap<Oid, usize>,
+    settings: &Settings,
+) -> Result<Vec<BranchInfo>, git2::Error> {
+    let mut branches = Vec::new();
+
+    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
+        let mut iter = repo.branches(Some(branch_type))?;
+        while let Some(branch_result) = iter.next() {
+            let (branch, _) = branch_result?;
+            branches.push((branch, branch_type));
+        }
+        Ok(())
+    };
+
+    push_branches(BranchType::Local)?;
+
+    if settings.include_remote {
+        push_branches(BranchType::Remote)?;
+    }
+
+    let mut branch_infos = branches
+        .into_iter()
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
+        .collect::<Vec<_>>();
+
+    branch_infos.sort_by(|left, right| {
+        left.visual
+            .order_group
+            .cmp(&right.visual.order_group)
+            .then(
+                branch_persistence(&left.name, &settings.branches)
+                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+            )
+            .then(left.name.cmp(&right.name))
+    });
+
+    Ok(branch_infos)
+}
+
 fn branch_info(
     branch: Branch,
     branch_type: BranchType,
@@ -111,19 +169,34 @@
     let target_index = indices.get(&target).copied()?;
     let short_name = branch_short_name(name, branch_type);
     let order_group = branch_order(short_name, settings);
+    let color_group = branch_color(short_name, settings);
 
     Some(BranchInfo {
         name: short_name.to_string(),
         target,
         target_index,
         is_remote: branch_type == BranchType::Remote,
-        order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
-        column: None,
+        visual: BranchVis {
+            order_group,
+            color_group,
+            column: None,
+        },
     })
 }
 
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
+}
+
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
     let name = normalized_branch_name(name);
     settings
@@ -144,105 +217,90 @@
         .unwrap_or(settings.order.len())
 }
 
+fn branch_color(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
+    settings
+        .color
+        .iter()
+        .enumerate()
+        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
+        .map(|(index, _)| index)
+        .unwrap_or(settings.color.len())
+}
+
 fn normalized_branch_name(name: &str) -> &str {
     name.strip_prefix("origin/").unwrap_or(name)
 }
 
-fn extract_branches(
-    repo: &Repository,
-    indices: &HashMap<Oid, usize>,
-    settings: &Settings,
-) -> Result<Vec<BranchInfo>, git2::Error> {
-    let mut branches = Vec::new();
-
-    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
-        let mut iter = repo.branches(Some(branch_type))?;
-        while let Some(branch_result) = iter.next() {
-            let (branch, _) = branch_result?;
-            branches.push((branch, branch_type));
+fn assign_parent_indices(commits: &mut [CommitInfo], indices: &HashMap<Oid, usize>) {
+    for info in commits.iter_mut() {
+        info.parents.clear();
+        for oid in &info.parent_ids {
+            if let Some(index) = indices.get(oid) {
+                info.parents.push(*index);
+            }
         }
-        Ok(())
-    };
+    }
+}
 
-    push_branches(BranchType::Local)?;
-
-    if settings.include_remote {
-        push_branches(BranchType::Remote)?;
+fn assign_children(commits: &mut [CommitInfo]) {
+    for commit in commits.iter_mut() {
+        commit.children.clear();
     }
 
-    let mut branch_infos = branches
-        .into_iter()
-        .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
-        })
-        .collect::<Vec<_>>();
-
-    branch_infos.sort_by(|left, right| {
-        left.order_group
-            .cmp(&right.order_group)
-            .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
-            )
-            .then(left.name.cmp(&right.name))
-    });
-
-    Ok(branch_infos)
-}
-
-fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
-    match branch_type {
-        BranchType::Local => reference_name
-            .strip_prefix("refs/heads/")
-            .unwrap_or(reference_name),
-        BranchType::Remote => reference_name
-            .strip_prefix("refs/remotes/")
-            .unwrap_or(reference_name),
+    for child_index in 0..commits.len() {
+        for &parent_index in &commits[child_index].parents {
+            if let Some(parent) = commits.get_mut(parent_index) {
+                parent.children.push(child_index);
+            }
+        }
     }
 }
 
-fn trace_branch(
-    commits: &mut [CommitInfo],
-    indices: &HashMap<Oid, usize>,
-    branch: &mut BranchInfo,
-    branch_index: usize,
-) -> bool {
+fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
-    let mut range_end = branch.target_index;
+    let mut range_tail = branch.target_index;
     let mut range_valid = true;
+    let mut previous = None;
+    let mut merge_anchor = None;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
             Some(trace) if trace == branch_index => break,
-            Some(_) => {}
+            Some(_) => {
+                if let Some(child_index) = previous {
+                    merge_anchor =
+                        merge_anchor.or_else(|| merge_start(commits, index, child_index));
+                }
+                break;
+            }
             None => {
                 commits[index].branch_trace = Some(branch_index);
                 any_assigned = true;
-                range_end = index;
+                range_tail = index;
             }
         }
 
-        let parent_index = commits[index]
-            .parent_ids
-            .iter()
-            .filter_map(|oid| indices.get(oid))
-            .copied()
-            .next();
+        let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
-            if parent_index < range_end {
-                // Jumping forward indicates a non-contiguous range; skip column assignment.
+            if parent_index < range_tail {
                 range_valid = false;
                 break;
             }
         }
 
+        previous = Some(index);
         current = parent_index;
     }
 
     if any_assigned && range_valid {
-        branch.range = Some((range_end, branch.target_index));
+        let mut start = range_tail;
+        if let Some(anchor) = merge_anchor {
+            start = start.max(anchor);
+        }
+        branch.range = Some((start, branch.target_index));
     } else {
         branch.range = None;
     }
@@ -250,6 +308,20 @@
     any_assigned
 }
 
+fn merge_start(commits: &[CommitInfo], parent_index: usize, child_index: usize) -> Option<usize> {
+    let children = commits
+        .get(parent_index)
+        .map(|info| info.children.as_slice())
+        .unwrap_or(&[]);
+
+    if children.len() <= 1 {
+        return None;
+    }
+
+    let anchor = children.iter().copied().max()?;
+    Some(anchor.max(child_index))
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
@@ -259,14 +331,20 @@
         return;
     }
 
+    for branch in branches.iter_mut() {
+        branch.visual.column = None;
+    }
+
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
         if branch.range.is_none() {
             continue;
         }
 
-        // Group index may exceed configured order length; keep as-is for stable layout.
-        groups.entry(branch.order_group).or_default().push(index);
+        groups
+            .entry(branch.visual.order_group)
+            .or_default()
+            .push(index);
     }
 
     let mut offset = 0;
@@ -312,7 +390,7 @@
         let group_width = occupied.len();
 
         for (branch_index, column) in assignments {
-            branches[branch_index].column = Some(column + offset);
+            branches[branch_index].visual.column = Some(column + offset);
         }
 
         offset += group_width;
diff --git a/src/main.rs b/src/main.rs
index 6e320e9bd9209afaaf06b86efe9caf12162a0a09..c2a6f05ed62b7ed7fffade0517a99a78b99f6f72
--- a/src/main.rs
+++ b/src/main.rs
@@ -24,9 +24,12 @@
     let commit = graph.commit(info)?;
 
     let symbol = if commit.parent_count() > 1 { "o" } else { "*" };
+    let merge_marker = if commit.parent_count() > 1 { 'M' } else { '.' };
     let short_id = short_id(commit.id());
     let indent = commit_indent(graph, info);
 
+    let (column, span) = branch_metrics(graph, info);
+
     let branch_details = info
         .branches
         .iter()
@@ -40,9 +43,9 @@
     };
 
     let summary = commit.summary().unwrap_or("---");
-    println!(
-        "{}{} {}{} {}",
-        indent, symbol, short_id, branch_str, summary
+    eprintln!(
+        "{}{}{} {} [{} | {}]{} {}",
+        indent, merge_marker, symbol, short_id, column, span, branch_str, summary
     );
 
     Ok(())
@@ -53,24 +56,33 @@
     let indent = indent_for_branch(branch);
 
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column = branch.column.unwrap_or(99);
+    let column = branch
+        .visual
+        .column
+        .map(|value| value.to_string())
+        .unwrap_or_else(|| "-".to_string());
+    let range = format_range(branch.range);
 
     format!(
-        "{}{} (col {}){}",
-        indent, branch.name, column, deleted_suffix
+        "{}{} (col {} | range {} | color {}){}",
+        indent, branch.name, column, range, branch.visual.color_group, deleted_suffix
     )
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {
     info.branch_trace
         .and_then(|index| graph.branches().get(index))
-        .and_then(|branch| branch.column)
+        .and_then(|branch| branch.visual.column)
         .map(indent_for_column)
         .unwrap_or_default()
 }
 
 fn indent_for_branch(branch: &BranchInfo) -> String {
-    branch.column.map(indent_for_column).unwrap_or_default()
+    branch
+        .visual
+        .column
+        .map(indent_for_column)
+        .unwrap_or_default()
 }
 
 fn indent_for_column(column: usize) -> String {
@@ -83,3 +95,23 @@
     id.truncate(7);
     id
 }
+
+fn branch_metrics(graph: &GitGraph, info: &CommitInfo) -> (String, String) {
+    info.branch_trace
+        .and_then(|index| graph.branches().get(index))
+        .map(|branch| {
+            let column = branch
+                .visual
+                .column
+                .map(|value| value.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            (column, format_range(branch.range))
+        })
+        .unwrap_or_else(|| ("-".to_string(), "-".to_string()))
+}
+
+fn format_range(range: Option<(usize, usize)>) -> String {
+    range
+        .map(|(start, end)| format!("{}..{}", start.min(end), start.max(end)))
+        .unwrap_or_else(|| "-".to_string())
+}
diff --git a/src/settings.rs b/src/settings.rs
index b25f1cec3dcfa4d21a1a1d4571e99379ec987969..77f4ff5ce72584c8bd6069341bab631d0ab1ebc6
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -26,6 +26,8 @@
     pub persistence: Vec<&'static str>,
     /// Branch grouping order used for indentation.
     pub order: Vec<Vec<&'static str>>,
+    /// Branch color group prefixes, used to map branches to palette slots.
+    pub color: Vec<Vec<&'static str>>,
 }
 
 impl Default for BranchSettings {
@@ -46,6 +48,14 @@
                 vec!["release", "hotfix"],
                 vec!["feature", "bugfix"],
             ],
+            color: vec![
+                vec!["master", "main"],
+                vec!["develop", "dev"],
+                vec!["release"],
+                vec!["hotfix"],
+                vec!["feature"],
+                vec!["bugfix"],
+            ],
         }
     }
 }


[2025-09-21T12:27:52] thinking

**Tracking line numbers for parent indices**
[2025-09-21T12:27:53] exec bash -lc "nl -ba src/graph.rs | sed -n '200,400p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:27:53] bash -lc "nl -ba src/graph.rs | sed -n '200,400p'" succeeded in 24ms:
   200	fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
   201	    let name = normalized_branch_name(name);
   202	    settings
   203	        .persistence
   204	        .iter()
   205	        .position(|candidate| name.starts_with(candidate))
   206	        .unwrap_or(settings.persistence.len())
   207	}
   208	
   209	fn branch_order(name: &str, settings: &BranchSettings) -> usize {
   210	    let name = normalized_branch_name(name);
   211	    settings
   212	        .order
   213	        .iter()
   214	        .enumerate()
   215	        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
   216	        .map(|(index, _)| index)
   217	        .unwrap_or(settings.order.len())
   218	}
   219	
[2025-09-21T12:27:53] tokens used: 122,715
[2025-09-21T12:27:53] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 982924ca97e4ce3ef4764cbf2ccc4d1bd4122343..d440daef0ddc990bb7d87ea5a4004926dbd7f28b
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,19 +5,26 @@
 pub struct CommitInfo {
     pub id: Oid,
     pub parent_ids: Vec<Oid>,
+    pub parents: Vec<usize>,
+    pub children: Vec<usize>,
     pub branches: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
+pub struct BranchVis {
+    pub order_group: usize,
+    pub color_group: usize,
+    pub column: Option<usize>,
+}
+
 pub struct BranchInfo {
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
     pub is_remote: bool,
-    pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
-    pub column: Option<usize>,
+    pub visual: BranchVis,
 }
 
 pub struct GitGraph {
@@ -35,14 +42,18 @@
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
+
         for (index, oid_result) in revwalk.enumerate() {
             let oid = oid_result?;
             let commit = repo.find_commit(oid)?;
             let parent_ids = commit.parent_ids().collect();
+
             indices.insert(oid, index);
             commits.push(CommitInfo {
                 id: oid,
                 parent_ids,
+                parents: Vec::new(),
+                children: Vec::new(),
                 branches: Vec::new(),
                 branch_trace: None,
             });
@@ -54,8 +65,12 @@
             branches: Vec::new(),
         };
 
+        assign_parent_indices(&mut graph.commits, &indices);
+        assign_children(&mut graph.commits);
+
         let branches = graph.assign_branches(&indices, settings)?;
         graph.branches = branches;
+
         assign_branch_columns(&graph.commits, &mut graph.branches, settings);
 
         Ok(graph)
@@ -71,7 +86,7 @@
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, indices, &mut info, branch_index);
+            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -98,6 +113,49 @@
     }
 }
 
+fn extract_branches(
+    repo: &Repository,
+    indices: &HashMap<Oid, usize>,
+    settings: &Settings,
+) -> Result<Vec<BranchInfo>, git2::Error> {
+    let mut branches = Vec::new();
+
+    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
+        let mut iter = repo.branches(Some(branch_type))?;
+        while let Some(branch_result) = iter.next() {
+            let (branch, _) = branch_result?;
+            branches.push((branch, branch_type));
+        }
+        Ok(())
+    };
+
+    push_branches(BranchType::Local)?;
+
+    if settings.include_remote {
+        push_branches(BranchType::Remote)?;
+    }
+
+    let mut branch_infos = branches
+        .into_iter()
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
+        .collect::<Vec<_>>();
+
+    branch_infos.sort_by(|left, right| {
+        left.visual
+            .order_group
+            .cmp(&right.visual.order_group)
+            .then(
+                branch_persistence(&left.name, &settings.branches)
+                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+            )
+            .then(left.name.cmp(&right.name))
+    });
+
+    Ok(branch_infos)
+}
+
 fn branch_info(
     branch: Branch,
     branch_type: BranchType,
@@ -111,19 +169,34 @@
     let target_index = indices.get(&target).copied()?;
     let short_name = branch_short_name(name, branch_type);
     let order_group = branch_order(short_name, settings);
+    let color_group = branch_color(short_name, settings);
 
     Some(BranchInfo {
         name: short_name.to_string(),
         target,
         target_index,
         is_remote: branch_type == BranchType::Remote,
-        order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
-        column: None,
+        visual: BranchVis {
+            order_group,
+            color_group,
+            column: None,
+        },
     })
 }
 
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
+}
+
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
     let name = normalized_branch_name(name);
     settings
@@ -144,105 +217,90 @@
         .unwrap_or(settings.order.len())
 }
 
+fn branch_color(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
+    settings
+        .color
+        .iter()
+        .enumerate()
+        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
+        .map(|(index, _)| index)
+        .unwrap_or(settings.color.len())
+}
+
 fn normalized_branch_name(name: &str) -> &str {
     name.strip_prefix("origin/").unwrap_or(name)
 }
 
-fn extract_branches(
-    repo: &Repository,
-    indices: &HashMap<Oid, usize>,
-    settings: &Settings,
-) -> Result<Vec<BranchInfo>, git2::Error> {
-    let mut branches = Vec::new();
-
-    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
-        let mut iter = repo.branches(Some(branch_type))?;
-        while let Some(branch_result) = iter.next() {
-            let (branch, _) = branch_result?;
-            branches.push((branch, branch_type));
+fn assign_parent_indices(commits: &mut [CommitInfo], indices: &HashMap<Oid, usize>) {
+    for info in commits.iter_mut() {
+        info.parents.clear();
+        for oid in &info.parent_ids {
+            if let Some(index) = indices.get(oid) {
+                info.parents.push(*index);
+            }
         }
-        Ok(())
-    };
+    }
+}
 
-    push_branches(BranchType::Local)?;
-
-    if settings.include_remote {
-        push_branches(BranchType::Remote)?;
+fn assign_children(commits: &mut [CommitInfo]) {
+    for commit in commits.iter_mut() {
+        commit.children.clear();
     }
 
-    let mut branch_infos = branches
-        .into_iter()
-        .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
-        })
-        .collect::<Vec<_>>();
-
-    branch_infos.sort_by(|left, right| {
-        left.order_group
-            .cmp(&right.order_group)
-            .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
-            )
-            .then(left.name.cmp(&right.name))
-    });
-
-    Ok(branch_infos)
-}
-
-fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
-    match branch_type {
-        BranchType::Local => reference_name
-            .strip_prefix("refs/heads/")
-            .unwrap_or(reference_name),
-        BranchType::Remote => reference_name
-            .strip_prefix("refs/remotes/")
-            .unwrap_or(reference_name),
+    for child_index in 0..commits.len() {
+        for &parent_index in &commits[child_index].parents {
+            if let Some(parent) = commits.get_mut(parent_index) {
+                parent.children.push(child_index);
+            }
+        }
     }
 }
 
-fn trace_branch(
-    commits: &mut [CommitInfo],
-    indices: &HashMap<Oid, usize>,
-    branch: &mut BranchInfo,
-    branch_index: usize,
-) -> bool {
+fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
-    let mut range_end = branch.target_index;
+    let mut range_tail = branch.target_index;
     let mut range_valid = true;
+    let mut previous = None;
+    let mut merge_anchor = None;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
             Some(trace) if trace == branch_index => break,
-            Some(_) => {}
+            Some(_) => {
+                if let Some(child_index) = previous {
+                    merge_anchor =
+                        merge_anchor.or_else(|| merge_start(commits, index, child_index));
+                }
+                break;
+            }
             None => {
                 commits[index].branch_trace = Some(branch_index);
                 any_assigned = true;
-                range_end = index;
+                range_tail = index;
             }
         }
 
-        let parent_index = commits[index]
-            .parent_ids
-            .iter()
-            .filter_map(|oid| indices.get(oid))
-            .copied()
-            .next();
+        let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
-            if parent_index < range_end {
-                // Jumping forward indicates a non-contiguous range; skip column assignment.
+            if parent_index < range_tail {
                 range_valid = false;
                 break;
             }
         }
 
+        previous = Some(index);
         current = parent_index;
     }
 
     if any_assigned && range_valid {
-        branch.range = Some((range_end, branch.target_index));
+        let mut start = range_tail;
+        if let Some(anchor) = merge_anchor {
+            start = start.max(anchor);
+        }
+        branch.range = Some((start, branch.target_index));
     } else {
         branch.range = None;
     }
@@ -250,6 +308,20 @@
     any_assigned
 }
 
+fn merge_start(commits: &[CommitInfo], parent_index: usize, child_index: usize) -> Option<usize> {
+    let children = commits
+        .get(parent_index)
+        .map(|info| info.children.as_slice())
+        .unwrap_or(&[]);
+
+    if children.len() <= 1 {
+        return None;
+    }
+
+    let anchor = children.iter().copied().max()?;
+    Some(anchor.max(child_index))
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
@@ -259,14 +331,20 @@
         return;
     }
 
+    for branch in branches.iter_mut() {
+        branch.visual.column = None;
+    }
+
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
         if branch.range.is_none() {
             continue;
         }
 
-        // Group index may exceed configured order length; keep as-is for stable layout.
-        groups.entry(branch.order_group).or_default().push(index);
+        groups
+            .entry(branch.visual.order_group)
+            .or_default()
+            .push(index);
     }
 
     let mut offset = 0;
@@ -312,7 +390,7 @@
         let group_width = occupied.len();
 
         for (branch_index, column) in assignments {
-            branches[branch_index].column = Some(column + offset);
+            branches[branch_index].visual.column = Some(column + offset);
         }
 
         offset += group_width;
diff --git a/src/main.rs b/src/main.rs
index 6e320e9bd9209afaaf06b86efe9caf12162a0a09..c2a6f05ed62b7ed7fffade0517a99a78b99f6f72
--- a/src/main.rs
+++ b/src/main.rs
@@ -24,9 +24,12 @@
     let commit = graph.commit(info)?;
 
     let symbol = if commit.parent_count() > 1 { "o" } else { "*" };
+    let merge_marker = if commit.parent_count() > 1 { 'M' } else { '.' };
     let short_id = short_id(commit.id());
     let indent = commit_indent(graph, info);
 
+    let (column, span) = branch_metrics(graph, info);
+
     let branch_details = info
         .branches
         .iter()
@@ -40,9 +43,9 @@
     };
 
     let summary = commit.summary().unwrap_or("---");
-    println!(
-        "{}{} {}{} {}",
-        indent, symbol, short_id, branch_str, summary
+    eprintln!(
+        "{}{}{} {} [{} | {}]{} {}",
+        indent, merge_marker, symbol, short_id, column, span, branch_str, summary
     );
 
     Ok(())
@@ -53,24 +56,33 @@
     let indent = indent_for_branch(branch);
 
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column = branch.column.unwrap_or(99);
+    let column = branch
+        .visual
+        .column
+        .map(|value| value.to_string())
+        .unwrap_or_else(|| "-".to_string());
+    let range = format_range(branch.range);
 
     format!(
-        "{}{} (col {}){}",
-        indent, branch.name, column, deleted_suffix
+        "{}{} (col {} | range {} | color {}){}",
+        indent, branch.name, column, range, branch.visual.color_group, deleted_suffix
     )
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {
     info.branch_trace
         .and_then(|index| graph.branches().get(index))
-        .and_then(|branch| branch.column)
+        .and_then(|branch| branch.visual.column)
         .map(indent_for_column)
         .unwrap_or_default()
 }
 
 fn indent_for_branch(branch: &BranchInfo) -> String {
-    branch.column.map(indent_for_column).unwrap_or_default()
+    branch
+        .visual
+        .column
+        .map(indent_for_column)
+        .unwrap_or_default()
 }
 
 fn indent_for_column(column: usize) -> String {
@@ -83,3 +95,23 @@
     id.truncate(7);
     id
 }
+
+fn branch_metrics(graph: &GitGraph, info: &CommitInfo) -> (String, String) {
+    info.branch_trace
+        .and_then(|index| graph.branches().get(index))
+        .map(|branch| {
+            let column = branch
+                .visual
+                .column
+                .map(|value| value.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            (column, format_range(branch.range))
+        })
+        .unwrap_or_else(|| ("-".to_string(), "-".to_string()))
+}
+
+fn format_range(range: Option<(usize, usize)>) -> String {
+    range
+        .map(|(start, end)| format!("{}..{}", start.min(end), start.max(end)))
+        .unwrap_or_else(|| "-".to_string())
+}
diff --git a/src/settings.rs b/src/settings.rs
index b25f1cec3dcfa4d21a1a1d4571e99379ec987969..77f4ff5ce72584c8bd6069341bab631d0ab1ebc6
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -26,6 +26,8 @@
     pub persistence: Vec<&'static str>,
     /// Branch grouping order used for indentation.
     pub order: Vec<Vec<&'static str>>,
+    /// Branch color group prefixes, used to map branches to palette slots.
+    pub color: Vec<Vec<&'static str>>,
 }
 
 impl Default for BranchSettings {
@@ -46,6 +48,14 @@
                 vec!["release", "hotfix"],
                 vec!["feature", "bugfix"],
             ],
+            color: vec![
+                vec!["master", "main"],
+                vec!["develop", "dev"],
+                vec!["release"],
+                vec!["hotfix"],
+                vec!["feature"],
+                vec!["bugfix"],
+            ],
         }
     }
 }


[2025-09-21T12:27:55] thinking

**Requesting more lines**
[2025-09-21T12:27:56] exec bash -lc "nl -ba src/graph.rs | sed -n '400,520p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:27:56] bash -lc "nl -ba src/graph.rs | sed -n '400,520p'" succeeded in 31ms:
   400	fn branch_interval(branch: &BranchInfo) -> (usize, usize) {
   401	    branch
   402	        .range
   403	        .map(|(start, end)| (start.min(end), start.max(end)))
   404	        .unwrap_or_else(|| (branch.target_index, branch.target_index))
   405	}
[2025-09-21T12:27:56] tokens used: 125,259
[2025-09-21T12:27:56] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 982924ca97e4ce3ef4764cbf2ccc4d1bd4122343..d440daef0ddc990bb7d87ea5a4004926dbd7f28b
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,19 +5,26 @@
 pub struct CommitInfo {
     pub id: Oid,
     pub parent_ids: Vec<Oid>,
+    pub parents: Vec<usize>,
+    pub children: Vec<usize>,
     pub branches: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
+pub struct BranchVis {
+    pub order_group: usize,
+    pub color_group: usize,
+    pub column: Option<usize>,
+}
+
 pub struct BranchInfo {
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
     pub is_remote: bool,
-    pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
-    pub column: Option<usize>,
+    pub visual: BranchVis,
 }
 
 pub struct GitGraph {
@@ -35,14 +42,18 @@
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
+
         for (index, oid_result) in revwalk.enumerate() {
             let oid = oid_result?;
             let commit = repo.find_commit(oid)?;
             let parent_ids = commit.parent_ids().collect();
+
             indices.insert(oid, index);
             commits.push(CommitInfo {
                 id: oid,
                 parent_ids,
+                parents: Vec::new(),
+                children: Vec::new(),
                 branches: Vec::new(),
                 branch_trace: None,
             });
@@ -54,8 +65,12 @@
             branches: Vec::new(),
         };
 
+        assign_parent_indices(&mut graph.commits, &indices);
+        assign_children(&mut graph.commits);
+
         let branches = graph.assign_branches(&indices, settings)?;
         graph.branches = branches;
+
         assign_branch_columns(&graph.commits, &mut graph.branches, settings);
 
         Ok(graph)
@@ -71,7 +86,7 @@
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, indices, &mut info, branch_index);
+            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -98,6 +113,49 @@
     }
 }
 
+fn extract_branches(
+    repo: &Repository,
+    indices: &HashMap<Oid, usize>,
+    settings: &Settings,
+) -> Result<Vec<BranchInfo>, git2::Error> {
+    let mut branches = Vec::new();
+
+    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
+        let mut iter = repo.branches(Some(branch_type))?;
+        while let Some(branch_result) = iter.next() {
+            let (branch, _) = branch_result?;
+            branches.push((branch, branch_type));
+        }
+        Ok(())
+    };
+
+    push_branches(BranchType::Local)?;
+
+    if settings.include_remote {
+        push_branches(BranchType::Remote)?;
+    }
+
+    let mut branch_infos = branches
+        .into_iter()
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
+        .collect::<Vec<_>>();
+
+    branch_infos.sort_by(|left, right| {
+        left.visual
+            .order_group
+            .cmp(&right.visual.order_group)
+            .then(
+                branch_persistence(&left.name, &settings.branches)
+                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+            )
+            .then(left.name.cmp(&right.name))
+    });
+
+    Ok(branch_infos)
+}
+
 fn branch_info(
     branch: Branch,
     branch_type: BranchType,
@@ -111,19 +169,34 @@
     let target_index = indices.get(&target).copied()?;
     let short_name = branch_short_name(name, branch_type);
     let order_group = branch_order(short_name, settings);
+    let color_group = branch_color(short_name, settings);
 
     Some(BranchInfo {
         name: short_name.to_string(),
         target,
         target_index,
         is_remote: branch_type == BranchType::Remote,
-        order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
-        column: None,
+        visual: BranchVis {
+            order_group,
+            color_group,
+            column: None,
+        },
     })
 }
 
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
+}
+
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
     let name = normalized_branch_name(name);
     settings
@@ -144,105 +217,90 @@
         .unwrap_or(settings.order.len())
 }
 
+fn branch_color(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
+    settings
+        .color
+        .iter()
+        .enumerate()
+        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
+        .map(|(index, _)| index)
+        .unwrap_or(settings.color.len())
+}
+
 fn normalized_branch_name(name: &str) -> &str {
     name.strip_prefix("origin/").unwrap_or(name)
 }
 
-fn extract_branches(
-    repo: &Repository,
-    indices: &HashMap<Oid, usize>,
-    settings: &Settings,
-) -> Result<Vec<BranchInfo>, git2::Error> {
-    let mut branches = Vec::new();
-
-    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
-        let mut iter = repo.branches(Some(branch_type))?;
-        while let Some(branch_result) = iter.next() {
-            let (branch, _) = branch_result?;
-            branches.push((branch, branch_type));
+fn assign_parent_indices(commits: &mut [CommitInfo], indices: &HashMap<Oid, usize>) {
+    for info in commits.iter_mut() {
+        info.parents.clear();
+        for oid in &info.parent_ids {
+            if let Some(index) = indices.get(oid) {
+                info.parents.push(*index);
+            }
         }
-        Ok(())
-    };
+    }
+}
 
-    push_branches(BranchType::Local)?;
-
-    if settings.include_remote {
-        push_branches(BranchType::Remote)?;
+fn assign_children(commits: &mut [CommitInfo]) {
+    for commit in commits.iter_mut() {
+        commit.children.clear();
     }
 
-    let mut branch_infos = branches
-        .into_iter()
-        .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
-        })
-        .collect::<Vec<_>>();
-
-    branch_infos.sort_by(|left, right| {
-        left.order_group
-            .cmp(&right.order_group)
-            .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
-            )
-            .then(left.name.cmp(&right.name))
-    });
-
-    Ok(branch_infos)
-}
-
-fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
-    match branch_type {
-        BranchType::Local => reference_name
-            .strip_prefix("refs/heads/")
-            .unwrap_or(reference_name),
-        BranchType::Remote => reference_name
-            .strip_prefix("refs/remotes/")
-            .unwrap_or(reference_name),
+    for child_index in 0..commits.len() {
+        for &parent_index in &commits[child_index].parents {
+            if let Some(parent) = commits.get_mut(parent_index) {
+                parent.children.push(child_index);
+            }
+        }
     }
 }
 
-fn trace_branch(
-    commits: &mut [CommitInfo],
-    indices: &HashMap<Oid, usize>,
-    branch: &mut BranchInfo,
-    branch_index: usize,
-) -> bool {
+fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
-    let mut range_end = branch.target_index;
+    let mut range_tail = branch.target_index;
     let mut range_valid = true;
+    let mut previous = None;
+    let mut merge_anchor = None;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
             Some(trace) if trace == branch_index => break,
-            Some(_) => {}
+            Some(_) => {
+                if let Some(child_index) = previous {
+                    merge_anchor =
+                        merge_anchor.or_else(|| merge_start(commits, index, child_index));
+                }
+                break;
+            }
             None => {
                 commits[index].branch_trace = Some(branch_index);
                 any_assigned = true;
-                range_end = index;
+                range_tail = index;
             }
         }
 
-        let parent_index = commits[index]
-            .parent_ids
-            .iter()
-            .filter_map(|oid| indices.get(oid))
-            .copied()
-            .next();
+        let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
-            if parent_index < range_end {
-                // Jumping forward indicates a non-contiguous range; skip column assignment.
+            if parent_index < range_tail {
                 range_valid = false;
                 break;
             }
         }
 
+        previous = Some(index);
         current = parent_index;
     }
 
     if any_assigned && range_valid {
-        branch.range = Some((range_end, branch.target_index));
+        let mut start = range_tail;
+        if let Some(anchor) = merge_anchor {
+            start = start.max(anchor);
+        }
+        branch.range = Some((start, branch.target_index));
     } else {
         branch.range = None;
     }
@@ -250,6 +308,20 @@
     any_assigned
 }
 
+fn merge_start(commits: &[CommitInfo], parent_index: usize, child_index: usize) -> Option<usize> {
+    let children = commits
+        .get(parent_index)
+        .map(|info| info.children.as_slice())
+        .unwrap_or(&[]);
+
+    if children.len() <= 1 {
+        return None;
+    }
+
+    let anchor = children.iter().copied().max()?;
+    Some(anchor.max(child_index))
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
@@ -259,14 +331,20 @@
         return;
     }
 
+    for branch in branches.iter_mut() {
+        branch.visual.column = None;
+    }
+
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
         if branch.range.is_none() {
             continue;
         }
 
-        // Group index may exceed configured order length; keep as-is for stable layout.
-        groups.entry(branch.order_group).or_default().push(index);
+        groups
+            .entry(branch.visual.order_group)
+            .or_default()
+            .push(index);
     }
 
     let mut offset = 0;
@@ -312,7 +390,7 @@
         let group_width = occupied.len();
 
         for (branch_index, column) in assignments {
-            branches[branch_index].column = Some(column + offset);
+            branches[branch_index].visual.column = Some(column + offset);
         }
 
         offset += group_width;
diff --git a/src/main.rs b/src/main.rs
index 6e320e9bd9209afaaf06b86efe9caf12162a0a09..c2a6f05ed62b7ed7fffade0517a99a78b99f6f72
--- a/src/main.rs
+++ b/src/main.rs
@@ -24,9 +24,12 @@
     let commit = graph.commit(info)?;
 
     let symbol = if commit.parent_count() > 1 { "o" } else { "*" };
+    let merge_marker = if commit.parent_count() > 1 { 'M' } else { '.' };
     let short_id = short_id(commit.id());
     let indent = commit_indent(graph, info);
 
+    let (column, span) = branch_metrics(graph, info);
+
     let branch_details = info
         .branches
         .iter()
@@ -40,9 +43,9 @@
     };
 
     let summary = commit.summary().unwrap_or("---");
-    println!(
-        "{}{} {}{} {}",
-        indent, symbol, short_id, branch_str, summary
+    eprintln!(
+        "{}{}{} {} [{} | {}]{} {}",
+        indent, merge_marker, symbol, short_id, column, span, branch_str, summary
     );
 
     Ok(())
@@ -53,24 +56,33 @@
     let indent = indent_for_branch(branch);
 
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column = branch.column.unwrap_or(99);
+    let column = branch
+        .visual
+        .column
+        .map(|value| value.to_string())
+        .unwrap_or_else(|| "-".to_string());
+    let range = format_range(branch.range);
 
     format!(
-        "{}{} (col {}){}",
-        indent, branch.name, column, deleted_suffix
+        "{}{} (col {} | range {} | color {}){}",
+        indent, branch.name, column, range, branch.visual.color_group, deleted_suffix
     )
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {
     info.branch_trace
         .and_then(|index| graph.branches().get(index))
-        .and_then(|branch| branch.column)
+        .and_then(|branch| branch.visual.column)
         .map(indent_for_column)
         .unwrap_or_default()
 }
 
 fn indent_for_branch(branch: &BranchInfo) -> String {
-    branch.column.map(indent_for_column).unwrap_or_default()
+    branch
+        .visual
+        .column
+        .map(indent_for_column)
+        .unwrap_or_default()
 }
 
 fn indent_for_column(column: usize) -> String {
@@ -83,3 +95,23 @@
     id.truncate(7);
     id
 }
+
+fn branch_metrics(graph: &GitGraph, info: &CommitInfo) -> (String, String) {
+    info.branch_trace
+        .and_then(|index| graph.branches().get(index))
+        .map(|branch| {
+            let column = branch
+                .visual
+                .column
+                .map(|value| value.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            (column, format_range(branch.range))
+        })
+        .unwrap_or_else(|| ("-".to_string(), "-".to_string()))
+}
+
+fn format_range(range: Option<(usize, usize)>) -> String {
+    range
+        .map(|(start, end)| format!("{}..{}", start.min(end), start.max(end)))
+        .unwrap_or_else(|| "-".to_string())
+}
diff --git a/src/settings.rs b/src/settings.rs
index b25f1cec3dcfa4d21a1a1d4571e99379ec987969..77f4ff5ce72584c8bd6069341bab631d0ab1ebc6
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -26,6 +26,8 @@
     pub persistence: Vec<&'static str>,
     /// Branch grouping order used for indentation.
     pub order: Vec<Vec<&'static str>>,
+    /// Branch color group prefixes, used to map branches to palette slots.
+    pub color: Vec<Vec<&'static str>>,
 }
 
 impl Default for BranchSettings {
@@ -46,6 +48,14 @@
                 vec!["release", "hotfix"],
                 vec!["feature", "bugfix"],
             ],
+            color: vec![
+                vec!["master", "main"],
+                vec!["develop", "dev"],
+                vec!["release"],
+                vec!["hotfix"],
+                vec!["feature"],
+                vec!["bugfix"],
+            ],
         }
     }
 }


[2025-09-21T12:28:03] thinking

**Noting key code sections with line numbers**
[2025-09-21T12:28:03] exec bash -lc 'nl -ba src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:28:03] bash -lc 'nl -ba src/main.rs' succeeded in 13ms:
     1	use git2::{Error, Oid};
     2	use git_graph::{
     3	    graph::{BranchInfo, CommitInfo, GitGraph},
     4	    settings::Settings,
     5	};
     6	use itertools::Itertools;
     7	
     8	fn main() -> Result<(), Error> {
     9	    let settings = Settings::git_flow();
    10	    run(".", &settings)
    11	}
    12	
    13	fn run(path: &str, settings: &Settings) -> Result<(), Error> {
    14	    let graph = GitGraph::new(path, settings)?;
    15	
    16	    for info in graph.commits() {
    17	        print_commit_short(&graph, info)?;
    18	    }
    19	
    20	    Ok(())
[2025-09-21T12:28:03] tokens used: 130,665
[2025-09-21T12:28:03] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 982924ca97e4ce3ef4764cbf2ccc4d1bd4122343..d440daef0ddc990bb7d87ea5a4004926dbd7f28b
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,19 +5,26 @@
 pub struct CommitInfo {
     pub id: Oid,
     pub parent_ids: Vec<Oid>,
+    pub parents: Vec<usize>,
+    pub children: Vec<usize>,
     pub branches: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
+pub struct BranchVis {
+    pub order_group: usize,
+    pub color_group: usize,
+    pub column: Option<usize>,
+}
+
 pub struct BranchInfo {
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
     pub is_remote: bool,
-    pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
-    pub column: Option<usize>,
+    pub visual: BranchVis,
 }
 
 pub struct GitGraph {
@@ -35,14 +42,18 @@
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
+
         for (index, oid_result) in revwalk.enumerate() {
             let oid = oid_result?;
             let commit = repo.find_commit(oid)?;
             let parent_ids = commit.parent_ids().collect();
+
             indices.insert(oid, index);
             commits.push(CommitInfo {
                 id: oid,
                 parent_ids,
+                parents: Vec::new(),
+                children: Vec::new(),
                 branches: Vec::new(),
                 branch_trace: None,
             });
@@ -54,8 +65,12 @@
             branches: Vec::new(),
         };
 
+        assign_parent_indices(&mut graph.commits, &indices);
+        assign_children(&mut graph.commits);
+
         let branches = graph.assign_branches(&indices, settings)?;
         graph.branches = branches;
+
         assign_branch_columns(&graph.commits, &mut graph.branches, settings);
 
         Ok(graph)
@@ -71,7 +86,7 @@
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, indices, &mut info, branch_index);
+            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -98,6 +113,49 @@
     }
 }
 
+fn extract_branches(
+    repo: &Repository,
+    indices: &HashMap<Oid, usize>,
+    settings: &Settings,
+) -> Result<Vec<BranchInfo>, git2::Error> {
+    let mut branches = Vec::new();
+
+    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
+        let mut iter = repo.branches(Some(branch_type))?;
+        while let Some(branch_result) = iter.next() {
+            let (branch, _) = branch_result?;
+            branches.push((branch, branch_type));
+        }
+        Ok(())
+    };
+
+    push_branches(BranchType::Local)?;
+
+    if settings.include_remote {
+        push_branches(BranchType::Remote)?;
+    }
+
+    let mut branch_infos = branches
+        .into_iter()
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
+        .collect::<Vec<_>>();
+
+    branch_infos.sort_by(|left, right| {
+        left.visual
+            .order_group
+            .cmp(&right.visual.order_group)
+            .then(
+                branch_persistence(&left.name, &settings.branches)
+                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+            )
+            .then(left.name.cmp(&right.name))
+    });
+
+    Ok(branch_infos)
+}
+
 fn branch_info(
     branch: Branch,
     branch_type: BranchType,
@@ -111,19 +169,34 @@
     let target_index = indices.get(&target).copied()?;
     let short_name = branch_short_name(name, branch_type);
     let order_group = branch_order(short_name, settings);
+    let color_group = branch_color(short_name, settings);
 
     Some(BranchInfo {
         name: short_name.to_string(),
         target,
         target_index,
         is_remote: branch_type == BranchType::Remote,
-        order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
-        column: None,
+        visual: BranchVis {
+            order_group,
+            color_group,
+            column: None,
+        },
     })
 }
 
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
+}
+
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
     let name = normalized_branch_name(name);
     settings
@@ -144,105 +217,90 @@
         .unwrap_or(settings.order.len())
 }
 
+fn branch_color(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
+    settings
+        .color
+        .iter()
+        .enumerate()
+        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
+        .map(|(index, _)| index)
+        .unwrap_or(settings.color.len())
+}
+
 fn normalized_branch_name(name: &str) -> &str {
     name.strip_prefix("origin/").unwrap_or(name)
 }
 
-fn extract_branches(
-    repo: &Repository,
-    indices: &HashMap<Oid, usize>,
-    settings: &Settings,
-) -> Result<Vec<BranchInfo>, git2::Error> {
-    let mut branches = Vec::new();
-
-    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
-        let mut iter = repo.branches(Some(branch_type))?;
-        while let Some(branch_result) = iter.next() {
-            let (branch, _) = branch_result?;
-            branches.push((branch, branch_type));
+fn assign_parent_indices(commits: &mut [CommitInfo], indices: &HashMap<Oid, usize>) {
+    for info in commits.iter_mut() {
+        info.parents.clear();
+        for oid in &info.parent_ids {
+            if let Some(index) = indices.get(oid) {
+                info.parents.push(*index);
+            }
         }
-        Ok(())
-    };
+    }
+}
 
-    push_branches(BranchType::Local)?;
-
-    if settings.include_remote {
-        push_branches(BranchType::Remote)?;
+fn assign_children(commits: &mut [CommitInfo]) {
+    for commit in commits.iter_mut() {
+        commit.children.clear();
     }
 
-    let mut branch_infos = branches
-        .into_iter()
-        .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
-        })
-        .collect::<Vec<_>>();
-
-    branch_infos.sort_by(|left, right| {
-        left.order_group
-            .cmp(&right.order_group)
-            .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
-            )
-            .then(left.name.cmp(&right.name))
-    });
-
-    Ok(branch_infos)
-}
-
-fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
-    match branch_type {
-        BranchType::Local => reference_name
-            .strip_prefix("refs/heads/")
-            .unwrap_or(reference_name),
-        BranchType::Remote => reference_name
-            .strip_prefix("refs/remotes/")
-            .unwrap_or(reference_name),
+    for child_index in 0..commits.len() {
+        for &parent_index in &commits[child_index].parents {
+            if let Some(parent) = commits.get_mut(parent_index) {
+                parent.children.push(child_index);
+            }
+        }
     }
 }
 
-fn trace_branch(
-    commits: &mut [CommitInfo],
-    indices: &HashMap<Oid, usize>,
-    branch: &mut BranchInfo,
-    branch_index: usize,
-) -> bool {
+fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
-    let mut range_end = branch.target_index;
+    let mut range_tail = branch.target_index;
     let mut range_valid = true;
+    let mut previous = None;
+    let mut merge_anchor = None;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
             Some(trace) if trace == branch_index => break,
-            Some(_) => {}
+            Some(_) => {
+                if let Some(child_index) = previous {
+                    merge_anchor =
+                        merge_anchor.or_else(|| merge_start(commits, index, child_index));
+                }
+                break;
+            }
             None => {
                 commits[index].branch_trace = Some(branch_index);
                 any_assigned = true;
-                range_end = index;
+                range_tail = index;
             }
         }
 
-        let parent_index = commits[index]
-            .parent_ids
-            .iter()
-            .filter_map(|oid| indices.get(oid))
-            .copied()
-            .next();
+        let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
-            if parent_index < range_end {
-                // Jumping forward indicates a non-contiguous range; skip column assignment.
+            if parent_index < range_tail {
                 range_valid = false;
                 break;
             }
         }
 
+        previous = Some(index);
         current = parent_index;
     }
 
     if any_assigned && range_valid {
-        branch.range = Some((range_end, branch.target_index));
+        let mut start = range_tail;
+        if let Some(anchor) = merge_anchor {
+            start = start.max(anchor);
+        }
+        branch.range = Some((start, branch.target_index));
     } else {
         branch.range = None;
     }
@@ -250,6 +308,20 @@
     any_assigned
 }
 
+fn merge_start(commits: &[CommitInfo], parent_index: usize, child_index: usize) -> Option<usize> {
+    let children = commits
+        .get(parent_index)
+        .map(|info| info.children.as_slice())
+        .unwrap_or(&[]);
+
+    if children.len() <= 1 {
+        return None;
+    }
+
+    let anchor = children.iter().copied().max()?;
+    Some(anchor.max(child_index))
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
@@ -259,14 +331,20 @@
         return;
     }
 
+    for branch in branches.iter_mut() {
+        branch.visual.column = None;
+    }
+
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
         if branch.range.is_none() {
             continue;
         }
 
-        // Group index may exceed configured order length; keep as-is for stable layout.
-        groups.entry(branch.order_group).or_default().push(index);
+        groups
+            .entry(branch.visual.order_group)
+            .or_default()
+            .push(index);
     }
 
     let mut offset = 0;
@@ -312,7 +390,7 @@
         let group_width = occupied.len();
 
         for (branch_index, column) in assignments {
-            branches[branch_index].column = Some(column + offset);
+            branches[branch_index].visual.column = Some(column + offset);
         }
 
         offset += group_width;
diff --git a/src/main.rs b/src/main.rs
index 6e320e9bd9209afaaf06b86efe9caf12162a0a09..c2a6f05ed62b7ed7fffade0517a99a78b99f6f72
--- a/src/main.rs
+++ b/src/main.rs
@@ -24,9 +24,12 @@
     let commit = graph.commit(info)?;
 
     let symbol = if commit.parent_count() > 1 { "o" } else { "*" };
+    let merge_marker = if commit.parent_count() > 1 { 'M' } else { '.' };
     let short_id = short_id(commit.id());
     let indent = commit_indent(graph, info);
 
+    let (column, span) = branch_metrics(graph, info);
+
     let branch_details = info
         .branches
         .iter()
@@ -40,9 +43,9 @@
     };
 
     let summary = commit.summary().unwrap_or("---");
-    println!(
-        "{}{} {}{} {}",
-        indent, symbol, short_id, branch_str, summary
+    eprintln!(
+        "{}{}{} {} [{} | {}]{} {}",
+        indent, merge_marker, symbol, short_id, column, span, branch_str, summary
     );
 
     Ok(())
@@ -53,24 +56,33 @@
     let indent = indent_for_branch(branch);
 
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column = branch.column.unwrap_or(99);
+    let column = branch
+        .visual
+        .column
+        .map(|value| value.to_string())
+        .unwrap_or_else(|| "-".to_string());
+    let range = format_range(branch.range);
 
     format!(
-        "{}{} (col {}){}",
-        indent, branch.name, column, deleted_suffix
+        "{}{} (col {} | range {} | color {}){}",
+        indent, branch.name, column, range, branch.visual.color_group, deleted_suffix
     )
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {
     info.branch_trace
         .and_then(|index| graph.branches().get(index))
-        .and_then(|branch| branch.column)
+        .and_then(|branch| branch.visual.column)
         .map(indent_for_column)
         .unwrap_or_default()
 }
 
 fn indent_for_branch(branch: &BranchInfo) -> String {
-    branch.column.map(indent_for_column).unwrap_or_default()
+    branch
+        .visual
+        .column
+        .map(indent_for_column)
+        .unwrap_or_default()
 }
 
 fn indent_for_column(column: usize) -> String {
@@ -83,3 +95,23 @@
     id.truncate(7);
     id
 }
+
+fn branch_metrics(graph: &GitGraph, info: &CommitInfo) -> (String, String) {
+    info.branch_trace
+        .and_then(|index| graph.branches().get(index))
+        .map(|branch| {
+            let column = branch
+                .visual
+                .column
+                .map(|value| value.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            (column, format_range(branch.range))
+        })
+        .unwrap_or_else(|| ("-".to_string(), "-".to_string()))
+}
+
+fn format_range(range: Option<(usize, usize)>) -> String {
+    range
+        .map(|(start, end)| format!("{}..{}", start.min(end), start.max(end)))
+        .unwrap_or_else(|| "-".to_string())
+}
diff --git a/src/settings.rs b/src/settings.rs
index b25f1cec3dcfa4d21a1a1d4571e99379ec987969..77f4ff5ce72584c8bd6069341bab631d0ab1ebc6
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -26,6 +26,8 @@
     pub persistence: Vec<&'static str>,
     /// Branch grouping order used for indentation.
     pub order: Vec<Vec<&'static str>>,
+    /// Branch color group prefixes, used to map branches to palette slots.
+    pub color: Vec<Vec<&'static str>>,
 }
 
 impl Default for BranchSettings {
@@ -46,6 +48,14 @@
                 vec!["release", "hotfix"],
                 vec!["feature", "bugfix"],
             ],
+            color: vec![
+                vec!["master", "main"],
+                vec!["develop", "dev"],
+                vec!["release"],
+                vec!["hotfix"],
+                vec!["feature"],
+                vec!["bugfix"],
+            ],
         }
     }
 }


[2025-09-21T12:28:06] thinking

**Reviewing settings.rs file**
[2025-09-21T12:28:06] exec bash -lc 'nl -ba src/settings.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:28:06] bash -lc 'nl -ba src/settings.rs' succeeded in 12ms:
     1	#[derive(Debug)]
     2	pub struct Settings {
     3	    pub include_remote: bool,
     4	    pub branches: BranchSettings,
     5	}
     6	
     7	impl Default for Settings {
     8	    fn default() -> Self {
     9	        Self::git_flow()
    10	    }
    11	}
    12	
    13	impl Settings {
    14	    /// Returns settings tuned for the conventional git-flow branch layout.
    15	    pub fn git_flow() -> Self {
    16	        Self {
    17	            include_remote: true,
    18	            branches: BranchSettings::git_flow(),
    19	        }
    20	    }
[2025-09-21T12:28:06] tokens used: 132,262
[2025-09-21T12:28:06] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 982924ca97e4ce3ef4764cbf2ccc4d1bd4122343..d440daef0ddc990bb7d87ea5a4004926dbd7f28b
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,19 +5,26 @@
 pub struct CommitInfo {
     pub id: Oid,
     pub parent_ids: Vec<Oid>,
+    pub parents: Vec<usize>,
+    pub children: Vec<usize>,
     pub branches: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
+pub struct BranchVis {
+    pub order_group: usize,
+    pub color_group: usize,
+    pub column: Option<usize>,
+}
+
 pub struct BranchInfo {
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
     pub is_remote: bool,
-    pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
-    pub column: Option<usize>,
+    pub visual: BranchVis,
 }
 
 pub struct GitGraph {
@@ -35,14 +42,18 @@
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
+
         for (index, oid_result) in revwalk.enumerate() {
             let oid = oid_result?;
             let commit = repo.find_commit(oid)?;
             let parent_ids = commit.parent_ids().collect();
+
             indices.insert(oid, index);
             commits.push(CommitInfo {
                 id: oid,
                 parent_ids,
+                parents: Vec::new(),
+                children: Vec::new(),
                 branches: Vec::new(),
                 branch_trace: None,
             });
@@ -54,8 +65,12 @@
             branches: Vec::new(),
         };
 
+        assign_parent_indices(&mut graph.commits, &indices);
+        assign_children(&mut graph.commits);
+
         let branches = graph.assign_branches(&indices, settings)?;
         graph.branches = branches;
+
         assign_branch_columns(&graph.commits, &mut graph.branches, settings);
 
         Ok(graph)
@@ -71,7 +86,7 @@
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, indices, &mut info, branch_index);
+            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -98,6 +113,49 @@
     }
 }
 
+fn extract_branches(
+    repo: &Repository,
+    indices: &HashMap<Oid, usize>,
+    settings: &Settings,
+) -> Result<Vec<BranchInfo>, git2::Error> {
+    let mut branches = Vec::new();
+
+    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
+        let mut iter = repo.branches(Some(branch_type))?;
+        while let Some(branch_result) = iter.next() {
+            let (branch, _) = branch_result?;
+            branches.push((branch, branch_type));
+        }
+        Ok(())
+    };
+
+    push_branches(BranchType::Local)?;
+
+    if settings.include_remote {
+        push_branches(BranchType::Remote)?;
+    }
+
+    let mut branch_infos = branches
+        .into_iter()
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
+        .collect::<Vec<_>>();
+
+    branch_infos.sort_by(|left, right| {
+        left.visual
+            .order_group
+            .cmp(&right.visual.order_group)
+            .then(
+                branch_persistence(&left.name, &settings.branches)
+                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+            )
+            .then(left.name.cmp(&right.name))
+    });
+
+    Ok(branch_infos)
+}
+
 fn branch_info(
     branch: Branch,
     branch_type: BranchType,
@@ -111,19 +169,34 @@
     let target_index = indices.get(&target).copied()?;
     let short_name = branch_short_name(name, branch_type);
     let order_group = branch_order(short_name, settings);
+    let color_group = branch_color(short_name, settings);
 
     Some(BranchInfo {
         name: short_name.to_string(),
         target,
         target_index,
         is_remote: branch_type == BranchType::Remote,
-        order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
-        column: None,
+        visual: BranchVis {
+            order_group,
+            color_group,
+            column: None,
+        },
     })
 }
 
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
+}
+
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
     let name = normalized_branch_name(name);
     settings
@@ -144,105 +217,90 @@
         .unwrap_or(settings.order.len())
 }
 
+fn branch_color(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
+    settings
+        .color
+        .iter()
+        .enumerate()
+        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
+        .map(|(index, _)| index)
+        .unwrap_or(settings.color.len())
+}
+
 fn normalized_branch_name(name: &str) -> &str {
     name.strip_prefix("origin/").unwrap_or(name)
 }
 
-fn extract_branches(
-    repo: &Repository,
-    indices: &HashMap<Oid, usize>,
-    settings: &Settings,
-) -> Result<Vec<BranchInfo>, git2::Error> {
-    let mut branches = Vec::new();
-
-    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
-        let mut iter = repo.branches(Some(branch_type))?;
-        while let Some(branch_result) = iter.next() {
-            let (branch, _) = branch_result?;
-            branches.push((branch, branch_type));
+fn assign_parent_indices(commits: &mut [CommitInfo], indices: &HashMap<Oid, usize>) {
+    for info in commits.iter_mut() {
+        info.parents.clear();
+        for oid in &info.parent_ids {
+            if let Some(index) = indices.get(oid) {
+                info.parents.push(*index);
+            }
         }
-        Ok(())
-    };
+    }
+}
 
-    push_branches(BranchType::Local)?;
-
-    if settings.include_remote {
-        push_branches(BranchType::Remote)?;
+fn assign_children(commits: &mut [CommitInfo]) {
+    for commit in commits.iter_mut() {
+        commit.children.clear();
     }
 
-    let mut branch_infos = branches
-        .into_iter()
-        .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
-        })
-        .collect::<Vec<_>>();
-
-    branch_infos.sort_by(|left, right| {
-        left.order_group
-            .cmp(&right.order_group)
-            .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
-            )
-            .then(left.name.cmp(&right.name))
-    });
-
-    Ok(branch_infos)
-}
-
-fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
-    match branch_type {
-        BranchType::Local => reference_name
-            .strip_prefix("refs/heads/")
-            .unwrap_or(reference_name),
-        BranchType::Remote => reference_name
-            .strip_prefix("refs/remotes/")
-            .unwrap_or(reference_name),
+    for child_index in 0..commits.len() {
+        for &parent_index in &commits[child_index].parents {
+            if let Some(parent) = commits.get_mut(parent_index) {
+                parent.children.push(child_index);
+            }
+        }
     }
 }
 
-fn trace_branch(
-    commits: &mut [CommitInfo],
-    indices: &HashMap<Oid, usize>,
-    branch: &mut BranchInfo,
-    branch_index: usize,
-) -> bool {
+fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
-    let mut range_end = branch.target_index;
+    let mut range_tail = branch.target_index;
     let mut range_valid = true;
+    let mut previous = None;
+    let mut merge_anchor = None;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
             Some(trace) if trace == branch_index => break,
-            Some(_) => {}
+            Some(_) => {
+                if let Some(child_index) = previous {
+                    merge_anchor =
+                        merge_anchor.or_else(|| merge_start(commits, index, child_index));
+                }
+                break;
+            }
             None => {
                 commits[index].branch_trace = Some(branch_index);
                 any_assigned = true;
-                range_end = index;
+                range_tail = index;
             }
         }
 
-        let parent_index = commits[index]
-            .parent_ids
-            .iter()
-            .filter_map(|oid| indices.get(oid))
-            .copied()
-            .next();
+        let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
-            if parent_index < range_end {
-                // Jumping forward indicates a non-contiguous range; skip column assignment.
+            if parent_index < range_tail {
                 range_valid = false;
                 break;
             }
         }
 
+        previous = Some(index);
         current = parent_index;
     }
 
     if any_assigned && range_valid {
-        branch.range = Some((range_end, branch.target_index));
+        let mut start = range_tail;
+        if let Some(anchor) = merge_anchor {
+            start = start.max(anchor);
+        }
+        branch.range = Some((start, branch.target_index));
     } else {
         branch.range = None;
     }
@@ -250,6 +308,20 @@
     any_assigned
 }
 
+fn merge_start(commits: &[CommitInfo], parent_index: usize, child_index: usize) -> Option<usize> {
+    let children = commits
+        .get(parent_index)
+        .map(|info| info.children.as_slice())
+        .unwrap_or(&[]);
+
+    if children.len() <= 1 {
+        return None;
+    }
+
+    let anchor = children.iter().copied().max()?;
+    Some(anchor.max(child_index))
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
@@ -259,14 +331,20 @@
         return;
     }
 
+    for branch in branches.iter_mut() {
+        branch.visual.column = None;
+    }
+
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
         if branch.range.is_none() {
             continue;
         }
 
-        // Group index may exceed configured order length; keep as-is for stable layout.
-        groups.entry(branch.order_group).or_default().push(index);
+        groups
+            .entry(branch.visual.order_group)
+            .or_default()
+            .push(index);
     }
 
     let mut offset = 0;
@@ -312,7 +390,7 @@
         let group_width = occupied.len();
 
         for (branch_index, column) in assignments {
-            branches[branch_index].column = Some(column + offset);
+            branches[branch_index].visual.column = Some(column + offset);
         }
 
         offset += group_width;
diff --git a/src/main.rs b/src/main.rs
index 6e320e9bd9209afaaf06b86efe9caf12162a0a09..c2a6f05ed62b7ed7fffade0517a99a78b99f6f72
--- a/src/main.rs
+++ b/src/main.rs
@@ -24,9 +24,12 @@
     let commit = graph.commit(info)?;
 
     let symbol = if commit.parent_count() > 1 { "o" } else { "*" };
+    let merge_marker = if commit.parent_count() > 1 { 'M' } else { '.' };
     let short_id = short_id(commit.id());
     let indent = commit_indent(graph, info);
 
+    let (column, span) = branch_metrics(graph, info);
+
     let branch_details = info
         .branches
         .iter()
@@ -40,9 +43,9 @@
     };
 
     let summary = commit.summary().unwrap_or("---");
-    println!(
-        "{}{} {}{} {}",
-        indent, symbol, short_id, branch_str, summary
+    eprintln!(
+        "{}{}{} {} [{} | {}]{} {}",
+        indent, merge_marker, symbol, short_id, column, span, branch_str, summary
     );
 
     Ok(())
@@ -53,24 +56,33 @@
     let indent = indent_for_branch(branch);
 
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column = branch.column.unwrap_or(99);
+    let column = branch
+        .visual
+        .column
+        .map(|value| value.to_string())
+        .unwrap_or_else(|| "-".to_string());
+    let range = format_range(branch.range);
 
     format!(
-        "{}{} (col {}){}",
-        indent, branch.name, column, deleted_suffix
+        "{}{} (col {} | range {} | color {}){}",
+        indent, branch.name, column, range, branch.visual.color_group, deleted_suffix
     )
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {
     info.branch_trace
         .and_then(|index| graph.branches().get(index))
-        .and_then(|branch| branch.column)
+        .and_then(|branch| branch.visual.column)
         .map(indent_for_column)
         .unwrap_or_default()
 }
 
 fn indent_for_branch(branch: &BranchInfo) -> String {
-    branch.column.map(indent_for_column).unwrap_or_default()
+    branch
+        .visual
+        .column
+        .map(indent_for_column)
+        .unwrap_or_default()
 }
 
 fn indent_for_column(column: usize) -> String {
@@ -83,3 +95,23 @@
     id.truncate(7);
     id
 }
+
+fn branch_metrics(graph: &GitGraph, info: &CommitInfo) -> (String, String) {
+    info.branch_trace
+        .and_then(|index| graph.branches().get(index))
+        .map(|branch| {
+            let column = branch
+                .visual
+                .column
+                .map(|value| value.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            (column, format_range(branch.range))
+        })
+        .unwrap_or_else(|| ("-".to_string(), "-".to_string()))
+}
+
+fn format_range(range: Option<(usize, usize)>) -> String {
+    range
+        .map(|(start, end)| format!("{}..{}", start.min(end), start.max(end)))
+        .unwrap_or_else(|| "-".to_string())
+}
diff --git a/src/settings.rs b/src/settings.rs
index b25f1cec3dcfa4d21a1a1d4571e99379ec987969..77f4ff5ce72584c8bd6069341bab631d0ab1ebc6
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -26,6 +26,8 @@
     pub persistence: Vec<&'static str>,
     /// Branch grouping order used for indentation.
     pub order: Vec<Vec<&'static str>>,
+    /// Branch color group prefixes, used to map branches to palette slots.
+    pub color: Vec<Vec<&'static str>>,
 }
 
 impl Default for BranchSettings {
@@ -46,6 +48,14 @@
                 vec!["release", "hotfix"],
                 vec!["feature", "bugfix"],
             ],
+            color: vec![
+                vec!["master", "main"],
+                vec!["develop", "dev"],
+                vec!["release"],
+                vec!["hotfix"],
+                vec!["feature"],
+                vec!["bugfix"],
+            ],
         }
     }
 }


[2025-09-21T12:28:19] thinking

**Preparing final summary with replication details**

I’m organizing the final message to include a clear replication explanation with bullets detailing file changes and code references, noting the build failure due to network issues, and mentioning assumptions made during the work; I'll also add verifying information and a natural next step to rerun the build when the network is back.
[2025-09-21T12:28:20] codex

**复现说明**
- 重建图构建核心：引入 `BranchVis` 并在 `trace_branch` 中结合 `assign_children` 处理合并截断，确保列区间与合并逻辑符合报告中的架构图与流程描述（`src/graph.rs:14`, `src/graph.rs:235`, `src/graph.rs:260`）。
- 列分配改为基于 `visual.order_group` 并清理列缓存，同时映射颜色分组，呼应 “列修复与结构调整”“颜色分配” 的说明（`src/graph.rs:325`, `src/graph.rs:338`）。
- 调整 CLI 输出来展示列、区间与合并标记，改用 STDERR 输出便于调试，匹配报告中的可观测性要求（`src/main.rs:23`, `src/main.rs:45`）。
- 为 `branches.color` 新增默认配置，以 git-flow 前缀推断颜色组，源自报告的配置新增说明（`src/settings.rs:24`, `src/settings.rs:41`）。
- 假设颜色组与顺序接近；若需精确色表可据原仓库配置替换。`cargo build` 因受限网络无法拉取 crates 而未完成，请在网络可用时重试验证。
[2025-09-21T12:28:24] tokens used: 133,978
[2025-09-21T12:28:24] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 982924ca97e4ce3ef4764cbf2ccc4d1bd4122343..d440daef0ddc990bb7d87ea5a4004926dbd7f28b
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,19 +5,26 @@
 pub struct CommitInfo {
     pub id: Oid,
     pub parent_ids: Vec<Oid>,
+    pub parents: Vec<usize>,
+    pub children: Vec<usize>,
     pub branches: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
+pub struct BranchVis {
+    pub order_group: usize,
+    pub color_group: usize,
+    pub column: Option<usize>,
+}
+
 pub struct BranchInfo {
     pub name: String,
     pub target: Oid,
     pub target_index: usize,
     pub is_remote: bool,
-    pub order_group: usize,
     pub range: Option<(usize, usize)>,
     pub deleted: bool,
-    pub column: Option<usize>,
+    pub visual: BranchVis,
 }
 
 pub struct GitGraph {
@@ -35,14 +42,18 @@
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
+
         for (index, oid_result) in revwalk.enumerate() {
             let oid = oid_result?;
             let commit = repo.find_commit(oid)?;
             let parent_ids = commit.parent_ids().collect();
+
             indices.insert(oid, index);
             commits.push(CommitInfo {
                 id: oid,
                 parent_ids,
+                parents: Vec::new(),
+                children: Vec::new(),
                 branches: Vec::new(),
                 branch_trace: None,
             });
@@ -54,8 +65,12 @@
             branches: Vec::new(),
         };
 
+        assign_parent_indices(&mut graph.commits, &indices);
+        assign_children(&mut graph.commits);
+
         let branches = graph.assign_branches(&indices, settings)?;
         graph.branches = branches;
+
         assign_branch_columns(&graph.commits, &mut graph.branches, settings);
 
         Ok(graph)
@@ -71,7 +86,7 @@
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, indices, &mut info, branch_index);
+            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -98,6 +113,49 @@
     }
 }
 
+fn extract_branches(
+    repo: &Repository,
+    indices: &HashMap<Oid, usize>,
+    settings: &Settings,
+) -> Result<Vec<BranchInfo>, git2::Error> {
+    let mut branches = Vec::new();
+
+    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
+        let mut iter = repo.branches(Some(branch_type))?;
+        while let Some(branch_result) = iter.next() {
+            let (branch, _) = branch_result?;
+            branches.push((branch, branch_type));
+        }
+        Ok(())
+    };
+
+    push_branches(BranchType::Local)?;
+
+    if settings.include_remote {
+        push_branches(BranchType::Remote)?;
+    }
+
+    let mut branch_infos = branches
+        .into_iter()
+        .filter_map(|(branch, branch_type)| {
+            branch_info(branch, branch_type, indices, &settings.branches)
+        })
+        .collect::<Vec<_>>();
+
+    branch_infos.sort_by(|left, right| {
+        left.visual
+            .order_group
+            .cmp(&right.visual.order_group)
+            .then(
+                branch_persistence(&left.name, &settings.branches)
+                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+            )
+            .then(left.name.cmp(&right.name))
+    });
+
+    Ok(branch_infos)
+}
+
 fn branch_info(
     branch: Branch,
     branch_type: BranchType,
@@ -111,19 +169,34 @@
     let target_index = indices.get(&target).copied()?;
     let short_name = branch_short_name(name, branch_type);
     let order_group = branch_order(short_name, settings);
+    let color_group = branch_color(short_name, settings);
 
     Some(BranchInfo {
         name: short_name.to_string(),
         target,
         target_index,
         is_remote: branch_type == BranchType::Remote,
-        order_group,
         range: None,
         deleted: false, // TODO(013-3091f5b): detect deleted branches once the report provides criteria.
-        column: None,
+        visual: BranchVis {
+            order_group,
+            color_group,
+            column: None,
+        },
     })
 }
 
+fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
+    match branch_type {
+        BranchType::Local => reference_name
+            .strip_prefix("refs/heads/")
+            .unwrap_or(reference_name),
+        BranchType::Remote => reference_name
+            .strip_prefix("refs/remotes/")
+            .unwrap_or(reference_name),
+    }
+}
+
 fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
     let name = normalized_branch_name(name);
     settings
@@ -144,105 +217,90 @@
         .unwrap_or(settings.order.len())
 }
 
+fn branch_color(name: &str, settings: &BranchSettings) -> usize {
+    let name = normalized_branch_name(name);
+    settings
+        .color
+        .iter()
+        .enumerate()
+        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
+        .map(|(index, _)| index)
+        .unwrap_or(settings.color.len())
+}
+
 fn normalized_branch_name(name: &str) -> &str {
     name.strip_prefix("origin/").unwrap_or(name)
 }
 
-fn extract_branches(
-    repo: &Repository,
-    indices: &HashMap<Oid, usize>,
-    settings: &Settings,
-) -> Result<Vec<BranchInfo>, git2::Error> {
-    let mut branches = Vec::new();
-
-    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
-        let mut iter = repo.branches(Some(branch_type))?;
-        while let Some(branch_result) = iter.next() {
-            let (branch, _) = branch_result?;
-            branches.push((branch, branch_type));
+fn assign_parent_indices(commits: &mut [CommitInfo], indices: &HashMap<Oid, usize>) {
+    for info in commits.iter_mut() {
+        info.parents.clear();
+        for oid in &info.parent_ids {
+            if let Some(index) = indices.get(oid) {
+                info.parents.push(*index);
+            }
         }
-        Ok(())
-    };
+    }
+}
 
-    push_branches(BranchType::Local)?;
-
-    if settings.include_remote {
-        push_branches(BranchType::Remote)?;
+fn assign_children(commits: &mut [CommitInfo]) {
+    for commit in commits.iter_mut() {
+        commit.children.clear();
     }
 
-    let mut branch_infos = branches
-        .into_iter()
-        .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
-        })
-        .collect::<Vec<_>>();
-
-    branch_infos.sort_by(|left, right| {
-        left.order_group
-            .cmp(&right.order_group)
-            .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
-            )
-            .then(left.name.cmp(&right.name))
-    });
-
-    Ok(branch_infos)
-}
-
-fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
-    match branch_type {
-        BranchType::Local => reference_name
-            .strip_prefix("refs/heads/")
-            .unwrap_or(reference_name),
-        BranchType::Remote => reference_name
-            .strip_prefix("refs/remotes/")
-            .unwrap_or(reference_name),
+    for child_index in 0..commits.len() {
+        for &parent_index in &commits[child_index].parents {
+            if let Some(parent) = commits.get_mut(parent_index) {
+                parent.children.push(child_index);
+            }
+        }
     }
 }
 
-fn trace_branch(
-    commits: &mut [CommitInfo],
-    indices: &HashMap<Oid, usize>,
-    branch: &mut BranchInfo,
-    branch_index: usize,
-) -> bool {
+fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
-    let mut range_end = branch.target_index;
+    let mut range_tail = branch.target_index;
     let mut range_valid = true;
+    let mut previous = None;
+    let mut merge_anchor = None;
 
     while let Some(index) = current {
         match commits[index].branch_trace {
             Some(trace) if trace == branch_index => break,
-            Some(_) => {}
+            Some(_) => {
+                if let Some(child_index) = previous {
+                    merge_anchor =
+                        merge_anchor.or_else(|| merge_start(commits, index, child_index));
+                }
+                break;
+            }
             None => {
                 commits[index].branch_trace = Some(branch_index);
                 any_assigned = true;
-                range_end = index;
+                range_tail = index;
             }
         }
 
-        let parent_index = commits[index]
-            .parent_ids
-            .iter()
-            .filter_map(|oid| indices.get(oid))
-            .copied()
-            .next();
+        let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
-            if parent_index < range_end {
-                // Jumping forward indicates a non-contiguous range; skip column assignment.
+            if parent_index < range_tail {
                 range_valid = false;
                 break;
             }
         }
 
+        previous = Some(index);
         current = parent_index;
     }
 
     if any_assigned && range_valid {
-        branch.range = Some((range_end, branch.target_index));
+        let mut start = range_tail;
+        if let Some(anchor) = merge_anchor {
+            start = start.max(anchor);
+        }
+        branch.range = Some((start, branch.target_index));
     } else {
         branch.range = None;
     }
@@ -250,6 +308,20 @@
     any_assigned
 }
 
+fn merge_start(commits: &[CommitInfo], parent_index: usize, child_index: usize) -> Option<usize> {
+    let children = commits
+        .get(parent_index)
+        .map(|info| info.children.as_slice())
+        .unwrap_or(&[]);
+
+    if children.len() <= 1 {
+        return None;
+    }
+
+    let anchor = children.iter().copied().max()?;
+    Some(anchor.max(child_index))
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
@@ -259,14 +331,20 @@
         return;
     }
 
+    for branch in branches.iter_mut() {
+        branch.visual.column = None;
+    }
+
     let mut groups: BTreeMap<usize, Vec<usize>> = BTreeMap::new();
     for (index, branch) in branches.iter().enumerate() {
         if branch.range.is_none() {
             continue;
         }
 
-        // Group index may exceed configured order length; keep as-is for stable layout.
-        groups.entry(branch.order_group).or_default().push(index);
+        groups
+            .entry(branch.visual.order_group)
+            .or_default()
+            .push(index);
     }
 
     let mut offset = 0;
@@ -312,7 +390,7 @@
         let group_width = occupied.len();
 
         for (branch_index, column) in assignments {
-            branches[branch_index].column = Some(column + offset);
+            branches[branch_index].visual.column = Some(column + offset);
         }
 
         offset += group_width;
diff --git a/src/main.rs b/src/main.rs
index 6e320e9bd9209afaaf06b86efe9caf12162a0a09..c2a6f05ed62b7ed7fffade0517a99a78b99f6f72
--- a/src/main.rs
+++ b/src/main.rs
@@ -24,9 +24,12 @@
     let commit = graph.commit(info)?;
 
     let symbol = if commit.parent_count() > 1 { "o" } else { "*" };
+    let merge_marker = if commit.parent_count() > 1 { 'M' } else { '.' };
     let short_id = short_id(commit.id());
     let indent = commit_indent(graph, info);
 
+    let (column, span) = branch_metrics(graph, info);
+
     let branch_details = info
         .branches
         .iter()
@@ -40,9 +43,9 @@
     };
 
     let summary = commit.summary().unwrap_or("---");
-    println!(
-        "{}{} {}{} {}",
-        indent, symbol, short_id, branch_str, summary
+    eprintln!(
+        "{}{}{} {} [{} | {}]{} {}",
+        indent, merge_marker, symbol, short_id, column, span, branch_str, summary
     );
 
     Ok(())
@@ -53,24 +56,33 @@
     let indent = indent_for_branch(branch);
 
     let deleted_suffix = if branch.deleted { " (deleted)" } else { "" };
-    let column = branch.column.unwrap_or(99);
+    let column = branch
+        .visual
+        .column
+        .map(|value| value.to_string())
+        .unwrap_or_else(|| "-".to_string());
+    let range = format_range(branch.range);
 
     format!(
-        "{}{} (col {}){}",
-        indent, branch.name, column, deleted_suffix
+        "{}{} (col {} | range {} | color {}){}",
+        indent, branch.name, column, range, branch.visual.color_group, deleted_suffix
     )
 }
 
 fn commit_indent(graph: &GitGraph, info: &CommitInfo) -> String {
     info.branch_trace
         .and_then(|index| graph.branches().get(index))
-        .and_then(|branch| branch.column)
+        .and_then(|branch| branch.visual.column)
         .map(indent_for_column)
         .unwrap_or_default()
 }
 
 fn indent_for_branch(branch: &BranchInfo) -> String {
-    branch.column.map(indent_for_column).unwrap_or_default()
+    branch
+        .visual
+        .column
+        .map(indent_for_column)
+        .unwrap_or_default()
 }
 
 fn indent_for_column(column: usize) -> String {
@@ -83,3 +95,23 @@
     id.truncate(7);
     id
 }
+
+fn branch_metrics(graph: &GitGraph, info: &CommitInfo) -> (String, String) {
+    info.branch_trace
+        .and_then(|index| graph.branches().get(index))
+        .map(|branch| {
+            let column = branch
+                .visual
+                .column
+                .map(|value| value.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            (column, format_range(branch.range))
+        })
+        .unwrap_or_else(|| ("-".to_string(), "-".to_string()))
+}
+
+fn format_range(range: Option<(usize, usize)>) -> String {
+    range
+        .map(|(start, end)| format!("{}..{}", start.min(end), start.max(end)))
+        .unwrap_or_else(|| "-".to_string())
+}
diff --git a/src/settings.rs b/src/settings.rs
index b25f1cec3dcfa4d21a1a1d4571e99379ec987969..77f4ff5ce72584c8bd6069341bab631d0ab1ebc6
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -26,6 +26,8 @@
     pub persistence: Vec<&'static str>,
     /// Branch grouping order used for indentation.
     pub order: Vec<Vec<&'static str>>,
+    /// Branch color group prefixes, used to map branches to palette slots.
+    pub color: Vec<Vec<&'static str>>,
 }
 
 impl Default for BranchSettings {
@@ -46,6 +48,14 @@
                 vec!["release", "hotfix"],
                 vec!["feature", "bugfix"],
             ],
+            color: vec![
+                vec!["master", "main"],
+                vec!["develop", "dev"],
+                vec!["release"],
+                vec!["hotfix"],
+                vec!["feature"],
+                vec!["bugfix"],
+            ],
         }
     }
 }


=== 错误 ===
2025-09-21T12:19:39.770709Z ERROR codex_core::exec: exec error: No such file or directory (os error 2)

=== 最终状态 ===
返回码: 0
状态: ✅ 执行成功
