=== 任务 019-854edee 执行日志 ===
时间: 2025-09-21 20:57:20.665979
Prompt:
请在 .workspace 内，依据 .workspace/todolist/todolist-019-854edee.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/019-854edee/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："019-854edee：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 019-854edee

=== 输出 ===
[2025-09-21T12:43:51] OpenAI Codex v0.39.0 (research preview)
--------
workdir: /Users/jqwang/104-CommitLens-codex/.workspace
model: gpt-5-codex-high
provider: codex
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
--------
[2025-09-21T12:43:51] User instructions:
请在 .workspace 内，依据 .workspace/todolist/todolist-019-854edee.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/019-854edee/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："019-854edee：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 019-854edee

[2025-09-21T12:43:55] thinking

**Checking workspace directory contents**
[2025-09-21T12:43:56] exec bash -lc 'ls -la' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T12:43:56] bash -lc 'ls -la' succeeded in 15ms:
total 8216
drwxr-xr-x@  9 jqwang  staff      288 Sep 21 15:57 .
drwxr-xr-x@ 29 jqwang  staff      928 Sep 21 07:49 ..
-rw-r--r--@  1 jqwang  staff        0 Sep 21 20:43 codex_error.txt
-rw-r--r--@  1 jqwang  staff  3819427 Sep 21 20:43 codex_output.txt
-rw-r--r--@  1 jqwang  staff        7 Sep 21 20:43 codex_status.txt
drwxr-xr-x@ 22 jqwang  staff      704 Sep 21 19:31 logs
drwxr-xr-x@ 12 jqwang  staff      384 Sep 21 19:41 rust-project
-rw-r--r--@  1 jqwang  staff      459 Sep 21 20:43 task_status.json
drwxr-xr-x@  5 jqwang  staff      160 Sep 21 20:43 todolist
[2025-09-21T12:43:56] tokens used: 856

[2025-09-21T12:44:01] thinking

**Opening and planning from .tex file**
[2025-09-21T12:44:01] exec bash -lc "sed -n '1,160p' todolist/todolist-019-854edee.tex" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T12:44:01] bash -lc "sed -n '1,160p' todolist/todolist-019-854edee.tex" succeeded in 18ms:
\section{提交考古：019-854edee}

\subsection*{Commit 元信息}
\begin{itemize}
  \item 标题：restructured settings, moved things to settings, added doc stings
  % Escape underscores in email to avoid LaTeX math-mode errors
  \item 作者：Martin Lange <\texttt{martin\_lange\_@gmx.net}>
  \item 日期：2020-12-21T23:46:57+01:00
\end{itemize}

\subsection*{变更摘要（阅读提示）}
\begin{verbatim}
HEAD:   7 files changed, 175 insertions(+), 164 deletions(-)
HEAD-1: 2 files changed, 118 insertions(+), 66 deletions(-)
HEAD-2: 6 files changed, 212 insertions(+)
\end{verbatim}

\subsection*{差异解读（证据）}
\begin{itemize}
  \item 改了什么：重构 \texttt{settings} 模块，新增 \texttt{Settings\{debug, branches, merge\_patterns\}}，将 \texttt{BranchSettings::git\_flow()} 移入 impl，并新增 \texttt{color\_unknown} 字段；统一引入 \texttt{MergePatterns} 替代原先 \texttt{lazy\_static} 正则常量（见 head/src/settings.rs:L4-L11, L63-L86；head/src/text.rs:L1-L12）。
[2025-09-21T12:44:01] tokens used: 4,560

[2025-09-21T12:44:04] thinking

**Continuing file exploration**
[2025-09-21T12:44:06] exec bash -lc "sed -n '160,320p' todolist/todolist-019-854edee.tex" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T12:44:06] bash -lc "sed -n '160,320p' todolist/todolist-019-854edee.tex" succeeded in 13ms:

[2025-09-21T12:44:06] tokens used: 6,565

[2025-09-21T12:44:10] thinking

**Planning code reconstruction from HEAD**
[2025-09-21T12:44:11] exec bash -lc 'ls -la' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:44:11] bash -lc 'ls -la' succeeded in 19ms:
total 72
drwxr-xr-x@ 12 jqwang  staff    384 Sep 21 19:41 .
drwxr-xr-x@  9 jqwang  staff    288 Sep 21 15:57 ..
drwxr-xr-x@ 12 jqwang  staff    384 Sep 21 20:43 .git
-rw-r--r--@  1 jqwang  staff     19 Sep 21 16:00 .gitignore
-rw-r--r--@  1 jqwang  staff    393 Sep 21 16:25 .travis.yml
-rw-r--r--@  1 jqwang  staff  15452 Sep 21 20:34 Cargo.lock
-rw-r--r--@  1 jqwang  staff    305 Sep 21 20:31 Cargo.toml
-rw-r--r--@  1 jqwang  staff    109 Sep 21 16:21 LICENSE
-rw-r--r--@  1 jqwang  staff    601 Sep 21 16:22 README.md
drwxr-xr-x@  3 jqwang  staff     96 Sep 21 16:01 scripts
drwxr-xr-x@  8 jqwang  staff    256 Sep 21 20:31 src
drwxr-xr-x@  5 jqwang  staff    160 Sep 21 16:01 target
[2025-09-21T12:44:11] tokens used: 10,024

[2025-09-21T12:44:13] thinking

**Inspecting source directory**
[2025-09-21T12:44:13] exec bash -lc 'find src -maxdepth 2 -type f' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:44:13] bash -lc 'find src -maxdepth 2 -type f' succeeded in 21ms:
src/graph.rs
src/lib.rs
src/print/mod.rs
src/print/svg.rs
src/main.rs
src/text.rs
src/settings.rs
[2025-09-21T12:44:13] tokens used: 10,587

[2025-09-21T12:44:19] thinking

**Outlining update plan**
[2025-09-21T12:44:19] exec bash -lc "sed -n '1,200p' src/settings.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:44:19] bash -lc "sed -n '1,200p' src/settings.rs" succeeded in 10ms:
#[derive(Debug)]
pub struct Settings {
    pub include_remote: bool,
    pub branches: BranchSettings,
}

impl Default for Settings {
    fn default() -> Self {
        Self::git_flow()
    }
}

impl Settings {
    /// Returns settings tuned for the conventional git-flow branch layout.
    pub fn git_flow() -> Self {
        Self {
            include_remote: true,
            branches: BranchSettings::git_flow(),
        }
    }
[2025-09-21T12:44:19] tokens used: 14,701

[2025-09-21T12:44:21] thinking

**Planning settings restructuring**
[2025-09-21T12:44:21] exec bash -lc "sed -n '1,200p' src/text.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:44:21] bash -lc "sed -n '1,200p' src/text.rs" succeeded in 13ms:
use lazy_static::lazy_static;
use regex::Regex;

lazy_static! {
    static ref MERGE_GITLAB: Regex =
        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
    static ref MERGE_GIT_DEFAULT: Regex =
        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
    static ref MERGE_GIT_SOURCE_ONLY: Regex =
        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
    static ref MERGE_GITHUB: Regex =
        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
    static ref MERGE_BITBUCKET: Regex =
        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
}

pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
    let summary = summary.trim();

    if let Some(captures) = MERGE_GITLAB.captures(summary) {
[2025-09-21T12:44:21] tokens used: 16,170

[2025-09-21T12:44:23] thinking

**Reviewing key source files**
[2025-09-21T12:44:24] exec bash -lc "sed -n '1,200p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:44:24] bash -lc "sed -n '1,200p' src/graph.rs" succeeded in 7ms:
use crate::settings::{BranchSettings, Settings};
use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
use std::collections::{BTreeMap, HashMap};

pub struct CommitInfo {
    pub id: Oid,
    pub parent_ids: Vec<Oid>,
    pub parents: Vec<usize>,
    pub children: Vec<usize>,
    pub branches: Vec<usize>,
    pub branch_trace: Option<usize>,
}

pub struct BranchVis {
    pub order_group: usize,
    pub color_group: usize,
    pub column: Option<usize>,
}

pub struct BranchInfo {
[2025-09-21T12:44:24] tokens used: 18,125

[2025-09-21T12:44:25] thinking

**Continuing work**
[2025-09-21T12:44:25] exec bash -lc "sed -n '200,400p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:44:25] bash -lc "sed -n '200,400p' src/graph.rs" succeeded in 10ms:
        })
        .collect::<Vec<_>>();

    branch_infos.sort_by(|left, right| {
        left.visual
            .order_group
            .cmp(&right.visual.order_group)
            .then(
                branch_persistence(&left.name, &settings.branches)
                    .cmp(&branch_persistence(&right.name, &settings.branches)),
            )
            .then(left.name.cmp(&right.name))
    });

    Ok(branch_infos)
}

fn branch_info(
    branch: Branch,
    branch_type: BranchType,
[2025-09-21T12:44:25] tokens used: 19,819

[2025-09-21T12:44:28] thinking

**Continuing exploration**
[2025-09-21T12:44:29] exec bash -lc "sed -n '400,800p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:44:29] bash -lc "sed -n '400,800p' src/graph.rs" succeeded in 17ms:
        }

        groups
            .entry(branch.visual.order_group)
            .or_default()
            .push(index);
    }

    let mut offset = 0;
    for (_group, mut indices) in groups.into_iter() {
        indices.sort_by(|left, right| {
            let left_branch = &branches[*left];
            let right_branch = &branches[*right];
            let (left_start, left_end) = branch_interval(left_branch);
            let (right_start, right_end) = branch_interval(right_branch);

            left_start
                .cmp(&right_start)
                .then(left_end.cmp(&right_end))
                .then(left_branch.name.cmp(&right_branch.name))
[2025-09-21T12:44:29] tokens used: 24,911

[2025-09-21T12:44:32] thinking

**Reviewing SVG module for redesign**
[2025-09-21T12:44:32] exec bash -lc "sed -n '1,200p' src/print/svg.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:44:32] bash -lc "sed -n '1,200p' src/print/svg.rs" succeeded in 22ms:
use crate::{
    graph::{BranchInfo, CommitInfo, GitGraph},
    settings::BranchSettings,
};
use svg::node::element::path::Data;
use svg::node::element::{Circle, Group, Line, Path, Text};
use svg::node::Text as TextNode;
use svg::Document;

const COLUMN_STEP: f64 = 15.0;
const ROW_STEP: f64 = 15.0;
const NODE_RADIUS: f64 = 3.0;
const STROKE_WIDTH: f64 = 1.5;
const MERGE_STROKE_WIDTH: f64 = 2.5;
const DEBUG_FONT_SIZE: i32 = 7;

const BRANCH_COLORS: [&str; 8] = [
    "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
];

[2025-09-21T12:44:32] tokens used: 29,936

[2025-09-21T12:44:35] thinking

**Updating usage to new settings**
[2025-09-21T12:44:35] exec bash -lc "sed -n '1,160p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:44:35] bash -lc "sed -n '1,160p' src/main.rs" succeeded in 9ms:
use git2::{Error, Oid};
use git_graph::{
    graph::{BranchInfo, CommitInfo, GitGraph},
    print::svg::print_svg,
    settings::Settings,
};
use itertools::Itertools;

fn main() -> Result<(), Error> {
    let settings = Settings::git_flow();
    run(".", &settings)
}

fn run(path: &str, settings: &Settings) -> Result<(), Error> {
    let graph = GitGraph::new(path, settings)?;

    for info in graph.commits() {
        print_commit_short(&graph, info)?;
    }

[2025-09-21T12:44:35] tokens used: 32,474

[2025-09-21T12:44:38] thinking

**Checking for impact on src/lib.rs**
[2025-09-21T12:44:39] exec bash -lc "sed -n '1,200p' src/lib.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:44:39] bash -lc "sed -n '1,200p' src/lib.rs" succeeded in 9ms:
pub mod graph;
pub mod print;
pub mod settings;
pub mod text;
[2025-09-21T12:44:39] tokens used: 33,683

[2025-09-21T12:44:41] thinking

**Checking module declaration**
[2025-09-21T12:44:42] exec bash -lc "sed -n '1,160p' src/print/mod.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:44:42] bash -lc "sed -n '1,160p' src/print/mod.rs" succeeded in 9ms:
pub mod svg;
[2025-09-21T12:44:42] tokens used: 39,128

[2025-09-21T12:45:07] thinking

**Reconstructing Settings and related modules**

I'm piecing together the final structure of `Settings` based on the report, which adds `debug`, `branches`, `merge_patterns`, and `color_unknown` fields. It looks like `color_unknown` belongs in `Settings` since it’s referenced directly there in SVG printing. I’m also noting that `MergePatterns` replaces previous lazy_static regex constants, likely holding compiled regex patterns, and that `parse_merge_summary` now returns an `Option<String>` using these patterns. The `graph` module’s branch extraction functions now accept `MergePatterns` too, so this all ties together in parsing and branch tracking logic. I’m aiming to build a coherent final design from these clues.
[2025-09-21T12:45:09] exec bash -lc "sed -n '240,360p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:45:09] bash -lc "sed -n '240,360p' src/graph.rs" succeeded in 14ms:
            order_group,
            color_group,
            column: None,
        },
    })
}

fn branch_short_name(reference_name: &str, branch_type: BranchType) -> &str {
    match branch_type {
        BranchType::Local => reference_name
            .strip_prefix("refs/heads/")
            .unwrap_or(reference_name),
        BranchType::Remote => reference_name
            .strip_prefix("refs/remotes/")
            .unwrap_or(reference_name),
    }
}

fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
    let name = normalized_branch_name(name);
[2025-09-21T12:45:09] tokens used: 44,037

[2025-09-21T12:45:28] thinking

**Analyzing merge parsing integration**
[2025-09-21T12:45:28] exec bash -lc 'rg "parse_merge_summary" -n' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:45:28] bash -lc 'rg "parse_merge_summary" -n' succeeded in 14ms:
src/text.rs:17:pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
src/text.rs:51:    use super::parse_merge_summary;
src/text.rs:55:        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
src/text.rs:62:        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
src/text.rs:69:        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
src/text.rs:76:        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
src/text.rs:83:        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
src/text.rs:90:        let (to, from) = parse_merge_summary("Regular commit message");
[2025-09-21T12:45:28] tokens used: 48,154

[2025-09-21T12:46:39] thinking

**Designing merge parsing integration**
**Integrating merge patterns in branch extraction**
[2025-09-21T12:46:40] codex
**Integrating merge patterns in branch extraction**
[2025-09-21T12:46:40] exec bash -lc 'rg "MergePatterns" -n ..' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T12:46:40] bash -lc 'rg "MergePatterns" -n ..' exited 1 in 12ms:

[2025-09-21T12:46:40] tokens used: 55,604

[2025-09-21T12:47:28] thinking

**Planning major Settings and graph.rs refactor**

I'm organizing a big update to introduce merge pattern support in Settings, update print_svg to use Settings for colors, and adjust graph.rs to accept new parameters for parsing merge summaries. I'll restructure settings.rs with a new MergePatterns type that compiles regexes, modify text.rs to use it for parsing, and gradually adapt graph.rs to integrate these patterns—although full usage is limited due to unavailable remote commits. I'll keep implementation aligned with best effort and plan TODOs for missing parts.
[2025-09-21T12:47:30] exec bash -lc "nl -ba src/graph.rs | sed -n '260,320p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:47:30] bash -lc "nl -ba src/graph.rs | sed -n '260,320p'" succeeded in 27ms:
   260	    settings
   261	        .persistence
   262	        .iter()
   263	        .position(|candidate| name.starts_with(candidate))
   264	        .unwrap_or(settings.persistence.len())
   265	}
   266	
   267	fn branch_order(name: &str, settings: &BranchSettings) -> usize {
   268	    let name = normalized_branch_name(name);
   269	    settings
   270	        .order
   271	        .iter()
   272	        .enumerate()
   273	        .find(|(_, prefixes)| prefixes.iter().any(|prefix| name.starts_with(prefix)))
   274	        .map(|(index, _)| index)
   275	        .unwrap_or(settings.order.len())
   276	}
   277	
   278	fn branch_color(name: &str, settings: &BranchSettings) -> usize {
   279	    let name = normalized_branch_name(name);
[2025-09-21T12:47:30] tokens used: 58,832

[2025-09-21T12:47:54] thinking

**Mapping new merge summary parsing**
[2025-09-21T12:47:55] apply_patch auto_approved=true:
D /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/settings.rs
#[derive(Debug)]
pub struct Settings {
    pub include_remote: bool,
    pub branches: BranchSettings,
}

impl Default for Settings {
    fn default() -> Self {
        Self::git_flow()
    }
}

impl Settings {
    /// Returns settings tuned for the conventional git-flow branch layout.
    pub fn git_flow() -> Self {
        Self {
            include_remote: true,
            branches: BranchSettings::git_flow(),
        }
    }
}

#[derive(Debug)]
pub struct BranchSettings {
    /// Known branch name prefixes ordered by persistence priority.
    pub persistence: Vec<&'static str>,
    /// Branch grouping order used for indentation.
    pub order: Vec<Vec<&'static str>>,
    /// Branch color group prefixes, used to map branches to palette slots.
    pub color: Vec<Vec<&'static str>>,
}

impl Default for BranchSettings {
    fn default() -> Self {
        Self::git_flow()
    }
}

impl BranchSettings {
    pub fn git_flow() -> Self {
        Self {
            persistence: vec![
                "master", "main", "develop", "dev", "feature", "release", "hotfix", "bugfix",
            ],
            order: vec![
                vec!["master", "main"],
                vec!["develop", "dev"],
                vec!["release", "hotfix"],
                vec!["feature", "bugfix"],
            ],
            color: vec![
                vec!["master", "main"],
                vec!["develop", "dev"],
                vec!["release"],
                vec!["hotfix"],
                vec!["feature"],
                vec!["bugfix"],
            ],
        }
    }
}
[2025-09-21T12:47:55] apply_patch(auto_approved=true) exited 0 in 14ms:
Success. Updated the following files:
D src/settings.rs
[2025-09-21T12:47:55] turn diff:
diff --git a/src/settings.rs b/src/settings.rs
deleted file mode 100644
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..0000000000000000000000000000000000000000
--- a/src/settings.rs
+++ /dev/null
@@ -1,61 +0,0 @@
-#[derive(Debug)]
-pub struct Settings {
-    pub include_remote: bool,
-    pub branches: BranchSettings,
-}
-
-impl Default for Settings {
-    fn default() -> Self {
-        Self::git_flow()
-    }
-}
-
-impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
-    pub fn git_flow() -> Self {
-        Self {
-            include_remote: true,
-            branches: BranchSettings::git_flow(),
-        }
-    }
-}
-
-#[derive(Debug)]
-pub struct BranchSettings {
-    /// Known branch name prefixes ordered by persistence priority.
-    pub persistence: Vec<&'static str>,
-    /// Branch grouping order used for indentation.
-    pub order: Vec<Vec<&'static str>>,
-    /// Branch color group prefixes, used to map branches to palette slots.
-    pub color: Vec<Vec<&'static str>>,
-}
-
-impl Default for BranchSettings {
-    fn default() -> Self {
-        Self::git_flow()
-    }
-}
-
-impl BranchSettings {
-    pub fn git_flow() -> Self {
-        Self {
-            persistence: vec![
-                "master", "main", "develop", "dev", "feature", "release", "hotfix", "bugfix",
-            ],
-            order: vec![
-                vec!["master", "main"],
-                vec!["develop", "dev"],
-                vec!["release", "hotfix"],
-                vec!["feature", "bugfix"],
-            ],
-            color: vec![
-                vec!["master", "main"],
-                vec!["develop", "dev"],
-                vec!["release"],
-                vec!["hotfix"],
-                vec!["feature"],
-                vec!["bugfix"],
-            ],
-        }
-    }
-}

[2025-09-21T12:47:55] tokens used: 69,217
[2025-09-21T12:47:55] turn diff:
diff --git a/src/settings.rs b/src/settings.rs
deleted file mode 100644
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..0000000000000000000000000000000000000000
--- a/src/settings.rs
+++ /dev/null
@@ -1,61 +0,0 @@
-#[derive(Debug)]
-pub struct Settings {
-    pub include_remote: bool,
-    pub branches: BranchSettings,
-}
-
-impl Default for Settings {
-    fn default() -> Self {
-        Self::git_flow()
-    }
-}
-
-impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
-    pub fn git_flow() -> Self {
-        Self {
-            include_remote: true,
-            branches: BranchSettings::git_flow(),
-        }
-    }
-}
-
-#[derive(Debug)]
-pub struct BranchSettings {
-    /// Known branch name prefixes ordered by persistence priority.
-    pub persistence: Vec<&'static str>,
-    /// Branch grouping order used for indentation.
-    pub order: Vec<Vec<&'static str>>,
-    /// Branch color group prefixes, used to map branches to palette slots.
-    pub color: Vec<Vec<&'static str>>,
-}
-
-impl Default for BranchSettings {
-    fn default() -> Self {
-        Self::git_flow()
-    }
-}
-
-impl BranchSettings {
-    pub fn git_flow() -> Self {
-        Self {
-            persistence: vec![
-                "master", "main", "develop", "dev", "feature", "release", "hotfix", "bugfix",
-            ],
-            order: vec![
-                vec!["master", "main"],
-                vec!["develop", "dev"],
-                vec!["release", "hotfix"],
-                vec!["feature", "bugfix"],
-            ],
-            color: vec![
-                vec!["master", "main"],
-                vec!["develop", "dev"],
-                vec!["release"],
-                vec!["hotfix"],
-                vec!["feature"],
-                vec!["bugfix"],
-            ],
-        }
-    }
-}


[2025-09-21T12:47:58] thinking

**Creating new file with content**
[2025-09-21T12:48:03] exec bash -lc "cat <<'EOF' > src/settings.rs
use regex::Regex;

#[derive(Debug)]
pub struct Settings {
    pub include_remote: bool,
    pub debug: bool,
    pub color_unknown: String,
    pub branches: BranchSettings,
    pub merge_patterns: MergePatterns,
}

impl Default for Settings {
    fn default() -> Self {
        Self::git_flow()
    }
}

impl Settings {
    pub fn git_flow() -> Self {
        Self {
            include_remote: true,
            debug: false,
            color_unknown: \"#444444\".to_string(),
            branches: BranchSettings::git_flow(),
            merge_patterns: MergePatterns::default(),
        }
    }
}

#[derive(Debug)]
pub struct BranchSettings {
    /// Known branch name prefixes ordered by persistence priority.
    pub persistence: Vec<&'static str>,
    /// Branch grouping order used for indentation.
    pub order: Vec<Vec<&'static str>>,
    /// Branch color group prefixes, used to map branches to palette slots.
    pub color: Vec<Vec<&'static str>>,
}

impl Default for BranchSettings {
    fn default() -> Self {
        Self::git_flow()
    }
}

impl BranchSettings {
    pub fn git_flow() -> Self {
        Self {
            persistence: vec"'![
                "master", "main", "develop", "dev", "feature", "release", "hotfix", "bugfix",
            ],
            order: vec![
                vec!["master", "main"],
                vec!["develop", "dev"],
                vec!["release", "hotfix"],
                vec!["feature", "bugfix"],
            ],
            color: vec![
                vec!["master", "main"],
                vec!["develop", "dev"],
                vec!["release"],
                vec!["hotfix"],
                vec!["feature"],
                vec!["bugfix"],
            ],
        }
    }
}

#[derive(Debug)]
pub struct MergePatterns {
    patterns: Vec<Regex>,
}

impl MergePatterns {
    pub fn new(patterns: Vec<Regex>) -> Self {
        Self { patterns }
    }

    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '"'_ {
        self.patterns.iter()
    }
}

impl Default for MergePatterns {
    fn default() -> Self {
        fn compile(pattern: &str) -> Regex {
            Regex::new(pattern).expect(\"compile merge pattern\")
        }

        Self::new(vec"'![
            compile(r"''^Merge branch '"'(["'^'"']+)' into '(["'^'"']+)'"'$"),
            compile(r"''^Merge branch '"'(["'^'"']+)' into (["'^'"'].*)"'$"),
            compile(r"''^Merge branch '"'(["'^'"']+)'"'$"),
            compile(r"''^Merge pull request #[0-9]+ from (.+)$"),
            compile(r"''^Merged in (.+) '"\\(pull request #[0-9]+\\)"'$"),
        ])
    }
}
EOF
' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:48:03] bash -lc "cat <<'EOF' > src/settings.rs
use regex::Regex;

#[derive(Debug)]
pub struct Settings {
    pub include_remote: bool,
    pub debug: bool,
    pub color_unknown: String,
    pub branches: BranchSettings,
    pub merge_patterns: MergePatterns,
}

impl Default for Settings {
    fn default() -> Self {
        Self::git_flow()
    }
}

impl Settings {
    pub fn git_flow() -> Self {
        Self {
            include_remote: true,
            debug: false,
            color_unknown: \"#444444\".to_string(),
            branches: BranchSettings::git_flow(),
            merge_patterns: MergePatterns::default(),
        }
    }
}

#[derive(Debug)]
pub struct BranchSettings {
    /// Known branch name prefixes ordered by persistence priority.
    pub persistence: Vec<&'static str>,
    /// Branch grouping order used for indentation.
    pub order: Vec<Vec<&'static str>>,
    /// Branch color group prefixes, used to map branches to palette slots.
    pub color: Vec<Vec<&'static str>>,
}

impl Default for BranchSettings {
    fn default() -> Self {
        Self::git_flow()
    }
}

impl BranchSettings {
    pub fn git_flow() -> Self {
        Self {
            persistence: vec"'![
                "master", "main", "develop", "dev", "feature", "release", "hotfix", "bugfix",
            ],
            order: vec![
                vec!["master", "main"],
                vec!["develop", "dev"],
                vec!["release", "hotfix"],
                vec!["feature", "bugfix"],
            ],
            color: vec![
                vec!["master", "main"],
                vec!["develop", "dev"],
                vec!["release"],
                vec!["hotfix"],
                vec!["feature"],
                vec!["bugfix"],
            ],
        }
    }
}

#[derive(Debug)]
pub struct MergePatterns {
    patterns: Vec<Regex>,
}

impl MergePatterns {
    pub fn new(patterns: Vec<Regex>) -> Self {
        Self { patterns }
    }

    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '"'_ {
        self.patterns.iter()
    }
}

impl Default for MergePatterns {
    fn default() -> Self {
        fn compile(pattern: &str) -> Regex {
            Regex::new(pattern).expect(\"compile merge pattern\")
        }

        Self::new(vec"'![
            compile(r"''^Merge branch '"'(["'^'"']+)' into '(["'^'"']+)'"'$"),
            compile(r"''^Merge branch '"'(["'^'"']+)' into (["'^'"'].*)"'$"),
            compile(r"''^Merge branch '"'(["'^'"']+)'"'$"),
            compile(r"''^Merge pull request #[0-9]+ from (.+)$"),
            compile(r"''^Merged in (.+) '"\\(pull request #[0-9]+\\)"'$"),
        ])
    }
}
EOF
' succeeded in 21ms:

[2025-09-21T12:48:03] tokens used: 99,279
[2025-09-21T12:48:03] turn diff:
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}


[2025-09-21T12:48:07] thinking

**Checking for regex dependency**
[2025-09-21T12:48:07] exec bash -lc 'cat Cargo.toml' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:48:07] bash -lc 'cat Cargo.toml' succeeded in 7ms:
[package]
name = "git-graph"
version = "0.1.0"
authors = ["Martin Lange <martin_lange_@gmx.net>"]
edition = "2018"

[lib]
name = "git_graph"
path = "src/lib.rs"

[[bin]]
name = "git-graph"
path = "src/main.rs"

[dependencies]
git2 = "0.13"
itertools = "0.10"
lazy_static = "1.4"
regex = "1.4"
svg = "0.8"
[2025-09-21T12:48:07] tokens used: 114,458
[2025-09-21T12:48:07] turn diff:
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}


[2025-09-21T12:48:10] thinking

**Verifying removal of lazy_static dependency**
[2025-09-21T12:48:10] exec bash -lc 'rg "lazy_static" -n' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:48:10] bash -lc 'rg "lazy_static" -n' succeeded in 27ms:
src/text.rs:1:use lazy_static::lazy_static;
src/text.rs:4:lazy_static! {
Cargo.lock:88: "lazy_static",
Cargo.lock:235:name = "lazy_static"
Cargo.toml:18:lazy_static = "1.4"
[2025-09-21T12:48:10] tokens used: 114,861
[2025-09-21T12:48:10] turn diff:
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}


[2025-09-21T12:48:15] thinking

**Preparing for text.rs rewrite and dependency cleanup**
[2025-09-21T12:48:16] apply_patch auto_approved=true:
D /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/text.rs
use lazy_static::lazy_static;
use regex::Regex;

lazy_static! {
    static ref MERGE_GITLAB: Regex =
        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
    static ref MERGE_GIT_DEFAULT: Regex =
        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
    static ref MERGE_GIT_SOURCE_ONLY: Regex =
        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
    static ref MERGE_GITHUB: Regex =
        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
    static ref MERGE_BITBUCKET: Regex =
        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
}

pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
    let summary = summary.trim();

    if let Some(captures) = MERGE_GITLAB.captures(summary) {
        return (
            Some(captures[2].trim().to_string()),
            Some(captures[1].trim().to_string()),
        );
    }

    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
        return (
            Some(captures[2].trim_matches('\'').trim().to_string()),
            Some(captures[1].trim().to_string()),
        );
    }

    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
        return (None, Some(captures[1].trim().to_string()));
    }

    if let Some(captures) = MERGE_GITHUB.captures(summary) {
        return (None, Some(captures[1].trim().to_string()));
    }

    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
        return (None, Some(captures[1].trim().to_string()));
    }

    (None, None)
}

#[cfg(test)]
mod tests {
    use super::parse_merge_summary;

    #[test]
    fn parses_gitlab_merge_summary() {
        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
        assert_eq!(to.as_deref(), Some("master"));
        assert_eq!(from.as_deref(), Some("feature/login"));
    }

    #[test]
    fn parses_git_default_merge_summary() {
        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
        assert_eq!(to.as_deref(), Some("develop"));
        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
    }

    #[test]
    fn parses_source_only_merge_summary() {
        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
        assert_eq!(to, None);
        assert_eq!(from.as_deref(), Some("release/v1.0"));
    }

    #[test]
    fn parses_github_merge_summary() {
        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
        assert_eq!(to, None);
        assert_eq!(from.as_deref(), Some("org/feature/login"));
    }

    #[test]
    fn parses_bitbucket_merge_summary() {
        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
        assert_eq!(to, None);
        assert_eq!(from.as_deref(), Some("feature/login"));
    }

    #[test]
    fn returns_none_for_unmatched_summary() {
        let (to, from) = parse_merge_summary("Regular commit message");
        assert_eq!(to, None);
        assert_eq!(from, None);
    }
}
[2025-09-21T12:48:16] apply_patch(auto_approved=true) exited 0 in 18ms:
Success. Updated the following files:
D src/text.rs
[2025-09-21T12:48:16] turn diff:
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
deleted file mode 100644
index dc817606e5a30175dc2c1160f65fd6c60714320f..0000000000000000000000000000000000000000
--- a/src/text.rs
+++ /dev/null
@@ -1,94 +0,0 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
-    let summary = summary.trim();
-
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
-}
-
-#[cfg(test)]
-mod tests {
-    use super::parse_merge_summary;
-
-    #[test]
-    fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
-    }
-
-    #[test]
-    fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
-    }
-
-    #[test]
-    fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
-    }
-
-    #[test]
-    fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
-    }
-
-    #[test]
-    fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
-    }
-
-    #[test]
-    fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
-    }
-}

[2025-09-21T12:48:16] tokens used: 116,574
[2025-09-21T12:48:16] turn diff:
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
deleted file mode 100644
index dc817606e5a30175dc2c1160f65fd6c60714320f..0000000000000000000000000000000000000000
--- a/src/text.rs
+++ /dev/null
@@ -1,94 +0,0 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
-    let summary = summary.trim();
-
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
-}
-
-#[cfg(test)]
-mod tests {
-    use super::parse_merge_summary;
-
-    #[test]
-    fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
-    }
-
-    #[test]
-    fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
-    }
-
-    #[test]
-    fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
-    }
-
-    #[test]
-    fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
-    }
-
-    #[test]
-    fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
-    }
-
-    #[test]
-    fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
-    }
-}


[2025-09-21T12:48:19] thinking

**Creating new file**
[2025-09-21T12:48:24] exec bash -lc "cat <<'EOF' > src/text.rs
use crate::settings::MergePatterns;

pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
    let summary = summary.trim();

    patterns.iter().find_map(|pattern| {
        pattern
            .captures(summary)
            .and_then(|capture| capture.get(1))
            .map(|branch| branch.as_str().trim().to_string())
    })
}

#[cfg(test)]
mod tests {
    use super::parse_merge_summary;
    use crate::settings::MergePatterns;

    #[test]
    fn parses_gitlab_merge_summary() {
        let patterns = MergePatterns::default();
        let branch = parse_merge_summary(\"Merge branch 'feature/login' into 'master'\", &patterns);
        assert_eq"'!(branch.as_deref(), Some("feature/login"));
    }

    #[test]
    fn parses_git_default_merge_summary() {
        let patterns = MergePatterns::default();
        let branch = parse_merge_summary("Merge branch '"'bugfix/issue-1' into develop\", &patterns);
        assert_eq"'!(branch.as_deref(), Some("bugfix/issue-1"));
    }

    #[test]
    fn parses_source_only_merge_summary() {
        let patterns = MergePatterns::default();
        let branch = parse_merge_summary("Merge branch '"'release/v1.0'\", &patterns);
        assert_eq"'!(branch.as_deref(), Some("release/v1.0"));
    }

    #[test]
    fn parses_github_merge_summary() {
        let patterns = MergePatterns::default();
        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
        assert_eq!(branch.as_deref(), Some("org/feature/login"));
    }

    #[test]
    fn parses_bitbucket_merge_summary() {
        let patterns = MergePatterns::default();
        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
        assert_eq!(branch.as_deref(), Some("feature/login"));
    }

    #[test]
    fn returns_none_for_unmatched_summary() {
        let patterns = MergePatterns::default();
        let branch = parse_merge_summary("Regular commit message", &patterns);
        assert_eq!(branch, None);
    }
}
EOF
' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:48:24] bash -lc "cat <<'EOF' > src/text.rs
use crate::settings::MergePatterns;

pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
    let summary = summary.trim();

    patterns.iter().find_map(|pattern| {
        pattern
            .captures(summary)
            .and_then(|capture| capture.get(1))
            .map(|branch| branch.as_str().trim().to_string())
    })
}

#[cfg(test)]
mod tests {
    use super::parse_merge_summary;
    use crate::settings::MergePatterns;

    #[test]
    fn parses_gitlab_merge_summary() {
        let patterns = MergePatterns::default();
        let branch = parse_merge_summary(\"Merge branch 'feature/login' into 'master'\", &patterns);
        assert_eq"'!(branch.as_deref(), Some("feature/login"));
    }

    #[test]
    fn parses_git_default_merge_summary() {
        let patterns = MergePatterns::default();
        let branch = parse_merge_summary("Merge branch '"'bugfix/issue-1' into develop\", &patterns);
        assert_eq"'!(branch.as_deref(), Some("bugfix/issue-1"));
    }

    #[test]
    fn parses_source_only_merge_summary() {
        let patterns = MergePatterns::default();
        let branch = parse_merge_summary("Merge branch '"'release/v1.0'\", &patterns);
        assert_eq"'!(branch.as_deref(), Some("release/v1.0"));
    }

    #[test]
    fn parses_github_merge_summary() {
        let patterns = MergePatterns::default();
        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
        assert_eq!(branch.as_deref(), Some("org/feature/login"));
    }

    #[test]
    fn parses_bitbucket_merge_summary() {
        let patterns = MergePatterns::default();
        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
        assert_eq!(branch.as_deref(), Some("feature/login"));
    }

    #[test]
    fn returns_none_for_unmatched_summary() {
        let patterns = MergePatterns::default();
        let branch = parse_merge_summary("Regular commit message", &patterns);
        assert_eq!(branch, None);
    }
}
EOF
' succeeded in 28ms:

[2025-09-21T12:48:24] tokens used: 117,395
[2025-09-21T12:48:24] turn diff:
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:49:44] thinking

**Planning graph.rs modifications**
**Detailing trace_branch improvements**
[2025-09-21T12:49:45] codex
**Detailing trace_branch improvements**
[2025-09-21T12:49:45] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -1,2 +1,2 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
[2025-09-21T12:49:45] apply_patch(auto_approved=true) exited 0 in 41ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T12:49:45] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..af15b2b8aa39886af5975af92506b11cb6b12baf
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }

[2025-09-21T12:49:45] tokens used: 123,087
[2025-09-21T12:49:45] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..af15b2b8aa39886af5975af92506b11cb6b12baf
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:49:52] thinking

**Modifying assign_branches to include patterns**
[2025-09-21T12:49:54] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -85,3 +85,8 @@
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
@@ -90,3 +95,9 @@
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
[2025-09-21T12:49:54] apply_patch(auto_approved=true) exited 0 in 30ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T12:49:54] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..3781e357765d46800d7d78e9af07305fba5f2c5b
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,23 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }

[2025-09-21T12:49:54] tokens used: 123,694
[2025-09-21T12:49:54] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..3781e357765d46800d7d78e9af07305fba5f2c5b
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,23 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:49:59] thinking

**Updating trace_branch function signature and body**
[2025-09-21T12:50:01] tokens used: 124,535
[2025-09-21T12:50:01] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..3781e357765d46800d7d78e9af07305fba5f2c5b
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,23 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:50:04] thinking

**Correcting working directory setting**
[2025-09-21T12:50:11] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -328,3 +328,9 @@
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
@@ -353,2 +359,12 @@
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
[2025-09-21T12:50:11] apply_patch(auto_approved=true) exited 0 in 41ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T12:50:11] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..9300483231d3121f66629cf278487447d1031405
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,23 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -315,7 +326,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +357,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }

[2025-09-21T12:50:11] tokens used: 135,267
[2025-09-21T12:50:11] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..9300483231d3121f66629cf278487447d1031405
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,23 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -315,7 +326,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +357,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:50:15] thinking

**Adding merge_branch_name function**
[2025-09-21T12:50:16] tokens used: 136,335
[2025-09-21T12:50:16] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..9300483231d3121f66629cf278487447d1031405
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,23 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -315,7 +326,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +357,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:50:19] thinking

**Noticing missing workdir**
[2025-09-21T12:50:20] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -409,2 +409,7 @@
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
[2025-09-21T12:50:20] apply_patch(auto_approved=true) exited 0 in 30ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T12:50:20] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..92d819f58c60c582259e58ab62502916b3a2a421
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,23 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -315,7 +326,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +357,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +407,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }

[2025-09-21T12:50:20] tokens used: 136,819
[2025-09-21T12:50:20] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..92d819f58c60c582259e58ab62502916b3a2a421
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,23 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -315,7 +326,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +357,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +407,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:50:25] thinking

**Updating extract_branches signature**
[2025-09-21T12:50:27] tokens used: 145,377
[2025-09-21T12:50:27] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..92d819f58c60c582259e58ab62502916b3a2a421
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,23 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -315,7 +326,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +357,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +407,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:50:29] thinking

**Resetting working directory**
[2025-09-21T12:50:32] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -187,3 +187,4 @@
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
@@ -209,3 +210,3 @@
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
[2025-09-21T12:50:32] apply_patch(auto_approved=true) exited 0 in 42ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T12:50:32] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..f9e42a73918f06638d59a2cc95ca1c4459820586
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,23 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,7 +185,8 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
 
@@ -196,7 +208,7 @@
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -315,7 +327,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +358,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +408,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }

[2025-09-21T12:50:32] tokens used: 147,111
[2025-09-21T12:50:32] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..f9e42a73918f06638d59a2cc95ca1c4459820586
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,23 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,7 +185,8 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
 
@@ -196,7 +208,7 @@
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -315,7 +327,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +358,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +408,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:50:35] thinking

**Adding placeholder to suppress warnings**
[2025-09-21T12:50:36] tokens used: 148,313
[2025-09-21T12:50:36] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..f9e42a73918f06638d59a2cc95ca1c4459820586
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,23 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,7 +185,8 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
 
@@ -196,7 +208,7 @@
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -315,7 +327,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +358,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +408,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:50:39] thinking

**Setting working directory**
[2025-09-21T12:50:39] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -191,2 +191,5 @@
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
[2025-09-21T12:50:39] apply_patch(auto_approved=true) exited 0 in 41ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T12:50:39] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..33dda59261c1a99dc7bb448b9cb20941ed3ddd8e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,23 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +185,13 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -196,7 +211,7 @@
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -315,7 +330,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +361,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +411,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }

[2025-09-21T12:50:39] tokens used: 149,364
[2025-09-21T12:50:39] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..33dda59261c1a99dc7bb448b9cb20941ed3ddd8e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,23 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +185,13 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -196,7 +211,7 @@
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -315,7 +330,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +361,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +411,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:50:47] thinking

**Updating variable usage to branch_settings**
[2025-09-21T12:50:48] tokens used: 150,519
[2025-09-21T12:50:48] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..33dda59261c1a99dc7bb448b9cb20941ed3ddd8e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,23 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +185,13 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -196,7 +211,7 @@
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -315,7 +330,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +361,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +411,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:50:51] thinking

**Noticing missing working directory setting**
[2025-09-21T12:50:52] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -222,4 +222,4 @@
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
[2025-09-21T12:50:52] apply_patch(auto_approved=true) exited 0 in 49ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T12:50:52] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..bb157ab6bec688db5f83f0870fd420148409abda
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,23 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +185,13 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -196,7 +211,7 @@
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +220,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +330,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +361,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +411,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }

[2025-09-21T12:50:52] tokens used: 151,650
[2025-09-21T12:50:52] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..bb157ab6bec688db5f83f0870fd420148409abda
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,23 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +185,13 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -196,7 +211,7 @@
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +220,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +330,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +361,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +411,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:50:55] thinking

**Checking settings references in extract_branches**
[2025-09-21T12:50:56] exec bash -lc 'rg "settings" src/graph.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:50:56] bash -lc 'rg "settings" src/graph.rs' succeeded in 25ms:
use crate::settings::{BranchSettings, MergePatterns, Settings};
    pub fn new(path: &str, settings: &Settings) -> Result<Self, git2::Error> {
        let branches = graph.assign_branches(settings)?;
        if !settings.include_remote {
        assign_branch_columns(&graph.commits, &mut graph.branches, settings);
    fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
            &settings.branches,
            &settings.merge_patterns,
                &settings.merge_patterns,
    branch_settings: &BranchSettings,
    if settings.include_remote {
            branch_info(branch, branch_type, indices, branch_settings)
                branch_persistence(&left.name, branch_settings)
                    .cmp(&branch_persistence(&right.name, branch_settings)),
    settings: &BranchSettings,
    let order_group = branch_order(short_name, settings);
    let color_group = branch_color(short_name, settings);
fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
    settings
        .unwrap_or(settings.persistence.len())
[2025-09-21T12:50:56] tokens used: 152,132
[2025-09-21T12:50:56] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..bb157ab6bec688db5f83f0870fd420148409abda
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,23 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +185,13 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -196,7 +211,7 @@
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +220,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +330,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +361,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +411,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:51:02] thinking

**Adjusting extract_branches parameters**
[2025-09-21T12:51:02] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -88,2 +88,3 @@
             &self.indices,
+            settings.include_remote,
             &settings.branches,
[2025-09-21T12:51:02] apply_patch(auto_approved=true) exited 0 in 39ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T12:51:02] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..f5e15eaa5741b4fb46926b6c7effe25ab1434715
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,13 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -196,7 +212,7 @@
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +221,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +331,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +362,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +412,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }

[2025-09-21T12:51:02] tokens used: 153,951
[2025-09-21T12:51:02] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..f5e15eaa5741b4fb46926b6c7effe25ab1434715
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,13 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -196,7 +212,7 @@
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +221,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +331,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +362,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +412,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:51:04] thinking

**Updating function signature**
[2025-09-21T12:51:05] tokens used: 154,387
[2025-09-21T12:51:05] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..f5e15eaa5741b4fb46926b6c7effe25ab1434715
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,13 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -196,7 +212,7 @@
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +221,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +331,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +362,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +412,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:51:08] thinking

**Setting working directory**
[2025-09-21T12:51:10] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -188,2 +188,3 @@
     indices: &HashMap<Oid, usize>,
+    include_remote: bool,
     branch_settings: &BranchSettings,
@@ -207,3 +208,3 @@
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
[2025-09-21T12:51:10] apply_patch(auto_approved=true) exited 0 in 43ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T12:51:10] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }

[2025-09-21T12:51:10] tokens used: 155,876
[2025-09-21T12:51:10] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:51:15] thinking

**Verifying updated variable usage**
[2025-09-21T12:51:15] exec bash -lc 'rg "settings" src/graph.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:51:15] bash -lc 'rg "settings" src/graph.rs' succeeded in 13ms:
use crate::settings::{BranchSettings, MergePatterns, Settings};
    pub fn new(path: &str, settings: &Settings) -> Result<Self, git2::Error> {
        let branches = graph.assign_branches(settings)?;
        if !settings.include_remote {
        assign_branch_columns(&graph.commits, &mut graph.branches, settings);
    fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
            settings.include_remote,
            &settings.branches,
            &settings.merge_patterns,
                &settings.merge_patterns,
    branch_settings: &BranchSettings,
            branch_info(branch, branch_type, indices, branch_settings)
                branch_persistence(&left.name, branch_settings)
                    .cmp(&branch_persistence(&right.name, branch_settings)),
    settings: &BranchSettings,
    let order_group = branch_order(short_name, settings);
    let color_group = branch_color(short_name, settings);
fn branch_persistence(name: &str, settings: &BranchSettings) -> usize {
    settings
        .unwrap_or(settings.persistence.len())
[2025-09-21T12:51:15] tokens used: 156,380
[2025-09-21T12:51:15] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:51:34] thinking

**Refactoring SVG print with settings integration**

I’m updating `print_svg` and related color functions to use the new comprehensive `Settings` struct instead of `BranchSettings`. This includes changing function signatures, removing the fallback color constant, adapting `branch_color` to return a `String` using `settings.color_unknown` for unknown branches, and making sure color mapping wraps properly using `BRANCH_COLORS`. I also plan to update all calls and imports accordingly while handling debug flags from settings directly.
[2025-09-21T12:51:35] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/svg.rs
@@ -2,3 +2,3 @@
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
[2025-09-21T12:51:35] apply_patch(auto_approved=true) exited 0 in 30ms:
Success. Updated the following files:
M src/print/svg.rs
[2025-09-21T12:51:35] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..c9966b9cb710d5cf1668cdb25d3d0e781067eaa4
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }

[2025-09-21T12:51:35] tokens used: 159,020
[2025-09-21T12:51:35] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..c9966b9cb710d5cf1668cdb25d3d0e781067eaa4
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:51:42] thinking

**Updating color fallback and doc comment**
[2025-09-21T12:51:54] tokens used: 163,954
[2025-09-21T12:51:54] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..c9966b9cb710d5cf1668cdb25d3d0e781067eaa4
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:51:58] thinking

**Noticing missing workdir**
[2025-09-21T12:52:02] tokens used: 167,380
[2025-09-21T12:52:02] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..c9966b9cb710d5cf1668cdb25d3d0e781067eaa4
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:52:14] thinking

**Analyzing patch application path issues**
[2025-09-21T12:52:14] exec bash -lc 'ls src/print' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:52:14] bash -lc 'ls src/print' succeeded in 13ms:
mod.rs
svg.rs
[2025-09-21T12:52:14] tokens used: 169,247
[2025-09-21T12:52:14] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..c9966b9cb710d5cf1668cdb25d3d0e781067eaa4
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:52:28] thinking

**Analyzing patch file path issues**
[2025-09-21T12:52:29] exec bash -lc "sed -n '1,200p' src/print/svg.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:52:29] bash -lc "sed -n '1,200p' src/print/svg.rs" succeeded in 19ms:
use crate::{
    graph::{BranchInfo, CommitInfo, GitGraph},
    settings::Settings,
};
use svg::node::element::path::Data;
use svg::node::element::{Circle, Group, Line, Path, Text};
use svg::node::Text as TextNode;
use svg::Document;

const COLUMN_STEP: f64 = 15.0;
const ROW_STEP: f64 = 15.0;
const NODE_RADIUS: f64 = 3.0;
const STROKE_WIDTH: f64 = 1.5;
const MERGE_STROKE_WIDTH: f64 = 2.5;
const DEBUG_FONT_SIZE: i32 = 7;

const BRANCH_COLORS: [&str; 8] = [
    "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
];

[2025-09-21T12:52:29] tokens used: 170,875
[2025-09-21T12:52:29] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..c9966b9cb710d5cf1668cdb25d3d0e781067eaa4
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:52:39] thinking

**Rewriting entire svg.rs file**

I'm planning to rewrite the whole `src/print/svg.rs` file from scratch to simplify updates and replicate needed changes. I'll update imports, adjust functions like `print_svg` and `branch_color`, remove unused constants and references, and handle color selection with proper fallbacks using modulo indexing. This clean approach should make the modifications clearer and easier to manage.
[2025-09-21T12:52:50] exec bash -lc "cat <<'EOF' > src/print/svg.rs
use crate::{
    graph::{BranchInfo, CommitInfo, GitGraph},
    settings::Settings,
};
use svg::node::element::path::Data;
use svg::node::element::{Circle, Group, Line, Path, Text};
use svg::node::Text as TextNode;
use svg::Document;

const COLUMN_STEP: f64 = 15.0;
const ROW_STEP: f64 = 15.0;
const NODE_RADIUS: f64 = 3.0;
const STROKE_WIDTH: f64 = 1.5;
const MERGE_STROKE_WIDTH: f64 = 2.5;
const DEBUG_FONT_SIZE: i32 = 7;

const BRANCH_COLORS: [&str; 8] = [
    \"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\", \"#e377c2\", \"#7f7f7f\",
];

/// Renders the commit graph as an SVG string.
///
/// Known branch groups are colored with the curated palette above. Branches that cannot be
/// classified use "'`Settings::color_unknown`, matching the behaviour described by the archived
/// submission.
pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
    let max_column = graph
        .branches()
        .iter()
        .filter_map(|branch| branch.visual.column)
        .max()
        .unwrap_or(0);

    let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;

    let mut document = Document::new()
        .set("viewBox", format!("0 0 {} {}", width, height))
        .set("width", width)
        .set("height", height);

    let mut edges = Group::new().set("id", "edges").set("fill", "none");

    for (index, commit) in graph.commits().iter().enumerate() {
        let from_column = commit_column(graph, commit);
        let from = commit_coords(from_column, index);
        let color = branch_color(graph, settings, commit);
        let stroke_width = if commit.parents.len() > 1 && settings.debug {
            MERGE_STROKE_WIDTH
        } else {
            STROKE_WIDTH
        };

        for parent_id in &commit.parent_ids {
            if let Some(&parent_index) = graph.indices().get(parent_id) {
                if let Some(parent_commit) = graph.commits().get(parent_index) {
                    let to_column = commit_column(graph, parent_commit);
                    let to = commit_coords(to_column, parent_index);

                    let edge = if from_column == to_column {
                        line(from, to, color.as_str(), stroke_width)
                    } else {
                        path(from, to, color.as_str(), stroke_width)
                    };

                    edges = edges.add(edge);
                }
            }
        }
    }

    document = document.add(edges);

    let mut nodes = Group::new().set("id", "nodes");

    for (index, commit) in graph.commits().iter().enumerate() {
        let column = commit_column(graph, commit);
        let center = commit_coords(column, index);
        let color = branch_color(graph, settings, commit);

        nodes = nodes.add(commit_dot(center, color.as_str()));

        if settings.debug {
            nodes = nodes.add(debug_label(center, index));
        }
    }

    document = document.add(nodes);

    let mut buffer = Vec::new();
    svg::write(&mut buffer, &document).expect("write svg");

    String::from_utf8(buffer).expect("valid svg utf-8")
}

type Point = (f64, f64);

fn commit_column(graph: &GitGraph, info: &CommitInfo) -> Option<usize> {
    primary_branch(graph, info).and_then(|branch| branch.visual.column)
}

fn primary_branch<'"'graph>(
    graph: &'graph GitGraph,
    info: &CommitInfo,
) -> Option<&'graph BranchInfo> {
    if let Some(trace) = info.branch_trace {
        return graph.branches().get(trace);
    }

    info.branches
        .iter()
        .find_map(|index| graph.branches().get(*index))
}

fn commit_coords(column: Option<usize>, index: usize) -> Point {
    let column = column.unwrap_or(0) as f64;
    let x = (column + 1.0) * COLUMN_STEP;
    let y = (index as f64 + 1.0) * ROW_STEP;
    (x, y)
}

fn line(from: Point, to: Point, color: &str, stroke_width: f64) -> Line {
    Line::new()
        .set(\"x1\", from.0)
        .set(\"y1\", from.1)
        .set(\"x2\", to.0)
        .set(\"y2\", to.1)
        .set(\"stroke\", color)
        .set(\"stroke-width\", stroke_width)
}

fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
    let control_x = (from.0 + to.0) / 2.0;
    let data = Data::new()
        .move_to((from.0, from.1))
        .quadratic_curve_to((control_x, from.1, to.0, to.1));

    Path::new()
        .set(\"d\", data)
        .set(\"stroke\", color)
        .set(\"stroke-width\", stroke_width)
        .set(\"fill\", \"none\")
}

fn commit_dot(center: Point, color: &str) -> Circle {
    Circle::new()
        .set(\"cx\", center.0)
        .set(\"cy\", center.1)
        .set(\"r\", NODE_RADIUS)
        .set(\"fill\", color)
        .set(\"stroke\", \"#111111\")
        .set(\"stroke-width\", 0.5)
}

fn debug_label(center: Point, index: usize) -> Text {
    let mut label = Text::new()
        .set(\"x\", center.0 + NODE_RADIUS + 2.0)
        .set(\"y\", center.1 + (DEBUG_FONT_SIZE as f64 / 2.0))
        .set(\"font-size\", DEBUG_FONT_SIZE)
        .set(\"fill\", \"#666666\");

    label.add(TextNode::new(index.to_string()))
}

fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
    if let Some(branch) = primary_branch(graph, info) {
        let group = branch.visual.color_group;
        return color_for_group(group).to_string();
    }

    settings.color_unknown.clone()
}

fn color_for_group(group: usize) -> &'static str {
    BRANCH_COLORS[group % BRANCH_COLORS.len()]
}
EOF
" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:52:50] bash -lc "cat <<'EOF' > src/print/svg.rs
use crate::{
    graph::{BranchInfo, CommitInfo, GitGraph},
    settings::Settings,
};
use svg::node::element::path::Data;
use svg::node::element::{Circle, Group, Line, Path, Text};
use svg::node::Text as TextNode;
use svg::Document;

const COLUMN_STEP: f64 = 15.0;
const ROW_STEP: f64 = 15.0;
const NODE_RADIUS: f64 = 3.0;
const STROKE_WIDTH: f64 = 1.5;
const MERGE_STROKE_WIDTH: f64 = 2.5;
const DEBUG_FONT_SIZE: i32 = 7;

const BRANCH_COLORS: [&str; 8] = [
    \"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\", \"#e377c2\", \"#7f7f7f\",
];

/// Renders the commit graph as an SVG string.
///
/// Known branch groups are colored with the curated palette above. Branches that cannot be
/// classified use "'`Settings::color_unknown`, matching the behaviour described by the archived
/// submission.
pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
    let max_column = graph
        .branches()
        .iter()
        .filter_map(|branch| branch.visual.column)
        .max()
        .unwrap_or(0);

    let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;

    let mut document = Document::new()
        .set("viewBox", format!("0 0 {} {}", width, height))
        .set("width", width)
        .set("height", height);

    let mut edges = Group::new().set("id", "edges").set("fill", "none");

    for (index, commit) in graph.commits().iter().enumerate() {
        let from_column = commit_column(graph, commit);
        let from = commit_coords(from_column, index);
        let color = branch_color(graph, settings, commit);
        let stroke_width = if commit.parents.len() > 1 && settings.debug {
            MERGE_STROKE_WIDTH
        } else {
            STROKE_WIDTH
        };

        for parent_id in &commit.parent_ids {
            if let Some(&parent_index) = graph.indices().get(parent_id) {
                if let Some(parent_commit) = graph.commits().get(parent_index) {
                    let to_column = commit_column(graph, parent_commit);
                    let to = commit_coords(to_column, parent_index);

                    let edge = if from_column == to_column {
                        line(from, to, color.as_str(), stroke_width)
                    } else {
                        path(from, to, color.as_str(), stroke_width)
                    };

                    edges = edges.add(edge);
                }
            }
        }
    }

    document = document.add(edges);

    let mut nodes = Group::new().set("id", "nodes");

    for (index, commit) in graph.commits().iter().enumerate() {
        let column = commit_column(graph, commit);
        let center = commit_coords(column, index);
        let color = branch_color(graph, settings, commit);

        nodes = nodes.add(commit_dot(center, color.as_str()));

        if settings.debug {
            nodes = nodes.add(debug_label(center, index));
        }
    }

    document = document.add(nodes);

    let mut buffer = Vec::new();
    svg::write(&mut buffer, &document).expect("write svg");

    String::from_utf8(buffer).expect("valid svg utf-8")
}

type Point = (f64, f64);

fn commit_column(graph: &GitGraph, info: &CommitInfo) -> Option<usize> {
    primary_branch(graph, info).and_then(|branch| branch.visual.column)
}

fn primary_branch<'"'graph>(
    graph: &'graph GitGraph,
    info: &CommitInfo,
) -> Option<&'graph BranchInfo> {
    if let Some(trace) = info.branch_trace {
        return graph.branches().get(trace);
    }

    info.branches
        .iter()
        .find_map(|index| graph.branches().get(*index))
}

fn commit_coords(column: Option<usize>, index: usize) -> Point {
    let column = column.unwrap_or(0) as f64;
    let x = (column + 1.0) * COLUMN_STEP;
    let y = (index as f64 + 1.0) * ROW_STEP;
    (x, y)
}

fn line(from: Point, to: Point, color: &str, stroke_width: f64) -> Line {
    Line::new()
        .set(\"x1\", from.0)
        .set(\"y1\", from.1)
        .set(\"x2\", to.0)
        .set(\"y2\", to.1)
        .set(\"stroke\", color)
        .set(\"stroke-width\", stroke_width)
}

fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
    let control_x = (from.0 + to.0) / 2.0;
    let data = Data::new()
        .move_to((from.0, from.1))
        .quadratic_curve_to((control_x, from.1, to.0, to.1));

    Path::new()
        .set(\"d\", data)
        .set(\"stroke\", color)
        .set(\"stroke-width\", stroke_width)
        .set(\"fill\", \"none\")
}

fn commit_dot(center: Point, color: &str) -> Circle {
    Circle::new()
        .set(\"cx\", center.0)
        .set(\"cy\", center.1)
        .set(\"r\", NODE_RADIUS)
        .set(\"fill\", color)
        .set(\"stroke\", \"#111111\")
        .set(\"stroke-width\", 0.5)
}

fn debug_label(center: Point, index: usize) -> Text {
    let mut label = Text::new()
        .set(\"x\", center.0 + NODE_RADIUS + 2.0)
        .set(\"y\", center.1 + (DEBUG_FONT_SIZE as f64 / 2.0))
        .set(\"font-size\", DEBUG_FONT_SIZE)
        .set(\"fill\", \"#666666\");

    label.add(TextNode::new(index.to_string()))
}

fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
    if let Some(branch) = primary_branch(graph, info) {
        let group = branch.visual.color_group;
        return color_for_group(group).to_string();
    }

    settings.color_unknown.clone()
}

fn color_for_group(group: usize) -> &'static str {
    BRANCH_COLORS[group % BRANCH_COLORS.len()]
}
EOF
" succeeded in 44ms:

[2025-09-21T12:52:50] tokens used: 175,439
[2025-09-21T12:52:50] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:53:02] thinking

**Updating main.rs for new Settings usage**
[2025-09-21T12:53:03] exec bash -lc 'rg "Itertools" -n src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:53:03] bash -lc 'rg "Itertools" -n src/main.rs' succeeded in 23ms:
7:use itertools::Itertools;
[2025-09-21T12:53:03] tokens used: 182,891
[2025-09-21T12:53:03] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:53:11] thinking

**Updating main and run functions with debug flag**
[2025-09-21T12:53:14] tokens used: 186,151
[2025-09-21T12:53:14] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:53:18] thinking

**Noticing missing workdir setting**
[2025-09-21T12:53:22] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -9,3 +9,4 @@
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
@@ -16,7 +17,9 @@
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
[2025-09-21T12:53:22] apply_patch(auto_approved=true) exited 0 in 42ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T12:53:22] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }

[2025-09-21T12:53:22] tokens used: 238,567
[2025-09-21T12:53:22] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:53:33] thinking

**Cleaning up debug printing and dependencies**
[2025-09-21T12:53:34] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/Cargo.toml
@@ -17,3 +17,2 @@
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
[2025-09-21T12:53:34] apply_patch(auto_approved=true) exited 0 in 47ms:
Success. Updated the following files:
M Cargo.toml
[2025-09-21T12:53:34] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }

[2025-09-21T12:53:34] tokens used: 244,992
[2025-09-21T12:53:34] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..924eb8ae2e9246d022949c554c31f18a1987308b
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,60 @@
-use lazy_static::lazy_static;
-use regex::Regex;
+use crate::settings::MergePatterns;
 
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
-
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:53:45] thinking

**Handling dependency cleanup and formatting**

I'm reviewing how to remove `lazy_static` from dependencies and its impact on `Cargo.lock`. Since `cargo build` or `cargo check` may not automatically remove unused crates from the lock file, I'll likely run `cargo update` or specifically `cargo update -p lazy_static` to clean it properly. Before that, I'll run `cargo fmt` to ensure the code formatting is consistent after replacements. I'm also confirming that `regex` is still used, so I'll keep that dependency intact.
[2025-09-21T12:53:46] exec bash -lc 'cargo fmt' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:53:46] bash -lc 'cargo fmt' succeeded in 70ms:

[2025-09-21T12:53:46] tokens used: 246,517
[2025-09-21T12:53:46] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:53:50] thinking

**Running cargo check to verify compilation**
[2025-09-21T12:53:50] exec bash -lc 'cargo check' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:53:50] bash -lc 'cargo check' exited 101 in 23ms:
error: checksum for `svg v0.8.0` changed between lock files

this could be indicative of a few possible errors:

    * the lock file is corrupt
    * a replacement source in use (e.g., a mirror) returned a different checksum
    * the source itself may be corrupt in one way or another

unable to verify that `svg v0.8.0` is the same as when the lockfile was generated

[2025-09-21T12:53:50] tokens used: 247,281
[2025-09-21T12:53:50] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:53:59] thinking

**Resolving Cargo.lock checksum mismatch**

I’m considering removing the outdated `Cargo.lock` file and regenerating it with `cargo generate-lockfile` to fix the checksum mismatch, since the offline environment prevents updating dependencies normally. This should align the lock file with local crate versions and resolve the `cargo check` failure.
[2025-09-21T12:54:00] exec bash -lc 'rm Cargo.lock' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:54:00] bash -lc 'rm Cargo.lock' succeeded in 19ms:

[2025-09-21T12:54:00] tokens used: 247,931
[2025-09-21T12:54:00] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:54:02] thinking

**Generating lockfile with cargo**
[2025-09-21T12:54:02] exec bash -lc 'cargo generate-lockfile' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:54:12] bash -lc 'cargo generate-lockfile' exited 124 in 10.00s:
    Updating crates.io index
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
[2025-09-21T12:54:12] tokens used: 248,662
[2025-09-21T12:54:12] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:54:16] thinking

**Restoring deleted Cargo.lock**
[2025-09-21T12:54:17] exec bash -lc 'git checkout -- Cargo.lock' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:54:17] bash -lc 'git checkout -- Cargo.lock' succeeded in 38ms:

[2025-09-21T12:54:17] tokens used: 250,802
[2025-09-21T12:54:17] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:54:32] thinking

**Planning offline build workaround**

I'm figuring out how to handle build issues without network access, focusing on manually editing `Cargo.lock` to remove `lazy_static` since automatic updates and lockfile regeneration require connectivity. I'm considering how to address checksum mismatches that prevent `cargo check` from succeeding offline and preparing to note these limitations in the final message.
[2025-09-21T12:54:32] exec bash -lc 'rg "lazy_static" Cargo.lock' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:54:32] bash -lc 'rg "lazy_static" Cargo.lock' succeeded in 12ms:
 "lazy_static",
name = "lazy_static"
[2025-09-21T12:54:32] tokens used: 251,902
[2025-09-21T12:54:32] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:54:37] thinking

**Preparing dependency cleanup**
[2025-09-21T12:54:38] exec bash -lc "sed -n '1,160p' Cargo.lock" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:54:38] bash -lc "sed -n '1,160p' Cargo.lock" succeeded in 10ms:
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
[2025-09-21T12:54:38] tokens used: 304,670
[2025-09-21T12:54:38] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:54:42] thinking

**Preparing to remove lazy_static from Cargo.lock**
[2025-09-21T12:54:43] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/Cargo.lock
@@ -87,3 +87,2 @@
  "itertools",
- "lazy_static",
  "regex",
[2025-09-21T12:54:43] apply_patch(auto_approved=true) exited 0 in 46ms:
Success. Updated the following files:
M Cargo.lock
[2025-09-21T12:54:43] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..ceec99e95956b68c6e7bf0d83f67f628ddbf4ecb
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }

[2025-09-21T12:54:43] tokens used: 310,413
[2025-09-21T12:54:43] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..ceec99e95956b68c6e7bf0d83f67f628ddbf4ecb
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:54:47] thinking

**Removing lazy_static package section**
[2025-09-21T12:54:47] exec bash -lc "rg -n \"\\[\\[package\\]\\]\\nname = \\\"lazy_static\\\"\" Cargo.lock" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:54:47] bash -lc "rg -n \"\\[\\[package\\]\\]\\nname = \\\"lazy_static\\\"\" Cargo.lock" exited 2 in 12ms:
the literal '"\n"' is not allowed in a regex

Consider enabling multiline mode with the --multiline flag (or -U for short).
When multiline mode is enabled, new line characters can be matched.
[2025-09-21T12:54:47] tokens used: 312,700
[2025-09-21T12:54:47] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..ceec99e95956b68c6e7bf0d83f67f628ddbf4ecb
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:54:50] thinking

**Adapting search strategy**
[2025-09-21T12:54:52] exec bash -lc "rg \"name = \\\"lazy_static\\\"\" -n Cargo.lock" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:54:52] bash -lc "rg \"name = \\\"lazy_static\\\"\" -n Cargo.lock" succeeded in 23ms:
234:name = "lazy_static"
[2025-09-21T12:54:52] tokens used: 316,304
[2025-09-21T12:54:52] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..ceec99e95956b68c6e7bf0d83f67f628ddbf4ecb
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:54:55] thinking

**Preparing to remove code block**
[2025-09-21T12:54:55] exec bash -lc "sed -n '220,250p' Cargo.lock" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:54:55] bash -lc "sed -n '220,250p' Cargo.lock" succeeded in 8ms:
 "either",
]

[[package]]
name = "jobserver"
version = "0.1.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9afb3de4395d6b3e67a780b6de64b51c978ecf11cb9a462c66be7d4ca9039d33"
dependencies = [
 "getrandom",
 "libc",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
[2025-09-21T12:54:55] tokens used: 319,630
[2025-09-21T12:54:55] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..ceec99e95956b68c6e7bf0d83f67f628ddbf4ecb
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:54:59] thinking

**Removing lazy_static block**
[2025-09-21T12:55:00] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/Cargo.lock
@@ -233,8 +233,2 @@
 [[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
-
-[[package]]
 name = "libc"
[2025-09-21T12:55:00] apply_patch(auto_approved=true) exited 0 in 45ms:
Success. Updated the following files:
M Cargo.lock
[2025-09-21T12:55:00] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }

[2025-09-21T12:55:00] tokens used: 320,458
[2025-09-21T12:55:00] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:55:06] thinking

**Verifying Cargo.lock consistency**
[2025-09-21T12:55:06] exec bash -lc 'cargo check --offline' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:55:06] bash -lc 'cargo check --offline' exited 101 in 43ms:
error: checksum for `svg v0.8.0` changed between lock files

this could be indicative of a few possible errors:

    * the lock file is corrupt
    * a replacement source in use (e.g., a mirror) returned a different checksum
    * the source itself may be corrupt in one way or another

unable to verify that `svg v0.8.0` is the same as when the lockfile was generated

[2025-09-21T12:55:06] tokens used: 321,458
[2025-09-21T12:55:06] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:55:10] thinking

**Reviewing crate imports and exports**
[2025-09-21T12:55:10] exec bash -lc 'rg "color_unknown" -n' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:55:10] bash -lc 'rg "color_unknown" -n' succeeded in 24ms:
src/settings.rs:7:    pub color_unknown: String,
src/settings.rs:23:            color_unknown: "#444444".to_string(),
src/print/svg.rs:24:/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
src/print/svg.rs:171:    settings.color_unknown.clone()
[2025-09-21T12:55:10] tokens used: 325,068
[2025-09-21T12:55:10] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:55:14] thinking

**Verifying code imports and dependencies**
[2025-09-21T12:55:15] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:55:15] bash -lc 'git status -sb' succeeded in 20ms:
## main
 M Cargo.lock
 M Cargo.toml
 M src/graph.rs
 M src/main.rs
 M src/print/svg.rs
 M src/settings.rs
 M src/text.rs
[2025-09-21T12:55:15] tokens used: 325,696
[2025-09-21T12:55:15] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:55:19] thinking

**Reviewing code modifications**
[2025-09-21T12:55:19] exec bash -lc "sed -n '1,200p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:55:19] bash -lc "sed -n '1,200p' src/graph.rs" succeeded in 13ms:
use crate::settings::{BranchSettings, MergePatterns, Settings};
use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
use std::collections::{BTreeMap, HashMap};

pub struct CommitInfo {
    pub id: Oid,
    pub parent_ids: Vec<Oid>,
    pub parents: Vec<usize>,
    pub children: Vec<usize>,
    pub branches: Vec<usize>,
    pub branch_trace: Option<usize>,
}

pub struct BranchVis {
    pub order_group: usize,
    pub color_group: usize,
    pub column: Option<usize>,
}

pub struct BranchInfo {
[2025-09-21T12:55:19] tokens used: 326,871
[2025-09-21T12:55:19] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:55:25] thinking

**Cleaning up debug print statements**
[2025-09-21T12:55:26] tokens used: 330,697
[2025-09-21T12:55:26] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..69979415ea6e8f66b4ca76411e97edce715e42b9
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -174,9 +186,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +206,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +222,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +332,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +363,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +413,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:55:31] thinking

**Remembering the working directory**
[2025-09-21T12:55:32] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -161,3 +161,2 @@
             branch.target_index = target_index;
-            eprintln!("{}", branch.name);
 
[2025-09-21T12:55:32] apply_patch(auto_approved=true) exited 0 in 58ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T12:55:32] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..0777719c984242bffa8d7ab578014843c5a30dee
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -147,7 +159,6 @@
             };
 
             branch.target_index = target_index;
-            eprintln!("{}", branch.name);
 
             let mut start = None;
             let mut end = None;
@@ -174,9 +185,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +205,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +221,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +331,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +362,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +412,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }

[2025-09-21T12:55:32] tokens used: 332,759
[2025-09-21T12:55:32] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..0777719c984242bffa8d7ab578014843c5a30dee
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -147,7 +159,6 @@
             };
 
             branch.target_index = target_index;
-            eprintln!("{}", branch.name);
 
             let mut start = None;
             let mut end = None;
@@ -174,9 +185,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +205,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +221,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +331,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +362,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +412,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:55:36] thinking

**Re-running cargo fmt**
[2025-09-21T12:55:36] exec bash -lc 'cargo fmt' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:55:37] bash -lc 'cargo fmt' succeeded in 70ms:

[2025-09-21T12:55:37] tokens used: 332,998
[2025-09-21T12:55:37] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..0777719c984242bffa8d7ab578014843c5a30dee
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -147,7 +159,6 @@
             };
 
             branch.target_index = target_index;
-            eprintln!("{}", branch.name);
 
             let mut start = None;
             let mut end = None;
@@ -174,9 +185,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +205,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +221,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +331,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +362,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +412,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:55:40] thinking

**Checking trace_branch usage**
[2025-09-21T12:55:41] exec bash -lc "sed -n '200,360p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:55:41] bash -lc "sed -n '200,360p' src/graph.rs" succeeded in 14ms:
            let (branch, _) = branch_result?;
            branches.push((branch, branch_type));
        }
        Ok(())
    };

    push_branches(BranchType::Local)?;

    if include_remote {
        push_branches(BranchType::Remote)?;
    }

    let mut branch_infos = branches
        .into_iter()
        .filter_map(|(branch, branch_type)| {
            branch_info(branch, branch_type, indices, branch_settings)
        })
        .collect::<Vec<_>>();

    branch_infos.sort_by(|left, right| {
[2025-09-21T12:55:41] tokens used: 333,466
[2025-09-21T12:55:41] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..0777719c984242bffa8d7ab578014843c5a30dee
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -147,7 +159,6 @@
             };
 
             branch.target_index = target_index;
-            eprintln!("{}", branch.name);
 
             let mut start = None;
             let mut end = None;
@@ -174,9 +185,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +205,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +221,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +331,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +362,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +412,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:55:44] thinking

**Verifying new code compliance**
[2025-09-21T12:55:44] exec bash -lc "sed -n '360,520p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:55:44] bash -lc "sed -n '360,520p' src/graph.rs" succeeded in 12ms:
                any_assigned = true;
                range_tail = index;
            }
        }

        if commits[index].parent_ids.len() > 1 {
            if let Ok(commit) = repo.find_commit(commits[index].id) {
                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
                    // TODO(019-854edee): Integrate merge branch hints into tracing once
                    // downstream reports provide the expected handling strategy.
                    let _ = branch_hint;
                }
            }
        }

        let parent_index = commits[index].parents.first().copied();

        if let Some(parent_index) = parent_index {
            if parent_index < range_tail {
                range_valid = false;
[2025-09-21T12:55:44] tokens used: 334,896
[2025-09-21T12:55:44] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..0777719c984242bffa8d7ab578014843c5a30dee
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -147,7 +159,6 @@
             };
 
             branch.target_index = target_index;
-            eprintln!("{}", branch.name);
 
             let mut start = None;
             let mut end = None;
@@ -174,9 +185,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +205,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +221,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +331,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +362,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +412,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:55:50] thinking

**Reviewing settings usage and cleanup**
[2025-09-21T12:55:50] exec bash -lc "sed -n '1,200p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:55:50] bash -lc "sed -n '1,200p' src/main.rs" succeeded in 22ms:
use git2::{Error, Oid};
use git_graph::{
    graph::{BranchInfo, CommitInfo, GitGraph},
    print::svg::print_svg,
    settings::Settings,
};
use itertools::Itertools;

fn main() -> Result<(), Error> {
    let mut settings = Settings::git_flow();
    settings.debug = true;
    run(".", &settings)
}

fn run(path: &str, settings: &Settings) -> Result<(), Error> {
    let graph = GitGraph::new(path, settings)?;

    if settings.debug {
        for info in graph.commits() {
            print_commit_short(&graph, info)?;
[2025-09-21T12:55:50] tokens used: 337,651
[2025-09-21T12:55:50] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..0777719c984242bffa8d7ab578014843c5a30dee
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -147,7 +159,6 @@
             };
 
             branch.target_index = target_index;
-            eprintln!("{}", branch.name);
 
             let mut start = None;
             let mut end = None;
@@ -174,9 +185,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +205,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +221,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +331,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +362,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +412,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:55:55] thinking

**Reviewing commit print behavior and next steps**
[2025-09-21T12:55:59] exec bash -lc 'git diff' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:55:59] bash -lc 'git diff' succeeded in 21ms:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c5..71d24c7 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@ version = "0.1.0"
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -231,12 +230,6 @@ dependencies = [
  "libc",
 ]
 
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
[2025-09-21T12:55:59] tokens used: 338,930
[2025-09-21T12:55:59] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..0777719c984242bffa8d7ab578014843c5a30dee
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -147,7 +159,6 @@
             };
 
             branch.target_index = target_index;
-            eprintln!("{}", branch.name);
 
             let mut start = None;
             let mut end = None;
@@ -174,9 +185,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +205,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +221,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +331,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +362,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +412,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:56:04] thinking

**Verifying partial diff accuracy**
[2025-09-21T12:56:05] exec bash -lc 'git diff src/print/svg.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:56:05] bash -lc 'git diff src/print/svg.rs' succeeded in 22ms:
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd..7e52050 100644
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@ const BRANCH_COLORS: [&str; 8] = [
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
[2025-09-21T12:56:05] tokens used: 350,039
[2025-09-21T12:56:05] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..0777719c984242bffa8d7ab578014843c5a30dee
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -147,7 +159,6 @@
             };
 
             branch.target_index = target_index;
-            eprintln!("{}", branch.name);
 
             let mut start = None;
             let mut end = None;
@@ -174,9 +185,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +205,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +221,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +331,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +362,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +412,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:56:17] thinking

**Reviewing code changes and preparing commit**
[2025-09-21T12:56:18] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:56:18] bash -lc 'git status -sb' succeeded in 36ms:
## main
 M Cargo.lock
 M Cargo.toml
 M src/graph.rs
 M src/main.rs
 M src/print/svg.rs
 M src/settings.rs
 M src/text.rs
[2025-09-21T12:56:18] tokens used: 354,850
[2025-09-21T12:56:18] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..0777719c984242bffa8d7ab578014843c5a30dee
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -147,7 +159,6 @@
             };
 
             branch.target_index = target_index;
-            eprintln!("{}", branch.name);
 
             let mut start = None;
             let mut end = None;
@@ -174,9 +185,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +205,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +221,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +331,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +362,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +412,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:56:20] thinking

**Preparing to stage all changes**
[2025-09-21T12:56:21] exec bash -lc 'git add -A' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:56:21] bash -lc 'git add -A' succeeded in 33ms:

[2025-09-21T12:56:21] tokens used: 355,089
[2025-09-21T12:56:21] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..0777719c984242bffa8d7ab578014843c5a30dee
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -147,7 +159,6 @@
             };
 
             branch.target_index = target_index;
-            eprintln!("{}", branch.name);
 
             let mut start = None;
             let mut end = None;
@@ -174,9 +185,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +205,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +221,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +331,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +362,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +412,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:56:24] thinking

**Committing changes**
[2025-09-21T12:56:25] exec bash -lc 'git commit -m "019-854edee：复现提交代码内容。"' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:56:25] bash -lc 'git commit -m "019-854edee：复现提交代码内容。"' succeeded in 44ms:
[main 4571e7b] 019-854edee：复现提交代码内容。
 7 files changed, 135 insertions(+), 103 deletions(-)
[2025-09-21T12:56:25] tokens used: 366,309
[2025-09-21T12:56:25] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..0777719c984242bffa8d7ab578014843c5a30dee
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -147,7 +159,6 @@
             };
 
             branch.target_index = target_index;
-            eprintln!("{}", branch.name);
 
             let mut start = None;
             let mut end = None;
@@ -174,9 +185,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +205,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +221,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +331,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +362,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +412,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:56:32] thinking

**Preparing final response details**
[2025-09-21T12:56:33] exec bash -lc "nl -ba src/settings.rs | sed -n '1,200p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:56:33] bash -lc "nl -ba src/settings.rs | sed -n '1,200p'" succeeded in 31ms:
     1	use regex::Regex;
     2	
     3	#[derive(Debug)]
     4	pub struct Settings {
     5	    pub include_remote: bool,
     6	    pub debug: bool,
     7	    pub color_unknown: String,
     8	    pub branches: BranchSettings,
     9	    pub merge_patterns: MergePatterns,
    10	}
    11	
    12	impl Default for Settings {
    13	    fn default() -> Self {
    14	        Self::git_flow()
    15	    }
    16	}
    17	
    18	impl Settings {
    19	    pub fn git_flow() -> Self {
    20	        Self {
[2025-09-21T12:56:33] tokens used: 367,040
[2025-09-21T12:56:33] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..0777719c984242bffa8d7ab578014843c5a30dee
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -147,7 +159,6 @@
             };
 
             branch.target_index = target_index;
-            eprintln!("{}", branch.name);
 
             let mut start = None;
             let mut end = None;
@@ -174,9 +185,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +205,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +221,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +331,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +362,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +412,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:56:40] thinking

**Reviewing TODO comments and src/text.rs features**
[2025-09-21T12:56:41] exec bash -lc "nl -ba src/text.rs | sed -n '1,200p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:56:41] bash -lc "nl -ba src/text.rs | sed -n '1,200p'" succeeded in 26ms:
     1	use crate::settings::MergePatterns;
     2	
     3	pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     4	    let summary = summary.trim();
     5	
     6	    patterns.iter().find_map(|pattern| {
     7	        pattern
     8	            .captures(summary)
     9	            .and_then(|capture| capture.get(1))
    10	            .map(|branch| branch.as_str().trim().to_string())
    11	    })
    12	}
    13	
    14	#[cfg(test)]
    15	mod tests {
    16	    use super::parse_merge_summary;
    17	    use crate::settings::MergePatterns;
    18	
    19	    #[test]
    20	    fn parses_gitlab_merge_summary() {
[2025-09-21T12:56:41] tokens used: 368,372
[2025-09-21T12:56:41] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..0777719c984242bffa8d7ab578014843c5a30dee
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -147,7 +159,6 @@
             };
 
             branch.target_index = target_index;
-            eprintln!("{}", branch.name);
 
             let mut start = None;
             let mut end = None;
@@ -174,9 +185,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +205,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +221,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +331,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +362,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +412,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:56:45] thinking

**Preparing code reference details**
[2025-09-21T12:56:46] exec bash -lc "nl -ba src/graph.rs | sed -n '70,180p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:56:46] bash -lc "nl -ba src/graph.rs | sed -n '70,180p'" succeeded in 30ms:
    70	        assign_parent_indices(&mut graph.commits, &graph.indices);
    71	        assign_children(&mut graph.commits);
    72	
    73	        let branches = graph.assign_branches(settings)?;
    74	        graph.branches = branches;
    75	
    76	        if !settings.include_remote {
    77	            graph.filter_to_local_commits();
    78	        }
    79	
    80	        assign_branch_columns(&graph.commits, &mut graph.branches, settings);
    81	
    82	        Ok(graph)
    83	    }
    84	
    85	    fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
    86	        let branch_infos = extract_branches(
    87	            &self.repo,
    88	            &self.indices,
    89	            settings.include_remote,
[2025-09-21T12:56:46] tokens used: 369,332
[2025-09-21T12:56:46] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..0777719c984242bffa8d7ab578014843c5a30dee
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -147,7 +159,6 @@
             };
 
             branch.target_index = target_index;
-            eprintln!("{}", branch.name);
 
             let mut start = None;
             let mut end = None;
@@ -174,9 +185,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +205,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +221,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +331,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +362,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +412,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:56:49] thinking

**Preparing to add extract_branches lines**
[2025-09-21T12:56:50] exec bash -lc "nl -ba src/graph.rs | sed -n '180,320p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:56:50] bash -lc "nl -ba src/graph.rs | sed -n '180,320p'" succeeded in 16ms:
   180	            };
   181	        }
   182	    }
   183	}
   184	
   185	fn extract_branches(
   186	    repo: &Repository,
   187	    indices: &HashMap<Oid, usize>,
   188	    include_remote: bool,
   189	    branch_settings: &BranchSettings,
   190	    merge_patterns: &MergePatterns,
   191	) -> Result<Vec<BranchInfo>, git2::Error> {
   192	    let mut branches = Vec::new();
   193	    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
   194	    // because the archival report omits the expected target range handling.
   195	    let _ = merge_patterns;
   196	
   197	    let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
   198	        let mut iter = repo.branches(Some(branch_type))?;
   199	        while let Some(branch_result) = iter.next() {
[2025-09-21T12:56:50] tokens used: 370,799
[2025-09-21T12:56:50] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..0777719c984242bffa8d7ab578014843c5a30dee
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -147,7 +159,6 @@
             };
 
             branch.target_index = target_index;
-            eprintln!("{}", branch.name);
 
             let mut start = None;
             let mut end = None;
@@ -174,9 +185,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +205,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +221,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +331,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +362,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +412,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:56:55] thinking

**Preparing to add tracing lines**
[2025-09-21T12:56:57] exec bash -lc "nl -ba src/graph.rs | sed -n '320,460p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:56:57] bash -lc "nl -ba src/graph.rs | sed -n '320,460p'" succeeded in 30ms:
   320	fn assign_children(commits: &mut [CommitInfo]) {
   321	    for commit in commits.iter_mut() {
   322	        commit.children.clear();
   323	    }
   324	
   325	    for child_index in 0..commits.len() {
   326	        for &parent_index in &commits[child_index].parents {
   327	            if let Some(parent) = commits.get_mut(parent_index) {
   328	                parent.children.push(child_index);
   329	            }
   330	        }
   331	    }
   332	}
   333	
   334	fn trace_branch(
   335	    repo: &Repository,
   336	    commits: &mut [CommitInfo],
   337	    branch: &mut BranchInfo,
   338	    branch_index: usize,
   339	    merge_patterns: &MergePatterns,
[2025-09-21T12:56:57] tokens used: 372,648
[2025-09-21T12:56:57] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..0777719c984242bffa8d7ab578014843c5a30dee
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -147,7 +159,6 @@
             };
 
             branch.target_index = target_index;
-            eprintln!("{}", branch.name);
 
             let mut start = None;
             let mut end = None;
@@ -174,9 +185,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +205,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +221,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +331,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +362,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +412,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:57:00] thinking

**Checking src/main.rs line numbers**
[2025-09-21T12:57:01] exec bash -lc "nl -ba src/main.rs | sed -n '1,160p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T12:57:01] bash -lc "nl -ba src/main.rs | sed -n '1,160p'" succeeded in 19ms:
     1	use git2::{Error, Oid};
     2	use git_graph::{
     3	    graph::{BranchInfo, CommitInfo, GitGraph},
     4	    print::svg::print_svg,
     5	    settings::Settings,
     6	};
     7	use itertools::Itertools;
     8	
     9	fn main() -> Result<(), Error> {
    10	    let mut settings = Settings::git_flow();
    11	    settings.debug = true;
    12	    run(".", &settings)
    13	}
    14	
    15	fn run(path: &str, settings: &Settings) -> Result<(), Error> {
    16	    let graph = GitGraph::new(path, settings)?;
    17	
    18	    if settings.debug {
    19	        for info in graph.commits() {
    20	            print_commit_short(&graph, info)?;
[2025-09-21T12:57:01] tokens used: 387,757
[2025-09-21T12:57:01] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..0777719c984242bffa8d7ab578014843c5a30dee
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -147,7 +159,6 @@
             };
 
             branch.target_index = target_index;
-            eprintln!("{}", branch.name);
 
             let mut start = None;
             let mut end = None;
@@ -174,9 +185,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +205,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +221,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +331,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +362,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +412,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


[2025-09-21T12:57:15] thinking

**Drafting detailed final summary**

I’m putting together a clear final message that leads with a concise explanation of the major changes, followed by bullet points referencing file paths and line ranges where key modifications happened. I’ll highlight TODOs and assumptions with their line references and note the test attempt that failed due to the offline checksum issue. Finally, I plan to suggest natural next steps involving running cargo commands with network access and further integration once more data is available.
[2025-09-21T12:57:15] codex

新配置集中在 `Settings`：`src/settings.rs:4-26` 引入 `debug`、`color_unknown` 与 `merge_patterns` 字段，`MergePatterns` 统一在配置侧编译原先的五类正则，`Settings::git_flow` 默认造出完整实例。对应地，`src/text.rs:1-59` 的 `parse_merge_summary` 接受 `&MergePatterns` 并按顺序寻找首个命中的分支名，测试用例同步适配。

`src/graph.rs:85-418` 全面改造分支提取/追踪流程：`assign_branches`、`extract_branches` 与 `trace_branch` 均接收 `MergePatterns`，内置的 `merge_branch_name` 调用文本解析器并保留 TODO，便于后续按报告补齐合并分支重建逻辑；同时移除了遗留调试输出。SVG 渲染切换为读取完整配置：`src/print/svg.rs:21-172` 现在使用 `Settings` 选择调试分支、统一的分支配色，并把未知分支回退到 `settings.color_unknown`。入口处 `src/main.rs:9-25` 显式开启调试模式，调试打印与 SVG 输出均来自同一 `Settings` 实例。依赖方面移除了 `lazy_static`（`Cargo.toml:18`、`Cargo.lock:85-236`），让解析逻辑完全由 `MergePatterns` 管理。

关键假设 / TODO  
- `src/graph.rs:193-195`、`src/graph.rs:365-371` 留下 TODO，说明报告未给出如何利用合并摘要生成“仅日志存在的分支”，后续待补规则。

验证  
- `cargo check --offline` 因 `svg v0.8.0` 校验和与现有锁文件不符而失败；离线环境无法刷新 crates.io 索引。后续需在可联网环境下执行 `cargo check --locked` 或更新 `svg` 的锁文件校验和以确认构建。

下一步建议  
1. 在可访问 crates.io 时运行 `cargo check --locked`，或用镜像更新 `svg` 校验和，验证构建。  
2. 待拿到补充资料后，实现 TODO 中提到的“仅日志出现的合并分支”重建策略。
[2025-09-21T12:57:20] tokens used: 392,416
[2025-09-21T12:57:20] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index a4275c50e96137a13b06a99ccd6b9fd206e847a1..71d24c7abf070a40766e4b8b7518f3d4107c76d1
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -85,7 +85,6 @@
 dependencies = [
  "git2",
  "itertools",
- "lazy_static",
  "regex",
  "svg",
 ]
@@ -230,12 +229,6 @@
  "getrandom",
  "libc",
 ]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
diff --git a/Cargo.toml b/Cargo.toml
index 349387c251a2adf9d1e10ef2e585e1117a9a8e91..07051054501f411a6fca6d8359533cbe62bad87e
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,6 +15,5 @@
 [dependencies]
 git2 = "0.13"
 itertools = "0.10"
-lazy_static = "1.4"
 regex = "1.4"
 svg = "0.8"
diff --git a/src/graph.rs b/src/graph.rs
index 5a840a525c3ee855761b30524887e5d926a9e516..0777719c984242bffa8d7ab578014843c5a30dee
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,4 +1,4 @@
-use crate::settings::{BranchSettings, Settings};
+use crate::settings::{BranchSettings, MergePatterns, Settings};
 use git2::{Branch, BranchType, Commit, Oid, Repository, Sort};
 use std::collections::{BTreeMap, HashMap};
 
@@ -83,12 +83,24 @@
     }
 
     fn assign_branches(&mut self, settings: &Settings) -> Result<Vec<BranchInfo>, git2::Error> {
-        let branch_infos = extract_branches(&self.repo, &self.indices, settings)?;
+        let branch_infos = extract_branches(
+            &self.repo,
+            &self.indices,
+            settings.include_remote,
+            &settings.branches,
+            &settings.merge_patterns,
+        )?;
 
         let mut result = Vec::new();
         for mut info in branch_infos {
             let branch_index = result.len();
-            let assigned_any = trace_branch(&mut self.commits, &mut info, branch_index);
+            let assigned_any = trace_branch(
+                &self.repo,
+                &mut self.commits,
+                &mut info,
+                branch_index,
+                &settings.merge_patterns,
+            );
 
             if !info.deleted {
                 self.commits[info.target_index].branches.push(branch_index);
@@ -147,7 +159,6 @@
             };
 
             branch.target_index = target_index;
-            eprintln!("{}", branch.name);
 
             let mut start = None;
             let mut end = None;
@@ -174,9 +185,14 @@
 fn extract_branches(
     repo: &Repository,
     indices: &HashMap<Oid, usize>,
-    settings: &Settings,
+    include_remote: bool,
+    branch_settings: &BranchSettings,
+    merge_patterns: &MergePatterns,
 ) -> Result<Vec<BranchInfo>, git2::Error> {
     let mut branches = Vec::new();
+    // TODO(019-854edee): Merge-only branches reported in summaries are not reconstructed yet
+    // because the archival report omits the expected target range handling.
+    let _ = merge_patterns;
 
     let mut push_branches = |branch_type: BranchType| -> Result<(), git2::Error> {
         let mut iter = repo.branches(Some(branch_type))?;
@@ -189,14 +205,14 @@
 
     push_branches(BranchType::Local)?;
 
-    if settings.include_remote {
+    if include_remote {
         push_branches(BranchType::Remote)?;
     }
 
     let mut branch_infos = branches
         .into_iter()
         .filter_map(|(branch, branch_type)| {
-            branch_info(branch, branch_type, indices, &settings.branches)
+            branch_info(branch, branch_type, indices, branch_settings)
         })
         .collect::<Vec<_>>();
 
@@ -205,8 +221,8 @@
             .order_group
             .cmp(&right.visual.order_group)
             .then(
-                branch_persistence(&left.name, &settings.branches)
-                    .cmp(&branch_persistence(&right.name, &settings.branches)),
+                branch_persistence(&left.name, branch_settings)
+                    .cmp(&branch_persistence(&right.name, branch_settings)),
             )
             .then(left.name.cmp(&right.name))
     });
@@ -315,7 +331,13 @@
     }
 }
 
-fn trace_branch(commits: &mut [CommitInfo], branch: &mut BranchInfo, branch_index: usize) -> bool {
+fn trace_branch(
+    repo: &Repository,
+    commits: &mut [CommitInfo],
+    branch: &mut BranchInfo,
+    branch_index: usize,
+    merge_patterns: &MergePatterns,
+) -> bool {
     let mut current = Some(branch.target_index);
     let mut any_assigned = false;
     let mut range_tail = branch.target_index;
@@ -340,6 +362,16 @@
             }
         }
 
+        if commits[index].parent_ids.len() > 1 {
+            if let Ok(commit) = repo.find_commit(commits[index].id) {
+                if let Some(branch_hint) = merge_branch_name(&commit, merge_patterns) {
+                    // TODO(019-854edee): Integrate merge branch hints into tracing once
+                    // downstream reports provide the expected handling strategy.
+                    let _ = branch_hint;
+                }
+            }
+        }
+
         let parent_index = commits[index].parents.first().copied();
 
         if let Some(parent_index) = parent_index {
@@ -380,6 +412,11 @@
     Some(anchor.max(child_index))
 }
 
+fn merge_branch_name(commit: &Commit, patterns: &MergePatterns) -> Option<String> {
+    let summary = commit.summary()?;
+    crate::text::parse_merge_summary(summary, patterns)
+}
+
 fn assign_branch_columns(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
diff --git a/src/main.rs b/src/main.rs
index f43b99bbcff61500e0dd7ef4f21b7605a8f74e8f..98856ac9b61f4358de91492f414eac17dac765d8
--- a/src/main.rs
+++ b/src/main.rs
@@ -7,18 +7,21 @@
 use itertools::Itertools;
 
 fn main() -> Result<(), Error> {
-    let settings = Settings::git_flow();
+    let mut settings = Settings::git_flow();
+    settings.debug = true;
     run(".", &settings)
 }
 
 fn run(path: &str, settings: &Settings) -> Result<(), Error> {
     let graph = GitGraph::new(path, settings)?;
 
-    for info in graph.commits() {
-        print_commit_short(&graph, info)?;
+    if settings.debug {
+        for info in graph.commits() {
+            print_commit_short(&graph, info)?;
+        }
     }
 
-    println!("{}", print_svg(&graph, &settings.branches, true));
+    println!("{}", print_svg(&graph, settings));
 
     Ok(())
 }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index cfeeefd9b5eb7f0209e3ff97fee135b22c4dd91d..7e5205015e3442d8dbc56adf59970e3f751b6ce9
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,6 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::BranchSettings,
+    settings::Settings,
 };
 use svg::node::element::path::Data;
 use svg::node::element::{Circle, Group, Line, Path, Text};
@@ -18,14 +18,12 @@
     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
 ];
 
-const FALLBACK_COLOR: &str = "#444444";
-
 /// Renders the commit graph as an SVG string.
 ///
-/// The original report does not provide the exact color palette used by `BranchSettings`,
-/// therefore a neutral placeholder palette is used to keep the rendering functional.
-/// TODO(017-525aaac): Replace the placeholder palette once the report includes the palette data.
-pub fn print_svg(graph: &GitGraph, settings: &BranchSettings, debug: bool) -> String {
+/// Known branch groups are colored with the curated palette above. Branches that cannot be
+/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
+/// submission.
+pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
         .branches()
         .iter()
@@ -47,7 +45,7 @@
         let from_column = commit_column(graph, commit);
         let from = commit_coords(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && debug {
+        let stroke_width = if commit.parents.len() > 1 && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
@@ -60,9 +58,9 @@
                     let to = commit_coords(to_column, parent_index);
 
                     let edge = if from_column == to_column {
-                        line(from, to, color, stroke_width)
+                        line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color, stroke_width)
+                        path(from, to, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -80,9 +78,9 @@
         let center = commit_coords(column, index);
         let color = branch_color(graph, settings, commit);
 
-        nodes = nodes.add(commit_dot(center, color));
+        nodes = nodes.add(commit_dot(center, color.as_str()));
 
-        if debug {
+        if settings.debug {
             nodes = nodes.add(debug_label(center, index));
         }
     }
@@ -164,18 +162,15 @@
     label.add(TextNode::new(index.to_string()))
 }
 
-fn branch_color(graph: &GitGraph, settings: &BranchSettings, info: &CommitInfo) -> &'static str {
+fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
     if let Some(branch) = primary_branch(graph, info) {
         let group = branch.visual.color_group;
-        return color_for_group(group);
+        return color_for_group(group).to_string();
     }
 
-    color_for_group(settings.color.len())
+    settings.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS
-        .get(group % BRANCH_COLORS.len())
-        .copied()
-        .unwrap_or(FALLBACK_COLOR)
+    BRANCH_COLORS[group % BRANCH_COLORS.len()]
 }
diff --git a/src/settings.rs b/src/settings.rs
index 77f4ff5ce72584c8bd6069341bab631d0ab1ebc6..53b55e3463c860cf23227d67540ce629fdc51690
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,7 +1,12 @@
+use regex::Regex;
+
 #[derive(Debug)]
 pub struct Settings {
     pub include_remote: bool,
+    pub debug: bool,
+    pub color_unknown: String,
     pub branches: BranchSettings,
+    pub merge_patterns: MergePatterns,
 }
 
 impl Default for Settings {
@@ -11,11 +16,13 @@
 }
 
 impl Settings {
-    /// Returns settings tuned for the conventional git-flow branch layout.
     pub fn git_flow() -> Self {
         Self {
             include_remote: true,
+            debug: false,
+            color_unknown: "#444444".to_string(),
             branches: BranchSettings::git_flow(),
+            merge_patterns: MergePatterns::default(),
         }
     }
 }
@@ -59,3 +66,34 @@
         }
     }
 }
+
+#[derive(Debug)]
+pub struct MergePatterns {
+    patterns: Vec<Regex>,
+}
+
+impl MergePatterns {
+    pub fn new(patterns: Vec<Regex>) -> Self {
+        Self { patterns }
+    }
+
+    pub fn iter(&self) -> impl Iterator<Item = &Regex> + '_ {
+        self.patterns.iter()
+    }
+}
+
+impl Default for MergePatterns {
+    fn default() -> Self {
+        fn compile(pattern: &str) -> Regex {
+            Regex::new(pattern).expect("compile merge pattern")
+        }
+
+        Self::new(vec![
+            compile(r"^Merge branch '([^']+)' into '([^']+)'$"),
+            compile(r"^Merge branch '([^']+)' into ([^'].*)$"),
+            compile(r"^Merge branch '([^']+)'$"),
+            compile(r"^Merge pull request #[0-9]+ from (.+)$"),
+            compile(r"^Merged in (.+) \(pull request #[0-9]+\)$"),
+        ])
+    }
+}
diff --git a/src/text.rs b/src/text.rs
index dc817606e5a30175dc2c1160f65fd6c60714320f..685390d45dc4d9dbdc6c792cb4908032b0b4957c
--- a/src/text.rs
+++ b/src/text.rs
@@ -1,94 +1,61 @@
-use lazy_static::lazy_static;
-use regex::Regex;
-
-lazy_static! {
-    static ref MERGE_GITLAB: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into '([^']+)'$").expect("compile gitlab regex");
-    static ref MERGE_GIT_DEFAULT: Regex =
-        Regex::new(r"^Merge branch '([^']+)' into ([^'].*)$").expect("compile git regex");
-    static ref MERGE_GIT_SOURCE_ONLY: Regex =
-        Regex::new(r"^Merge branch '([^']+)'$").expect("compile git source-only regex");
-    static ref MERGE_GITHUB: Regex =
-        Regex::new(r"^Merge pull request #[0-9]+ from (.+)$").expect("compile github regex");
-    static ref MERGE_BITBUCKET: Regex =
-        Regex::new(r"^Merged in (.+) \(pull request #[0-9]+\)$").expect("compile bitbucket regex");
-}
+use crate::settings::MergePatterns;
 
-pub fn parse_merge_summary(summary: &str) -> (Option<String>, Option<String>) {
+pub fn parse_merge_summary(summary: &str, patterns: &MergePatterns) -> Option<String> {
     let summary = summary.trim();
 
-    if let Some(captures) = MERGE_GITLAB.captures(summary) {
-        return (
-            Some(captures[2].trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_DEFAULT.captures(summary) {
-        return (
-            Some(captures[2].trim_matches('\'').trim().to_string()),
-            Some(captures[1].trim().to_string()),
-        );
-    }
-
-    if let Some(captures) = MERGE_GIT_SOURCE_ONLY.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_GITHUB.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    if let Some(captures) = MERGE_BITBUCKET.captures(summary) {
-        return (None, Some(captures[1].trim().to_string()));
-    }
-
-    (None, None)
+    patterns.iter().find_map(|pattern| {
+        pattern
+            .captures(summary)
+            .and_then(|capture| capture.get(1))
+            .map(|branch| branch.as_str().trim().to_string())
+    })
 }
 
 #[cfg(test)]
 mod tests {
     use super::parse_merge_summary;
+    use crate::settings::MergePatterns;
 
     #[test]
     fn parses_gitlab_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'feature/login' into 'master'");
-        assert_eq!(to.as_deref(), Some("master"));
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'feature/login' into 'master'", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn parses_git_default_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop");
-        assert_eq!(to.as_deref(), Some("develop"));
-        assert_eq!(from.as_deref(), Some("bugfix/issue-1"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'bugfix/issue-1' into develop", &patterns);
+        assert_eq!(branch.as_deref(), Some("bugfix/issue-1"));
     }
 
     #[test]
     fn parses_source_only_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge branch 'release/v1.0'");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("release/v1.0"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merge branch 'release/v1.0'", &patterns);
+        assert_eq!(branch.as_deref(), Some("release/v1.0"));
     }
 
     #[test]
     fn parses_github_merge_summary() {
-        let (to, from) = parse_merge_summary("Merge pull request #42 from org/feature/login");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("org/feature/login"));
+        let patterns = MergePatterns::default();
+        let branch =
+            parse_merge_summary("Merge pull request #42 from org/feature/login", &patterns);
+        assert_eq!(branch.as_deref(), Some("org/feature/login"));
     }
 
     #[test]
     fn parses_bitbucket_merge_summary() {
-        let (to, from) = parse_merge_summary("Merged in feature/login (pull request #42)");
-        assert_eq!(to, None);
-        assert_eq!(from.as_deref(), Some("feature/login"));
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Merged in feature/login (pull request #42)", &patterns);
+        assert_eq!(branch.as_deref(), Some("feature/login"));
     }
 
     #[test]
     fn returns_none_for_unmatched_summary() {
-        let (to, from) = parse_merge_summary("Regular commit message");
-        assert_eq!(to, None);
-        assert_eq!(from, None);
+        let patterns = MergePatterns::default();
+        let branch = parse_merge_summary("Regular commit message", &patterns);
+        assert_eq!(branch, None);
     }
 }


=== 最终状态 ===
返回码: 0
状态: ✅ 执行成功
