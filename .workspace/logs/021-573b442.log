=== 任务 021-573b442 执行日志 ===
时间: 2025-09-21 21:09:01.262059
Prompt:
请在 .workspace 内，依据 .workspace/todolist/todolist-021-573b442.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/021-573b442/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："021-573b442：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 021-573b442

=== 输出 ===
[2025-09-21T12:59:59] OpenAI Codex v0.39.0 (research preview)
--------
workdir: /Users/jqwang/104-CommitLens-codex/.workspace
model: gpt-5-codex-high
provider: codex
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
--------
[2025-09-21T12:59:59] User instructions:
请在 .workspace 内，依据 .workspace/todolist/todolist-021-573b442.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/021-573b442/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："021-573b442：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 021-573b442

[2025-09-21T13:00:04] thinking

**Preparing to analyze and plan**
[2025-09-21T13:00:04] exec bash -lc 'ls -la' in /Users/jqwang/104-CommitLens-codex/.workspace/.workspace
[2025-09-21T13:00:04] bash -lc 'ls -la' exited -1 in 0ms:
No such file or directory (os error 2)
[2025-09-21T13:00:04] tokens used: 779

[2025-09-21T13:00:07] thinking

**Considering absolute workspace path**
[2025-09-21T13:00:07] exec bash -lc pwd in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T13:00:07] bash -lc pwd succeeded in 6ms:
/Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T13:00:07] tokens used: 973

[2025-09-21T13:00:09] thinking

**Presenting the list**
[2025-09-21T13:00:09] exec bash -lc 'ls -la' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T13:00:09] bash -lc 'ls -la' succeeded in 20ms:
total 10272
drwxr-xr-x@  9 jqwang  staff      288 Sep 21 15:57 .
drwxr-xr-x@ 29 jqwang  staff      928 Sep 21 07:49 ..
-rw-r--r--@  1 jqwang  staff      103 Sep 21 21:00 codex_error.txt
-rw-r--r--@  1 jqwang  staff  5005180 Sep 21 21:00 codex_output.txt
-rw-r--r--@  1 jqwang  staff        7 Sep 21 20:59 codex_status.txt
drwxr-xr-x@ 22 jqwang  staff      704 Sep 21 19:31 logs
drwxr-xr-x@ 12 jqwang  staff      384 Sep 21 20:54 rust-project
-rw-r--r--@  1 jqwang  staff      497 Sep 21 20:59 task_status.json
drwxr-xr-x@  5 jqwang  staff      160 Sep 21 20:59 todolist
[2025-09-21T13:00:09] tokens used: 2,173

[2025-09-21T13:00:11] thinking

**Viewing todolist file**
[2025-09-21T13:00:13] exec bash -lc 'cat todolist/todolist-021-573b442.tex' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T13:00:13] bash -lc 'cat todolist/todolist-021-573b442.tex' succeeded in 10ms:
\section{提交考古：021-573b442}

\subsection*{Commit 元信息}
\begin{itemize}
  \item 标题：moved calculation of index to deviate from column to module print, added longest-first sort mode
  % Escape underscores in email to avoid math mode errors
  \item 作者：Martin Lange <martin\_lange\_@gmx.net>
  \item 日期：2020-12-22T14:19:46+01:00
\end{itemize}

\subsection*{变更摘要（阅读提示）}
\begin{verbatim}
HEAD:   src/graph.rs     | 23 ++++++++++++++++++----
       src/print/mod.rs | 37 ++++++++++++++++++++++++++++++++++
       src/print/svg.rs | 60 +++++++++++++++-----------------------------------------
       src/settings.rs  |  5 +++++
       4 files changed, 77 insertions(+), 48 deletions(-)
\end{verbatim}

\subsection*{差异解读（证据）}
[2025-09-21T13:00:13] tokens used: 2,565

[2025-09-21T13:00:16] thinking

**Examining Rust project structure**
[2025-09-21T13:00:16] exec bash -lc 'ls -R' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:00:16] bash -lc 'ls -R' succeeded in 22ms:
Cargo.lock
Cargo.toml
LICENSE
README.md
scripts
src
target

./scripts:
linearize-history.sh

./src:
graph.rs
lib.rs
main.rs
print
settings.rs
text.rs

./src/print:
[2025-09-21T13:00:16] tokens used: 8,496

[2025-09-21T13:00:18] thinking

**Inspecting settings file**
[2025-09-21T13:00:18] exec bash -lc "sed -n '1,160p' src/settings.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:00:18] bash -lc "sed -n '1,160p' src/settings.rs" succeeded in 10ms:
use regex::Regex;

/// Ordering policy for branches in visual columns.
pub enum BranchOrder {
    /// Recommended! Shortest branches are inserted left-most.
    ///
    /// For branches with equal length, branches ending last are inserted first.
    /// Reverse (arg = false): Branches ending first are inserted first.
    ShortestFirst(bool),
    /// Branches ending last are inserted left-most.
    ///
    /// Reverse (arg = false): Branches starting first are inserted left-most.
    FirstComeFirstServed(bool),
}

/// Top-level settings
pub struct Settings {
    /// Debug printing and drawing
    pub debug: bool,
    /// Include remote branches?
[2025-09-21T13:00:18] tokens used: 12,863

[2025-09-21T13:00:20] thinking

**Updating BranchOrder options**
[2025-09-21T13:00:20] exec bash -lc "sed -n '1,200p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:00:20] bash -lc "sed -n '1,200p' src/graph.rs" succeeded in 9ms:
use crate::settings::{BranchOrder, BranchSettings, Settings};
use crate::text;
use git2::{BranchType, Commit, Error, Oid, Repository};
use itertools::Itertools;
use std::collections::{HashMap, VecDeque};

/// Represents a git history graph.
pub struct GitGraph {
    pub repository: Repository,
    pub commits: Vec<CommitInfo>,
    pub indices: HashMap<Oid, usize>,
    pub branches: Vec<BranchInfo>,
}

impl GitGraph {
    pub fn new(path: &str, settings: &Settings) -> Result<Self, Error> {
        let repository = Repository::open(path)?;
        let mut walk = repository.revwalk()?;

        walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)?;
[2025-09-21T13:00:20] tokens used: 13,914

[2025-09-21T13:00:22] thinking

**Reviewing assign_branch_columns function**
[2025-09-21T13:00:22] exec bash -lc 'rg "assign_branch_columns" -n' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:00:22] bash -lc 'rg "assign_branch_columns" -n' succeeded in 23ms:
src/graph.rs:37:                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
src/graph.rs:39:            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
src/graph.rs:384:fn assign_branch_columns_fcfs(
src/graph.rs:485:fn assign_branch_columns_shortest_first(
[2025-09-21T13:00:22] tokens used: 15,634
[2025-09-21T13:00:25] exec bash -lc "sed -n '360,560p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:00:25] bash -lc "sed -n '360,560p' src/graph.rs" succeeded in 18ms:
                start_index = index as i32;
                break;
            }
            _ => {
                prev_index = Some(index);
                curr_oid = commit.parent_id(0)?;
            }
        }
    }
    if let Some(end) = branch.range.0 {
        if start_index < end as i32 {
            // TODO: find a better solution (bool field?) to identify non-deleted branches that were not assigned to any commits, and thus should not occupy a column.
            branch.range = (None, None);
        } else {
            branch.range = (branch.range.0, Some(start_index as usize));
        }
    } else {
        branch.range = (branch.range.0, Some(start_index as usize));
    }
    Ok(any_assigned)
[2025-09-21T13:00:25] tokens used: 25,217

[2025-09-21T13:00:31] thinking

**Planning branch order and printing updates**
[2025-09-21T13:00:31] exec bash -lc "sed -n '1,200p' src/print/mod.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:00:31] bash -lc "sed -n '1,200p' src/print/mod.rs" succeeded in 7ms:
pub mod svg;
[2025-09-21T13:00:31] tokens used: 27,376

[2025-09-21T13:00:34] thinking

**Considering module re-exports**
[2025-09-21T13:00:34] exec bash -lc "sed -n '1,260p' src/print/svg.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:00:34] bash -lc "sed -n '1,260p' src/print/svg.rs" succeeded in 7ms:
use crate::{
    graph::{BranchInfo, CommitInfo, GitGraph},
    settings::Settings,
};
use svg::node::element::path::Data;
use svg::node::element::{Circle, Group, Line, Path, Text};
use svg::node::Text as TextNode;
use svg::Document;

const COLUMN_STEP: f64 = 15.0;
const ROW_STEP: f64 = 15.0;
const NODE_RADIUS: f64 = 3.0;
const STROKE_WIDTH: f64 = 1.5;
const MERGE_STROKE_WIDTH: f64 = 2.5;
const DEBUG_FONT_SIZE: i32 = 7;

const BRANCH_COLORS: [&str; 8] = [
    "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
];

[2025-09-21T13:00:34] tokens used: 29,765

[2025-09-21T13:00:38] thinking

**Analyzing commit_coord function discrepancies**
[2025-09-21T13:00:39] exec bash -lc "sed -n '260,520p' src/print/svg.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:00:39] bash -lc "sed -n '260,520p' src/print/svg.rs" succeeded in 10ms:

[2025-09-21T13:00:39] tokens used: 31,867

[2025-09-21T13:00:57] thinking

**Analyzing commit and code discrepancies**

I'm comparing the current codebase with the commit description, noticing some mismatches and complexities. To align with the commit, I need to implement `BranchOrder::LongestFirst` with a new unified function for branch length sorting that supports shortest and longest modes using a boolean flag. I also have to examine and adapt sorting logic in `assign_branch_columns_branch_length`, plus update `CommitInfo` structures and methods in `graph.rs` and reconcile differences in `print/svg.rs` regarding parent fields and graph accessors to prepare for implementing new features correctly.
[2025-09-21T13:00:58] exec bash -lc 'rg "pub fn commits" -n src/graph.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:00:58] bash -lc 'rg "pub fn commits" -n src/graph.rs' exited 1 in 23ms:

[2025-09-21T13:00:58] tokens used: 33,228

[2025-09-21T13:01:02] thinking

**Checking for GitGraph definition**
[2025-09-21T13:01:02] exec bash -lc "sed -n '1,200p' src/lib.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:01:02] bash -lc "sed -n '1,200p' src/lib.rs" succeeded in 12ms:
pub mod graph;
pub mod print;
pub mod settings;
pub mod text;
[2025-09-21T13:01:02] tokens used: 36,896

[2025-09-21T13:01:05] thinking

**Inspecting main.rs and wrappers**
[2025-09-21T13:01:05] exec bash -lc "sed -n '1,200p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:01:05] bash -lc "sed -n '1,200p' src/main.rs" succeeded in 13ms:
use git2::Error;
use git_graph::graph::{CommitInfo, GitGraph};
use git_graph::print::svg::print_svg;
use git_graph::settings::{BranchOrder, BranchSettings, MergePatterns, Settings};
use std::time::Instant;

struct Args {}

fn main() -> Result<(), Error> {
    let _args = Args {};

    let settings = Settings {
        debug: true,
        include_remote: true,
        branch_order: BranchOrder::ShortestFirst(true),
        branches: BranchSettings::git_flow(),
        merge_patterns: MergePatterns::default(),
    };

    run(&settings)?;
[2025-09-21T13:01:05] tokens used: 37,231

[2025-09-21T13:01:13] thinking

**Investigating function signature mismatch**
[2025-09-21T13:01:13] exec bash -lc 'cat Cargo.toml' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:01:13] bash -lc 'cat Cargo.toml' succeeded in 9ms:
[package]
name = "git-graph"
version = "0.1.0"
authors = ["Martin Lange <martin_lange_@gmx.net>"]
edition = "2018"

[lib]
name = "git_graph"
path = "src/lib.rs"

[[bin]]
name = "git-graph"
path = "src/main.rs"

[dependencies]
git2 = "0.13"
itertools = "0.10"
regex = "1.4"
svg = "0.8"
[2025-09-21T13:01:13] tokens used: 51,393

[2025-09-21T13:01:16] thinking

**Exploring GitGraph methods**
[2025-09-21T13:01:16] exec bash -lc "rg \"branches\\(\" -n src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:01:16] bash -lc "rg \"branches\\(\" -n src/graph.rs" succeeded in 21ms:
33:        let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
200:fn assign_branches(
207:    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
236:fn extract_branches(
248:        .branches(filter)?
[2025-09-21T13:01:16] tokens used: 51,748

[2025-09-21T13:01:20] thinking

**Checking for branches method**
[2025-09-21T13:01:20] exec bash -lc 'rg "pub fn branches" src -n' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:01:20] bash -lc 'rg "pub fn branches" src -n' exited 1 in 18ms:

[2025-09-21T13:01:20] tokens used: 66,462

[2025-09-21T13:01:26] thinking

**Investigating GitGraph methods and branches access**
[2025-09-21T13:01:26] exec bash -lc 'tail -n 200 src/graph.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:01:26] bash -lc 'tail -n 200 src/graph.rs' succeeded in 11ms:
            branch.range = (branch.range.0, Some(start_index as usize));
        }
    } else {
        branch.range = (branch.range.0, Some(start_index as usize));
    }
    Ok(any_assigned)
}

/// Sorts branches into columns for visualization, that all branches can be
/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
fn assign_branch_columns_fcfs(
    commits: &[CommitInfo],
    branches: &mut [BranchInfo],
    settings: &BranchSettings,
    forward: bool,
) {
    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];

    let sort_factor = if forward { 1 } else { -1 };

[2025-09-21T13:01:26] tokens used: 68,720

[2025-09-21T13:01:42] thinking

**Planning commit graph update implementation**

I’m working through adapting commit graph and SVG print logic to match a new commit’s described changes, focusing on adding a `LongestFirst` variant, updating branch assignment, and reconstructing functions like `get_deviate_index` to handle path deviations in graph edges while reconciling structural differences in `CommitInfo` fields and method usages. Since the exact diff isn’t available, I’m piecing together the final code from descriptions, existing code, and inferred behavior.
[2025-09-21T13:01:43] exec bash -lc 'rg "parent_ids" -n' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:01:43] bash -lc 'rg "parent_ids" -n' succeeded in 18ms:
src/print/svg.rs:54:        for parent_id in &commit.parent_ids {
[2025-09-21T13:01:43] tokens used: 73,779

[2025-09-21T13:01:46] thinking

**Verifying CommitInfo struct fields**
[2025-09-21T13:01:46] exec bash -lc "sed -n '60,140p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:01:46] bash -lc "sed -n '60,140p' src/graph.rs" succeeded in 8ms:
                .iter()
                .enumerate()
                .map(|(idx, info)| (info.oid, idx))
                .collect();

            let index_map: HashMap<usize, Option<&usize>> = indices
                .iter()
                .map(|(oid, index)| (*index, filtered_indices.get(oid)))
                .collect();

            for branch in branches.iter_mut() {
                eprintln!("{}", branch.name);
                if let Some(mut start_idx) = branch.range.0 {
                    let mut idx0 = index_map[&start_idx];
                    while idx0.is_none() {
                        start_idx += 1;
                        idx0 = index_map[&start_idx];
                    }
                    branch.range.0 = Some(*idx0.unwrap());
                }
[2025-09-21T13:01:46] tokens used: 74,057

[2025-09-21T13:02:00] thinking

**Analyzing commit structure and functions**
[2025-09-21T13:02:01] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:02:01] bash -lc 'git status -sb' succeeded in 25ms:
## main
[2025-09-21T13:02:01] tokens used: 78,705

[2025-09-21T13:02:51] thinking

**Designing graph and SVG modifications**

I'm planning to add a `LongestFirst(bool)` variant to branch ordering and refactor branch column assignment to support sorting by branch length in either direction. I'll implement a new helper `get_deviate_index` that calculates a child's position among a parent's children to help SVG rendering avoid line crossings by adjusting path coordinates. To apply this, I'll merge coordinate functions into one unified `commit_coord` and update path drawing to use the deviate index, including adjusting function signatures to pass necessary graph context. Since I lack exact original code, I'll create plausible implementations with TODO notes for any missing context, aiming for a faithful and logical reconstruction of the intended features.
**Planning path function and deviate index integration**

I’m designing the new `path` function to accept graph context and commit indices, computing columns and calling `get_deviate_index` to find where to deviate connections between commits in the graph. Since `split_idx` indicates a sibling’s position to avoid crossing lines, I’ll use it to split the path into vertical and horizontal segments, merging coordinate computations into `commit_coord`. Given limited exact details, I plan plausible logic where `get_deviate_index` returns an ordinal or commit index used to calculate intermediate path points—embedding TODO notes where assumptions fill gaps—so the SVG paths can better route connections around siblings.
**Refining deviate index and updating svg coordination**

I'm settling on `get_deviate_index` returning an ordinal to offset the SVG path’s control point horizontally, helping avoid line overlaps by nudging curves sideways based on sibling order. I’ll update `svg.rs` to replace method calls with direct field access on `GitGraph`, adjust loops to use actual commit parent fields, and modify `print_svg` to compute edges using the new helper and path logic with `split_idx`. This should align compilation and improve commit edge routing with a clear TODO about perfecting deviation once full original context or layout details are available.
[2025-09-21T13:04:52] codex
**Planning path function and deviate index integration**

I’m designing the new `path` function to accept graph context and commit indices, computing columns and calling `get_deviate_index` to find where to deviate connections between commits in the graph. Since `split_idx` indicates a sibling’s position to avoid crossing lines, I’ll use it to split the path into vertical and horizontal segments, merging coordinate computations into `commit_coord`. Given limited exact details, I plan plausible logic where `get_deviate_index` returns an ordinal or commit index used to calculate intermediate path points—embedding TODO notes where assumptions fill gaps—so the SVG paths can better route connections around siblings.
[2025-09-21T13:04:52] codex
**Refining deviate index and updating svg coordination**

I'm settling on `get_deviate_index` returning an ordinal to offset the SVG path’s control point horizontally, helping avoid line overlaps by nudging curves sideways based on sibling order. I’ll update `svg.rs` to replace method calls with direct field access on `GitGraph`, adjust loops to use actual commit parent fields, and modify `print_svg` to compute edges using the new helper and path logic with `split_idx`. This should align compilation and improve commit edge routing with a clear TODO about perfecting deviation once full original context or layout details are available.
[2025-09-21T13:04:52] exec bash -lc 'cargo check' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:04:52] bash -lc 'cargo check' exited 101 in 24ms:
error: checksum for `svg v0.8.0` changed between lock files

this could be indicative of a few possible errors:

    * the lock file is corrupt
    * a replacement source in use (e.g., a mirror) returned a different checksum
    * the source itself may be corrupt in one way or another

unable to verify that `svg v0.8.0` is the same as when the lockfile was generated

[2025-09-21T13:04:52] tokens used: 92,044

[2025-09-21T13:05:36] thinking

**Implementing branch order and SVG updates**

I'm working through adding a new `LongestFirst` variant to branch ordering, updating related functions and match arms accordingly, and modifying the SVG rendering code to incorporate a deviation index for branch drawing. There’s a lot to restructure—function renaming, sorting logic changes, comment additions, and utility adjustments—to align with this new behavior, while also handling imports and types carefully in this offline environment.
[2025-09-21T13:05:37] exec bash -lc "sed -n '100,200p' src/print/svg.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:05:37] bash -lc "sed -n '100,200p' src/print/svg.rs" succeeded in 22ms:
}

fn primary_branch<'graph>(
    graph: &'graph GitGraph,
    info: &CommitInfo,
) -> Option<&'graph BranchInfo> {
    if let Some(trace) = info.branch_trace {
        return graph.branches().get(trace);
    }

    info.branches
        .iter()
        .find_map(|index| graph.branches().get(*index))
}

fn commit_coords(column: Option<usize>, index: usize) -> Point {
    let column = column.unwrap_or(0) as f64;
    let x = (column + 1.0) * COLUMN_STEP;
    let y = (index as f64 + 1.0) * ROW_STEP;
    (x, y)
[2025-09-21T13:05:37] tokens used: 94,876

[2025-09-21T13:05:50] thinking

**Planning comprehensive svg.rs rewrite**

I see there's a compile bug with graph.branches usage and inconsistent settings access, so I’ll rewrite the entire svg.rs file to ensure consistent, compiling code that updates all branch and color references, adjusts commit column logic, and refines how commit coordinates and stroke widths are handled. This will help produce a clean, final version aligned with current data structures.
[2025-09-21T13:05:54] tokens used: 110,988

[2025-09-21T13:05:57] thinking

**Correcting workdir and file path**
[2025-09-21T13:06:01] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/settings.rs
@@ -9,2 +9,7 @@
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
[2025-09-21T13:06:01] apply_patch(auto_approved=true) exited 0 in 24ms:
Success. Updated the following files:
M src/settings.rs
[2025-09-21T13:06:01] turn diff:
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.

[2025-09-21T13:06:01] tokens used: 112,926
[2025-09-21T13:06:01] turn diff:
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


[2025-09-21T13:06:04] thinking

**Updating match block and renaming function in graph.rs**
[2025-09-21T13:06:06] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -38,3 +38,10 @@
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
@@ -43,2 +50,3 @@
                 forward,
+                true,
             ),
[2025-09-21T13:06:06] apply_patch(auto_approved=true) exited 0 in 26ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T13:06:06] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..d8023327c900fad5fad7add051aa39b0c3401666
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.

[2025-09-21T13:06:06] tokens used: 113,740
[2025-09-21T13:06:06] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..d8023327c900fad5fad7add051aa39b0c3401666
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


[2025-09-21T13:06:16] thinking

**Renaming and enhancing branch assignment function**
[2025-09-21T13:06:25] tokens used: 136,815
[2025-09-21T13:06:25] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..d8023327c900fad5fad7add051aa39b0c3401666
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


[2025-09-21T13:06:28] thinking

**Noticing incorrect path usage**
[2025-09-21T13:06:32] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -491,4 +491,4 @@
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
@@ -497,2 +497,3 @@
     forward: bool,
+    longest_first: bool,
 ) {
@@ -501,2 +502,3 @@
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
@@ -513,3 +515,8 @@
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
[2025-09-21T13:06:32] apply_patch(auto_approved=true) exited 0 in 36ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T13:06:32] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.

[2025-09-21T13:06:32] tokens used: 137,974
[2025-09-21T13:06:32] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


[2025-09-21T13:06:42] thinking

**Ensuring function updates and module restructuring**
[2025-09-21T13:06:48] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/mod.rs
@@ -1 +1,33 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .filter(|oid| **oid == child_oid)
+        .next()
+        .map(|_| ordinal)
+}
[2025-09-21T13:06:48] apply_patch(auto_approved=true) exited 0 in 33ms:
Success. Updated the following files:
M src/print/mod.rs
[2025-09-21T13:06:48] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..8e0a891fd5f21f3d32a7a106bdde1da6cc86b860
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,33 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .filter(|oid| **oid == child_oid)
+        .next()
+        .map(|_| ordinal)
+}
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.

[2025-09-21T13:06:48] tokens used: 140,793
[2025-09-21T13:06:48] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..8e0a891fd5f21f3d32a7a106bdde1da6cc86b860
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,33 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .filter(|oid| **oid == child_oid)
+        .next()
+        .map(|_| ordinal)
+}
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


[2025-09-21T13:07:04] thinking

**Rewriting svg.rs for clarity**

I'm preparing to replace the entire svg.rs file with a clearer, consistent implementation that redraws the SVG graph using commits, parents, and branches. I'll carefully handle options and iterators while ensuring proper imports and helper functions like `commit_coord` and `path` are defined to keep the code clean and readable.
[2025-09-21T13:07:04] apply_patch auto_approved=true:
D /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/svg.rs
use crate::{
    graph::{BranchInfo, CommitInfo, GitGraph},
    settings::Settings,
};
use svg::node::element::path::Data;
use svg::node::element::{Circle, Group, Line, Path, Text};
use svg::node::Text as TextNode;
use svg::Document;

const COLUMN_STEP: f64 = 15.0;
const ROW_STEP: f64 = 15.0;
const NODE_RADIUS: f64 = 3.0;
const STROKE_WIDTH: f64 = 1.5;
const MERGE_STROKE_WIDTH: f64 = 2.5;
const DEBUG_FONT_SIZE: i32 = 7;

const BRANCH_COLORS: [&str; 8] = [
    "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
];

/// Renders the commit graph as an SVG string.
///
/// Known branch groups are colored with the curated palette above. Branches that cannot be
/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
/// submission.
pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
    let max_column = graph
        .branches()
        .iter()
        .filter_map(|branch| branch.visual.column)
        .max()
        .unwrap_or(0);

    let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;

    let mut document = Document::new()
        .set("viewBox", format!("0 0 {} {}", width, height))
        .set("width", width)
        .set("height", height);

    let mut edges = Group::new().set("id", "edges").set("fill", "none");

    for (index, commit) in graph.commits().iter().enumerate() {
        let from_column = commit_column(graph, commit);
        let from = commit_coords(from_column, index);
        let color = branch_color(graph, settings, commit);
        let stroke_width = if commit.parents.len() > 1 && settings.debug {
            MERGE_STROKE_WIDTH
        } else {
            STROKE_WIDTH
        };

        for parent_id in &commit.parent_ids {
            if let Some(&parent_index) = graph.indices().get(parent_id) {
                if let Some(parent_commit) = graph.commits().get(parent_index) {
                    let to_column = commit_column(graph, parent_commit);
                    let to = commit_coords(to_column, parent_index);

                    let edge = if from_column == to_column {
                        line(from, to, color.as_str(), stroke_width)
                    } else {
                        path(from, to, color.as_str(), stroke_width)
                    };

                    edges = edges.add(edge);
                }
            }
        }
    }

    document = document.add(edges);

    let mut nodes = Group::new().set("id", "nodes");

    for (index, commit) in graph.commits().iter().enumerate() {
        let column = commit_column(graph, commit);
        let center = commit_coords(column, index);
        let color = branch_color(graph, settings, commit);

        nodes = nodes.add(commit_dot(center, color.as_str()));

        if settings.debug {
            nodes = nodes.add(debug_label(center, index));
        }
    }

    document = document.add(nodes);

    let mut buffer = Vec::new();
    svg::write(&mut buffer, &document).expect("write svg");

    String::from_utf8(buffer).expect("valid svg utf-8")
}

type Point = (f64, f64);

fn commit_column(graph: &GitGraph, info: &CommitInfo) -> Option<usize> {
    primary_branch(graph, info).and_then(|branch| branch.visual.column)
}

fn primary_branch<'graph>(
    graph: &'graph GitGraph,
    info: &CommitInfo,
) -> Option<&'graph BranchInfo> {
    if let Some(trace) = info.branch_trace {
        return graph.branches().get(trace);
    }

    info.branches
        .iter()
        .find_map(|index| graph.branches().get(*index))
}

fn commit_coords(column: Option<usize>, index: usize) -> Point {
    let column = column.unwrap_or(0) as f64;
    let x = (column + 1.0) * COLUMN_STEP;
    let y = (index as f64 + 1.0) * ROW_STEP;
    (x, y)
}

fn line(from: Point, to: Point, color: &str, stroke_width: f64) -> Line {
    Line::new()
        .set("x1", from.0)
        .set("y1", from.1)
        .set("x2", to.0)
        .set("y2", to.1)
        .set("stroke", color)
        .set("stroke-width", stroke_width)
}

fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
    let control_x = (from.0 + to.0) / 2.0;
    let data = Data::new()
        .move_to((from.0, from.1))
        .quadratic_curve_to((control_x, from.1, to.0, to.1));

    Path::new()
        .set("d", data)
        .set("stroke", color)
        .set("stroke-width", stroke_width)
        .set("fill", "none")
}

fn commit_dot(center: Point, color: &str) -> Circle {
    Circle::new()
        .set("cx", center.0)
        .set("cy", center.1)
        .set("r", NODE_RADIUS)
        .set("fill", color)
        .set("stroke", "#111111")
        .set("stroke-width", 0.5)
}

fn debug_label(center: Point, index: usize) -> Text {
    let mut label = Text::new()
        .set("x", center.0 + NODE_RADIUS + 2.0)
        .set("y", center.1 + (DEBUG_FONT_SIZE as f64 / 2.0))
        .set("font-size", DEBUG_FONT_SIZE)
        .set("fill", "#666666");

    label.add(TextNode::new(index.to_string()))
}

fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
    if let Some(branch) = primary_branch(graph, info) {
        let group = branch.visual.color_group;
        return color_for_group(group).to_string();
    }

    settings.color_unknown.clone()
}

fn color_for_group(group: usize) -> &'static str {
    BRANCH_COLORS[group % BRANCH_COLORS.len()]
}
[2025-09-21T13:07:04] apply_patch(auto_approved=true) exited 0 in 38ms:
Success. Updated the following files:
D src/print/svg.rs
[2025-09-21T13:07:04] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..8e0a891fd5f21f3d32a7a106bdde1da6cc86b860
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,33 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .filter(|oid| **oid == child_oid)
+        .next()
+        .map(|_| ordinal)
+}
diff --git a/src/print/svg.rs b/src/print/svg.rs
deleted file mode 100644
index 7e5205015e3442d8dbc56adf59970e3f751b6ce9..0000000000000000000000000000000000000000
--- a/src/print/svg.rs
+++ /dev/null
@@ -1,176 +0,0 @@
-use crate::{
-    graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::Settings,
-};
-use svg::node::element::path::Data;
-use svg::node::element::{Circle, Group, Line, Path, Text};
-use svg::node::Text as TextNode;
-use svg::Document;
-
-const COLUMN_STEP: f64 = 15.0;
-const ROW_STEP: f64 = 15.0;
-const NODE_RADIUS: f64 = 3.0;
-const STROKE_WIDTH: f64 = 1.5;
-const MERGE_STROKE_WIDTH: f64 = 2.5;
-const DEBUG_FONT_SIZE: i32 = 7;
-
-const BRANCH_COLORS: [&str; 8] = [
-    "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
-];
-
-/// Renders the commit graph as an SVG string.
-///
-/// Known branch groups are colored with the curated palette above. Branches that cannot be
-/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
-/// submission.
-pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
-    let max_column = graph
-        .branches()
-        .iter()
-        .filter_map(|branch| branch.visual.column)
-        .max()
-        .unwrap_or(0);
-
-    let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
-    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
-
-    let mut document = Document::new()
-        .set("viewBox", format!("0 0 {} {}", width, height))
-        .set("width", width)
-        .set("height", height);
-
-    let mut edges = Group::new().set("id", "edges").set("fill", "none");
-
-    for (index, commit) in graph.commits().iter().enumerate() {
-        let from_column = commit_column(graph, commit);
-        let from = commit_coords(from_column, index);
-        let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && settings.debug {
-            MERGE_STROKE_WIDTH
-        } else {
-            STROKE_WIDTH
-        };
-
-        for parent_id in &commit.parent_ids {
-            if let Some(&parent_index) = graph.indices().get(parent_id) {
-                if let Some(parent_commit) = graph.commits().get(parent_index) {
-                    let to_column = commit_column(graph, parent_commit);
-                    let to = commit_coords(to_column, parent_index);
-
-                    let edge = if from_column == to_column {
-                        line(from, to, color.as_str(), stroke_width)
-                    } else {
-                        path(from, to, color.as_str(), stroke_width)
-                    };
-
-                    edges = edges.add(edge);
-                }
-            }
-        }
-    }
-
-    document = document.add(edges);
-
-    let mut nodes = Group::new().set("id", "nodes");
-
-    for (index, commit) in graph.commits().iter().enumerate() {
-        let column = commit_column(graph, commit);
-        let center = commit_coords(column, index);
-        let color = branch_color(graph, settings, commit);
-
-        nodes = nodes.add(commit_dot(center, color.as_str()));
-
-        if settings.debug {
-            nodes = nodes.add(debug_label(center, index));
-        }
-    }
-
-    document = document.add(nodes);
-
-    let mut buffer = Vec::new();
-    svg::write(&mut buffer, &document).expect("write svg");
-
-    String::from_utf8(buffer).expect("valid svg utf-8")
-}
-
-type Point = (f64, f64);
-
-fn commit_column(graph: &GitGraph, info: &CommitInfo) -> Option<usize> {
-    primary_branch(graph, info).and_then(|branch| branch.visual.column)
-}
-
-fn primary_branch<'graph>(
-    graph: &'graph GitGraph,
-    info: &CommitInfo,
-) -> Option<&'graph BranchInfo> {
-    if let Some(trace) = info.branch_trace {
-        return graph.branches().get(trace);
-    }
-
-    info.branches
-        .iter()
-        .find_map(|index| graph.branches().get(*index))
-}
-
-fn commit_coords(column: Option<usize>, index: usize) -> Point {
-    let column = column.unwrap_or(0) as f64;
-    let x = (column + 1.0) * COLUMN_STEP;
-    let y = (index as f64 + 1.0) * ROW_STEP;
-    (x, y)
-}
-
-fn line(from: Point, to: Point, color: &str, stroke_width: f64) -> Line {
-    Line::new()
-        .set("x1", from.0)
-        .set("y1", from.1)
-        .set("x2", to.0)
-        .set("y2", to.1)
-        .set("stroke", color)
-        .set("stroke-width", stroke_width)
-}
-
-fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
-    let control_x = (from.0 + to.0) / 2.0;
-    let data = Data::new()
-        .move_to((from.0, from.1))
-        .quadratic_curve_to((control_x, from.1, to.0, to.1));
-
-    Path::new()
-        .set("d", data)
-        .set("stroke", color)
-        .set("stroke-width", stroke_width)
-        .set("fill", "none")
-}
-
-fn commit_dot(center: Point, color: &str) -> Circle {
-    Circle::new()
-        .set("cx", center.0)
-        .set("cy", center.1)
-        .set("r", NODE_RADIUS)
-        .set("fill", color)
-        .set("stroke", "#111111")
-        .set("stroke-width", 0.5)
-}
-
-fn debug_label(center: Point, index: usize) -> Text {
-    let mut label = Text::new()
-        .set("x", center.0 + NODE_RADIUS + 2.0)
-        .set("y", center.1 + (DEBUG_FONT_SIZE as f64 / 2.0))
-        .set("font-size", DEBUG_FONT_SIZE)
-        .set("fill", "#666666");
-
-    label.add(TextNode::new(index.to_string()))
-}
-
-fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
-    if let Some(branch) = primary_branch(graph, info) {
-        let group = branch.visual.color_group;
-        return color_for_group(group).to_string();
-    }
-
-    settings.color_unknown.clone()
-}
-
-fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS[group % BRANCH_COLORS.len()]
-}
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.

[2025-09-21T13:07:04] tokens used: 142,610
[2025-09-21T13:07:04] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..8e0a891fd5f21f3d32a7a106bdde1da6cc86b860
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,33 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .filter(|oid| **oid == child_oid)
+        .next()
+        .map(|_| ordinal)
+}
diff --git a/src/print/svg.rs b/src/print/svg.rs
deleted file mode 100644
index 7e5205015e3442d8dbc56adf59970e3f751b6ce9..0000000000000000000000000000000000000000
--- a/src/print/svg.rs
+++ /dev/null
@@ -1,176 +0,0 @@
-use crate::{
-    graph::{BranchInfo, CommitInfo, GitGraph},
-    settings::Settings,
-};
-use svg::node::element::path::Data;
-use svg::node::element::{Circle, Group, Line, Path, Text};
-use svg::node::Text as TextNode;
-use svg::Document;
-
-const COLUMN_STEP: f64 = 15.0;
-const ROW_STEP: f64 = 15.0;
-const NODE_RADIUS: f64 = 3.0;
-const STROKE_WIDTH: f64 = 1.5;
-const MERGE_STROKE_WIDTH: f64 = 2.5;
-const DEBUG_FONT_SIZE: i32 = 7;
-
-const BRANCH_COLORS: [&str; 8] = [
-    "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
-];
-
-/// Renders the commit graph as an SVG string.
-///
-/// Known branch groups are colored with the curated palette above. Branches that cannot be
-/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
-/// submission.
-pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
-    let max_column = graph
-        .branches()
-        .iter()
-        .filter_map(|branch| branch.visual.column)
-        .max()
-        .unwrap_or(0);
-
-    let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
-    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
-
-    let mut document = Document::new()
-        .set("viewBox", format!("0 0 {} {}", width, height))
-        .set("width", width)
-        .set("height", height);
-
-    let mut edges = Group::new().set("id", "edges").set("fill", "none");
-
-    for (index, commit) in graph.commits().iter().enumerate() {
-        let from_column = commit_column(graph, commit);
-        let from = commit_coords(from_column, index);
-        let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && settings.debug {
-            MERGE_STROKE_WIDTH
-        } else {
-            STROKE_WIDTH
-        };
-
-        for parent_id in &commit.parent_ids {
-            if let Some(&parent_index) = graph.indices().get(parent_id) {
-                if let Some(parent_commit) = graph.commits().get(parent_index) {
-                    let to_column = commit_column(graph, parent_commit);
-                    let to = commit_coords(to_column, parent_index);
-
-                    let edge = if from_column == to_column {
-                        line(from, to, color.as_str(), stroke_width)
-                    } else {
-                        path(from, to, color.as_str(), stroke_width)
-                    };
-
-                    edges = edges.add(edge);
-                }
-            }
-        }
-    }
-
-    document = document.add(edges);
-
-    let mut nodes = Group::new().set("id", "nodes");
-
-    for (index, commit) in graph.commits().iter().enumerate() {
-        let column = commit_column(graph, commit);
-        let center = commit_coords(column, index);
-        let color = branch_color(graph, settings, commit);
-
-        nodes = nodes.add(commit_dot(center, color.as_str()));
-
-        if settings.debug {
-            nodes = nodes.add(debug_label(center, index));
-        }
-    }
-
-    document = document.add(nodes);
-
-    let mut buffer = Vec::new();
-    svg::write(&mut buffer, &document).expect("write svg");
-
-    String::from_utf8(buffer).expect("valid svg utf-8")
-}
-
-type Point = (f64, f64);
-
-fn commit_column(graph: &GitGraph, info: &CommitInfo) -> Option<usize> {
-    primary_branch(graph, info).and_then(|branch| branch.visual.column)
-}
-
-fn primary_branch<'graph>(
-    graph: &'graph GitGraph,
-    info: &CommitInfo,
-) -> Option<&'graph BranchInfo> {
-    if let Some(trace) = info.branch_trace {
-        return graph.branches().get(trace);
-    }
-
-    info.branches
-        .iter()
-        .find_map(|index| graph.branches().get(*index))
-}
-
-fn commit_coords(column: Option<usize>, index: usize) -> Point {
-    let column = column.unwrap_or(0) as f64;
-    let x = (column + 1.0) * COLUMN_STEP;
-    let y = (index as f64 + 1.0) * ROW_STEP;
-    (x, y)
-}
-
-fn line(from: Point, to: Point, color: &str, stroke_width: f64) -> Line {
-    Line::new()
-        .set("x1", from.0)
-        .set("y1", from.1)
-        .set("x2", to.0)
-        .set("y2", to.1)
-        .set("stroke", color)
-        .set("stroke-width", stroke_width)
-}
-
-fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
-    let control_x = (from.0 + to.0) / 2.0;
-    let data = Data::new()
-        .move_to((from.0, from.1))
-        .quadratic_curve_to((control_x, from.1, to.0, to.1));
-
-    Path::new()
-        .set("d", data)
-        .set("stroke", color)
-        .set("stroke-width", stroke_width)
-        .set("fill", "none")
-}
-
-fn commit_dot(center: Point, color: &str) -> Circle {
-    Circle::new()
-        .set("cx", center.0)
-        .set("cy", center.1)
-        .set("r", NODE_RADIUS)
-        .set("fill", color)
-        .set("stroke", "#111111")
-        .set("stroke-width", 0.5)
-}
-
-fn debug_label(center: Point, index: usize) -> Text {
-    let mut label = Text::new()
-        .set("x", center.0 + NODE_RADIUS + 2.0)
-        .set("y", center.1 + (DEBUG_FONT_SIZE as f64 / 2.0))
-        .set("font-size", DEBUG_FONT_SIZE)
-        .set("fill", "#666666");
-
-    label.add(TextNode::new(index.to_string()))
-}
-
-fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
-    if let Some(branch) = primary_branch(graph, info) {
-        let group = branch.visual.color_group;
-        return color_for_group(group).to_string();
-    }
-
-    settings.color_unknown.clone()
-}
-
-fn color_for_group(group: usize) -> &'static str {
-    BRANCH_COLORS[group % BRANCH_COLORS.len()]
-}
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


[2025-09-21T13:07:08] thinking

**Preparing to recreate file with new content**
[2025-09-21T13:07:22] exec bash -lc "cat <<'EOF' > src/print/svg.rs
use crate::{
    graph::{BranchInfo, CommitInfo, GitGraph},
    print::get_deviate_index,
    settings::Settings,
};
use svg::node::element::path::Data;
use svg::node::element::{Circle, Group, Line, Path, Text};
use svg::node::Text as TextNode;
use svg::Document;

const COLUMN_STEP: f64 = 15.0;
const ROW_STEP: f64 = 15.0;
const NODE_RADIUS: f64 = 3.0;
const STROKE_WIDTH: f64 = 1.5;
const MERGE_STROKE_WIDTH: f64 = 2.5;
const DEBUG_FONT_SIZE: i32 = 7;

const BRANCH_COLORS: [&str; 8] = [
    \"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\", \"#e377c2\", \"#7f7f7f\",
];

/// Renders the commit graph as an SVG string.
pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
    let max_column = graph
        .branches
        .iter()
        .filter_map(|branch| branch.visual.column)
        .max()
        .unwrap_or(0);

    let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
    let height = ((graph.commits.len() as f64 + 2.0) * ROW_STEP).ceil() as u32;

    let mut document = Document::new()
        .set(\"viewBox\", format"'!("0 0 {} {}", width, height))
        .set("width", width)
        .set("height", height);

    let mut edges = Group::new().set("id", "edges").set("fill", "none");

    for (index, commit) in graph.commits.iter().enumerate() {
        let from_column = commit_column(graph, commit);
        let from = commit_coord(from_column, index);
        let color = branch_color(graph, settings, commit);
        let stroke_width = if commit.is_merge && settings.debug {
            MERGE_STROKE_WIDTH
        } else {
            STROKE_WIDTH
        };

        for parent_id in commit.parents.iter().flatten() {
            if let Some(&parent_index) = graph.indices.get(parent_id) {
                if let Some(parent_commit) = graph.commits.get(parent_index) {
                    let to_column = commit_column(graph, parent_commit);
                    let to = commit_coord(to_column, parent_index);
                    let split_idx = get_deviate_index(graph, parent_index, index);

                    let edge = if from_column == to_column {
                        line(from, to, color.as_str(), stroke_width)
                    } else {
                        path(from, to, split_idx, color.as_str(), stroke_width)
                    };

                    edges = edges.add(edge);
                }
            }
        }
    }

    document = document.add(edges);

    let mut nodes = Group::new().set("id", "nodes");

    for (index, commit) in graph.commits.iter().enumerate() {
        let column = commit_column(graph, commit);
        let center = commit_coord(column, index);
        let color = branch_color(graph, settings, commit);

        nodes = nodes.add(commit_dot(center, color.as_str()));

        if settings.debug {
            nodes = nodes.add(debug_label(center, index));
        }
    }

    document = document.add(nodes);

    let mut buffer = Vec::new();
    svg::write(&mut buffer, &document).expect("write svg");

    String::from_utf8(buffer).expect("valid svg utf-8")
}

type Point = (f64, f64);

fn commit_column(graph: &GitGraph, info: &CommitInfo) -> Option<usize> {
    primary_branch(graph, info).and_then(|branch| branch.visual.column)
}

fn primary_branch<'"'graph>(
    graph: &'graph GitGraph,
    info: &CommitInfo,
) -> Option<&'graph BranchInfo> {
    if let Some(trace) = info.branch_trace {
        return graph.branches.get(trace);
    }

    info
        .branches
        .iter()
        .find_map(|index| graph.branches.get(*index))
}

fn commit_coord(column: Option<usize>, index: usize) -> Point {
    let column = column.unwrap_or(0) as f64;
    let x = (column + 1.0) * COLUMN_STEP;
    let y = (index as f64 + 1.0) * ROW_STEP;
    (x, y)
}

fn line(from: Point, to: Point, color: &str, stroke_width: f64) -> Line {
    Line::new()
        .set(\"x1\", from.0)
        .set(\"y1\", from.1)
        .set(\"x2\", to.0)
        .set(\"y2\", to.1)
        .set(\"stroke\", color)
        .set(\"stroke-width\", stroke_width)
}

fn path(
    from: Point,
    to: Point,
    split_idx: Option<usize>,
    color: &str,
    stroke_width: f64,
) -> Path {
    let base = (from.0 + to.0) / 2.0;
    let deviation = split_idx
        .map(|idx| (idx as f64 + 1.0) * (COLUMN_STEP / 4.0))
        .unwrap_or(0.0);
    let control_x = if from.0 <= to.0 {
        base + deviation
    } else {
        base - deviation
    };

    // TODO(021-573b442): Match the exact curvature used by the archived commit once samples are available.
    let data = Data::new()
        .move_to((from.0, from.1))
        .quadratic_curve_to((control_x, from.1, to.0, to.1));

    Path::new()
        .set(\"d\", data)
        .set(\"stroke\", color)
        .set(\"stroke-width\", stroke_width)
        .set(\"fill\", \"none\")
}

fn commit_dot(center: Point, color: &str) -> Circle {
    Circle::new()
        .set(\"cx\", center.0)
        .set(\"cy\", center.1)
        .set(\"r\", NODE_RADIUS)
        .set(\"fill\", color)
        .set(\"stroke\", \"#111111\")
        .set(\"stroke-width\", 0.5)
}

fn debug_label(center: Point, index: usize) -> Text {
    let mut label = Text::new()
        .set(\"x\", center.0 + NODE_RADIUS + 2.0)
        .set(\"y\", center.1 + (DEBUG_FONT_SIZE as f64 / 2.0))
        .set(\"font-size\", DEBUG_FONT_SIZE)
        .set(\"fill\", \"#666666\");

    label.add(TextNode::new(index.to_string()))
}

fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
    if let Some(branch) = primary_branch(graph, info) {
        let group = branch.visual.color_group;
        return color_for_group(group).to_string();
    }

    settings.branches.color_unknown.clone()
}

fn color_for_group(group: usize) -> &'static str {
    BRANCH_COLORS[group % BRANCH_COLORS.len()]
}
EOF
" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:07:22] bash -lc "cat <<'EOF' > src/print/svg.rs
use crate::{
    graph::{BranchInfo, CommitInfo, GitGraph},
    print::get_deviate_index,
    settings::Settings,
};
use svg::node::element::path::Data;
use svg::node::element::{Circle, Group, Line, Path, Text};
use svg::node::Text as TextNode;
use svg::Document;

const COLUMN_STEP: f64 = 15.0;
const ROW_STEP: f64 = 15.0;
const NODE_RADIUS: f64 = 3.0;
const STROKE_WIDTH: f64 = 1.5;
const MERGE_STROKE_WIDTH: f64 = 2.5;
const DEBUG_FONT_SIZE: i32 = 7;

const BRANCH_COLORS: [&str; 8] = [
    \"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\", \"#e377c2\", \"#7f7f7f\",
];

/// Renders the commit graph as an SVG string.
pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
    let max_column = graph
        .branches
        .iter()
        .filter_map(|branch| branch.visual.column)
        .max()
        .unwrap_or(0);

    let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
    let height = ((graph.commits.len() as f64 + 2.0) * ROW_STEP).ceil() as u32;

    let mut document = Document::new()
        .set(\"viewBox\", format"'!("0 0 {} {}", width, height))
        .set("width", width)
        .set("height", height);

    let mut edges = Group::new().set("id", "edges").set("fill", "none");

    for (index, commit) in graph.commits.iter().enumerate() {
        let from_column = commit_column(graph, commit);
        let from = commit_coord(from_column, index);
        let color = branch_color(graph, settings, commit);
        let stroke_width = if commit.is_merge && settings.debug {
            MERGE_STROKE_WIDTH
        } else {
            STROKE_WIDTH
        };

        for parent_id in commit.parents.iter().flatten() {
            if let Some(&parent_index) = graph.indices.get(parent_id) {
                if let Some(parent_commit) = graph.commits.get(parent_index) {
                    let to_column = commit_column(graph, parent_commit);
                    let to = commit_coord(to_column, parent_index);
                    let split_idx = get_deviate_index(graph, parent_index, index);

                    let edge = if from_column == to_column {
                        line(from, to, color.as_str(), stroke_width)
                    } else {
                        path(from, to, split_idx, color.as_str(), stroke_width)
                    };

                    edges = edges.add(edge);
                }
            }
        }
    }

    document = document.add(edges);

    let mut nodes = Group::new().set("id", "nodes");

    for (index, commit) in graph.commits.iter().enumerate() {
        let column = commit_column(graph, commit);
        let center = commit_coord(column, index);
        let color = branch_color(graph, settings, commit);

        nodes = nodes.add(commit_dot(center, color.as_str()));

        if settings.debug {
            nodes = nodes.add(debug_label(center, index));
        }
    }

    document = document.add(nodes);

    let mut buffer = Vec::new();
    svg::write(&mut buffer, &document).expect("write svg");

    String::from_utf8(buffer).expect("valid svg utf-8")
}

type Point = (f64, f64);

fn commit_column(graph: &GitGraph, info: &CommitInfo) -> Option<usize> {
    primary_branch(graph, info).and_then(|branch| branch.visual.column)
}

fn primary_branch<'"'graph>(
    graph: &'graph GitGraph,
    info: &CommitInfo,
) -> Option<&'graph BranchInfo> {
    if let Some(trace) = info.branch_trace {
        return graph.branches.get(trace);
    }

    info
        .branches
        .iter()
        .find_map(|index| graph.branches.get(*index))
}

fn commit_coord(column: Option<usize>, index: usize) -> Point {
    let column = column.unwrap_or(0) as f64;
    let x = (column + 1.0) * COLUMN_STEP;
    let y = (index as f64 + 1.0) * ROW_STEP;
    (x, y)
}

fn line(from: Point, to: Point, color: &str, stroke_width: f64) -> Line {
    Line::new()
        .set(\"x1\", from.0)
        .set(\"y1\", from.1)
        .set(\"x2\", to.0)
        .set(\"y2\", to.1)
        .set(\"stroke\", color)
        .set(\"stroke-width\", stroke_width)
}

fn path(
    from: Point,
    to: Point,
    split_idx: Option<usize>,
    color: &str,
    stroke_width: f64,
) -> Path {
    let base = (from.0 + to.0) / 2.0;
    let deviation = split_idx
        .map(|idx| (idx as f64 + 1.0) * (COLUMN_STEP / 4.0))
        .unwrap_or(0.0);
    let control_x = if from.0 <= to.0 {
        base + deviation
    } else {
        base - deviation
    };

    // TODO(021-573b442): Match the exact curvature used by the archived commit once samples are available.
    let data = Data::new()
        .move_to((from.0, from.1))
        .quadratic_curve_to((control_x, from.1, to.0, to.1));

    Path::new()
        .set(\"d\", data)
        .set(\"stroke\", color)
        .set(\"stroke-width\", stroke_width)
        .set(\"fill\", \"none\")
}

fn commit_dot(center: Point, color: &str) -> Circle {
    Circle::new()
        .set(\"cx\", center.0)
        .set(\"cy\", center.1)
        .set(\"r\", NODE_RADIUS)
        .set(\"fill\", color)
        .set(\"stroke\", \"#111111\")
        .set(\"stroke-width\", 0.5)
}

fn debug_label(center: Point, index: usize) -> Text {
    let mut label = Text::new()
        .set(\"x\", center.0 + NODE_RADIUS + 2.0)
        .set(\"y\", center.1 + (DEBUG_FONT_SIZE as f64 / 2.0))
        .set(\"font-size\", DEBUG_FONT_SIZE)
        .set(\"fill\", \"#666666\");

    label.add(TextNode::new(index.to_string()))
}

fn branch_color(graph: &GitGraph, settings: &Settings, info: &CommitInfo) -> String {
    if let Some(branch) = primary_branch(graph, info) {
        let group = branch.visual.color_group;
        return color_for_group(group).to_string();
    }

    settings.branches.color_unknown.clone()
}

fn color_for_group(group: usize) -> &'static str {
    BRANCH_COLORS[group % BRANCH_COLORS.len()]
}
EOF
" succeeded in 28ms:

[2025-09-21T13:07:22] tokens used: 144,605
[2025-09-21T13:07:22] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..8e0a891fd5f21f3d32a7a106bdde1da6cc86b860
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,33 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .filter(|oid| **oid == child_oid)
+        .next()
+        .map(|_| ordinal)
+}
diff --git a/src/print/svg.rs b/src/print/svg.rs
index 7e5205015e3442d8dbc56adf59970e3f751b6ce9..3b340ba69ac9cbc6500893e6b536c33a5041cd36
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,5 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
+    print::get_deviate_index,
     settings::Settings,
 };
 use svg::node::element::path::Data;
@@ -19,20 +20,16 @@
 ];
 
 /// Renders the commit graph as an SVG string.
-///
-/// Known branch groups are colored with the curated palette above. Branches that cannot be
-/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
-/// submission.
 pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
-        .branches()
+        .branches
         .iter()
         .filter_map(|branch| branch.visual.column)
         .max()
         .unwrap_or(0);
 
     let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
-    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
+    let height = ((graph.commits.len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
 
     let mut document = Document::new()
         .set("viewBox", format!("0 0 {} {}", width, height))
@@ -41,26 +38,27 @@
 
     let mut edges = Group::new().set("id", "edges").set("fill", "none");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let from_column = commit_column(graph, commit);
-        let from = commit_coords(from_column, index);
+        let from = commit_coord(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && settings.debug {
+        let stroke_width = if commit.is_merge && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
         };
 
-        for parent_id in &commit.parent_ids {
-            if let Some(&parent_index) = graph.indices().get(parent_id) {
-                if let Some(parent_commit) = graph.commits().get(parent_index) {
+        for parent_id in commit.parents.iter().flatten() {
+            if let Some(&parent_index) = graph.indices.get(parent_id) {
+                if let Some(parent_commit) = graph.commits.get(parent_index) {
                     let to_column = commit_column(graph, parent_commit);
-                    let to = commit_coords(to_column, parent_index);
+                    let to = commit_coord(to_column, parent_index);
+                    let split_idx = get_deviate_index(graph, parent_index, index);
 
                     let edge = if from_column == to_column {
                         line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color.as_str(), stroke_width)
+                        path(from, to, split_idx, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -73,9 +71,9 @@
 
     let mut nodes = Group::new().set("id", "nodes");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let column = commit_column(graph, commit);
-        let center = commit_coords(column, index);
+        let center = commit_coord(column, index);
         let color = branch_color(graph, settings, commit);
 
         nodes = nodes.add(commit_dot(center, color.as_str()));
@@ -104,15 +102,16 @@
     info: &CommitInfo,
 ) -> Option<&'graph BranchInfo> {
     if let Some(trace) = info.branch_trace {
-        return graph.branches().get(trace);
+        return graph.branches.get(trace);
     }
 
-    info.branches
+    info
+        .branches
         .iter()
-        .find_map(|index| graph.branches().get(*index))
+        .find_map(|index| graph.branches.get(*index))
 }
 
-fn commit_coords(column: Option<usize>, index: usize) -> Point {
+fn commit_coord(column: Option<usize>, index: usize) -> Point {
     let column = column.unwrap_or(0) as f64;
     let x = (column + 1.0) * COLUMN_STEP;
     let y = (index as f64 + 1.0) * ROW_STEP;
@@ -129,8 +128,24 @@
         .set("stroke-width", stroke_width)
 }
 
-fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
-    let control_x = (from.0 + to.0) / 2.0;
+fn path(
+    from: Point,
+    to: Point,
+    split_idx: Option<usize>,
+    color: &str,
+    stroke_width: f64,
+) -> Path {
+    let base = (from.0 + to.0) / 2.0;
+    let deviation = split_idx
+        .map(|idx| (idx as f64 + 1.0) * (COLUMN_STEP / 4.0))
+        .unwrap_or(0.0);
+    let control_x = if from.0 <= to.0 {
+        base + deviation
+    } else {
+        base - deviation
+    };
+
+    // TODO(021-573b442): Match the exact curvature used by the archived commit once samples are available.
     let data = Data::new()
         .move_to((from.0, from.1))
         .quadratic_curve_to((control_x, from.1, to.0, to.1));
@@ -168,7 +183,7 @@
         return color_for_group(group).to_string();
     }
 
-    settings.color_unknown.clone()
+    settings.branches.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


[2025-09-21T13:07:27] thinking

**Verifying code integrity and formatting**
[2025-09-21T13:07:27] exec bash -lc 'cargo fmt' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:07:27] bash -lc 'cargo fmt' succeeded in 68ms:

[2025-09-21T13:07:27] tokens used: 146,804
[2025-09-21T13:07:27] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..8e0a891fd5f21f3d32a7a106bdde1da6cc86b860
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,33 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .filter(|oid| **oid == child_oid)
+        .next()
+        .map(|_| ordinal)
+}
diff --git a/src/print/svg.rs b/src/print/svg.rs
index 7e5205015e3442d8dbc56adf59970e3f751b6ce9..441167a7fad24952130a985128a6c4ebd4d2383f
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,5 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
+    print::get_deviate_index,
     settings::Settings,
 };
 use svg::node::element::path::Data;
@@ -19,20 +20,16 @@
 ];
 
 /// Renders the commit graph as an SVG string.
-///
-/// Known branch groups are colored with the curated palette above. Branches that cannot be
-/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
-/// submission.
 pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
-        .branches()
+        .branches
         .iter()
         .filter_map(|branch| branch.visual.column)
         .max()
         .unwrap_or(0);
 
     let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
-    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
+    let height = ((graph.commits.len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
 
     let mut document = Document::new()
         .set("viewBox", format!("0 0 {} {}", width, height))
@@ -41,26 +38,27 @@
 
     let mut edges = Group::new().set("id", "edges").set("fill", "none");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let from_column = commit_column(graph, commit);
-        let from = commit_coords(from_column, index);
+        let from = commit_coord(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && settings.debug {
+        let stroke_width = if commit.is_merge && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
         };
 
-        for parent_id in &commit.parent_ids {
-            if let Some(&parent_index) = graph.indices().get(parent_id) {
-                if let Some(parent_commit) = graph.commits().get(parent_index) {
+        for parent_id in commit.parents.iter().flatten() {
+            if let Some(&parent_index) = graph.indices.get(parent_id) {
+                if let Some(parent_commit) = graph.commits.get(parent_index) {
                     let to_column = commit_column(graph, parent_commit);
-                    let to = commit_coords(to_column, parent_index);
+                    let to = commit_coord(to_column, parent_index);
+                    let split_idx = get_deviate_index(graph, parent_index, index);
 
                     let edge = if from_column == to_column {
                         line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color.as_str(), stroke_width)
+                        path(from, to, split_idx, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -73,9 +71,9 @@
 
     let mut nodes = Group::new().set("id", "nodes");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let column = commit_column(graph, commit);
-        let center = commit_coords(column, index);
+        let center = commit_coord(column, index);
         let color = branch_color(graph, settings, commit);
 
         nodes = nodes.add(commit_dot(center, color.as_str()));
@@ -104,15 +102,15 @@
     info: &CommitInfo,
 ) -> Option<&'graph BranchInfo> {
     if let Some(trace) = info.branch_trace {
-        return graph.branches().get(trace);
+        return graph.branches.get(trace);
     }
 
     info.branches
         .iter()
-        .find_map(|index| graph.branches().get(*index))
+        .find_map(|index| graph.branches.get(*index))
 }
 
-fn commit_coords(column: Option<usize>, index: usize) -> Point {
+fn commit_coord(column: Option<usize>, index: usize) -> Point {
     let column = column.unwrap_or(0) as f64;
     let x = (column + 1.0) * COLUMN_STEP;
     let y = (index as f64 + 1.0) * ROW_STEP;
@@ -129,8 +127,18 @@
         .set("stroke-width", stroke_width)
 }
 
-fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
-    let control_x = (from.0 + to.0) / 2.0;
+fn path(from: Point, to: Point, split_idx: Option<usize>, color: &str, stroke_width: f64) -> Path {
+    let base = (from.0 + to.0) / 2.0;
+    let deviation = split_idx
+        .map(|idx| (idx as f64 + 1.0) * (COLUMN_STEP / 4.0))
+        .unwrap_or(0.0);
+    let control_x = if from.0 <= to.0 {
+        base + deviation
+    } else {
+        base - deviation
+    };
+
+    // TODO(021-573b442): Match the exact curvature used by the archived commit once samples are available.
     let data = Data::new()
         .move_to((from.0, from.1))
         .quadratic_curve_to((control_x, from.1, to.0, to.1));
@@ -168,7 +176,7 @@
         return color_for_group(group).to_string();
     }
 
-    settings.color_unknown.clone()
+    settings.branches.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


[2025-09-21T13:07:30] thinking

**Checking git status**
[2025-09-21T13:07:30] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:07:30] bash -lc 'git status -sb' succeeded in 36ms:
## main
 M src/graph.rs
 M src/print/mod.rs
 M src/print/svg.rs
 M src/settings.rs
[2025-09-21T13:07:30] tokens used: 146,939
[2025-09-21T13:07:30] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..8e0a891fd5f21f3d32a7a106bdde1da6cc86b860
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,33 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .filter(|oid| **oid == child_oid)
+        .next()
+        .map(|_| ordinal)
+}
diff --git a/src/print/svg.rs b/src/print/svg.rs
index 7e5205015e3442d8dbc56adf59970e3f751b6ce9..441167a7fad24952130a985128a6c4ebd4d2383f
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,5 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
+    print::get_deviate_index,
     settings::Settings,
 };
 use svg::node::element::path::Data;
@@ -19,20 +20,16 @@
 ];
 
 /// Renders the commit graph as an SVG string.
-///
-/// Known branch groups are colored with the curated palette above. Branches that cannot be
-/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
-/// submission.
 pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
-        .branches()
+        .branches
         .iter()
         .filter_map(|branch| branch.visual.column)
         .max()
         .unwrap_or(0);
 
     let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
-    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
+    let height = ((graph.commits.len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
 
     let mut document = Document::new()
         .set("viewBox", format!("0 0 {} {}", width, height))
@@ -41,26 +38,27 @@
 
     let mut edges = Group::new().set("id", "edges").set("fill", "none");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let from_column = commit_column(graph, commit);
-        let from = commit_coords(from_column, index);
+        let from = commit_coord(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && settings.debug {
+        let stroke_width = if commit.is_merge && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
         };
 
-        for parent_id in &commit.parent_ids {
-            if let Some(&parent_index) = graph.indices().get(parent_id) {
-                if let Some(parent_commit) = graph.commits().get(parent_index) {
+        for parent_id in commit.parents.iter().flatten() {
+            if let Some(&parent_index) = graph.indices.get(parent_id) {
+                if let Some(parent_commit) = graph.commits.get(parent_index) {
                     let to_column = commit_column(graph, parent_commit);
-                    let to = commit_coords(to_column, parent_index);
+                    let to = commit_coord(to_column, parent_index);
+                    let split_idx = get_deviate_index(graph, parent_index, index);
 
                     let edge = if from_column == to_column {
                         line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color.as_str(), stroke_width)
+                        path(from, to, split_idx, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -73,9 +71,9 @@
 
     let mut nodes = Group::new().set("id", "nodes");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let column = commit_column(graph, commit);
-        let center = commit_coords(column, index);
+        let center = commit_coord(column, index);
         let color = branch_color(graph, settings, commit);
 
         nodes = nodes.add(commit_dot(center, color.as_str()));
@@ -104,15 +102,15 @@
     info: &CommitInfo,
 ) -> Option<&'graph BranchInfo> {
     if let Some(trace) = info.branch_trace {
-        return graph.branches().get(trace);
+        return graph.branches.get(trace);
     }
 
     info.branches
         .iter()
-        .find_map(|index| graph.branches().get(*index))
+        .find_map(|index| graph.branches.get(*index))
 }
 
-fn commit_coords(column: Option<usize>, index: usize) -> Point {
+fn commit_coord(column: Option<usize>, index: usize) -> Point {
     let column = column.unwrap_or(0) as f64;
     let x = (column + 1.0) * COLUMN_STEP;
     let y = (index as f64 + 1.0) * ROW_STEP;
@@ -129,8 +127,18 @@
         .set("stroke-width", stroke_width)
 }
 
-fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
-    let control_x = (from.0 + to.0) / 2.0;
+fn path(from: Point, to: Point, split_idx: Option<usize>, color: &str, stroke_width: f64) -> Path {
+    let base = (from.0 + to.0) / 2.0;
+    let deviation = split_idx
+        .map(|idx| (idx as f64 + 1.0) * (COLUMN_STEP / 4.0))
+        .unwrap_or(0.0);
+    let control_x = if from.0 <= to.0 {
+        base + deviation
+    } else {
+        base - deviation
+    };
+
+    // TODO(021-573b442): Match the exact curvature used by the archived commit once samples are available.
     let data = Data::new()
         .move_to((from.0, from.1))
         .quadratic_curve_to((control_x, from.1, to.0, to.1));
@@ -168,7 +176,7 @@
         return color_for_group(group).to_string();
     }
 
-    settings.color_unknown.clone()
+    settings.branches.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


[2025-09-21T13:07:33] thinking

**Verifying new function implementation**
[2025-09-21T13:07:34] exec bash -lc 'rg "assign_branch_columns_branch_length" -n src/graph.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:07:34] bash -lc 'rg "assign_branch_columns_branch_length" -n src/graph.rs' succeeded in 16ms:
39:            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
46:            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
493:fn assign_branch_columns_branch_length(
[2025-09-21T13:07:34] tokens used: 147,203
[2025-09-21T13:07:34] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..8e0a891fd5f21f3d32a7a106bdde1da6cc86b860
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,33 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .filter(|oid| **oid == child_oid)
+        .next()
+        .map(|_| ordinal)
+}
diff --git a/src/print/svg.rs b/src/print/svg.rs
index 7e5205015e3442d8dbc56adf59970e3f751b6ce9..441167a7fad24952130a985128a6c4ebd4d2383f
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,5 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
+    print::get_deviate_index,
     settings::Settings,
 };
 use svg::node::element::path::Data;
@@ -19,20 +20,16 @@
 ];
 
 /// Renders the commit graph as an SVG string.
-///
-/// Known branch groups are colored with the curated palette above. Branches that cannot be
-/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
-/// submission.
 pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
-        .branches()
+        .branches
         .iter()
         .filter_map(|branch| branch.visual.column)
         .max()
         .unwrap_or(0);
 
     let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
-    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
+    let height = ((graph.commits.len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
 
     let mut document = Document::new()
         .set("viewBox", format!("0 0 {} {}", width, height))
@@ -41,26 +38,27 @@
 
     let mut edges = Group::new().set("id", "edges").set("fill", "none");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let from_column = commit_column(graph, commit);
-        let from = commit_coords(from_column, index);
+        let from = commit_coord(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && settings.debug {
+        let stroke_width = if commit.is_merge && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
         };
 
-        for parent_id in &commit.parent_ids {
-            if let Some(&parent_index) = graph.indices().get(parent_id) {
-                if let Some(parent_commit) = graph.commits().get(parent_index) {
+        for parent_id in commit.parents.iter().flatten() {
+            if let Some(&parent_index) = graph.indices.get(parent_id) {
+                if let Some(parent_commit) = graph.commits.get(parent_index) {
                     let to_column = commit_column(graph, parent_commit);
-                    let to = commit_coords(to_column, parent_index);
+                    let to = commit_coord(to_column, parent_index);
+                    let split_idx = get_deviate_index(graph, parent_index, index);
 
                     let edge = if from_column == to_column {
                         line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color.as_str(), stroke_width)
+                        path(from, to, split_idx, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -73,9 +71,9 @@
 
     let mut nodes = Group::new().set("id", "nodes");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let column = commit_column(graph, commit);
-        let center = commit_coords(column, index);
+        let center = commit_coord(column, index);
         let color = branch_color(graph, settings, commit);
 
         nodes = nodes.add(commit_dot(center, color.as_str()));
@@ -104,15 +102,15 @@
     info: &CommitInfo,
 ) -> Option<&'graph BranchInfo> {
     if let Some(trace) = info.branch_trace {
-        return graph.branches().get(trace);
+        return graph.branches.get(trace);
     }
 
     info.branches
         .iter()
-        .find_map(|index| graph.branches().get(*index))
+        .find_map(|index| graph.branches.get(*index))
 }
 
-fn commit_coords(column: Option<usize>, index: usize) -> Point {
+fn commit_coord(column: Option<usize>, index: usize) -> Point {
     let column = column.unwrap_or(0) as f64;
     let x = (column + 1.0) * COLUMN_STEP;
     let y = (index as f64 + 1.0) * ROW_STEP;
@@ -129,8 +127,18 @@
         .set("stroke-width", stroke_width)
 }
 
-fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
-    let control_x = (from.0 + to.0) / 2.0;
+fn path(from: Point, to: Point, split_idx: Option<usize>, color: &str, stroke_width: f64) -> Path {
+    let base = (from.0 + to.0) / 2.0;
+    let deviation = split_idx
+        .map(|idx| (idx as f64 + 1.0) * (COLUMN_STEP / 4.0))
+        .unwrap_or(0.0);
+    let control_x = if from.0 <= to.0 {
+        base + deviation
+    } else {
+        base - deviation
+    };
+
+    // TODO(021-573b442): Match the exact curvature used by the archived commit once samples are available.
     let data = Data::new()
         .move_to((from.0, from.1))
         .quadratic_curve_to((control_x, from.1, to.0, to.1));
@@ -168,7 +176,7 @@
         return color_for_group(group).to_string();
     }
 
-    settings.color_unknown.clone()
+    settings.branches.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.

[2025-09-21T13:07:36] exec bash -lc "sed -n '480,560p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:07:36] bash -lc "sed -n '480,560p' src/graph.rs" succeeded in 21ms:
        if let Some(column) = branch.visual.column {
            let offset = if branch.visual.order_group == 0 {
                0
            } else {
                group_offset[branch.visual.order_group - 1]
            };
            branch.visual.column = Some(column + offset);
        }
    }
}

/// Sorts branches into columns for visualization, that all branches can be
/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
fn assign_branch_columns_branch_length(
    _commits: &[CommitInfo],
    branches: &mut [BranchInfo],
    settings: &BranchSettings,
    forward: bool,
    longest_first: bool,
) {
[2025-09-21T13:07:36] tokens used: 147,515
[2025-09-21T13:07:36] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..8e0a891fd5f21f3d32a7a106bdde1da6cc86b860
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,33 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .filter(|oid| **oid == child_oid)
+        .next()
+        .map(|_| ordinal)
+}
diff --git a/src/print/svg.rs b/src/print/svg.rs
index 7e5205015e3442d8dbc56adf59970e3f751b6ce9..441167a7fad24952130a985128a6c4ebd4d2383f
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,5 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
+    print::get_deviate_index,
     settings::Settings,
 };
 use svg::node::element::path::Data;
@@ -19,20 +20,16 @@
 ];
 
 /// Renders the commit graph as an SVG string.
-///
-/// Known branch groups are colored with the curated palette above. Branches that cannot be
-/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
-/// submission.
 pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
-        .branches()
+        .branches
         .iter()
         .filter_map(|branch| branch.visual.column)
         .max()
         .unwrap_or(0);
 
     let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
-    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
+    let height = ((graph.commits.len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
 
     let mut document = Document::new()
         .set("viewBox", format!("0 0 {} {}", width, height))
@@ -41,26 +38,27 @@
 
     let mut edges = Group::new().set("id", "edges").set("fill", "none");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let from_column = commit_column(graph, commit);
-        let from = commit_coords(from_column, index);
+        let from = commit_coord(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && settings.debug {
+        let stroke_width = if commit.is_merge && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
         };
 
-        for parent_id in &commit.parent_ids {
-            if let Some(&parent_index) = graph.indices().get(parent_id) {
-                if let Some(parent_commit) = graph.commits().get(parent_index) {
+        for parent_id in commit.parents.iter().flatten() {
+            if let Some(&parent_index) = graph.indices.get(parent_id) {
+                if let Some(parent_commit) = graph.commits.get(parent_index) {
                     let to_column = commit_column(graph, parent_commit);
-                    let to = commit_coords(to_column, parent_index);
+                    let to = commit_coord(to_column, parent_index);
+                    let split_idx = get_deviate_index(graph, parent_index, index);
 
                     let edge = if from_column == to_column {
                         line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color.as_str(), stroke_width)
+                        path(from, to, split_idx, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -73,9 +71,9 @@
 
     let mut nodes = Group::new().set("id", "nodes");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let column = commit_column(graph, commit);
-        let center = commit_coords(column, index);
+        let center = commit_coord(column, index);
         let color = branch_color(graph, settings, commit);
 
         nodes = nodes.add(commit_dot(center, color.as_str()));
@@ -104,15 +102,15 @@
     info: &CommitInfo,
 ) -> Option<&'graph BranchInfo> {
     if let Some(trace) = info.branch_trace {
-        return graph.branches().get(trace);
+        return graph.branches.get(trace);
     }
 
     info.branches
         .iter()
-        .find_map(|index| graph.branches().get(*index))
+        .find_map(|index| graph.branches.get(*index))
 }
 
-fn commit_coords(column: Option<usize>, index: usize) -> Point {
+fn commit_coord(column: Option<usize>, index: usize) -> Point {
     let column = column.unwrap_or(0) as f64;
     let x = (column + 1.0) * COLUMN_STEP;
     let y = (index as f64 + 1.0) * ROW_STEP;
@@ -129,8 +127,18 @@
         .set("stroke-width", stroke_width)
 }
 
-fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
-    let control_x = (from.0 + to.0) / 2.0;
+fn path(from: Point, to: Point, split_idx: Option<usize>, color: &str, stroke_width: f64) -> Path {
+    let base = (from.0 + to.0) / 2.0;
+    let deviation = split_idx
+        .map(|idx| (idx as f64 + 1.0) * (COLUMN_STEP / 4.0))
+        .unwrap_or(0.0);
+    let control_x = if from.0 <= to.0 {
+        base + deviation
+    } else {
+        base - deviation
+    };
+
+    // TODO(021-573b442): Match the exact curvature used by the archived commit once samples are available.
     let data = Data::new()
         .move_to((from.0, from.1))
         .quadratic_curve_to((control_x, from.1, to.0, to.1));
@@ -168,7 +176,7 @@
         return color_for_group(group).to_string();
     }
 
-    settings.color_unknown.clone()
+    settings.branches.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


[2025-09-21T13:07:39] thinking

**Reviewing recent code changes**
[2025-09-21T13:07:39] exec bash -lc 'cat src/print/mod.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:07:39] bash -lc 'cat src/print/mod.rs' succeeded in 21ms:
pub mod svg;

use crate::graph::GitGraph;

/// Determine the zero-based position of `child_index` within the visible children of
/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
/// when multiple edges leave the same parent column.
pub fn get_deviate_index(
    graph: &GitGraph,
    parent_index: usize,
    child_index: usize,
) -> Option<usize> {
    let parent = graph.commits.get(parent_index)?;
    let child_oid = graph.commits.get(child_index)?.oid;

    let mut ordinal = 0usize;
    for candidate_oid in &parent.children {
        if let Some(&idx) = graph.indices.get(candidate_oid) {
            if idx == child_index {
                return Some(ordinal);
[2025-09-21T13:07:39] tokens used: 148,532
[2025-09-21T13:07:39] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..8e0a891fd5f21f3d32a7a106bdde1da6cc86b860
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,33 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .filter(|oid| **oid == child_oid)
+        .next()
+        .map(|_| ordinal)
+}
diff --git a/src/print/svg.rs b/src/print/svg.rs
index 7e5205015e3442d8dbc56adf59970e3f751b6ce9..441167a7fad24952130a985128a6c4ebd4d2383f
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,5 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
+    print::get_deviate_index,
     settings::Settings,
 };
 use svg::node::element::path::Data;
@@ -19,20 +20,16 @@
 ];
 
 /// Renders the commit graph as an SVG string.
-///
-/// Known branch groups are colored with the curated palette above. Branches that cannot be
-/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
-/// submission.
 pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
-        .branches()
+        .branches
         .iter()
         .filter_map(|branch| branch.visual.column)
         .max()
         .unwrap_or(0);
 
     let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
-    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
+    let height = ((graph.commits.len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
 
     let mut document = Document::new()
         .set("viewBox", format!("0 0 {} {}", width, height))
@@ -41,26 +38,27 @@
 
     let mut edges = Group::new().set("id", "edges").set("fill", "none");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let from_column = commit_column(graph, commit);
-        let from = commit_coords(from_column, index);
+        let from = commit_coord(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && settings.debug {
+        let stroke_width = if commit.is_merge && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
         };
 
-        for parent_id in &commit.parent_ids {
-            if let Some(&parent_index) = graph.indices().get(parent_id) {
-                if let Some(parent_commit) = graph.commits().get(parent_index) {
+        for parent_id in commit.parents.iter().flatten() {
+            if let Some(&parent_index) = graph.indices.get(parent_id) {
+                if let Some(parent_commit) = graph.commits.get(parent_index) {
                     let to_column = commit_column(graph, parent_commit);
-                    let to = commit_coords(to_column, parent_index);
+                    let to = commit_coord(to_column, parent_index);
+                    let split_idx = get_deviate_index(graph, parent_index, index);
 
                     let edge = if from_column == to_column {
                         line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color.as_str(), stroke_width)
+                        path(from, to, split_idx, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -73,9 +71,9 @@
 
     let mut nodes = Group::new().set("id", "nodes");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let column = commit_column(graph, commit);
-        let center = commit_coords(column, index);
+        let center = commit_coord(column, index);
         let color = branch_color(graph, settings, commit);
 
         nodes = nodes.add(commit_dot(center, color.as_str()));
@@ -104,15 +102,15 @@
     info: &CommitInfo,
 ) -> Option<&'graph BranchInfo> {
     if let Some(trace) = info.branch_trace {
-        return graph.branches().get(trace);
+        return graph.branches.get(trace);
     }
 
     info.branches
         .iter()
-        .find_map(|index| graph.branches().get(*index))
+        .find_map(|index| graph.branches.get(*index))
 }
 
-fn commit_coords(column: Option<usize>, index: usize) -> Point {
+fn commit_coord(column: Option<usize>, index: usize) -> Point {
     let column = column.unwrap_or(0) as f64;
     let x = (column + 1.0) * COLUMN_STEP;
     let y = (index as f64 + 1.0) * ROW_STEP;
@@ -129,8 +127,18 @@
         .set("stroke-width", stroke_width)
 }
 
-fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
-    let control_x = (from.0 + to.0) / 2.0;
+fn path(from: Point, to: Point, split_idx: Option<usize>, color: &str, stroke_width: f64) -> Path {
+    let base = (from.0 + to.0) / 2.0;
+    let deviation = split_idx
+        .map(|idx| (idx as f64 + 1.0) * (COLUMN_STEP / 4.0))
+        .unwrap_or(0.0);
+    let control_x = if from.0 <= to.0 {
+        base + deviation
+    } else {
+        base - deviation
+    };
+
+    // TODO(021-573b442): Match the exact curvature used by the archived commit once samples are available.
     let data = Data::new()
         .move_to((from.0, from.1))
         .quadratic_curve_to((control_x, from.1, to.0, to.1));
@@ -168,7 +176,7 @@
         return color_for_group(group).to_string();
     }
 
-    settings.color_unknown.clone()
+    settings.branches.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


[2025-09-21T13:07:46] thinking

**Improving child search with find**
[2025-09-21T13:07:48] tokens used: 157,543
[2025-09-21T13:07:48] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..8e0a891fd5f21f3d32a7a106bdde1da6cc86b860
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,33 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .filter(|oid| **oid == child_oid)
+        .next()
+        .map(|_| ordinal)
+}
diff --git a/src/print/svg.rs b/src/print/svg.rs
index 7e5205015e3442d8dbc56adf59970e3f751b6ce9..441167a7fad24952130a985128a6c4ebd4d2383f
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,5 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
+    print::get_deviate_index,
     settings::Settings,
 };
 use svg::node::element::path::Data;
@@ -19,20 +20,16 @@
 ];
 
 /// Renders the commit graph as an SVG string.
-///
-/// Known branch groups are colored with the curated palette above. Branches that cannot be
-/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
-/// submission.
 pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
-        .branches()
+        .branches
         .iter()
         .filter_map(|branch| branch.visual.column)
         .max()
         .unwrap_or(0);
 
     let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
-    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
+    let height = ((graph.commits.len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
 
     let mut document = Document::new()
         .set("viewBox", format!("0 0 {} {}", width, height))
@@ -41,26 +38,27 @@
 
     let mut edges = Group::new().set("id", "edges").set("fill", "none");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let from_column = commit_column(graph, commit);
-        let from = commit_coords(from_column, index);
+        let from = commit_coord(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && settings.debug {
+        let stroke_width = if commit.is_merge && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
         };
 
-        for parent_id in &commit.parent_ids {
-            if let Some(&parent_index) = graph.indices().get(parent_id) {
-                if let Some(parent_commit) = graph.commits().get(parent_index) {
+        for parent_id in commit.parents.iter().flatten() {
+            if let Some(&parent_index) = graph.indices.get(parent_id) {
+                if let Some(parent_commit) = graph.commits.get(parent_index) {
                     let to_column = commit_column(graph, parent_commit);
-                    let to = commit_coords(to_column, parent_index);
+                    let to = commit_coord(to_column, parent_index);
+                    let split_idx = get_deviate_index(graph, parent_index, index);
 
                     let edge = if from_column == to_column {
                         line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color.as_str(), stroke_width)
+                        path(from, to, split_idx, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -73,9 +71,9 @@
 
     let mut nodes = Group::new().set("id", "nodes");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let column = commit_column(graph, commit);
-        let center = commit_coords(column, index);
+        let center = commit_coord(column, index);
         let color = branch_color(graph, settings, commit);
 
         nodes = nodes.add(commit_dot(center, color.as_str()));
@@ -104,15 +102,15 @@
     info: &CommitInfo,
 ) -> Option<&'graph BranchInfo> {
     if let Some(trace) = info.branch_trace {
-        return graph.branches().get(trace);
+        return graph.branches.get(trace);
     }
 
     info.branches
         .iter()
-        .find_map(|index| graph.branches().get(*index))
+        .find_map(|index| graph.branches.get(*index))
 }
 
-fn commit_coords(column: Option<usize>, index: usize) -> Point {
+fn commit_coord(column: Option<usize>, index: usize) -> Point {
     let column = column.unwrap_or(0) as f64;
     let x = (column + 1.0) * COLUMN_STEP;
     let y = (index as f64 + 1.0) * ROW_STEP;
@@ -129,8 +127,18 @@
         .set("stroke-width", stroke_width)
 }
 
-fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
-    let control_x = (from.0 + to.0) / 2.0;
+fn path(from: Point, to: Point, split_idx: Option<usize>, color: &str, stroke_width: f64) -> Path {
+    let base = (from.0 + to.0) / 2.0;
+    let deviation = split_idx
+        .map(|idx| (idx as f64 + 1.0) * (COLUMN_STEP / 4.0))
+        .unwrap_or(0.0);
+    let control_x = if from.0 <= to.0 {
+        base + deviation
+    } else {
+        base - deviation
+    };
+
+    // TODO(021-573b442): Match the exact curvature used by the archived commit once samples are available.
     let data = Data::new()
         .move_to((from.0, from.1))
         .quadratic_curve_to((control_x, from.1, to.0, to.1));
@@ -168,7 +176,7 @@
         return color_for_group(group).to_string();
     }
 
-    settings.color_unknown.clone()
+    settings.branches.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


[2025-09-21T13:07:52] thinking

**Correcting patch context details**
[2025-09-21T13:07:53] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/mod.rs
@@ -29,4 +29,3 @@
         .iter()
-        .filter(|oid| **oid == child_oid)
-        .next()
+        .find(|oid| **oid == child_oid)
         .map(|_| ordinal)
[2025-09-21T13:07:53] apply_patch(auto_approved=true) exited 0 in 50ms:
Success. Updated the following files:
M src/print/mod.rs
[2025-09-21T13:07:53] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..79465f73ca472f9acc4789a552caff6b08d4aeac
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,32 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .find(|oid| **oid == child_oid)
+        .map(|_| ordinal)
+}
diff --git a/src/print/svg.rs b/src/print/svg.rs
index 7e5205015e3442d8dbc56adf59970e3f751b6ce9..441167a7fad24952130a985128a6c4ebd4d2383f
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,5 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
+    print::get_deviate_index,
     settings::Settings,
 };
 use svg::node::element::path::Data;
@@ -19,20 +20,16 @@
 ];
 
 /// Renders the commit graph as an SVG string.
-///
-/// Known branch groups are colored with the curated palette above. Branches that cannot be
-/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
-/// submission.
 pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
-        .branches()
+        .branches
         .iter()
         .filter_map(|branch| branch.visual.column)
         .max()
         .unwrap_or(0);
 
     let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
-    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
+    let height = ((graph.commits.len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
 
     let mut document = Document::new()
         .set("viewBox", format!("0 0 {} {}", width, height))
@@ -41,26 +38,27 @@
 
     let mut edges = Group::new().set("id", "edges").set("fill", "none");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let from_column = commit_column(graph, commit);
-        let from = commit_coords(from_column, index);
+        let from = commit_coord(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && settings.debug {
+        let stroke_width = if commit.is_merge && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
         };
 
-        for parent_id in &commit.parent_ids {
-            if let Some(&parent_index) = graph.indices().get(parent_id) {
-                if let Some(parent_commit) = graph.commits().get(parent_index) {
+        for parent_id in commit.parents.iter().flatten() {
+            if let Some(&parent_index) = graph.indices.get(parent_id) {
+                if let Some(parent_commit) = graph.commits.get(parent_index) {
                     let to_column = commit_column(graph, parent_commit);
-                    let to = commit_coords(to_column, parent_index);
+                    let to = commit_coord(to_column, parent_index);
+                    let split_idx = get_deviate_index(graph, parent_index, index);
 
                     let edge = if from_column == to_column {
                         line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color.as_str(), stroke_width)
+                        path(from, to, split_idx, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -73,9 +71,9 @@
 
     let mut nodes = Group::new().set("id", "nodes");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let column = commit_column(graph, commit);
-        let center = commit_coords(column, index);
+        let center = commit_coord(column, index);
         let color = branch_color(graph, settings, commit);
 
         nodes = nodes.add(commit_dot(center, color.as_str()));
@@ -104,15 +102,15 @@
     info: &CommitInfo,
 ) -> Option<&'graph BranchInfo> {
     if let Some(trace) = info.branch_trace {
-        return graph.branches().get(trace);
+        return graph.branches.get(trace);
     }
 
     info.branches
         .iter()
-        .find_map(|index| graph.branches().get(*index))
+        .find_map(|index| graph.branches.get(*index))
 }
 
-fn commit_coords(column: Option<usize>, index: usize) -> Point {
+fn commit_coord(column: Option<usize>, index: usize) -> Point {
     let column = column.unwrap_or(0) as f64;
     let x = (column + 1.0) * COLUMN_STEP;
     let y = (index as f64 + 1.0) * ROW_STEP;
@@ -129,8 +127,18 @@
         .set("stroke-width", stroke_width)
 }
 
-fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
-    let control_x = (from.0 + to.0) / 2.0;
+fn path(from: Point, to: Point, split_idx: Option<usize>, color: &str, stroke_width: f64) -> Path {
+    let base = (from.0 + to.0) / 2.0;
+    let deviation = split_idx
+        .map(|idx| (idx as f64 + 1.0) * (COLUMN_STEP / 4.0))
+        .unwrap_or(0.0);
+    let control_x = if from.0 <= to.0 {
+        base + deviation
+    } else {
+        base - deviation
+    };
+
+    // TODO(021-573b442): Match the exact curvature used by the archived commit once samples are available.
     let data = Data::new()
         .move_to((from.0, from.1))
         .quadratic_curve_to((control_x, from.1, to.0, to.1));
@@ -168,7 +176,7 @@
         return color_for_group(group).to_string();
     }
 
-    settings.color_unknown.clone()
+    settings.branches.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.

[2025-09-21T13:07:53] tokens used: 157,926
[2025-09-21T13:07:53] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..79465f73ca472f9acc4789a552caff6b08d4aeac
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,32 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .find(|oid| **oid == child_oid)
+        .map(|_| ordinal)
+}
diff --git a/src/print/svg.rs b/src/print/svg.rs
index 7e5205015e3442d8dbc56adf59970e3f751b6ce9..441167a7fad24952130a985128a6c4ebd4d2383f
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,5 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
+    print::get_deviate_index,
     settings::Settings,
 };
 use svg::node::element::path::Data;
@@ -19,20 +20,16 @@
 ];
 
 /// Renders the commit graph as an SVG string.
-///
-/// Known branch groups are colored with the curated palette above. Branches that cannot be
-/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
-/// submission.
 pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
-        .branches()
+        .branches
         .iter()
         .filter_map(|branch| branch.visual.column)
         .max()
         .unwrap_or(0);
 
     let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
-    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
+    let height = ((graph.commits.len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
 
     let mut document = Document::new()
         .set("viewBox", format!("0 0 {} {}", width, height))
@@ -41,26 +38,27 @@
 
     let mut edges = Group::new().set("id", "edges").set("fill", "none");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let from_column = commit_column(graph, commit);
-        let from = commit_coords(from_column, index);
+        let from = commit_coord(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && settings.debug {
+        let stroke_width = if commit.is_merge && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
         };
 
-        for parent_id in &commit.parent_ids {
-            if let Some(&parent_index) = graph.indices().get(parent_id) {
-                if let Some(parent_commit) = graph.commits().get(parent_index) {
+        for parent_id in commit.parents.iter().flatten() {
+            if let Some(&parent_index) = graph.indices.get(parent_id) {
+                if let Some(parent_commit) = graph.commits.get(parent_index) {
                     let to_column = commit_column(graph, parent_commit);
-                    let to = commit_coords(to_column, parent_index);
+                    let to = commit_coord(to_column, parent_index);
+                    let split_idx = get_deviate_index(graph, parent_index, index);
 
                     let edge = if from_column == to_column {
                         line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color.as_str(), stroke_width)
+                        path(from, to, split_idx, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -73,9 +71,9 @@
 
     let mut nodes = Group::new().set("id", "nodes");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let column = commit_column(graph, commit);
-        let center = commit_coords(column, index);
+        let center = commit_coord(column, index);
         let color = branch_color(graph, settings, commit);
 
         nodes = nodes.add(commit_dot(center, color.as_str()));
@@ -104,15 +102,15 @@
     info: &CommitInfo,
 ) -> Option<&'graph BranchInfo> {
     if let Some(trace) = info.branch_trace {
-        return graph.branches().get(trace);
+        return graph.branches.get(trace);
     }
 
     info.branches
         .iter()
-        .find_map(|index| graph.branches().get(*index))
+        .find_map(|index| graph.branches.get(*index))
 }
 
-fn commit_coords(column: Option<usize>, index: usize) -> Point {
+fn commit_coord(column: Option<usize>, index: usize) -> Point {
     let column = column.unwrap_or(0) as f64;
     let x = (column + 1.0) * COLUMN_STEP;
     let y = (index as f64 + 1.0) * ROW_STEP;
@@ -129,8 +127,18 @@
         .set("stroke-width", stroke_width)
 }
 
-fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
-    let control_x = (from.0 + to.0) / 2.0;
+fn path(from: Point, to: Point, split_idx: Option<usize>, color: &str, stroke_width: f64) -> Path {
+    let base = (from.0 + to.0) / 2.0;
+    let deviation = split_idx
+        .map(|idx| (idx as f64 + 1.0) * (COLUMN_STEP / 4.0))
+        .unwrap_or(0.0);
+    let control_x = if from.0 <= to.0 {
+        base + deviation
+    } else {
+        base - deviation
+    };
+
+    // TODO(021-573b442): Match the exact curvature used by the archived commit once samples are available.
     let data = Data::new()
         .move_to((from.0, from.1))
         .quadratic_curve_to((control_x, from.1, to.0, to.1));
@@ -168,7 +176,7 @@
         return color_for_group(group).to_string();
     }
 
-    settings.color_unknown.clone()
+    settings.branches.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


[2025-09-21T13:07:55] thinking

**Running cargo fmt for formatting**
[2025-09-21T13:07:56] exec bash -lc 'cargo fmt' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:07:56] bash -lc 'cargo fmt' succeeded in 74ms:

[2025-09-21T13:07:56] tokens used: 165,203
[2025-09-21T13:07:56] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..79465f73ca472f9acc4789a552caff6b08d4aeac
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,32 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .find(|oid| **oid == child_oid)
+        .map(|_| ordinal)
+}
diff --git a/src/print/svg.rs b/src/print/svg.rs
index 7e5205015e3442d8dbc56adf59970e3f751b6ce9..441167a7fad24952130a985128a6c4ebd4d2383f
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,5 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
+    print::get_deviate_index,
     settings::Settings,
 };
 use svg::node::element::path::Data;
@@ -19,20 +20,16 @@
 ];
 
 /// Renders the commit graph as an SVG string.
-///
-/// Known branch groups are colored with the curated palette above. Branches that cannot be
-/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
-/// submission.
 pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
-        .branches()
+        .branches
         .iter()
         .filter_map(|branch| branch.visual.column)
         .max()
         .unwrap_or(0);
 
     let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
-    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
+    let height = ((graph.commits.len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
 
     let mut document = Document::new()
         .set("viewBox", format!("0 0 {} {}", width, height))
@@ -41,26 +38,27 @@
 
     let mut edges = Group::new().set("id", "edges").set("fill", "none");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let from_column = commit_column(graph, commit);
-        let from = commit_coords(from_column, index);
+        let from = commit_coord(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && settings.debug {
+        let stroke_width = if commit.is_merge && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
         };
 
-        for parent_id in &commit.parent_ids {
-            if let Some(&parent_index) = graph.indices().get(parent_id) {
-                if let Some(parent_commit) = graph.commits().get(parent_index) {
+        for parent_id in commit.parents.iter().flatten() {
+            if let Some(&parent_index) = graph.indices.get(parent_id) {
+                if let Some(parent_commit) = graph.commits.get(parent_index) {
                     let to_column = commit_column(graph, parent_commit);
-                    let to = commit_coords(to_column, parent_index);
+                    let to = commit_coord(to_column, parent_index);
+                    let split_idx = get_deviate_index(graph, parent_index, index);
 
                     let edge = if from_column == to_column {
                         line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color.as_str(), stroke_width)
+                        path(from, to, split_idx, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -73,9 +71,9 @@
 
     let mut nodes = Group::new().set("id", "nodes");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let column = commit_column(graph, commit);
-        let center = commit_coords(column, index);
+        let center = commit_coord(column, index);
         let color = branch_color(graph, settings, commit);
 
         nodes = nodes.add(commit_dot(center, color.as_str()));
@@ -104,15 +102,15 @@
     info: &CommitInfo,
 ) -> Option<&'graph BranchInfo> {
     if let Some(trace) = info.branch_trace {
-        return graph.branches().get(trace);
+        return graph.branches.get(trace);
     }
 
     info.branches
         .iter()
-        .find_map(|index| graph.branches().get(*index))
+        .find_map(|index| graph.branches.get(*index))
 }
 
-fn commit_coords(column: Option<usize>, index: usize) -> Point {
+fn commit_coord(column: Option<usize>, index: usize) -> Point {
     let column = column.unwrap_or(0) as f64;
     let x = (column + 1.0) * COLUMN_STEP;
     let y = (index as f64 + 1.0) * ROW_STEP;
@@ -129,8 +127,18 @@
         .set("stroke-width", stroke_width)
 }
 
-fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
-    let control_x = (from.0 + to.0) / 2.0;
+fn path(from: Point, to: Point, split_idx: Option<usize>, color: &str, stroke_width: f64) -> Path {
+    let base = (from.0 + to.0) / 2.0;
+    let deviation = split_idx
+        .map(|idx| (idx as f64 + 1.0) * (COLUMN_STEP / 4.0))
+        .unwrap_or(0.0);
+    let control_x = if from.0 <= to.0 {
+        base + deviation
+    } else {
+        base - deviation
+    };
+
+    // TODO(021-573b442): Match the exact curvature used by the archived commit once samples are available.
     let data = Data::new()
         .move_to((from.0, from.1))
         .quadratic_curve_to((control_x, from.1, to.0, to.1));
@@ -168,7 +176,7 @@
         return color_for_group(group).to_string();
     }
 
-    settings.color_unknown.clone()
+    settings.branches.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


[2025-09-21T13:08:10] thinking

**Verifying build and test process**
[2025-09-21T13:08:11] exec bash -lc 'cargo check --locked' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:08:11] bash -lc 'cargo check --locked' exited 101 in 20ms:
error: checksum for `svg v0.8.0` changed between lock files

this could be indicative of a few possible errors:

    * the lock file is corrupt
    * a replacement source in use (e.g., a mirror) returned a different checksum
    * the source itself may be corrupt in one way or another

unable to verify that `svg v0.8.0` is the same as when the lockfile was generated

[2025-09-21T13:08:11] tokens used: 166,431
[2025-09-21T13:08:11] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..79465f73ca472f9acc4789a552caff6b08d4aeac
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,32 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .find(|oid| **oid == child_oid)
+        .map(|_| ordinal)
+}
diff --git a/src/print/svg.rs b/src/print/svg.rs
index 7e5205015e3442d8dbc56adf59970e3f751b6ce9..441167a7fad24952130a985128a6c4ebd4d2383f
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,5 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
+    print::get_deviate_index,
     settings::Settings,
 };
 use svg::node::element::path::Data;
@@ -19,20 +20,16 @@
 ];
 
 /// Renders the commit graph as an SVG string.
-///
-/// Known branch groups are colored with the curated palette above. Branches that cannot be
-/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
-/// submission.
 pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
-        .branches()
+        .branches
         .iter()
         .filter_map(|branch| branch.visual.column)
         .max()
         .unwrap_or(0);
 
     let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
-    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
+    let height = ((graph.commits.len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
 
     let mut document = Document::new()
         .set("viewBox", format!("0 0 {} {}", width, height))
@@ -41,26 +38,27 @@
 
     let mut edges = Group::new().set("id", "edges").set("fill", "none");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let from_column = commit_column(graph, commit);
-        let from = commit_coords(from_column, index);
+        let from = commit_coord(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && settings.debug {
+        let stroke_width = if commit.is_merge && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
         };
 
-        for parent_id in &commit.parent_ids {
-            if let Some(&parent_index) = graph.indices().get(parent_id) {
-                if let Some(parent_commit) = graph.commits().get(parent_index) {
+        for parent_id in commit.parents.iter().flatten() {
+            if let Some(&parent_index) = graph.indices.get(parent_id) {
+                if let Some(parent_commit) = graph.commits.get(parent_index) {
                     let to_column = commit_column(graph, parent_commit);
-                    let to = commit_coords(to_column, parent_index);
+                    let to = commit_coord(to_column, parent_index);
+                    let split_idx = get_deviate_index(graph, parent_index, index);
 
                     let edge = if from_column == to_column {
                         line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color.as_str(), stroke_width)
+                        path(from, to, split_idx, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -73,9 +71,9 @@
 
     let mut nodes = Group::new().set("id", "nodes");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let column = commit_column(graph, commit);
-        let center = commit_coords(column, index);
+        let center = commit_coord(column, index);
         let color = branch_color(graph, settings, commit);
 
         nodes = nodes.add(commit_dot(center, color.as_str()));
@@ -104,15 +102,15 @@
     info: &CommitInfo,
 ) -> Option<&'graph BranchInfo> {
     if let Some(trace) = info.branch_trace {
-        return graph.branches().get(trace);
+        return graph.branches.get(trace);
     }
 
     info.branches
         .iter()
-        .find_map(|index| graph.branches().get(*index))
+        .find_map(|index| graph.branches.get(*index))
 }
 
-fn commit_coords(column: Option<usize>, index: usize) -> Point {
+fn commit_coord(column: Option<usize>, index: usize) -> Point {
     let column = column.unwrap_or(0) as f64;
     let x = (column + 1.0) * COLUMN_STEP;
     let y = (index as f64 + 1.0) * ROW_STEP;
@@ -129,8 +127,18 @@
         .set("stroke-width", stroke_width)
 }
 
-fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
-    let control_x = (from.0 + to.0) / 2.0;
+fn path(from: Point, to: Point, split_idx: Option<usize>, color: &str, stroke_width: f64) -> Path {
+    let base = (from.0 + to.0) / 2.0;
+    let deviation = split_idx
+        .map(|idx| (idx as f64 + 1.0) * (COLUMN_STEP / 4.0))
+        .unwrap_or(0.0);
+    let control_x = if from.0 <= to.0 {
+        base + deviation
+    } else {
+        base - deviation
+    };
+
+    // TODO(021-573b442): Match the exact curvature used by the archived commit once samples are available.
     let data = Data::new()
         .move_to((from.0, from.1))
         .quadratic_curve_to((control_x, from.1, to.0, to.1));
@@ -168,7 +176,7 @@
         return color_for_group(group).to_string();
     }
 
-    settings.color_unknown.clone()
+    settings.branches.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


[2025-09-21T13:08:14] thinking

**Preparing to commit changes**
[2025-09-21T13:08:14] exec bash -lc 'git add -A' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:08:14] bash -lc 'git add -A' succeeded in 30ms:

[2025-09-21T13:08:14] tokens used: 166,740
[2025-09-21T13:08:14] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..79465f73ca472f9acc4789a552caff6b08d4aeac
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,32 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .find(|oid| **oid == child_oid)
+        .map(|_| ordinal)
+}
diff --git a/src/print/svg.rs b/src/print/svg.rs
index 7e5205015e3442d8dbc56adf59970e3f751b6ce9..441167a7fad24952130a985128a6c4ebd4d2383f
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,5 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
+    print::get_deviate_index,
     settings::Settings,
 };
 use svg::node::element::path::Data;
@@ -19,20 +20,16 @@
 ];
 
 /// Renders the commit graph as an SVG string.
-///
-/// Known branch groups are colored with the curated palette above. Branches that cannot be
-/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
-/// submission.
 pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
-        .branches()
+        .branches
         .iter()
         .filter_map(|branch| branch.visual.column)
         .max()
         .unwrap_or(0);
 
     let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
-    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
+    let height = ((graph.commits.len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
 
     let mut document = Document::new()
         .set("viewBox", format!("0 0 {} {}", width, height))
@@ -41,26 +38,27 @@
 
     let mut edges = Group::new().set("id", "edges").set("fill", "none");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let from_column = commit_column(graph, commit);
-        let from = commit_coords(from_column, index);
+        let from = commit_coord(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && settings.debug {
+        let stroke_width = if commit.is_merge && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
         };
 
-        for parent_id in &commit.parent_ids {
-            if let Some(&parent_index) = graph.indices().get(parent_id) {
-                if let Some(parent_commit) = graph.commits().get(parent_index) {
+        for parent_id in commit.parents.iter().flatten() {
+            if let Some(&parent_index) = graph.indices.get(parent_id) {
+                if let Some(parent_commit) = graph.commits.get(parent_index) {
                     let to_column = commit_column(graph, parent_commit);
-                    let to = commit_coords(to_column, parent_index);
+                    let to = commit_coord(to_column, parent_index);
+                    let split_idx = get_deviate_index(graph, parent_index, index);
 
                     let edge = if from_column == to_column {
                         line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color.as_str(), stroke_width)
+                        path(from, to, split_idx, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -73,9 +71,9 @@
 
     let mut nodes = Group::new().set("id", "nodes");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let column = commit_column(graph, commit);
-        let center = commit_coords(column, index);
+        let center = commit_coord(column, index);
         let color = branch_color(graph, settings, commit);
 
         nodes = nodes.add(commit_dot(center, color.as_str()));
@@ -104,15 +102,15 @@
     info: &CommitInfo,
 ) -> Option<&'graph BranchInfo> {
     if let Some(trace) = info.branch_trace {
-        return graph.branches().get(trace);
+        return graph.branches.get(trace);
     }
 
     info.branches
         .iter()
-        .find_map(|index| graph.branches().get(*index))
+        .find_map(|index| graph.branches.get(*index))
 }
 
-fn commit_coords(column: Option<usize>, index: usize) -> Point {
+fn commit_coord(column: Option<usize>, index: usize) -> Point {
     let column = column.unwrap_or(0) as f64;
     let x = (column + 1.0) * COLUMN_STEP;
     let y = (index as f64 + 1.0) * ROW_STEP;
@@ -129,8 +127,18 @@
         .set("stroke-width", stroke_width)
 }
 
-fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
-    let control_x = (from.0 + to.0) / 2.0;
+fn path(from: Point, to: Point, split_idx: Option<usize>, color: &str, stroke_width: f64) -> Path {
+    let base = (from.0 + to.0) / 2.0;
+    let deviation = split_idx
+        .map(|idx| (idx as f64 + 1.0) * (COLUMN_STEP / 4.0))
+        .unwrap_or(0.0);
+    let control_x = if from.0 <= to.0 {
+        base + deviation
+    } else {
+        base - deviation
+    };
+
+    // TODO(021-573b442): Match the exact curvature used by the archived commit once samples are available.
     let data = Data::new()
         .move_to((from.0, from.1))
         .quadratic_curve_to((control_x, from.1, to.0, to.1));
@@ -168,7 +176,7 @@
         return color_for_group(group).to_string();
     }
 
-    settings.color_unknown.clone()
+    settings.branches.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


[2025-09-21T13:08:18] thinking

**Committing changes**
[2025-09-21T13:08:18] exec bash -lc 'git commit -m "021-573b442：复现提交代码内容。"' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:08:18] bash -lc 'git commit -m "021-573b442：复现提交代码内容。"' succeeded in 32ms:
[main 8a95d12] 021-573b442：复现提交代码内容。
 4 files changed, 85 insertions(+), 26 deletions(-)
[2025-09-21T13:08:18] tokens used: 212,117
[2025-09-21T13:08:18] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..79465f73ca472f9acc4789a552caff6b08d4aeac
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,32 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .find(|oid| **oid == child_oid)
+        .map(|_| ordinal)
+}
diff --git a/src/print/svg.rs b/src/print/svg.rs
index 7e5205015e3442d8dbc56adf59970e3f751b6ce9..441167a7fad24952130a985128a6c4ebd4d2383f
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,5 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
+    print::get_deviate_index,
     settings::Settings,
 };
 use svg::node::element::path::Data;
@@ -19,20 +20,16 @@
 ];
 
 /// Renders the commit graph as an SVG string.
-///
-/// Known branch groups are colored with the curated palette above. Branches that cannot be
-/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
-/// submission.
 pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
-        .branches()
+        .branches
         .iter()
         .filter_map(|branch| branch.visual.column)
         .max()
         .unwrap_or(0);
 
     let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
-    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
+    let height = ((graph.commits.len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
 
     let mut document = Document::new()
         .set("viewBox", format!("0 0 {} {}", width, height))
@@ -41,26 +38,27 @@
 
     let mut edges = Group::new().set("id", "edges").set("fill", "none");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let from_column = commit_column(graph, commit);
-        let from = commit_coords(from_column, index);
+        let from = commit_coord(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && settings.debug {
+        let stroke_width = if commit.is_merge && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
         };
 
-        for parent_id in &commit.parent_ids {
-            if let Some(&parent_index) = graph.indices().get(parent_id) {
-                if let Some(parent_commit) = graph.commits().get(parent_index) {
+        for parent_id in commit.parents.iter().flatten() {
+            if let Some(&parent_index) = graph.indices.get(parent_id) {
+                if let Some(parent_commit) = graph.commits.get(parent_index) {
                     let to_column = commit_column(graph, parent_commit);
-                    let to = commit_coords(to_column, parent_index);
+                    let to = commit_coord(to_column, parent_index);
+                    let split_idx = get_deviate_index(graph, parent_index, index);
 
                     let edge = if from_column == to_column {
                         line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color.as_str(), stroke_width)
+                        path(from, to, split_idx, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -73,9 +71,9 @@
 
     let mut nodes = Group::new().set("id", "nodes");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let column = commit_column(graph, commit);
-        let center = commit_coords(column, index);
+        let center = commit_coord(column, index);
         let color = branch_color(graph, settings, commit);
 
         nodes = nodes.add(commit_dot(center, color.as_str()));
@@ -104,15 +102,15 @@
     info: &CommitInfo,
 ) -> Option<&'graph BranchInfo> {
     if let Some(trace) = info.branch_trace {
-        return graph.branches().get(trace);
+        return graph.branches.get(trace);
     }
 
     info.branches
         .iter()
-        .find_map(|index| graph.branches().get(*index))
+        .find_map(|index| graph.branches.get(*index))
 }
 
-fn commit_coords(column: Option<usize>, index: usize) -> Point {
+fn commit_coord(column: Option<usize>, index: usize) -> Point {
     let column = column.unwrap_or(0) as f64;
     let x = (column + 1.0) * COLUMN_STEP;
     let y = (index as f64 + 1.0) * ROW_STEP;
@@ -129,8 +127,18 @@
         .set("stroke-width", stroke_width)
 }
 
-fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
-    let control_x = (from.0 + to.0) / 2.0;
+fn path(from: Point, to: Point, split_idx: Option<usize>, color: &str, stroke_width: f64) -> Path {
+    let base = (from.0 + to.0) / 2.0;
+    let deviation = split_idx
+        .map(|idx| (idx as f64 + 1.0) * (COLUMN_STEP / 4.0))
+        .unwrap_or(0.0);
+    let control_x = if from.0 <= to.0 {
+        base + deviation
+    } else {
+        base - deviation
+    };
+
+    // TODO(021-573b442): Match the exact curvature used by the archived commit once samples are available.
     let data = Data::new()
         .move_to((from.0, from.1))
         .quadratic_curve_to((control_x, from.1, to.0, to.1));
@@ -168,7 +176,7 @@
         return color_for_group(group).to_string();
     }
 
-    settings.color_unknown.clone()
+    settings.branches.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


[2025-09-21T13:08:22] thinking

**Preparing final summary and confirmation**
[2025-09-21T13:08:23] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:08:23] bash -lc 'git status -sb' succeeded in 35ms:
## main
[2025-09-21T13:08:23] tokens used: 213,203
[2025-09-21T13:08:23] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..79465f73ca472f9acc4789a552caff6b08d4aeac
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,32 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .find(|oid| **oid == child_oid)
+        .map(|_| ordinal)
+}
diff --git a/src/print/svg.rs b/src/print/svg.rs
index 7e5205015e3442d8dbc56adf59970e3f751b6ce9..441167a7fad24952130a985128a6c4ebd4d2383f
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,5 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
+    print::get_deviate_index,
     settings::Settings,
 };
 use svg::node::element::path::Data;
@@ -19,20 +20,16 @@
 ];
 
 /// Renders the commit graph as an SVG string.
-///
-/// Known branch groups are colored with the curated palette above. Branches that cannot be
-/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
-/// submission.
 pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
-        .branches()
+        .branches
         .iter()
         .filter_map(|branch| branch.visual.column)
         .max()
         .unwrap_or(0);
 
     let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
-    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
+    let height = ((graph.commits.len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
 
     let mut document = Document::new()
         .set("viewBox", format!("0 0 {} {}", width, height))
@@ -41,26 +38,27 @@
 
     let mut edges = Group::new().set("id", "edges").set("fill", "none");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let from_column = commit_column(graph, commit);
-        let from = commit_coords(from_column, index);
+        let from = commit_coord(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && settings.debug {
+        let stroke_width = if commit.is_merge && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
         };
 
-        for parent_id in &commit.parent_ids {
-            if let Some(&parent_index) = graph.indices().get(parent_id) {
-                if let Some(parent_commit) = graph.commits().get(parent_index) {
+        for parent_id in commit.parents.iter().flatten() {
+            if let Some(&parent_index) = graph.indices.get(parent_id) {
+                if let Some(parent_commit) = graph.commits.get(parent_index) {
                     let to_column = commit_column(graph, parent_commit);
-                    let to = commit_coords(to_column, parent_index);
+                    let to = commit_coord(to_column, parent_index);
+                    let split_idx = get_deviate_index(graph, parent_index, index);
 
                     let edge = if from_column == to_column {
                         line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color.as_str(), stroke_width)
+                        path(from, to, split_idx, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -73,9 +71,9 @@
 
     let mut nodes = Group::new().set("id", "nodes");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let column = commit_column(graph, commit);
-        let center = commit_coords(column, index);
+        let center = commit_coord(column, index);
         let color = branch_color(graph, settings, commit);
 
         nodes = nodes.add(commit_dot(center, color.as_str()));
@@ -104,15 +102,15 @@
     info: &CommitInfo,
 ) -> Option<&'graph BranchInfo> {
     if let Some(trace) = info.branch_trace {
-        return graph.branches().get(trace);
+        return graph.branches.get(trace);
     }
 
     info.branches
         .iter()
-        .find_map(|index| graph.branches().get(*index))
+        .find_map(|index| graph.branches.get(*index))
 }
 
-fn commit_coords(column: Option<usize>, index: usize) -> Point {
+fn commit_coord(column: Option<usize>, index: usize) -> Point {
     let column = column.unwrap_or(0) as f64;
     let x = (column + 1.0) * COLUMN_STEP;
     let y = (index as f64 + 1.0) * ROW_STEP;
@@ -129,8 +127,18 @@
         .set("stroke-width", stroke_width)
 }
 
-fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
-    let control_x = (from.0 + to.0) / 2.0;
+fn path(from: Point, to: Point, split_idx: Option<usize>, color: &str, stroke_width: f64) -> Path {
+    let base = (from.0 + to.0) / 2.0;
+    let deviation = split_idx
+        .map(|idx| (idx as f64 + 1.0) * (COLUMN_STEP / 4.0))
+        .unwrap_or(0.0);
+    let control_x = if from.0 <= to.0 {
+        base + deviation
+    } else {
+        base - deviation
+    };
+
+    // TODO(021-573b442): Match the exact curvature used by the archived commit once samples are available.
     let data = Data::new()
         .move_to((from.0, from.1))
         .quadratic_curve_to((control_x, from.1, to.0, to.1));
@@ -168,7 +176,7 @@
         return color_for_group(group).to_string();
     }
 
-    settings.color_unknown.clone()
+    settings.branches.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


[2025-09-21T13:08:29] thinking

**Preparing final message details**
[2025-09-21T13:08:30] exec bash -lc "nl -ba src/settings.rs | sed -n '1,80p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:08:30] bash -lc "nl -ba src/settings.rs | sed -n '1,80p'" succeeded in 30ms:
     1	use regex::Regex;
     2	
     3	/// Ordering policy for branches in visual columns.
     4	pub enum BranchOrder {
     5	    /// Recommended! Shortest branches are inserted left-most.
     6	    ///
     7	    /// For branches with equal length, branches ending last are inserted first.
     8	    /// Reverse (arg = false): Branches ending first are inserted first.
     9	    ShortestFirst(bool),
    10	    /// Longest branches are inserted left-most.
    11	    ///
    12	    /// For branches with equal length, branches ending last are inserted first.
    13	    /// Reverse (arg = false): Branches starting first are inserted first.
    14	    LongestFirst(bool),
    15	    /// Branches ending last are inserted left-most.
    16	    ///
    17	    /// Reverse (arg = false): Branches starting first are inserted left-most.
    18	    FirstComeFirstServed(bool),
    19	}
    20	
[2025-09-21T13:08:30] tokens used: 214,279
[2025-09-21T13:08:30] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..79465f73ca472f9acc4789a552caff6b08d4aeac
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,32 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .find(|oid| **oid == child_oid)
+        .map(|_| ordinal)
+}
diff --git a/src/print/svg.rs b/src/print/svg.rs
index 7e5205015e3442d8dbc56adf59970e3f751b6ce9..441167a7fad24952130a985128a6c4ebd4d2383f
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,5 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
+    print::get_deviate_index,
     settings::Settings,
 };
 use svg::node::element::path::Data;
@@ -19,20 +20,16 @@
 ];
 
 /// Renders the commit graph as an SVG string.
-///
-/// Known branch groups are colored with the curated palette above. Branches that cannot be
-/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
-/// submission.
 pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
-        .branches()
+        .branches
         .iter()
         .filter_map(|branch| branch.visual.column)
         .max()
         .unwrap_or(0);
 
     let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
-    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
+    let height = ((graph.commits.len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
 
     let mut document = Document::new()
         .set("viewBox", format!("0 0 {} {}", width, height))
@@ -41,26 +38,27 @@
 
     let mut edges = Group::new().set("id", "edges").set("fill", "none");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let from_column = commit_column(graph, commit);
-        let from = commit_coords(from_column, index);
+        let from = commit_coord(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && settings.debug {
+        let stroke_width = if commit.is_merge && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
         };
 
-        for parent_id in &commit.parent_ids {
-            if let Some(&parent_index) = graph.indices().get(parent_id) {
-                if let Some(parent_commit) = graph.commits().get(parent_index) {
+        for parent_id in commit.parents.iter().flatten() {
+            if let Some(&parent_index) = graph.indices.get(parent_id) {
+                if let Some(parent_commit) = graph.commits.get(parent_index) {
                     let to_column = commit_column(graph, parent_commit);
-                    let to = commit_coords(to_column, parent_index);
+                    let to = commit_coord(to_column, parent_index);
+                    let split_idx = get_deviate_index(graph, parent_index, index);
 
                     let edge = if from_column == to_column {
                         line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color.as_str(), stroke_width)
+                        path(from, to, split_idx, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -73,9 +71,9 @@
 
     let mut nodes = Group::new().set("id", "nodes");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let column = commit_column(graph, commit);
-        let center = commit_coords(column, index);
+        let center = commit_coord(column, index);
         let color = branch_color(graph, settings, commit);
 
         nodes = nodes.add(commit_dot(center, color.as_str()));
@@ -104,15 +102,15 @@
     info: &CommitInfo,
 ) -> Option<&'graph BranchInfo> {
     if let Some(trace) = info.branch_trace {
-        return graph.branches().get(trace);
+        return graph.branches.get(trace);
     }
 
     info.branches
         .iter()
-        .find_map(|index| graph.branches().get(*index))
+        .find_map(|index| graph.branches.get(*index))
 }
 
-fn commit_coords(column: Option<usize>, index: usize) -> Point {
+fn commit_coord(column: Option<usize>, index: usize) -> Point {
     let column = column.unwrap_or(0) as f64;
     let x = (column + 1.0) * COLUMN_STEP;
     let y = (index as f64 + 1.0) * ROW_STEP;
@@ -129,8 +127,18 @@
         .set("stroke-width", stroke_width)
 }
 
-fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
-    let control_x = (from.0 + to.0) / 2.0;
+fn path(from: Point, to: Point, split_idx: Option<usize>, color: &str, stroke_width: f64) -> Path {
+    let base = (from.0 + to.0) / 2.0;
+    let deviation = split_idx
+        .map(|idx| (idx as f64 + 1.0) * (COLUMN_STEP / 4.0))
+        .unwrap_or(0.0);
+    let control_x = if from.0 <= to.0 {
+        base + deviation
+    } else {
+        base - deviation
+    };
+
+    // TODO(021-573b442): Match the exact curvature used by the archived commit once samples are available.
     let data = Data::new()
         .move_to((from.0, from.1))
         .quadratic_curve_to((control_x, from.1, to.0, to.1));
@@ -168,7 +176,7 @@
         return color_for_group(group).to_string();
     }
 
-    settings.color_unknown.clone()
+    settings.branches.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


[2025-09-21T13:08:33] thinking

**Tracking line numbers in graph.rs**
[2025-09-21T13:08:34] exec bash -lc "nl -ba src/graph.rs | sed -n '20,80p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:08:34] bash -lc "nl -ba src/graph.rs | sed -n '20,80p'" succeeded in 30ms:
    20	        walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)?;
    21	        walk.push_glob("*")?;
    22	
    23	        let mut commits = Vec::new();
    24	        let mut indices = HashMap::new();
    25	        for (idx, oid) in walk.enumerate() {
    26	            let oid = oid?;
    27	            let commit = repository.find_commit(oid).unwrap();
    28	            commits.push(CommitInfo::new(&commit));
    29	            indices.insert(oid, idx);
    30	        }
    31	        assign_children(&mut commits, &indices);
    32	
    33	        let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
    34	
    35	        match settings.branch_order {
    36	            BranchOrder::FirstComeFirstServed(forward) => {
    37	                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
    38	            }
    39	            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
[2025-09-21T13:08:34] tokens used: 215,999
[2025-09-21T13:08:34] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..79465f73ca472f9acc4789a552caff6b08d4aeac
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,32 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .find(|oid| **oid == child_oid)
+        .map(|_| ordinal)
+}
diff --git a/src/print/svg.rs b/src/print/svg.rs
index 7e5205015e3442d8dbc56adf59970e3f751b6ce9..441167a7fad24952130a985128a6c4ebd4d2383f
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,5 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
+    print::get_deviate_index,
     settings::Settings,
 };
 use svg::node::element::path::Data;
@@ -19,20 +20,16 @@
 ];
 
 /// Renders the commit graph as an SVG string.
-///
-/// Known branch groups are colored with the curated palette above. Branches that cannot be
-/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
-/// submission.
 pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
-        .branches()
+        .branches
         .iter()
         .filter_map(|branch| branch.visual.column)
         .max()
         .unwrap_or(0);
 
     let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
-    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
+    let height = ((graph.commits.len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
 
     let mut document = Document::new()
         .set("viewBox", format!("0 0 {} {}", width, height))
@@ -41,26 +38,27 @@
 
     let mut edges = Group::new().set("id", "edges").set("fill", "none");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let from_column = commit_column(graph, commit);
-        let from = commit_coords(from_column, index);
+        let from = commit_coord(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && settings.debug {
+        let stroke_width = if commit.is_merge && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
         };
 
-        for parent_id in &commit.parent_ids {
-            if let Some(&parent_index) = graph.indices().get(parent_id) {
-                if let Some(parent_commit) = graph.commits().get(parent_index) {
+        for parent_id in commit.parents.iter().flatten() {
+            if let Some(&parent_index) = graph.indices.get(parent_id) {
+                if let Some(parent_commit) = graph.commits.get(parent_index) {
                     let to_column = commit_column(graph, parent_commit);
-                    let to = commit_coords(to_column, parent_index);
+                    let to = commit_coord(to_column, parent_index);
+                    let split_idx = get_deviate_index(graph, parent_index, index);
 
                     let edge = if from_column == to_column {
                         line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color.as_str(), stroke_width)
+                        path(from, to, split_idx, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -73,9 +71,9 @@
 
     let mut nodes = Group::new().set("id", "nodes");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let column = commit_column(graph, commit);
-        let center = commit_coords(column, index);
+        let center = commit_coord(column, index);
         let color = branch_color(graph, settings, commit);
 
         nodes = nodes.add(commit_dot(center, color.as_str()));
@@ -104,15 +102,15 @@
     info: &CommitInfo,
 ) -> Option<&'graph BranchInfo> {
     if let Some(trace) = info.branch_trace {
-        return graph.branches().get(trace);
+        return graph.branches.get(trace);
     }
 
     info.branches
         .iter()
-        .find_map(|index| graph.branches().get(*index))
+        .find_map(|index| graph.branches.get(*index))
 }
 
-fn commit_coords(column: Option<usize>, index: usize) -> Point {
+fn commit_coord(column: Option<usize>, index: usize) -> Point {
     let column = column.unwrap_or(0) as f64;
     let x = (column + 1.0) * COLUMN_STEP;
     let y = (index as f64 + 1.0) * ROW_STEP;
@@ -129,8 +127,18 @@
         .set("stroke-width", stroke_width)
 }
 
-fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
-    let control_x = (from.0 + to.0) / 2.0;
+fn path(from: Point, to: Point, split_idx: Option<usize>, color: &str, stroke_width: f64) -> Path {
+    let base = (from.0 + to.0) / 2.0;
+    let deviation = split_idx
+        .map(|idx| (idx as f64 + 1.0) * (COLUMN_STEP / 4.0))
+        .unwrap_or(0.0);
+    let control_x = if from.0 <= to.0 {
+        base + deviation
+    } else {
+        base - deviation
+    };
+
+    // TODO(021-573b442): Match the exact curvature used by the archived commit once samples are available.
     let data = Data::new()
         .move_to((from.0, from.1))
         .quadratic_curve_to((control_x, from.1, to.0, to.1));
@@ -168,7 +176,7 @@
         return color_for_group(group).to_string();
     }
 
-    settings.color_unknown.clone()
+    settings.branches.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


[2025-09-21T13:08:36] thinking

**Searching for function definition**
[2025-09-21T13:08:36] exec bash -lc "nl -ba src/graph.rs | sed -n '460,560p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:08:36] bash -lc "nl -ba src/graph.rs | sed -n '460,560p'" succeeded in 15ms:
   460	                    }
   461	                } else {
   462	                    end_queue.push_front(end);
   463	                    break;
   464	                }
   465	            } else {
   466	                break;
   467	            }
   468	        }
   469	    }
   470	
   471	    let group_offset: Vec<usize> = occupied
   472	        .iter()
   473	        .scan(0, |acc, group| {
   474	            *acc += group.len();
   475	            Some(*acc)
   476	        })
   477	        .collect();
   478	
   479	    for branch in branches {
[2025-09-21T13:08:36] tokens used: 216,947
[2025-09-21T13:08:36] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..79465f73ca472f9acc4789a552caff6b08d4aeac
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,32 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .find(|oid| **oid == child_oid)
+        .map(|_| ordinal)
+}
diff --git a/src/print/svg.rs b/src/print/svg.rs
index 7e5205015e3442d8dbc56adf59970e3f751b6ce9..441167a7fad24952130a985128a6c4ebd4d2383f
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,5 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
+    print::get_deviate_index,
     settings::Settings,
 };
 use svg::node::element::path::Data;
@@ -19,20 +20,16 @@
 ];
 
 /// Renders the commit graph as an SVG string.
-///
-/// Known branch groups are colored with the curated palette above. Branches that cannot be
-/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
-/// submission.
 pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
-        .branches()
+        .branches
         .iter()
         .filter_map(|branch| branch.visual.column)
         .max()
         .unwrap_or(0);
 
     let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
-    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
+    let height = ((graph.commits.len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
 
     let mut document = Document::new()
         .set("viewBox", format!("0 0 {} {}", width, height))
@@ -41,26 +38,27 @@
 
     let mut edges = Group::new().set("id", "edges").set("fill", "none");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let from_column = commit_column(graph, commit);
-        let from = commit_coords(from_column, index);
+        let from = commit_coord(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && settings.debug {
+        let stroke_width = if commit.is_merge && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
         };
 
-        for parent_id in &commit.parent_ids {
-            if let Some(&parent_index) = graph.indices().get(parent_id) {
-                if let Some(parent_commit) = graph.commits().get(parent_index) {
+        for parent_id in commit.parents.iter().flatten() {
+            if let Some(&parent_index) = graph.indices.get(parent_id) {
+                if let Some(parent_commit) = graph.commits.get(parent_index) {
                     let to_column = commit_column(graph, parent_commit);
-                    let to = commit_coords(to_column, parent_index);
+                    let to = commit_coord(to_column, parent_index);
+                    let split_idx = get_deviate_index(graph, parent_index, index);
 
                     let edge = if from_column == to_column {
                         line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color.as_str(), stroke_width)
+                        path(from, to, split_idx, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -73,9 +71,9 @@
 
     let mut nodes = Group::new().set("id", "nodes");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let column = commit_column(graph, commit);
-        let center = commit_coords(column, index);
+        let center = commit_coord(column, index);
         let color = branch_color(graph, settings, commit);
 
         nodes = nodes.add(commit_dot(center, color.as_str()));
@@ -104,15 +102,15 @@
     info: &CommitInfo,
 ) -> Option<&'graph BranchInfo> {
     if let Some(trace) = info.branch_trace {
-        return graph.branches().get(trace);
+        return graph.branches.get(trace);
     }
 
     info.branches
         .iter()
-        .find_map(|index| graph.branches().get(*index))
+        .find_map(|index| graph.branches.get(*index))
 }
 
-fn commit_coords(column: Option<usize>, index: usize) -> Point {
+fn commit_coord(column: Option<usize>, index: usize) -> Point {
     let column = column.unwrap_or(0) as f64;
     let x = (column + 1.0) * COLUMN_STEP;
     let y = (index as f64 + 1.0) * ROW_STEP;
@@ -129,8 +127,18 @@
         .set("stroke-width", stroke_width)
 }
 
-fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
-    let control_x = (from.0 + to.0) / 2.0;
+fn path(from: Point, to: Point, split_idx: Option<usize>, color: &str, stroke_width: f64) -> Path {
+    let base = (from.0 + to.0) / 2.0;
+    let deviation = split_idx
+        .map(|idx| (idx as f64 + 1.0) * (COLUMN_STEP / 4.0))
+        .unwrap_or(0.0);
+    let control_x = if from.0 <= to.0 {
+        base + deviation
+    } else {
+        base - deviation
+    };
+
+    // TODO(021-573b442): Match the exact curvature used by the archived commit once samples are available.
     let data = Data::new()
         .move_to((from.0, from.1))
         .quadratic_curve_to((control_x, from.1, to.0, to.1));
@@ -168,7 +176,7 @@
         return color_for_group(group).to_string();
     }
 
-    settings.color_unknown.clone()
+    settings.branches.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


[2025-09-21T13:08:39] thinking

**Recording line numbers for svg.rs**
[2025-09-21T13:08:39] exec bash -lc "nl -ba src/print/svg.rs | sed -n '1,200p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:08:39] bash -lc "nl -ba src/print/svg.rs | sed -n '1,200p'" succeeded in 17ms:
     1	use crate::{
     2	    graph::{BranchInfo, CommitInfo, GitGraph},
     3	    print::get_deviate_index,
     4	    settings::Settings,
     5	};
     6	use svg::node::element::path::Data;
     7	use svg::node::element::{Circle, Group, Line, Path, Text};
     8	use svg::node::Text as TextNode;
     9	use svg::Document;
    10	
    11	const COLUMN_STEP: f64 = 15.0;
    12	const ROW_STEP: f64 = 15.0;
    13	const NODE_RADIUS: f64 = 3.0;
    14	const STROKE_WIDTH: f64 = 1.5;
    15	const MERGE_STROKE_WIDTH: f64 = 2.5;
    16	const DEBUG_FONT_SIZE: i32 = 7;
    17	
    18	const BRANCH_COLORS: [&str; 8] = [
    19	    "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
    20	];
[2025-09-21T13:08:39] tokens used: 218,300
[2025-09-21T13:08:39] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..79465f73ca472f9acc4789a552caff6b08d4aeac
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,32 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .find(|oid| **oid == child_oid)
+        .map(|_| ordinal)
+}
diff --git a/src/print/svg.rs b/src/print/svg.rs
index 7e5205015e3442d8dbc56adf59970e3f751b6ce9..441167a7fad24952130a985128a6c4ebd4d2383f
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,5 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
+    print::get_deviate_index,
     settings::Settings,
 };
 use svg::node::element::path::Data;
@@ -19,20 +20,16 @@
 ];
 
 /// Renders the commit graph as an SVG string.
-///
-/// Known branch groups are colored with the curated palette above. Branches that cannot be
-/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
-/// submission.
 pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
-        .branches()
+        .branches
         .iter()
         .filter_map(|branch| branch.visual.column)
         .max()
         .unwrap_or(0);
 
     let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
-    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
+    let height = ((graph.commits.len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
 
     let mut document = Document::new()
         .set("viewBox", format!("0 0 {} {}", width, height))
@@ -41,26 +38,27 @@
 
     let mut edges = Group::new().set("id", "edges").set("fill", "none");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let from_column = commit_column(graph, commit);
-        let from = commit_coords(from_column, index);
+        let from = commit_coord(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && settings.debug {
+        let stroke_width = if commit.is_merge && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
         };
 
-        for parent_id in &commit.parent_ids {
-            if let Some(&parent_index) = graph.indices().get(parent_id) {
-                if let Some(parent_commit) = graph.commits().get(parent_index) {
+        for parent_id in commit.parents.iter().flatten() {
+            if let Some(&parent_index) = graph.indices.get(parent_id) {
+                if let Some(parent_commit) = graph.commits.get(parent_index) {
                     let to_column = commit_column(graph, parent_commit);
-                    let to = commit_coords(to_column, parent_index);
+                    let to = commit_coord(to_column, parent_index);
+                    let split_idx = get_deviate_index(graph, parent_index, index);
 
                     let edge = if from_column == to_column {
                         line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color.as_str(), stroke_width)
+                        path(from, to, split_idx, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -73,9 +71,9 @@
 
     let mut nodes = Group::new().set("id", "nodes");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let column = commit_column(graph, commit);
-        let center = commit_coords(column, index);
+        let center = commit_coord(column, index);
         let color = branch_color(graph, settings, commit);
 
         nodes = nodes.add(commit_dot(center, color.as_str()));
@@ -104,15 +102,15 @@
     info: &CommitInfo,
 ) -> Option<&'graph BranchInfo> {
     if let Some(trace) = info.branch_trace {
-        return graph.branches().get(trace);
+        return graph.branches.get(trace);
     }
 
     info.branches
         .iter()
-        .find_map(|index| graph.branches().get(*index))
+        .find_map(|index| graph.branches.get(*index))
 }
 
-fn commit_coords(column: Option<usize>, index: usize) -> Point {
+fn commit_coord(column: Option<usize>, index: usize) -> Point {
     let column = column.unwrap_or(0) as f64;
     let x = (column + 1.0) * COLUMN_STEP;
     let y = (index as f64 + 1.0) * ROW_STEP;
@@ -129,8 +127,18 @@
         .set("stroke-width", stroke_width)
 }
 
-fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
-    let control_x = (from.0 + to.0) / 2.0;
+fn path(from: Point, to: Point, split_idx: Option<usize>, color: &str, stroke_width: f64) -> Path {
+    let base = (from.0 + to.0) / 2.0;
+    let deviation = split_idx
+        .map(|idx| (idx as f64 + 1.0) * (COLUMN_STEP / 4.0))
+        .unwrap_or(0.0);
+    let control_x = if from.0 <= to.0 {
+        base + deviation
+    } else {
+        base - deviation
+    };
+
+    // TODO(021-573b442): Match the exact curvature used by the archived commit once samples are available.
     let data = Data::new()
         .move_to((from.0, from.1))
         .quadratic_curve_to((control_x, from.1, to.0, to.1));
@@ -168,7 +176,7 @@
         return color_for_group(group).to_string();
     }
 
-    settings.color_unknown.clone()
+    settings.branches.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


[2025-09-21T13:08:42] thinking

**Recording line numbers for print/mod.rs**
[2025-09-21T13:08:42] exec bash -lc 'nl -ba src/print/mod.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:08:42] bash -lc 'nl -ba src/print/mod.rs' succeeded in 9ms:
     1	pub mod svg;
     2	
     3	use crate::graph::GitGraph;
     4	
     5	/// Determine the zero-based position of `child_index` within the visible children of
     6	/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
     7	/// when multiple edges leave the same parent column.
     8	pub fn get_deviate_index(
     9	    graph: &GitGraph,
    10	    parent_index: usize,
    11	    child_index: usize,
    12	) -> Option<usize> {
    13	    let parent = graph.commits.get(parent_index)?;
    14	    let child_oid = graph.commits.get(child_index)?.oid;
    15	
    16	    let mut ordinal = 0usize;
    17	    for candidate_oid in &parent.children {
    18	        if let Some(&idx) = graph.indices.get(candidate_oid) {
    19	            if idx == child_index {
    20	                return Some(ordinal);
[2025-09-21T13:08:42] tokens used: 224,732
[2025-09-21T13:08:42] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..79465f73ca472f9acc4789a552caff6b08d4aeac
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,32 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .find(|oid| **oid == child_oid)
+        .map(|_| ordinal)
+}
diff --git a/src/print/svg.rs b/src/print/svg.rs
index 7e5205015e3442d8dbc56adf59970e3f751b6ce9..441167a7fad24952130a985128a6c4ebd4d2383f
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,5 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
+    print::get_deviate_index,
     settings::Settings,
 };
 use svg::node::element::path::Data;
@@ -19,20 +20,16 @@
 ];
 
 /// Renders the commit graph as an SVG string.
-///
-/// Known branch groups are colored with the curated palette above. Branches that cannot be
-/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
-/// submission.
 pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
-        .branches()
+        .branches
         .iter()
         .filter_map(|branch| branch.visual.column)
         .max()
         .unwrap_or(0);
 
     let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
-    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
+    let height = ((graph.commits.len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
 
     let mut document = Document::new()
         .set("viewBox", format!("0 0 {} {}", width, height))
@@ -41,26 +38,27 @@
 
     let mut edges = Group::new().set("id", "edges").set("fill", "none");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let from_column = commit_column(graph, commit);
-        let from = commit_coords(from_column, index);
+        let from = commit_coord(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && settings.debug {
+        let stroke_width = if commit.is_merge && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
         };
 
-        for parent_id in &commit.parent_ids {
-            if let Some(&parent_index) = graph.indices().get(parent_id) {
-                if let Some(parent_commit) = graph.commits().get(parent_index) {
+        for parent_id in commit.parents.iter().flatten() {
+            if let Some(&parent_index) = graph.indices.get(parent_id) {
+                if let Some(parent_commit) = graph.commits.get(parent_index) {
                     let to_column = commit_column(graph, parent_commit);
-                    let to = commit_coords(to_column, parent_index);
+                    let to = commit_coord(to_column, parent_index);
+                    let split_idx = get_deviate_index(graph, parent_index, index);
 
                     let edge = if from_column == to_column {
                         line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color.as_str(), stroke_width)
+                        path(from, to, split_idx, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -73,9 +71,9 @@
 
     let mut nodes = Group::new().set("id", "nodes");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let column = commit_column(graph, commit);
-        let center = commit_coords(column, index);
+        let center = commit_coord(column, index);
         let color = branch_color(graph, settings, commit);
 
         nodes = nodes.add(commit_dot(center, color.as_str()));
@@ -104,15 +102,15 @@
     info: &CommitInfo,
 ) -> Option<&'graph BranchInfo> {
     if let Some(trace) = info.branch_trace {
-        return graph.branches().get(trace);
+        return graph.branches.get(trace);
     }
 
     info.branches
         .iter()
-        .find_map(|index| graph.branches().get(*index))
+        .find_map(|index| graph.branches.get(*index))
 }
 
-fn commit_coords(column: Option<usize>, index: usize) -> Point {
+fn commit_coord(column: Option<usize>, index: usize) -> Point {
     let column = column.unwrap_or(0) as f64;
     let x = (column + 1.0) * COLUMN_STEP;
     let y = (index as f64 + 1.0) * ROW_STEP;
@@ -129,8 +127,18 @@
         .set("stroke-width", stroke_width)
 }
 
-fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
-    let control_x = (from.0 + to.0) / 2.0;
+fn path(from: Point, to: Point, split_idx: Option<usize>, color: &str, stroke_width: f64) -> Path {
+    let base = (from.0 + to.0) / 2.0;
+    let deviation = split_idx
+        .map(|idx| (idx as f64 + 1.0) * (COLUMN_STEP / 4.0))
+        .unwrap_or(0.0);
+    let control_x = if from.0 <= to.0 {
+        base + deviation
+    } else {
+        base - deviation
+    };
+
+    // TODO(021-573b442): Match the exact curvature used by the archived commit once samples are available.
     let data = Data::new()
         .move_to((from.0, from.1))
         .quadratic_curve_to((control_x, from.1, to.0, to.1));
@@ -168,7 +176,7 @@
         return color_for_group(group).to_string();
     }
 
-    settings.color_unknown.clone()
+    settings.branches.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


[2025-09-21T13:08:56] thinking

**Preparing final summary with TODOs and next steps**

I'll outline the changes made across various files, highlight the inserted TODO comments (especially in `svg.rs` line 141), note the cargo check failure due to a dependency checksum issue, and provide thoughtful next-step suggestions—wrapping everything into a clear bullet-point list with appropriate headers as requested.
[2025-09-21T13:08:57] codex

**复现内容**
- `src/settings.rs:10` 引入 `BranchOrder::LongestFirst(bool)`，与报告一致扩展排序策略枚举。
- `src/graph.rs:35` 更新分派逻辑并在 `src/graph.rs:493` 整合为 `assign_branch_columns_branch_length`，以布尔参数区分 shortest/longest 模式。
- `src/print/mod.rs:1` 新增 `get_deviate_index`，按父节点可见子集返回偏移序号（含 TODO 备注说明缺乏完整证据时的假设）。
- `src/print/svg.rs:23` 改写渲染流程：接入 `get_deviate_index` 生成跨列路径、统一 `commit_coord`、调整颜色访问；`src/print/svg.rs:130` 针对曲线偏移保留 TODO，待有实际样例后校准。

**验证**
- `cargo check --locked` → 失败：`svg v0.8.0` 校验和不匹配，离线环境无法复现包校验（需外部介入）。

**说明**
- 代码内保留 TODO(021-573b442) 于 `src/print/mod.rs:26`、`src/print/svg.rs:141`，标记报告缺失的细节假设。

**下一步**
1. 若可联网或取得缓存，请重新获取 `svg v0.8.0` 以消除校验问题，再执行 `cargo check/test`。
2. 准备实际仓库数据，调试 `get_deviate_index` 与曲线偏移参数，验证视觉回归。
[2025-09-21T13:09:01] tokens used: 228,635
[2025-09-21T13:09:01] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index b57b55721b7bd79b2cc20c3081b8f177b7fbcb46..34497ca99607d66c8c99d0fd46461a1572c503a1
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -36,11 +36,19 @@
             BranchOrder::FirstComeFirstServed(forward) => {
                 assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
             }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_shortest_first(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+                &commits,
+                &mut branches,
+                &settings.branches,
+                forward,
+                false,
+            ),
+            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
                 &mut branches,
                 &settings.branches,
                 forward,
+                true,
             ),
         }
 
@@ -481,16 +489,18 @@
 }
 
 /// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_shortest_first(
+/// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
+fn assign_branch_columns_branch_length(
     _commits: &[CommitInfo],
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
+    longest_first: bool,
 ) {
     let mut occupied: Vec<Vec<Vec<(usize, usize)>>> = vec![vec![]; settings.order.len() + 1];
 
     let sort_factor = if forward { 1 } else { -1 };
+    let length_factor: i32 = if longest_first { -1 } else { 1 };
 
     let branches_sort: VecDeque<_> = branches
         .iter()
@@ -503,7 +513,12 @@
                 br.range.1.unwrap_or(branches.len() - 1),
             )
         })
-        .sorted_by_key(|tup| (tup.2 as i32 - tup.1 as i32, tup.1 as i32 * sort_factor))
+        .sorted_by_key(|tup| {
+            (
+                (tup.2 as i32 - tup.1 as i32) * length_factor,
+                tup.1 as i32 * sort_factor,
+            )
+        })
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
diff --git a/src/print/mod.rs b/src/print/mod.rs
index 429f996fe0582cbf33c8e5b445b41c281c76c0d0..79465f73ca472f9acc4789a552caff6b08d4aeac
--- a/src/print/mod.rs
+++ b/src/print/mod.rs
@@ -1 +1,32 @@
 pub mod svg;
+
+use crate::graph::GitGraph;
+
+/// Determine the zero-based position of `child_index` within the visible children of
+/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
+/// when multiple edges leave the same parent column.
+pub fn get_deviate_index(
+    graph: &GitGraph,
+    parent_index: usize,
+    child_index: usize,
+) -> Option<usize> {
+    let parent = graph.commits.get(parent_index)?;
+    let child_oid = graph.commits.get(child_index)?.oid;
+
+    let mut ordinal = 0usize;
+    for candidate_oid in &parent.children {
+        if let Some(&idx) = graph.indices.get(candidate_oid) {
+            if idx == child_index {
+                return Some(ordinal);
+            }
+            ordinal += 1;
+        }
+    }
+
+    // TODO(021-573b442): Verify whether filtered-out children should contribute to the ordinal.
+    parent
+        .children
+        .iter()
+        .find(|oid| **oid == child_oid)
+        .map(|_| ordinal)
+}
diff --git a/src/print/svg.rs b/src/print/svg.rs
index 7e5205015e3442d8dbc56adf59970e3f751b6ce9..441167a7fad24952130a985128a6c4ebd4d2383f
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -1,5 +1,6 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
+    print::get_deviate_index,
     settings::Settings,
 };
 use svg::node::element::path::Data;
@@ -19,20 +20,16 @@
 ];
 
 /// Renders the commit graph as an SVG string.
-///
-/// Known branch groups are colored with the curated palette above. Branches that cannot be
-/// classified use `Settings::color_unknown`, matching the behaviour described by the archived
-/// submission.
 pub fn print_svg(graph: &GitGraph, settings: &Settings) -> String {
     let max_column = graph
-        .branches()
+        .branches
         .iter()
         .filter_map(|branch| branch.visual.column)
         .max()
         .unwrap_or(0);
 
     let width = ((max_column as f64 + 2.0) * COLUMN_STEP).ceil() as u32;
-    let height = ((graph.commits().len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
+    let height = ((graph.commits.len() as f64 + 2.0) * ROW_STEP).ceil() as u32;
 
     let mut document = Document::new()
         .set("viewBox", format!("0 0 {} {}", width, height))
@@ -41,26 +38,27 @@
 
     let mut edges = Group::new().set("id", "edges").set("fill", "none");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let from_column = commit_column(graph, commit);
-        let from = commit_coords(from_column, index);
+        let from = commit_coord(from_column, index);
         let color = branch_color(graph, settings, commit);
-        let stroke_width = if commit.parents.len() > 1 && settings.debug {
+        let stroke_width = if commit.is_merge && settings.debug {
             MERGE_STROKE_WIDTH
         } else {
             STROKE_WIDTH
         };
 
-        for parent_id in &commit.parent_ids {
-            if let Some(&parent_index) = graph.indices().get(parent_id) {
-                if let Some(parent_commit) = graph.commits().get(parent_index) {
+        for parent_id in commit.parents.iter().flatten() {
+            if let Some(&parent_index) = graph.indices.get(parent_id) {
+                if let Some(parent_commit) = graph.commits.get(parent_index) {
                     let to_column = commit_column(graph, parent_commit);
-                    let to = commit_coords(to_column, parent_index);
+                    let to = commit_coord(to_column, parent_index);
+                    let split_idx = get_deviate_index(graph, parent_index, index);
 
                     let edge = if from_column == to_column {
                         line(from, to, color.as_str(), stroke_width)
                     } else {
-                        path(from, to, color.as_str(), stroke_width)
+                        path(from, to, split_idx, color.as_str(), stroke_width)
                     };
 
                     edges = edges.add(edge);
@@ -73,9 +71,9 @@
 
     let mut nodes = Group::new().set("id", "nodes");
 
-    for (index, commit) in graph.commits().iter().enumerate() {
+    for (index, commit) in graph.commits.iter().enumerate() {
         let column = commit_column(graph, commit);
-        let center = commit_coords(column, index);
+        let center = commit_coord(column, index);
         let color = branch_color(graph, settings, commit);
 
         nodes = nodes.add(commit_dot(center, color.as_str()));
@@ -104,15 +102,15 @@
     info: &CommitInfo,
 ) -> Option<&'graph BranchInfo> {
     if let Some(trace) = info.branch_trace {
-        return graph.branches().get(trace);
+        return graph.branches.get(trace);
     }
 
     info.branches
         .iter()
-        .find_map(|index| graph.branches().get(*index))
+        .find_map(|index| graph.branches.get(*index))
 }
 
-fn commit_coords(column: Option<usize>, index: usize) -> Point {
+fn commit_coord(column: Option<usize>, index: usize) -> Point {
     let column = column.unwrap_or(0) as f64;
     let x = (column + 1.0) * COLUMN_STEP;
     let y = (index as f64 + 1.0) * ROW_STEP;
@@ -129,8 +127,18 @@
         .set("stroke-width", stroke_width)
 }
 
-fn path(from: Point, to: Point, color: &str, stroke_width: f64) -> Path {
-    let control_x = (from.0 + to.0) / 2.0;
+fn path(from: Point, to: Point, split_idx: Option<usize>, color: &str, stroke_width: f64) -> Path {
+    let base = (from.0 + to.0) / 2.0;
+    let deviation = split_idx
+        .map(|idx| (idx as f64 + 1.0) * (COLUMN_STEP / 4.0))
+        .unwrap_or(0.0);
+    let control_x = if from.0 <= to.0 {
+        base + deviation
+    } else {
+        base - deviation
+    };
+
+    // TODO(021-573b442): Match the exact curvature used by the archived commit once samples are available.
     let data = Data::new()
         .move_to((from.0, from.1))
         .quadratic_curve_to((control_x, from.1, to.0, to.1));
@@ -168,7 +176,7 @@
         return color_for_group(group).to_string();
     }
 
-    settings.color_unknown.clone()
+    settings.branches.color_unknown.clone()
 }
 
 fn color_for_group(group: usize) -> &'static str {
diff --git a/src/settings.rs b/src/settings.rs
index edf3c471fc868c874cddcefdb9cd2bfab68015b7..4e88dd036af4b6dbde590841dd17c9b5843722f1
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -7,6 +7,11 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     ShortestFirst(bool),
+    /// Longest branches are inserted left-most.
+    ///
+    /// For branches with equal length, branches ending last are inserted first.
+    /// Reverse (arg = false): Branches starting first are inserted first.
+    LongestFirst(bool),
     /// Branches ending last are inserted left-most.
     ///
     /// Reverse (arg = false): Branches starting first are inserted left-most.


=== 错误 ===
2025-09-21T13:00:04.558364Z ERROR codex_core::exec: exec error: No such file or directory (os error 2)

=== 最终状态 ===
返回码: 0
状态: ✅ 执行成功
