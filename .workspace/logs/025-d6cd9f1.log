=== 任务 025-d6cd9f1 执行日志 ===
时间: 2025-09-21 21:57:04.689808
Prompt:
请在 .workspace 内，依据 .workspace/todolist/todolist-025-d6cd9f1.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/025-d6cd9f1/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："025-d6cd9f1：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 025-d6cd9f1

=== 输出 ===
[2025-09-21T13:48:29] OpenAI Codex v0.39.0 (research preview)
--------
workdir: /Users/jqwang/104-CommitLens-codex/.workspace
model: gpt-5-codex-high
provider: codex
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
--------
[2025-09-21T13:48:29] User instructions:
请在 .workspace 内，依据 .workspace/todolist/todolist-025-d6cd9f1.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/025-d6cd9f1/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："025-d6cd9f1：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 025-d6cd9f1

[2025-09-21T13:48:41] thinking

**Preparing to read task file**
[2025-09-21T13:48:41] exec bash -lc 'ls -la' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T13:48:41] bash -lc 'ls -la' succeeded in 9ms:
total 12312
drwxr-xr-x@  9 jqwang  staff      288 Sep 21 15:57 .
drwxr-xr-x@ 29 jqwang  staff      928 Sep 21 07:49 ..
-rw-r--r--@  1 jqwang  staff        0 Sep 21 21:48 codex_error.txt
-rw-r--r--@  1 jqwang  staff  5609121 Sep 21 21:48 codex_output.txt
-rw-r--r--@  1 jqwang  staff        7 Sep 21 21:48 codex_status.txt
drwxr-xr-x@ 26 jqwang  staff      832 Sep 21 21:48 logs
drwxr-xr-x@ 12 jqwang  staff      384 Sep 21 20:54 rust-project
-rw-r--r--@  1 jqwang  staff      573 Sep 21 21:48 task_status.json
drwxr-xr-x@  5 jqwang  staff      160 Sep 21 21:48 todolist
[2025-09-21T13:48:41] tokens used: 928

[2025-09-21T13:48:43] thinking

**Reading LaTeX file**
[2025-09-21T13:48:43] exec bash -lc 'cat todolist/todolist-025-d6cd9f1.tex' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T13:48:43] bash -lc 'cat todolist/todolist-025-d6cd9f1.tex' succeeded in 9ms:
\section{提交考古：025-d6cd9f1}

\subsection*{Commit 元信息}
\begin{itemize}
  \item 标题：print commit summaries etc next to text-based graph
  \item 作者：Martin Lange \verb|<martin_lange_@gmx.net>|
  \item 日期：2020-12-23T23:21:23+01:00
\end{itemize}

\subsection*{变更摘要（阅读提示）}
本次提交集中改动 \verb|src/print/unicode.rs| 和 \verb|src/main.rs|（2 files changed, 110 insertions, 50 deletions）。在文本图旁新增“短 SHA、分支名、提交摘要”的打印逻辑，并新增 \verb|--debug| 控制台信息。

\subsection*{差异解读（证据）}
\begin{itemize}
  \item 改了什么：
    \begin{itemize}
      \item 引入打印挂钩：在文本渲染末段将原先的 \verb|grid.print*()| 替换为 \verb|print_graph(...)| 统筹一行的“前缀/主体/后缀”输出，见 \verb|head/src/print/unicode.rs:166–181|、\verb|head/src/print/unicode.rs:400–437|、\verb|head/src/print/unicode.rs:439–483|。
      \item 在 \verb|main.rs| 增加 \verb|--debug| 开关，并仅在开启时输出构建/渲染耗时，见 \verb|head/src/main.rs:1–40|（参数解析）与 \verb|head/src/main.rs:61–76|（条件输出）。
    \end{itemize}
  \item 为什么改：
[2025-09-21T13:48:43] tokens used: 2,381

[2025-09-21T13:48:49] thinking

**Reviewing modified Rust files**
[2025-09-21T13:48:49] exec bash -lc ls in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:48:49] bash -lc ls succeeded in 8ms:
Cargo.lock
Cargo.toml
LICENSE
README.md
scripts
src
target
[2025-09-21T13:48:49] tokens used: 3,720

[2025-09-21T13:48:52] thinking

**Reviewing relevant source files**
[2025-09-21T13:48:52] exec bash -lc "sed -n '1,200p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:48:52] bash -lc "sed -n '1,200p' src/print/unicode.rs" succeeded in 29ms:
use crate::{
    graph::{BranchInfo, CommitInfo, GitGraph},
    print::{colors, get_deviate_index},
    settings::BranchSettings,
};
use term_painter::{Color as PainterColor, ToStyle};

const DOT: char = '●';
const CIRCLE: char = '○';
const HOR: char = '─';
const VER: char = '│';
const TURN_UP_RIGHT: char = '└';
const TURN_UP_LEFT: char = '┘';
const TURN_DOWN_RIGHT: char = '┌';
const TURN_DOWN_LEFT: char = '┐';
const T_UP: char = '┴';
const T_DOWN: char = '┬';
const T_RIGHT: char = '├';
const T_LEFT: char = '┤';
const CROSS: char = '┼';
[2025-09-21T13:48:52] tokens used: 5,028

[2025-09-21T13:48:56] thinking

**Examining file for print_graph function**
[2025-09-21T13:48:56] exec bash -lc "sed -n '200,400p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:48:56] bash -lc "sed -n '200,400p' src/print/unicode.rs" succeeded in 29ms:
            cells: vec![' '; width * height],
            colors: vec![COLOR_NONE; width * height],
        }
    }

    fn index(&self, row: usize, col: usize) -> usize {
        row * self.width + col
    }

    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
        self.overlay(row, col, ch, color);
    }

    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
        if row >= self.height || col >= self.width {
            return;
        }
        let idx = self.index(row, col);
        let current = self.cells[idx];
        let merged = if current == ' ' {
[2025-09-21T13:48:56] tokens used: 7,006

[2025-09-21T13:48:59] thinking

**Continuing search for print_graph**
[2025-09-21T13:48:59] exec bash -lc "sed -n '400,600p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:48:59] bash -lc "sed -n '400,600p' src/print/unicode.rs" succeeded in 37ms:
            },
            _ => Default::default(),
        }
    }

    fn merge(self, other: LineBits) -> LineBits {
        let mut bits = self;
        bits.up |= other.up;
        bits.down |= other.down;
        bits.left |= other.left;
        bits.right |= other.right;
        bits.arrow_left |= other.arrow_left;
        bits.arrow_right |= other.arrow_right;
        bits.node = bits.node.or(other.node);
        bits
    }

    fn to_char(self) -> char {
        if let Some(node) = self.node {
            return node;
[2025-09-21T13:48:59] tokens used: 8,505

[2025-09-21T13:49:01] thinking

**Continuing near the end**
[2025-09-21T13:49:02] exec bash -lc "sed -n '600,850p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:49:02] bash -lc "sed -n '600,850p' src/print/unicode.rs" succeeded in 24ms:
                start = end;
            }
        }
        if let Some(label) = &labels[row] {
            if !line.is_empty() {
                line.push(' ');
            }
            line.push_str(label);
        }
        lines.push(line);
    }
    Ok(lines.join("\n"))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn merge_chars_combines_perpendicular_lines() {
[2025-09-21T13:49:02] tokens used: 10,339

[2025-09-21T13:49:10] thinking

**Evaluating commit replication strategy**
[2025-09-21T13:49:10] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:49:10] bash -lc 'git status -sb' succeeded in 19ms:
## main
[2025-09-21T13:49:10] tokens used: 11,225

[2025-09-21T13:49:13] thinking

**Checking commit history for target**
[2025-09-21T13:49:14] exec bash -lc 'git log --oneline | head' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:49:14] bash -lc 'git log --oneline | head' succeeded in 52ms:
b726c99 024-cf5b5d6：复现提交代码内容。
7d2e064 023-6c8f6ba：复现提交代码内容。
7aea985 022-10dd4fe：复现提交代码内容。
8a95d12 021-573b442：复现提交代码内容。
a55c389 020-d48e780：复现提交代码内容。
4571e7b 019-854edee：复现提交代码内容。
99f2358 018-f7aeb45：复现提交代码内容。
4114d95 017-525aaac：复现提交代码内容。
abfc061 016-f620960：复现提交代码内容。
80b0f1b 015-2e0c191：复现提交代码内容。
[2025-09-21T13:49:14] tokens used: 11,518

[2025-09-21T13:49:16] thinking

**Identifying target commit and files**
[2025-09-21T13:49:17] exec bash -lc "sed -n '1,200p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:49:17] bash -lc "sed -n '1,200p' src/main.rs" succeeded in 13ms:
use clap::{App, Arg};
use git_graph::graph::{CommitInfo, GitGraph};
use git_graph::print::svg::print_svg;
use git_graph::print::unicode::print_unicode;
use git_graph::settings::{BranchOrder, BranchSettings, MergePatterns, Settings};
use std::process;
use std::time::Instant;

fn main() {
    let matches = App::new("git-graph")
        .version(env!("CARGO_PKG_VERSION"))
        .about("Render git commit graphs as Unicode or SVG")
        .arg(
            Arg::with_name("svg")
                .long("svg")
                .help("Render SVG output instead of console output"),
        )
        .arg(
            Arg::with_name("no-color")
                .long("no-color")
[2025-09-21T13:49:17] tokens used: 11,943

[2025-09-21T13:49:26] thinking

**Analyzing print behavior and graph output restructuring**
[2025-09-21T13:49:26] exec bash -lc 'rg "print_graph" -n' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:49:26] bash -lc 'rg "print_graph" -n' exited 1 in 39ms:

[2025-09-21T13:49:26] tokens used: 13,923

[2025-09-21T13:49:39] thinking

**Analyzing print_graph function introduction**
[2025-09-21T13:49:40] exec bash -lc "nl -ba src/print/unicode.rs | sed -n '150,220p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:49:40] bash -lc "nl -ba src/print/unicode.rs | sed -n '150,220p'" succeeded in 19ms:
   150	                        insert_row,
   151	                        gcol + 1,
   152	                        parent_gcol - 1,
   153	                        arrow,
   154	                        Some(parent_color),
   155	                    );
   156	                }
   157	                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
   158	            } else {
   159	                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
   160	                if parent_gcol + 1 <= gcol.saturating_sub(1) {
   161	                    grid.hline(
   162	                        insert_row,
   163	                        parent_gcol + 1,
   164	                        gcol - 1,
   165	                        arrow,
   166	                        Some(parent_color),
   167	                    );
   168	                }
   169	                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
[2025-09-21T13:49:40] tokens used: 22,997

[2025-09-21T13:49:52] thinking

**Analyzing commit for print_graph and debug adjustments**

I'm piecing together how to implement the new `print_graph` that prints a short SHA, the graph ASCII art, branch names (colored), and commit summaries aligned neatly, based on the line ranges and description given. I also need to revise `main.rs` so the duration prints only happen with the debug flag set, matching the new conditional logic suggested by the commit, while figuring out details like how branch names are gathered and colored from existing structures. This is a bit of a puzzle without direct access to the original commit, but I’m guessing from the textual hints and repo context.
[2025-09-21T13:49:53] exec bash -lc 'ls src/print' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:49:53] bash -lc 'ls src/print' succeeded in 34ms:
colors.rs
mod.rs
svg.rs
unicode.rs
[2025-09-21T13:49:53] tokens used: 25,242

[2025-09-21T13:49:55] thinking

**Checking mod.rs for context**
[2025-09-21T13:49:55] exec bash -lc 'cat src/print/mod.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:49:55] bash -lc 'cat src/print/mod.rs' succeeded in 8ms:
pub mod colors;
pub mod svg;
pub mod unicode;

use crate::graph::GitGraph;

/// Determine the zero-based position of `child_index` within the visible children of
/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
/// when multiple edges leave the same parent column.
pub fn get_deviate_index(
    graph: &GitGraph,
    parent_index: usize,
    child_index: usize,
) -> Option<usize> {
    let parent = graph.commits.get(parent_index)?;
    let child_oid = graph.commits.get(child_index)?.oid;

    let mut ordinal = 0usize;
    for candidate_oid in &parent.children {
        if let Some(&idx) = graph.indices.get(candidate_oid) {
[2025-09-21T13:49:55] tokens used: 25,422

[2025-09-21T13:49:57] thinking

**Checking colors module**
[2025-09-21T13:49:58] exec bash -lc "sed -n '1,200p' src/print/colors.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:49:58] bash -lc "sed -n '1,200p' src/print/colors.rs" succeeded in 34ms:
use lazy_static::lazy_static;
use std::collections::HashMap;
use term_painter::Color;

lazy_static! {
    static ref COLOR_MAP: HashMap<&'static str, Color> = {
        let mut map = HashMap::new();
        map.insert("blue", Color::Blue);
        map.insert("green", Color::Green);
        map.insert("red", Color::Red);
        map.insert("purple", Color::Magenta);
        map.insert("magenta", Color::Magenta);
        map.insert("orange", Color::Yellow);
        map.insert("yellow", Color::Yellow);
        map.insert("grey", Color::BrightBlack);
        map.insert("gray", Color::BrightBlack);
        map.insert("pink", Color::Magenta);
        map
    };
}
[2025-09-21T13:49:58] tokens used: 25,832

[2025-09-21T13:50:47] thinking

**Designing structured line decorations**
[2025-09-21T13:50:47] exec bash -lc 'ls todolist/figs' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T13:50:47] bash -lc 'ls todolist/figs' succeeded in 15ms:
algorithm_flow.puml
architecture.puml
[2025-09-21T13:50:47] tokens used: 30,976

[2025-09-21T13:50:49] thinking

**Checking for subfolder named 025-d6cd9f1**
[2025-09-21T13:50:49] exec bash -lc 'ls todolist/figs/025-d6cd9f1' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T13:50:49] bash -lc 'ls todolist/figs/025-d6cd9f1' exited 1 in 25ms:
ls: todolist/figs/025-d6cd9f1: No such file or directory
[2025-09-21T13:50:49] tokens used: 34,177

[2025-09-21T13:50:58] thinking

**Considering strategies to replicate exact commit**
[2025-09-21T13:50:59] exec bash -lc 'ls todolist' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T13:50:59] bash -lc 'ls todolist' succeeded in 7ms:
figs
task_meta.json
todolist-025-d6cd9f1.tex
[2025-09-21T13:50:59] tokens used: 34,804

[2025-09-21T13:51:08] thinking

**Analyzing patch requirements and debug flag handling**
[2025-09-21T13:51:08] exec bash -lc 'rg "struct BranchInfo" -n src/graph -g"*.rs"' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:51:08] bash -lc 'rg "struct BranchInfo" -n src/graph -g"*.rs"' exited -1 in 0ms:
src/graph: No such file or directory (os error 2)
[2025-09-21T13:51:08] tokens used: 35,904

[2025-09-21T13:51:12] thinking

**Checking directory structure**
[2025-09-21T13:51:12] exec bash -lc 'ls src' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:51:12] bash -lc 'ls src' succeeded in 12ms:
graph.rs
lib.rs
main.rs
print
settings.rs
text.rs
[2025-09-21T13:51:12] tokens used: 55,819

[2025-09-21T13:51:15] thinking

**Opening graph.rs file**
[2025-09-21T13:51:15] exec bash -lc "sed -n '1,200p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:51:15] bash -lc "sed -n '1,200p' src/graph.rs" succeeded in 34ms:
use crate::settings::{BranchOrder, BranchSettings, Settings};
use crate::text;
use git2::{BranchType, Commit, Error, Oid, Repository};
use itertools::Itertools;
use std::collections::{HashMap, VecDeque};

/// Represents a git history graph.
pub struct GitGraph {
    pub repository: Repository,
    pub commits: Vec<CommitInfo>,
    pub indices: HashMap<Oid, usize>,
    pub branches: Vec<BranchInfo>,
}

impl GitGraph {
    pub fn new(path: &str, settings: &Settings) -> Result<Self, Error> {
        let repository = Repository::open(path)?;
        let mut walk = repository.revwalk()?;

        walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)?;
[2025-09-21T13:51:15] tokens used: 56,149

[2025-09-21T13:51:46] thinking

**Drafting detailed implementation plan**
[2025-09-21T13:51:46] exec bash -lc 'rg "短 SHA" -n ..' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T13:51:46] bash -lc 'rg "短 SHA" -n ..' exited 1 in 15ms:

[2025-09-21T13:51:46] tokens used: 59,645

[2025-09-21T13:51:49] thinking

**Considering debug options and next steps**
[2025-09-21T13:51:49] exec bash -lc 'rg "debug" src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:51:49] bash -lc 'rg "debug" src/main.rs' succeeded in 11ms:
            Arg::with_name("debug")
                .long("debug")
                .help("Enable debug output"),
    let debug = matches.is_present("debug");
        debug,
    if settings.debug {
        let unicode = print_unicode(&graph, &settings.branches, settings.debug, color_enabled)?;
[2025-09-21T13:51:49] tokens used: 59,811

[2025-09-21T13:53:42] thinking

**Designing graph printing structures**
**Finalizing graph line rendering logic**

I’m working out how to assemble the graph line by combining fixed-width colored prefix, trimmed colored graph content, and optional colored suffix with branch names and debug info, ensuring proper spacing and alignment without trailing spaces. I’ll implement helper functions for coloring text segments, ordering branch labels, and building each line cleanly using the new `LineDecoration` structs.
**Refactoring branch label handling and print_unicode updates**

I'll reorder branches to prioritize the traced branch, create colored branch labels accordingly, and replace the old label vector with a vector of new LineDecoration structs. Then I’ll update `print_unicode` to build and use these new decorations, culminating in a call to the new `print_graph` rendering function.
[2025-09-21T13:54:05] codex
**Finalizing graph line rendering logic**

I’m working out how to assemble the graph line by combining fixed-width colored prefix, trimmed colored graph content, and optional colored suffix with branch names and debug info, ensuring proper spacing and alignment without trailing spaces. I’ll implement helper functions for coloring text segments, ordering branch labels, and building each line cleanly using the new `LineDecoration` structs.
[2025-09-21T13:54:05] codex
**Refactoring branch label handling and print_unicode updates**

I'll reorder branches to prioritize the traced branch, create colored branch labels accordingly, and replace the old label vector with a vector of new LineDecoration structs. Then I’ll update `print_unicode` to build and use these new decorations, culminating in a call to the new `print_graph` rendering function.
[2025-09-21T13:54:16] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -56,3 +56,3 @@
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
@@ -73,11 +73,41 @@
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit
+            .oid
+            .to_string()
+            .chars()
+            .take(7)
+            .collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        branch_indices.dedup();
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
 
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
+
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
@@ -182,3 +212,3 @@
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
[2025-09-21T13:54:16] apply_patch(auto_approved=true) exited 0 in 38ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T13:54:16] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..0b5c37e03bc57a7cf53037d10385e380a1b97b2e
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -54,7 +54,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,15 +71,45 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit
+            .oid
+            .to_string()
+            .chars()
+            .take(7)
+            .collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        branch_indices.dedup();
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
 
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
+
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
                 Some(oid) => oid,
@@ -180,7 +210,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {

[2025-09-21T13:54:16] tokens used: 70,322
[2025-09-21T13:54:16] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..0b5c37e03bc57a7cf53037d10385e380a1b97b2e
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -54,7 +54,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,15 +71,45 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit
+            .oid
+            .to_string()
+            .chars()
+            .take(7)
+            .collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        branch_indices.dedup();
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
 
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
+
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
                 Some(oid) => oid,
@@ -180,7 +210,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {


[2025-09-21T13:54:28] thinking

**Reviewing deduplication and struct placement**
[2025-09-21T13:54:28] exec bash -lc "nl -ba src/print/unicode.rs | sed -n '320,460p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:54:28] bash -lc "nl -ba src/print/unicode.rs | sed -n '320,460p'" succeeded in 13ms:
   320	    }
   321	}
   322	
   323	#[derive(Clone, Copy)]
   324	enum Arrow {
   325	    Left,
   326	    Right,
   327	}
   328	
   329	impl Arrow {
   330	    fn char(self) -> char {
   331	        match self {
   332	            Arrow::Left => ARROW_LEFT,
   333	            Arrow::Right => ARROW_RIGHT,
   334	        }
   335	    }
   336	}
   337	
   338	#[derive(Clone, Copy, Default)]
   339	struct LineBits {
[2025-09-21T13:54:28] tokens used: 71,872
[2025-09-21T13:54:28] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..0b5c37e03bc57a7cf53037d10385e380a1b97b2e
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -54,7 +54,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,15 +71,45 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit
+            .oid
+            .to_string()
+            .chars()
+            .take(7)
+            .collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        branch_indices.dedup();
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
 
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
+
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
                 Some(oid) => oid,
@@ -180,7 +210,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {


[2025-09-21T13:54:32] thinking

**Locating encode_color_index definition**
[2025-09-21T13:54:32] exec bash -lc "nl -ba src/print/unicode.rs | sed -n '520,680p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:54:32] bash -lc "nl -ba src/print/unicode.rs | sed -n '520,680p'" succeeded in 29ms:
   520	    inserts
   521	}
   522	
   523	fn index_map(len: usize, inserts: &[Vec<Insert>]) -> (Vec<usize>, Vec<usize>) {
   524	    let mut rows = vec![0usize; len];
   525	    let mut extras = vec![0usize; len];
   526	
   527	    let mut offset = 0usize;
   528	    for index in 0..len {
   529	        rows[index] = index + offset;
   530	        let extra_rows = inserts[index]
   531	            .iter()
   532	            .map(|insert| insert.layer)
   533	            .max()
   534	            .map(|max_layer| max_layer + 1)
   535	            .unwrap_or(0);
   536	        extras[index] = extra_rows;
   537	        offset += extra_rows;
   538	    }
   539	
[2025-09-21T13:54:32] tokens used: 73,560
[2025-09-21T13:54:32] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..0b5c37e03bc57a7cf53037d10385e380a1b97b2e
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -54,7 +54,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,15 +71,45 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit
+            .oid
+            .to_string()
+            .chars()
+            .take(7)
+            .collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        branch_indices.dedup();
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
 
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
+
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
                 Some(oid) => oid,
@@ -180,7 +210,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {


[2025-09-21T13:54:41] thinking

**Preparing new graph rendering structures and constants**
[2025-09-21T13:54:42] exec bash -lc "nl -ba src/print/unicode.rs | sed -n '1,120p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:54:42] bash -lc "nl -ba src/print/unicode.rs | sed -n '1,120p'" succeeded in 44ms:
     1	use crate::{
     2	    graph::{BranchInfo, CommitInfo, GitGraph},
     3	    print::{colors, get_deviate_index},
     4	    settings::BranchSettings,
     5	};
     6	use term_painter::{Color as PainterColor, ToStyle};
     7	
     8	const DOT: char = '●';
     9	const CIRCLE: char = '○';
    10	const HOR: char = '─';
    11	const VER: char = '│';
    12	const TURN_UP_RIGHT: char = '└';
    13	const TURN_UP_LEFT: char = '┘';
    14	const TURN_DOWN_RIGHT: char = '┌';
    15	const TURN_DOWN_LEFT: char = '┐';
    16	const T_UP: char = '┴';
    17	const T_DOWN: char = '┬';
    18	const T_RIGHT: char = '├';
    19	const T_LEFT: char = '┤';
    20	const CROSS: char = '┼';
[2025-09-21T13:54:42] tokens used: 76,011
[2025-09-21T13:54:42] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..0b5c37e03bc57a7cf53037d10385e380a1b97b2e
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -54,7 +54,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,15 +71,45 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit
+            .oid
+            .to_string()
+            .chars()
+            .take(7)
+            .collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        branch_indices.dedup();
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
 
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
+
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
                 Some(oid) => oid,
@@ -180,7 +210,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {


[2025-09-21T13:54:45] thinking

**Preparing constants and structs**
[2025-09-21T13:54:47] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -24,2 +24,3 @@
 const COLOR_NONE: u8 = u8::MAX;
+const PREFIX_WIDTH: usize = 9;
 
@@ -32,2 +33,27 @@
 
+#[derive(Clone, Default)]
+struct LineDecoration {
+    prefix: Option<LinePrefix>,
+    suffix: Option<LineSuffix>,
+}
+
+#[derive(Clone)]
+struct LinePrefix {
+    short_id: String,
+    color: u8,
+}
+
+#[derive(Clone)]
+struct LineSuffix {
+    debug: Option<String>,
+    branches: Vec<LineBranch>,
+    summary: String,
+}
+
+#[derive(Clone)]
+struct LineBranch {
+    name: String,
+    color: u8,
+}
+
 /// Render the git graph as a Unicode string representation suitable for terminals.
[2025-09-21T13:54:47] apply_patch(auto_approved=true) exited 0 in 47ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T13:54:47] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..23d664da7b4af13f94586b3708b8a86d59c60735
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -22,6 +22,7 @@
 const ARROW_LEFT: char = '◀';
 
 const COLOR_NONE: u8 = u8::MAX;
+const PREFIX_WIDTH: usize = 9;
 
 #[derive(Clone, Debug)]
 struct Insert {
@@ -30,6 +31,31 @@
     layer: usize,
 }
 
+#[derive(Clone, Default)]
+struct LineDecoration {
+    prefix: Option<LinePrefix>,
+    suffix: Option<LineSuffix>,
+}
+
+#[derive(Clone)]
+struct LinePrefix {
+    short_id: String,
+    color: u8,
+}
+
+#[derive(Clone)]
+struct LineSuffix {
+    debug: Option<String>,
+    branches: Vec<LineBranch>,
+    summary: String,
+}
+
+#[derive(Clone)]
+struct LineBranch {
+    name: String,
+    color: u8,
+}
+
 /// Render the git graph as a Unicode string representation suitable for terminals.
 pub fn print_unicode(
     graph: &GitGraph,
@@ -54,7 +80,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,14 +97,44 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit
+            .oid
+            .to_string()
+            .chars()
+            .take(7)
+            .collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        branch_indices.dedup();
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
+
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
 
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
@@ -180,7 +236,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {

[2025-09-21T13:54:47] tokens used: 78,109
[2025-09-21T13:54:47] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..23d664da7b4af13f94586b3708b8a86d59c60735
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -22,6 +22,7 @@
 const ARROW_LEFT: char = '◀';
 
 const COLOR_NONE: u8 = u8::MAX;
+const PREFIX_WIDTH: usize = 9;
 
 #[derive(Clone, Debug)]
 struct Insert {
@@ -30,6 +31,31 @@
     layer: usize,
 }
 
+#[derive(Clone, Default)]
+struct LineDecoration {
+    prefix: Option<LinePrefix>,
+    suffix: Option<LineSuffix>,
+}
+
+#[derive(Clone)]
+struct LinePrefix {
+    short_id: String,
+    color: u8,
+}
+
+#[derive(Clone)]
+struct LineSuffix {
+    debug: Option<String>,
+    branches: Vec<LineBranch>,
+    summary: String,
+}
+
+#[derive(Clone)]
+struct LineBranch {
+    name: String,
+    color: u8,
+}
+
 /// Render the git graph as a Unicode string representation suitable for terminals.
 pub fn print_unicode(
     graph: &GitGraph,
@@ -54,7 +80,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,14 +97,44 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit
+            .oid
+            .to_string()
+            .chars()
+            .take(7)
+            .collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        branch_indices.dedup();
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
+
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
 
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
@@ -180,7 +236,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {


[2025-09-21T13:54:54] thinking

**Adding and reorganizing helper functions**
[2025-09-21T13:55:13] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -599,2 +599,11 @@
 
+fn color_index_for_branch(branch_settings: &BranchSettings, branch: &BranchInfo) -> usize {
+    let idx = branch.visual.color_group;
+    if idx < branch_settings.color.len() {
+        idx
+    } else {
+        branch_settings.color.len()
+    }
+}
+
 fn encode_color_index(idx: usize) -> u8 {
@@ -626,5 +635,5 @@
 
-fn to_string_block(
+fn print_graph(
     grid: &CharGrid,
-    labels: &[Option<String>],
+    decorations: &[LineDecoration],
     settings: &BranchSettings,
@@ -635,33 +644,25 @@
         let (chars, colors) = grid.row(row);
-        let mut line = String::new();
-        if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
-            let mut start = 0usize;
-            while start <= last_idx {
-                let color_idx = colors[start];
-                let mut end = start + 1;
-                while end <= last_idx && colors[end] == color_idx {
-                    end += 1;
-                }
-                let segment: String = chars[start..end].iter().collect();
-                if use_color {
-                    match term_color_for_index(color_idx, settings)? {
-                        Some(term_color) => {
-                            line.push_str(&term_color.paint(&segment).to_string());
-                        }
-                        None => line.push_str(&segment),
-                    }
-                } else {
-                    line.push_str(&segment);
-                }
-                start = end;
+        let prefix = render_prefix(decorations.get(row), settings, use_color)?;
+        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let suffix = render_suffix(decorations.get(row), settings, use_color)?;
+
+        let mut line = prefix;
+        let has_graph = !graph.is_empty();
+        if has_graph {
+            if !line.is_empty() {
+                line.push(' ');
             }
+            line.push_str(&graph);
         }
-        if let Some(label) = &labels[row] {
-            if !line.is_empty() {
+
+        if let Some(suffix) = suffix {
+            if has_graph || !line.trim().is_empty() {
                 line.push(' ');
             }
-            line.push_str(label);
+            line.push_str(&suffix);
         }
-        lines.push(line);
+
+        lines.push(line.trim_end().to_string());
     }
+
     Ok(lines.join("\n"))
@@ -669,2 +670,98 @@
 
+fn render_prefix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    let blank = " ".repeat(PREFIX_WIDTH);
+    let Some(prefix) = decoration.and_then(|d| d.prefix.as_ref()) else {
+        return Ok(blank);
+    };
+
+    let text = format!("{:<width$}", prefix.short_id, width = PREFIX_WIDTH);
+    paint_with_color(&text, prefix.color, settings, use_color)
+}
+
+fn render_suffix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<Option<String>, String> {
+    let Some(suffix) = decoration.and_then(|d| d.suffix.as_ref()) else {
+        return Ok(None);
+    };
+
+    let mut parts: Vec<String> = Vec::new();
+
+    if let Some(debug) = &suffix.debug {
+        parts.push(debug.clone());
+    }
+
+    if !suffix.branches.is_empty() {
+        let mut branch_parts = Vec::new();
+        for branch in &suffix.branches {
+            branch_parts.push(paint_with_color(&branch.name, branch.color, settings, use_color)?);
+        }
+        parts.push(branch_parts.join(", "));
+    }
+
+    if !suffix.summary.is_empty() {
+        parts.push(suffix.summary.clone());
+    }
+
+    if parts.is_empty() {
+        Ok(None)
+    } else {
+        Ok(Some(parts.join(" ")))
+    }
+}
+
+fn render_graph_line(
+    chars: &[char],
+    colors: &[u8],
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+        let mut line = String::new();
+        let mut start = 0usize;
+        while start <= last_idx {
+            let color_idx = colors[start];
+            let mut end = start + 1;
+            while end <= last_idx && colors[end] == color_idx {
+                end += 1;
+            }
+            let segment: String = chars[start..end].iter().collect();
+            if use_color {
+                match term_color_for_index(color_idx, settings)? {
+                    Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
+                    None => line.push_str(&segment),
+                }
+            } else {
+                line.push_str(&segment);
+            }
+            start = end;
+        }
+        Ok(line)
+    } else {
+        Ok(String::new())
+    }
+}
+
+fn paint_with_color(
+    text: &str,
+    color_idx: u8,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if !use_color {
+        return Ok(text.to_string());
+    }
+
+    match term_color_for_index(color_idx, settings)? {
+        Some(term_color) => Ok(term_color.paint(text).to_string()),
+        None => Ok(text.to_string()),
+    }
+}
+
 #[cfg(test)]
[2025-09-21T13:55:13] apply_patch(auto_approved=true) exited 0 in 41ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T13:55:13] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..eda18a34b61f8e0690f7935a2a05a1a82d14c420
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -22,6 +22,7 @@
 const ARROW_LEFT: char = '◀';
 
 const COLOR_NONE: u8 = u8::MAX;
+const PREFIX_WIDTH: usize = 9;
 
 #[derive(Clone, Debug)]
 struct Insert {
@@ -30,6 +31,31 @@
     layer: usize,
 }
 
+#[derive(Clone, Default)]
+struct LineDecoration {
+    prefix: Option<LinePrefix>,
+    suffix: Option<LineSuffix>,
+}
+
+#[derive(Clone)]
+struct LinePrefix {
+    short_id: String,
+    color: u8,
+}
+
+#[derive(Clone)]
+struct LineSuffix {
+    debug: Option<String>,
+    branches: Vec<LineBranch>,
+    summary: String,
+}
+
+#[derive(Clone)]
+struct LineBranch {
+    name: String,
+    color: u8,
+}
+
 /// Render the git graph as a Unicode string representation suitable for terminals.
 pub fn print_unicode(
     graph: &GitGraph,
@@ -54,7 +80,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,14 +97,44 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit
+            .oid
+            .to_string()
+            .chars()
+            .take(7)
+            .collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        branch_indices.dedup();
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
+
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
 
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
@@ -180,7 +236,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {
@@ -541,6 +597,15 @@
     branch_settings.color.len()
 }
 
+fn color_index_for_branch(branch_settings: &BranchSettings, branch: &BranchInfo) -> usize {
+    let idx = branch.visual.color_group;
+    if idx < branch_settings.color.len() {
+        idx
+    } else {
+        branch_settings.color.len()
+    }
+}
+
 fn encode_color_index(idx: usize) -> u8 {
     if idx >= COLOR_NONE as usize {
         (COLOR_NONE - 1) as u8
@@ -568,49 +633,137 @@
         .ok_or_else(|| format!("Unknown terminal color: {}", name))
 }
 
-fn to_string_block(
+fn print_graph(
     grid: &CharGrid,
-    labels: &[Option<String>],
+    decorations: &[LineDecoration],
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
         let (chars, colors) = grid.row(row);
-        let mut line = String::new();
-        if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
-            let mut start = 0usize;
-            while start <= last_idx {
-                let color_idx = colors[start];
-                let mut end = start + 1;
-                while end <= last_idx && colors[end] == color_idx {
-                    end += 1;
-                }
-                let segment: String = chars[start..end].iter().collect();
-                if use_color {
-                    match term_color_for_index(color_idx, settings)? {
-                        Some(term_color) => {
-                            line.push_str(&term_color.paint(&segment).to_string());
-                        }
-                        None => line.push_str(&segment),
-                    }
-                } else {
-                    line.push_str(&segment);
-                }
-                start = end;
+        let prefix = render_prefix(decorations.get(row), settings, use_color)?;
+        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let suffix = render_suffix(decorations.get(row), settings, use_color)?;
+
+        let mut line = prefix;
+        let has_graph = !graph.is_empty();
+        if has_graph {
+            if !line.is_empty() {
+                line.push(' ');
             }
+            line.push_str(&graph);
         }
-        if let Some(label) = &labels[row] {
-            if !line.is_empty() {
+
+        if let Some(suffix) = suffix {
+            if has_graph || !line.trim().is_empty() {
                 line.push(' ');
             }
-            line.push_str(label);
+            line.push_str(&suffix);
         }
-        lines.push(line);
+
+        lines.push(line.trim_end().to_string());
     }
+
     Ok(lines.join("\n"))
 }
 
+fn render_prefix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    let blank = " ".repeat(PREFIX_WIDTH);
+    let Some(prefix) = decoration.and_then(|d| d.prefix.as_ref()) else {
+        return Ok(blank);
+    };
+
+    let text = format!("{:<width$}", prefix.short_id, width = PREFIX_WIDTH);
+    paint_with_color(&text, prefix.color, settings, use_color)
+}
+
+fn render_suffix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<Option<String>, String> {
+    let Some(suffix) = decoration.and_then(|d| d.suffix.as_ref()) else {
+        return Ok(None);
+    };
+
+    let mut parts: Vec<String> = Vec::new();
+
+    if let Some(debug) = &suffix.debug {
+        parts.push(debug.clone());
+    }
+
+    if !suffix.branches.is_empty() {
+        let mut branch_parts = Vec::new();
+        for branch in &suffix.branches {
+            branch_parts.push(paint_with_color(&branch.name, branch.color, settings, use_color)?);
+        }
+        parts.push(branch_parts.join(", "));
+    }
+
+    if !suffix.summary.is_empty() {
+        parts.push(suffix.summary.clone());
+    }
+
+    if parts.is_empty() {
+        Ok(None)
+    } else {
+        Ok(Some(parts.join(" ")))
+    }
+}
+
+fn render_graph_line(
+    chars: &[char],
+    colors: &[u8],
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+        let mut line = String::new();
+        let mut start = 0usize;
+        while start <= last_idx {
+            let color_idx = colors[start];
+            let mut end = start + 1;
+            while end <= last_idx && colors[end] == color_idx {
+                end += 1;
+            }
+            let segment: String = chars[start..end].iter().collect();
+            if use_color {
+                match term_color_for_index(color_idx, settings)? {
+                    Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
+                    None => line.push_str(&segment),
+                }
+            } else {
+                line.push_str(&segment);
+            }
+            start = end;
+        }
+        Ok(line)
+    } else {
+        Ok(String::new())
+    }
+}
+
+fn paint_with_color(
+    text: &str,
+    color_idx: u8,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if !use_color {
+        return Ok(text.to_string());
+    }
+
+    match term_color_for_index(color_idx, settings)? {
+        Some(term_color) => Ok(term_color.paint(text).to_string()),
+        None => Ok(text.to_string()),
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;

[2025-09-21T13:55:13] tokens used: 80,627
[2025-09-21T13:55:13] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..eda18a34b61f8e0690f7935a2a05a1a82d14c420
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -22,6 +22,7 @@
 const ARROW_LEFT: char = '◀';
 
 const COLOR_NONE: u8 = u8::MAX;
+const PREFIX_WIDTH: usize = 9;
 
 #[derive(Clone, Debug)]
 struct Insert {
@@ -30,6 +31,31 @@
     layer: usize,
 }
 
+#[derive(Clone, Default)]
+struct LineDecoration {
+    prefix: Option<LinePrefix>,
+    suffix: Option<LineSuffix>,
+}
+
+#[derive(Clone)]
+struct LinePrefix {
+    short_id: String,
+    color: u8,
+}
+
+#[derive(Clone)]
+struct LineSuffix {
+    debug: Option<String>,
+    branches: Vec<LineBranch>,
+    summary: String,
+}
+
+#[derive(Clone)]
+struct LineBranch {
+    name: String,
+    color: u8,
+}
+
 /// Render the git graph as a Unicode string representation suitable for terminals.
 pub fn print_unicode(
     graph: &GitGraph,
@@ -54,7 +80,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,14 +97,44 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit
+            .oid
+            .to_string()
+            .chars()
+            .take(7)
+            .collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        branch_indices.dedup();
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
+
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
 
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
@@ -180,7 +236,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {
@@ -541,6 +597,15 @@
     branch_settings.color.len()
 }
 
+fn color_index_for_branch(branch_settings: &BranchSettings, branch: &BranchInfo) -> usize {
+    let idx = branch.visual.color_group;
+    if idx < branch_settings.color.len() {
+        idx
+    } else {
+        branch_settings.color.len()
+    }
+}
+
 fn encode_color_index(idx: usize) -> u8 {
     if idx >= COLOR_NONE as usize {
         (COLOR_NONE - 1) as u8
@@ -568,49 +633,137 @@
         .ok_or_else(|| format!("Unknown terminal color: {}", name))
 }
 
-fn to_string_block(
+fn print_graph(
     grid: &CharGrid,
-    labels: &[Option<String>],
+    decorations: &[LineDecoration],
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
         let (chars, colors) = grid.row(row);
-        let mut line = String::new();
-        if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
-            let mut start = 0usize;
-            while start <= last_idx {
-                let color_idx = colors[start];
-                let mut end = start + 1;
-                while end <= last_idx && colors[end] == color_idx {
-                    end += 1;
-                }
-                let segment: String = chars[start..end].iter().collect();
-                if use_color {
-                    match term_color_for_index(color_idx, settings)? {
-                        Some(term_color) => {
-                            line.push_str(&term_color.paint(&segment).to_string());
-                        }
-                        None => line.push_str(&segment),
-                    }
-                } else {
-                    line.push_str(&segment);
-                }
-                start = end;
+        let prefix = render_prefix(decorations.get(row), settings, use_color)?;
+        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let suffix = render_suffix(decorations.get(row), settings, use_color)?;
+
+        let mut line = prefix;
+        let has_graph = !graph.is_empty();
+        if has_graph {
+            if !line.is_empty() {
+                line.push(' ');
             }
+            line.push_str(&graph);
         }
-        if let Some(label) = &labels[row] {
-            if !line.is_empty() {
+
+        if let Some(suffix) = suffix {
+            if has_graph || !line.trim().is_empty() {
                 line.push(' ');
             }
-            line.push_str(label);
+            line.push_str(&suffix);
         }
-        lines.push(line);
+
+        lines.push(line.trim_end().to_string());
     }
+
     Ok(lines.join("\n"))
 }
 
+fn render_prefix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    let blank = " ".repeat(PREFIX_WIDTH);
+    let Some(prefix) = decoration.and_then(|d| d.prefix.as_ref()) else {
+        return Ok(blank);
+    };
+
+    let text = format!("{:<width$}", prefix.short_id, width = PREFIX_WIDTH);
+    paint_with_color(&text, prefix.color, settings, use_color)
+}
+
+fn render_suffix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<Option<String>, String> {
+    let Some(suffix) = decoration.and_then(|d| d.suffix.as_ref()) else {
+        return Ok(None);
+    };
+
+    let mut parts: Vec<String> = Vec::new();
+
+    if let Some(debug) = &suffix.debug {
+        parts.push(debug.clone());
+    }
+
+    if !suffix.branches.is_empty() {
+        let mut branch_parts = Vec::new();
+        for branch in &suffix.branches {
+            branch_parts.push(paint_with_color(&branch.name, branch.color, settings, use_color)?);
+        }
+        parts.push(branch_parts.join(", "));
+    }
+
+    if !suffix.summary.is_empty() {
+        parts.push(suffix.summary.clone());
+    }
+
+    if parts.is_empty() {
+        Ok(None)
+    } else {
+        Ok(Some(parts.join(" ")))
+    }
+}
+
+fn render_graph_line(
+    chars: &[char],
+    colors: &[u8],
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+        let mut line = String::new();
+        let mut start = 0usize;
+        while start <= last_idx {
+            let color_idx = colors[start];
+            let mut end = start + 1;
+            while end <= last_idx && colors[end] == color_idx {
+                end += 1;
+            }
+            let segment: String = chars[start..end].iter().collect();
+            if use_color {
+                match term_color_for_index(color_idx, settings)? {
+                    Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
+                    None => line.push_str(&segment),
+                }
+            } else {
+                line.push_str(&segment);
+            }
+            start = end;
+        }
+        Ok(line)
+    } else {
+        Ok(String::new())
+    }
+}
+
+fn paint_with_color(
+    text: &str,
+    color_idx: u8,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if !use_color {
+        return Ok(text.to_string());
+    }
+
+    match term_color_for_index(color_idx, settings)? {
+        Some(term_color) => Ok(term_color.paint(text).to_string()),
+        None => Ok(text.to_string()),
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;


[2025-09-21T13:55:20] thinking

**Verifying function replacements**
[2025-09-21T13:55:20] exec bash -lc 'rg "to_string_block" -n src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:55:20] bash -lc 'rg "to_string_block" -n src/print/unicode.rs' exited 1 in 11ms:

[2025-09-21T13:55:20] tokens used: 123,750
[2025-09-21T13:55:20] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..eda18a34b61f8e0690f7935a2a05a1a82d14c420
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -22,6 +22,7 @@
 const ARROW_LEFT: char = '◀';
 
 const COLOR_NONE: u8 = u8::MAX;
+const PREFIX_WIDTH: usize = 9;
 
 #[derive(Clone, Debug)]
 struct Insert {
@@ -30,6 +31,31 @@
     layer: usize,
 }
 
+#[derive(Clone, Default)]
+struct LineDecoration {
+    prefix: Option<LinePrefix>,
+    suffix: Option<LineSuffix>,
+}
+
+#[derive(Clone)]
+struct LinePrefix {
+    short_id: String,
+    color: u8,
+}
+
+#[derive(Clone)]
+struct LineSuffix {
+    debug: Option<String>,
+    branches: Vec<LineBranch>,
+    summary: String,
+}
+
+#[derive(Clone)]
+struct LineBranch {
+    name: String,
+    color: u8,
+}
+
 /// Render the git graph as a Unicode string representation suitable for terminals.
 pub fn print_unicode(
     graph: &GitGraph,
@@ -54,7 +80,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,14 +97,44 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit
+            .oid
+            .to_string()
+            .chars()
+            .take(7)
+            .collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        branch_indices.dedup();
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
+
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
 
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
@@ -180,7 +236,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {
@@ -541,6 +597,15 @@
     branch_settings.color.len()
 }
 
+fn color_index_for_branch(branch_settings: &BranchSettings, branch: &BranchInfo) -> usize {
+    let idx = branch.visual.color_group;
+    if idx < branch_settings.color.len() {
+        idx
+    } else {
+        branch_settings.color.len()
+    }
+}
+
 fn encode_color_index(idx: usize) -> u8 {
     if idx >= COLOR_NONE as usize {
         (COLOR_NONE - 1) as u8
@@ -568,49 +633,137 @@
         .ok_or_else(|| format!("Unknown terminal color: {}", name))
 }
 
-fn to_string_block(
+fn print_graph(
     grid: &CharGrid,
-    labels: &[Option<String>],
+    decorations: &[LineDecoration],
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
         let (chars, colors) = grid.row(row);
-        let mut line = String::new();
-        if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
-            let mut start = 0usize;
-            while start <= last_idx {
-                let color_idx = colors[start];
-                let mut end = start + 1;
-                while end <= last_idx && colors[end] == color_idx {
-                    end += 1;
-                }
-                let segment: String = chars[start..end].iter().collect();
-                if use_color {
-                    match term_color_for_index(color_idx, settings)? {
-                        Some(term_color) => {
-                            line.push_str(&term_color.paint(&segment).to_string());
-                        }
-                        None => line.push_str(&segment),
-                    }
-                } else {
-                    line.push_str(&segment);
-                }
-                start = end;
+        let prefix = render_prefix(decorations.get(row), settings, use_color)?;
+        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let suffix = render_suffix(decorations.get(row), settings, use_color)?;
+
+        let mut line = prefix;
+        let has_graph = !graph.is_empty();
+        if has_graph {
+            if !line.is_empty() {
+                line.push(' ');
             }
+            line.push_str(&graph);
         }
-        if let Some(label) = &labels[row] {
-            if !line.is_empty() {
+
+        if let Some(suffix) = suffix {
+            if has_graph || !line.trim().is_empty() {
                 line.push(' ');
             }
-            line.push_str(label);
+            line.push_str(&suffix);
         }
-        lines.push(line);
+
+        lines.push(line.trim_end().to_string());
     }
+
     Ok(lines.join("\n"))
 }
 
+fn render_prefix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    let blank = " ".repeat(PREFIX_WIDTH);
+    let Some(prefix) = decoration.and_then(|d| d.prefix.as_ref()) else {
+        return Ok(blank);
+    };
+
+    let text = format!("{:<width$}", prefix.short_id, width = PREFIX_WIDTH);
+    paint_with_color(&text, prefix.color, settings, use_color)
+}
+
+fn render_suffix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<Option<String>, String> {
+    let Some(suffix) = decoration.and_then(|d| d.suffix.as_ref()) else {
+        return Ok(None);
+    };
+
+    let mut parts: Vec<String> = Vec::new();
+
+    if let Some(debug) = &suffix.debug {
+        parts.push(debug.clone());
+    }
+
+    if !suffix.branches.is_empty() {
+        let mut branch_parts = Vec::new();
+        for branch in &suffix.branches {
+            branch_parts.push(paint_with_color(&branch.name, branch.color, settings, use_color)?);
+        }
+        parts.push(branch_parts.join(", "));
+    }
+
+    if !suffix.summary.is_empty() {
+        parts.push(suffix.summary.clone());
+    }
+
+    if parts.is_empty() {
+        Ok(None)
+    } else {
+        Ok(Some(parts.join(" ")))
+    }
+}
+
+fn render_graph_line(
+    chars: &[char],
+    colors: &[u8],
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+        let mut line = String::new();
+        let mut start = 0usize;
+        while start <= last_idx {
+            let color_idx = colors[start];
+            let mut end = start + 1;
+            while end <= last_idx && colors[end] == color_idx {
+                end += 1;
+            }
+            let segment: String = chars[start..end].iter().collect();
+            if use_color {
+                match term_color_for_index(color_idx, settings)? {
+                    Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
+                    None => line.push_str(&segment),
+                }
+            } else {
+                line.push_str(&segment);
+            }
+            start = end;
+        }
+        Ok(line)
+    } else {
+        Ok(String::new())
+    }
+}
+
+fn paint_with_color(
+    text: &str,
+    color_idx: u8,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if !use_color {
+        return Ok(text.to_string());
+    }
+
+    match term_color_for_index(color_idx, settings)? {
+        Some(term_color) => Ok(term_color.paint(text).to_string()),
+        None => Ok(text.to_string()),
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;


[2025-09-21T13:55:34] thinking

**Reviewing rendering and debug printing adjustments**

I'm checking how `dedup` interacts with branch indices and verifying proper usage of mutable references for line decorations. I'm also making sure prefix and suffix rendering handle spacing, coloring, and empty cases correctly. Finally, I'll ensure debug duration printing in `main.rs` only happens when the debug flag is set, wrapping the existing eprintln calls accordingly.
[2025-09-21T13:55:35] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -88,8 +88,10 @@
 
-    eprintln!(
-        "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
-        duration_graph as f32 / 1000.0,
-        duration_print as f32 / 1000.0,
-        graph.commits.len()
-    );
+    if settings.debug {
+        eprintln!(
+            "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
+            duration_graph as f32 / 1000.0,
+            duration_print as f32 / 1000.0,
+            graph.commits.len()
+        );
+    }
 
[2025-09-21T13:55:35] apply_patch(auto_approved=true) exited 0 in 49ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T13:55:35] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 770a37ff9549fd0b39bf41b9e0064c17396ff3fb..a0990b6ed45d7d794944230d35114c8ab003cd52
--- a/src/main.rs
+++ b/src/main.rs
@@ -86,12 +86,14 @@
     }
     let duration_print = now.elapsed().as_micros();
 
-    eprintln!(
-        "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
-        duration_graph as f32 / 1000.0,
-        duration_print as f32 / 1000.0,
-        graph.commits.len()
-    );
+    if settings.debug {
+        eprintln!(
+            "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
+            duration_graph as f32 / 1000.0,
+            duration_print as f32 / 1000.0,
+            graph.commits.len()
+        );
+    }
 
     Ok(())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..eda18a34b61f8e0690f7935a2a05a1a82d14c420
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -22,6 +22,7 @@
 const ARROW_LEFT: char = '◀';
 
 const COLOR_NONE: u8 = u8::MAX;
+const PREFIX_WIDTH: usize = 9;
 
 #[derive(Clone, Debug)]
 struct Insert {
@@ -30,6 +31,31 @@
     layer: usize,
 }
 
+#[derive(Clone, Default)]
+struct LineDecoration {
+    prefix: Option<LinePrefix>,
+    suffix: Option<LineSuffix>,
+}
+
+#[derive(Clone)]
+struct LinePrefix {
+    short_id: String,
+    color: u8,
+}
+
+#[derive(Clone)]
+struct LineSuffix {
+    debug: Option<String>,
+    branches: Vec<LineBranch>,
+    summary: String,
+}
+
+#[derive(Clone)]
+struct LineBranch {
+    name: String,
+    color: u8,
+}
+
 /// Render the git graph as a Unicode string representation suitable for terminals.
 pub fn print_unicode(
     graph: &GitGraph,
@@ -54,7 +80,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,14 +97,44 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit
+            .oid
+            .to_string()
+            .chars()
+            .take(7)
+            .collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        branch_indices.dedup();
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
+
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
 
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
@@ -180,7 +236,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {
@@ -541,6 +597,15 @@
     branch_settings.color.len()
 }
 
+fn color_index_for_branch(branch_settings: &BranchSettings, branch: &BranchInfo) -> usize {
+    let idx = branch.visual.color_group;
+    if idx < branch_settings.color.len() {
+        idx
+    } else {
+        branch_settings.color.len()
+    }
+}
+
 fn encode_color_index(idx: usize) -> u8 {
     if idx >= COLOR_NONE as usize {
         (COLOR_NONE - 1) as u8
@@ -568,49 +633,137 @@
         .ok_or_else(|| format!("Unknown terminal color: {}", name))
 }
 
-fn to_string_block(
+fn print_graph(
     grid: &CharGrid,
-    labels: &[Option<String>],
+    decorations: &[LineDecoration],
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
         let (chars, colors) = grid.row(row);
-        let mut line = String::new();
-        if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
-            let mut start = 0usize;
-            while start <= last_idx {
-                let color_idx = colors[start];
-                let mut end = start + 1;
-                while end <= last_idx && colors[end] == color_idx {
-                    end += 1;
-                }
-                let segment: String = chars[start..end].iter().collect();
-                if use_color {
-                    match term_color_for_index(color_idx, settings)? {
-                        Some(term_color) => {
-                            line.push_str(&term_color.paint(&segment).to_string());
-                        }
-                        None => line.push_str(&segment),
-                    }
-                } else {
-                    line.push_str(&segment);
-                }
-                start = end;
+        let prefix = render_prefix(decorations.get(row), settings, use_color)?;
+        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let suffix = render_suffix(decorations.get(row), settings, use_color)?;
+
+        let mut line = prefix;
+        let has_graph = !graph.is_empty();
+        if has_graph {
+            if !line.is_empty() {
+                line.push(' ');
             }
+            line.push_str(&graph);
         }
-        if let Some(label) = &labels[row] {
-            if !line.is_empty() {
+
+        if let Some(suffix) = suffix {
+            if has_graph || !line.trim().is_empty() {
                 line.push(' ');
             }
-            line.push_str(label);
+            line.push_str(&suffix);
         }
-        lines.push(line);
+
+        lines.push(line.trim_end().to_string());
     }
+
     Ok(lines.join("\n"))
 }
 
+fn render_prefix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    let blank = " ".repeat(PREFIX_WIDTH);
+    let Some(prefix) = decoration.and_then(|d| d.prefix.as_ref()) else {
+        return Ok(blank);
+    };
+
+    let text = format!("{:<width$}", prefix.short_id, width = PREFIX_WIDTH);
+    paint_with_color(&text, prefix.color, settings, use_color)
+}
+
+fn render_suffix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<Option<String>, String> {
+    let Some(suffix) = decoration.and_then(|d| d.suffix.as_ref()) else {
+        return Ok(None);
+    };
+
+    let mut parts: Vec<String> = Vec::new();
+
+    if let Some(debug) = &suffix.debug {
+        parts.push(debug.clone());
+    }
+
+    if !suffix.branches.is_empty() {
+        let mut branch_parts = Vec::new();
+        for branch in &suffix.branches {
+            branch_parts.push(paint_with_color(&branch.name, branch.color, settings, use_color)?);
+        }
+        parts.push(branch_parts.join(", "));
+    }
+
+    if !suffix.summary.is_empty() {
+        parts.push(suffix.summary.clone());
+    }
+
+    if parts.is_empty() {
+        Ok(None)
+    } else {
+        Ok(Some(parts.join(" ")))
+    }
+}
+
+fn render_graph_line(
+    chars: &[char],
+    colors: &[u8],
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+        let mut line = String::new();
+        let mut start = 0usize;
+        while start <= last_idx {
+            let color_idx = colors[start];
+            let mut end = start + 1;
+            while end <= last_idx && colors[end] == color_idx {
+                end += 1;
+            }
+            let segment: String = chars[start..end].iter().collect();
+            if use_color {
+                match term_color_for_index(color_idx, settings)? {
+                    Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
+                    None => line.push_str(&segment),
+                }
+            } else {
+                line.push_str(&segment);
+            }
+            start = end;
+        }
+        Ok(line)
+    } else {
+        Ok(String::new())
+    }
+}
+
+fn paint_with_color(
+    text: &str,
+    color_idx: u8,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if !use_color {
+        return Ok(text.to_string());
+    }
+
+    match term_color_for_index(color_idx, settings)? {
+        Some(term_color) => Ok(term_color.paint(text).to_string()),
+        None => Ok(text.to_string()),
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;

[2025-09-21T13:55:35] tokens used: 127,161
[2025-09-21T13:55:35] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 770a37ff9549fd0b39bf41b9e0064c17396ff3fb..a0990b6ed45d7d794944230d35114c8ab003cd52
--- a/src/main.rs
+++ b/src/main.rs
@@ -86,12 +86,14 @@
     }
     let duration_print = now.elapsed().as_micros();
 
-    eprintln!(
-        "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
-        duration_graph as f32 / 1000.0,
-        duration_print as f32 / 1000.0,
-        graph.commits.len()
-    );
+    if settings.debug {
+        eprintln!(
+            "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
+            duration_graph as f32 / 1000.0,
+            duration_print as f32 / 1000.0,
+            graph.commits.len()
+        );
+    }
 
     Ok(())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..eda18a34b61f8e0690f7935a2a05a1a82d14c420
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -22,6 +22,7 @@
 const ARROW_LEFT: char = '◀';
 
 const COLOR_NONE: u8 = u8::MAX;
+const PREFIX_WIDTH: usize = 9;
 
 #[derive(Clone, Debug)]
 struct Insert {
@@ -30,6 +31,31 @@
     layer: usize,
 }
 
+#[derive(Clone, Default)]
+struct LineDecoration {
+    prefix: Option<LinePrefix>,
+    suffix: Option<LineSuffix>,
+}
+
+#[derive(Clone)]
+struct LinePrefix {
+    short_id: String,
+    color: u8,
+}
+
+#[derive(Clone)]
+struct LineSuffix {
+    debug: Option<String>,
+    branches: Vec<LineBranch>,
+    summary: String,
+}
+
+#[derive(Clone)]
+struct LineBranch {
+    name: String,
+    color: u8,
+}
+
 /// Render the git graph as a Unicode string representation suitable for terminals.
 pub fn print_unicode(
     graph: &GitGraph,
@@ -54,7 +80,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,14 +97,44 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit
+            .oid
+            .to_string()
+            .chars()
+            .take(7)
+            .collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        branch_indices.dedup();
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
+
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
 
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
@@ -180,7 +236,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {
@@ -541,6 +597,15 @@
     branch_settings.color.len()
 }
 
+fn color_index_for_branch(branch_settings: &BranchSettings, branch: &BranchInfo) -> usize {
+    let idx = branch.visual.color_group;
+    if idx < branch_settings.color.len() {
+        idx
+    } else {
+        branch_settings.color.len()
+    }
+}
+
 fn encode_color_index(idx: usize) -> u8 {
     if idx >= COLOR_NONE as usize {
         (COLOR_NONE - 1) as u8
@@ -568,49 +633,137 @@
         .ok_or_else(|| format!("Unknown terminal color: {}", name))
 }
 
-fn to_string_block(
+fn print_graph(
     grid: &CharGrid,
-    labels: &[Option<String>],
+    decorations: &[LineDecoration],
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
         let (chars, colors) = grid.row(row);
-        let mut line = String::new();
-        if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
-            let mut start = 0usize;
-            while start <= last_idx {
-                let color_idx = colors[start];
-                let mut end = start + 1;
-                while end <= last_idx && colors[end] == color_idx {
-                    end += 1;
-                }
-                let segment: String = chars[start..end].iter().collect();
-                if use_color {
-                    match term_color_for_index(color_idx, settings)? {
-                        Some(term_color) => {
-                            line.push_str(&term_color.paint(&segment).to_string());
-                        }
-                        None => line.push_str(&segment),
-                    }
-                } else {
-                    line.push_str(&segment);
-                }
-                start = end;
+        let prefix = render_prefix(decorations.get(row), settings, use_color)?;
+        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let suffix = render_suffix(decorations.get(row), settings, use_color)?;
+
+        let mut line = prefix;
+        let has_graph = !graph.is_empty();
+        if has_graph {
+            if !line.is_empty() {
+                line.push(' ');
             }
+            line.push_str(&graph);
         }
-        if let Some(label) = &labels[row] {
-            if !line.is_empty() {
+
+        if let Some(suffix) = suffix {
+            if has_graph || !line.trim().is_empty() {
                 line.push(' ');
             }
-            line.push_str(label);
+            line.push_str(&suffix);
         }
-        lines.push(line);
+
+        lines.push(line.trim_end().to_string());
     }
+
     Ok(lines.join("\n"))
 }
 
+fn render_prefix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    let blank = " ".repeat(PREFIX_WIDTH);
+    let Some(prefix) = decoration.and_then(|d| d.prefix.as_ref()) else {
+        return Ok(blank);
+    };
+
+    let text = format!("{:<width$}", prefix.short_id, width = PREFIX_WIDTH);
+    paint_with_color(&text, prefix.color, settings, use_color)
+}
+
+fn render_suffix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<Option<String>, String> {
+    let Some(suffix) = decoration.and_then(|d| d.suffix.as_ref()) else {
+        return Ok(None);
+    };
+
+    let mut parts: Vec<String> = Vec::new();
+
+    if let Some(debug) = &suffix.debug {
+        parts.push(debug.clone());
+    }
+
+    if !suffix.branches.is_empty() {
+        let mut branch_parts = Vec::new();
+        for branch in &suffix.branches {
+            branch_parts.push(paint_with_color(&branch.name, branch.color, settings, use_color)?);
+        }
+        parts.push(branch_parts.join(", "));
+    }
+
+    if !suffix.summary.is_empty() {
+        parts.push(suffix.summary.clone());
+    }
+
+    if parts.is_empty() {
+        Ok(None)
+    } else {
+        Ok(Some(parts.join(" ")))
+    }
+}
+
+fn render_graph_line(
+    chars: &[char],
+    colors: &[u8],
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+        let mut line = String::new();
+        let mut start = 0usize;
+        while start <= last_idx {
+            let color_idx = colors[start];
+            let mut end = start + 1;
+            while end <= last_idx && colors[end] == color_idx {
+                end += 1;
+            }
+            let segment: String = chars[start..end].iter().collect();
+            if use_color {
+                match term_color_for_index(color_idx, settings)? {
+                    Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
+                    None => line.push_str(&segment),
+                }
+            } else {
+                line.push_str(&segment);
+            }
+            start = end;
+        }
+        Ok(line)
+    } else {
+        Ok(String::new())
+    }
+}
+
+fn paint_with_color(
+    text: &str,
+    color_idx: u8,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if !use_color {
+        return Ok(text.to_string());
+    }
+
+    match term_color_for_index(color_idx, settings)? {
+        Some(term_color) => Ok(term_color.paint(text).to_string()),
+        None => Ok(text.to_string()),
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;


[2025-09-21T13:55:40] thinking

**Improving duplicate removal logic in branch indices**
[2025-09-21T13:55:41] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -114,3 +114,11 @@
 
-        branch_indices.dedup();
+        let mut seen = Vec::new();
+        branch_indices.retain(|idx| {
+            if seen.contains(idx) {
+                false
+            } else {
+                seen.push(*idx);
+                true
+            }
+        });
 
[2025-09-21T13:55:41] apply_patch(auto_approved=true) exited 0 in 53ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T13:55:41] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 770a37ff9549fd0b39bf41b9e0064c17396ff3fb..a0990b6ed45d7d794944230d35114c8ab003cd52
--- a/src/main.rs
+++ b/src/main.rs
@@ -86,12 +86,14 @@
     }
     let duration_print = now.elapsed().as_micros();
 
-    eprintln!(
-        "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
-        duration_graph as f32 / 1000.0,
-        duration_print as f32 / 1000.0,
-        graph.commits.len()
-    );
+    if settings.debug {
+        eprintln!(
+            "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
+            duration_graph as f32 / 1000.0,
+            duration_print as f32 / 1000.0,
+            graph.commits.len()
+        );
+    }
 
     Ok(())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..39e6e6d925f2909b568ec1531fa54161caae8d83
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -22,6 +22,7 @@
 const ARROW_LEFT: char = '◀';
 
 const COLOR_NONE: u8 = u8::MAX;
+const PREFIX_WIDTH: usize = 9;
 
 #[derive(Clone, Debug)]
 struct Insert {
@@ -30,6 +31,31 @@
     layer: usize,
 }
 
+#[derive(Clone, Default)]
+struct LineDecoration {
+    prefix: Option<LinePrefix>,
+    suffix: Option<LineSuffix>,
+}
+
+#[derive(Clone)]
+struct LinePrefix {
+    short_id: String,
+    color: u8,
+}
+
+#[derive(Clone)]
+struct LineSuffix {
+    debug: Option<String>,
+    branches: Vec<LineBranch>,
+    summary: String,
+}
+
+#[derive(Clone)]
+struct LineBranch {
+    name: String,
+    color: u8,
+}
+
 /// Render the git graph as a Unicode string representation suitable for terminals.
 pub fn print_unicode(
     graph: &GitGraph,
@@ -54,7 +80,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,14 +97,52 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit
+            .oid
+            .to_string()
+            .chars()
+            .take(7)
+            .collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        let mut seen = Vec::new();
+        branch_indices.retain(|idx| {
+            if seen.contains(idx) {
+                false
+            } else {
+                seen.push(*idx);
+                true
+            }
+        });
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
+
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
 
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
@@ -180,7 +244,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {
@@ -541,6 +605,15 @@
     branch_settings.color.len()
 }
 
+fn color_index_for_branch(branch_settings: &BranchSettings, branch: &BranchInfo) -> usize {
+    let idx = branch.visual.color_group;
+    if idx < branch_settings.color.len() {
+        idx
+    } else {
+        branch_settings.color.len()
+    }
+}
+
 fn encode_color_index(idx: usize) -> u8 {
     if idx >= COLOR_NONE as usize {
         (COLOR_NONE - 1) as u8
@@ -568,49 +641,137 @@
         .ok_or_else(|| format!("Unknown terminal color: {}", name))
 }
 
-fn to_string_block(
+fn print_graph(
     grid: &CharGrid,
-    labels: &[Option<String>],
+    decorations: &[LineDecoration],
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
         let (chars, colors) = grid.row(row);
-        let mut line = String::new();
-        if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
-            let mut start = 0usize;
-            while start <= last_idx {
-                let color_idx = colors[start];
-                let mut end = start + 1;
-                while end <= last_idx && colors[end] == color_idx {
-                    end += 1;
-                }
-                let segment: String = chars[start..end].iter().collect();
-                if use_color {
-                    match term_color_for_index(color_idx, settings)? {
-                        Some(term_color) => {
-                            line.push_str(&term_color.paint(&segment).to_string());
-                        }
-                        None => line.push_str(&segment),
-                    }
-                } else {
-                    line.push_str(&segment);
-                }
-                start = end;
+        let prefix = render_prefix(decorations.get(row), settings, use_color)?;
+        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let suffix = render_suffix(decorations.get(row), settings, use_color)?;
+
+        let mut line = prefix;
+        let has_graph = !graph.is_empty();
+        if has_graph {
+            if !line.is_empty() {
+                line.push(' ');
             }
+            line.push_str(&graph);
         }
-        if let Some(label) = &labels[row] {
-            if !line.is_empty() {
+
+        if let Some(suffix) = suffix {
+            if has_graph || !line.trim().is_empty() {
                 line.push(' ');
             }
-            line.push_str(label);
+            line.push_str(&suffix);
         }
-        lines.push(line);
+
+        lines.push(line.trim_end().to_string());
     }
+
     Ok(lines.join("\n"))
 }
 
+fn render_prefix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    let blank = " ".repeat(PREFIX_WIDTH);
+    let Some(prefix) = decoration.and_then(|d| d.prefix.as_ref()) else {
+        return Ok(blank);
+    };
+
+    let text = format!("{:<width$}", prefix.short_id, width = PREFIX_WIDTH);
+    paint_with_color(&text, prefix.color, settings, use_color)
+}
+
+fn render_suffix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<Option<String>, String> {
+    let Some(suffix) = decoration.and_then(|d| d.suffix.as_ref()) else {
+        return Ok(None);
+    };
+
+    let mut parts: Vec<String> = Vec::new();
+
+    if let Some(debug) = &suffix.debug {
+        parts.push(debug.clone());
+    }
+
+    if !suffix.branches.is_empty() {
+        let mut branch_parts = Vec::new();
+        for branch in &suffix.branches {
+            branch_parts.push(paint_with_color(&branch.name, branch.color, settings, use_color)?);
+        }
+        parts.push(branch_parts.join(", "));
+    }
+
+    if !suffix.summary.is_empty() {
+        parts.push(suffix.summary.clone());
+    }
+
+    if parts.is_empty() {
+        Ok(None)
+    } else {
+        Ok(Some(parts.join(" ")))
+    }
+}
+
+fn render_graph_line(
+    chars: &[char],
+    colors: &[u8],
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+        let mut line = String::new();
+        let mut start = 0usize;
+        while start <= last_idx {
+            let color_idx = colors[start];
+            let mut end = start + 1;
+            while end <= last_idx && colors[end] == color_idx {
+                end += 1;
+            }
+            let segment: String = chars[start..end].iter().collect();
+            if use_color {
+                match term_color_for_index(color_idx, settings)? {
+                    Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
+                    None => line.push_str(&segment),
+                }
+            } else {
+                line.push_str(&segment);
+            }
+            start = end;
+        }
+        Ok(line)
+    } else {
+        Ok(String::new())
+    }
+}
+
+fn paint_with_color(
+    text: &str,
+    color_idx: u8,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if !use_color {
+        return Ok(text.to_string());
+    }
+
+    match term_color_for_index(color_idx, settings)? {
+        Some(term_color) => Ok(term_color.paint(text).to_string()),
+        None => Ok(text.to_string()),
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;

[2025-09-21T13:55:41] tokens used: 127,865
[2025-09-21T13:55:41] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 770a37ff9549fd0b39bf41b9e0064c17396ff3fb..a0990b6ed45d7d794944230d35114c8ab003cd52
--- a/src/main.rs
+++ b/src/main.rs
@@ -86,12 +86,14 @@
     }
     let duration_print = now.elapsed().as_micros();
 
-    eprintln!(
-        "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
-        duration_graph as f32 / 1000.0,
-        duration_print as f32 / 1000.0,
-        graph.commits.len()
-    );
+    if settings.debug {
+        eprintln!(
+            "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
+            duration_graph as f32 / 1000.0,
+            duration_print as f32 / 1000.0,
+            graph.commits.len()
+        );
+    }
 
     Ok(())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..39e6e6d925f2909b568ec1531fa54161caae8d83
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -22,6 +22,7 @@
 const ARROW_LEFT: char = '◀';
 
 const COLOR_NONE: u8 = u8::MAX;
+const PREFIX_WIDTH: usize = 9;
 
 #[derive(Clone, Debug)]
 struct Insert {
@@ -30,6 +31,31 @@
     layer: usize,
 }
 
+#[derive(Clone, Default)]
+struct LineDecoration {
+    prefix: Option<LinePrefix>,
+    suffix: Option<LineSuffix>,
+}
+
+#[derive(Clone)]
+struct LinePrefix {
+    short_id: String,
+    color: u8,
+}
+
+#[derive(Clone)]
+struct LineSuffix {
+    debug: Option<String>,
+    branches: Vec<LineBranch>,
+    summary: String,
+}
+
+#[derive(Clone)]
+struct LineBranch {
+    name: String,
+    color: u8,
+}
+
 /// Render the git graph as a Unicode string representation suitable for terminals.
 pub fn print_unicode(
     graph: &GitGraph,
@@ -54,7 +80,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,14 +97,52 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit
+            .oid
+            .to_string()
+            .chars()
+            .take(7)
+            .collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        let mut seen = Vec::new();
+        branch_indices.retain(|idx| {
+            if seen.contains(idx) {
+                false
+            } else {
+                seen.push(*idx);
+                true
+            }
+        });
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
+
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
 
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
@@ -180,7 +244,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {
@@ -541,6 +605,15 @@
     branch_settings.color.len()
 }
 
+fn color_index_for_branch(branch_settings: &BranchSettings, branch: &BranchInfo) -> usize {
+    let idx = branch.visual.color_group;
+    if idx < branch_settings.color.len() {
+        idx
+    } else {
+        branch_settings.color.len()
+    }
+}
+
 fn encode_color_index(idx: usize) -> u8 {
     if idx >= COLOR_NONE as usize {
         (COLOR_NONE - 1) as u8
@@ -568,49 +641,137 @@
         .ok_or_else(|| format!("Unknown terminal color: {}", name))
 }
 
-fn to_string_block(
+fn print_graph(
     grid: &CharGrid,
-    labels: &[Option<String>],
+    decorations: &[LineDecoration],
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
         let (chars, colors) = grid.row(row);
-        let mut line = String::new();
-        if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
-            let mut start = 0usize;
-            while start <= last_idx {
-                let color_idx = colors[start];
-                let mut end = start + 1;
-                while end <= last_idx && colors[end] == color_idx {
-                    end += 1;
-                }
-                let segment: String = chars[start..end].iter().collect();
-                if use_color {
-                    match term_color_for_index(color_idx, settings)? {
-                        Some(term_color) => {
-                            line.push_str(&term_color.paint(&segment).to_string());
-                        }
-                        None => line.push_str(&segment),
-                    }
-                } else {
-                    line.push_str(&segment);
-                }
-                start = end;
+        let prefix = render_prefix(decorations.get(row), settings, use_color)?;
+        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let suffix = render_suffix(decorations.get(row), settings, use_color)?;
+
+        let mut line = prefix;
+        let has_graph = !graph.is_empty();
+        if has_graph {
+            if !line.is_empty() {
+                line.push(' ');
             }
+            line.push_str(&graph);
         }
-        if let Some(label) = &labels[row] {
-            if !line.is_empty() {
+
+        if let Some(suffix) = suffix {
+            if has_graph || !line.trim().is_empty() {
                 line.push(' ');
             }
-            line.push_str(label);
+            line.push_str(&suffix);
         }
-        lines.push(line);
+
+        lines.push(line.trim_end().to_string());
     }
+
     Ok(lines.join("\n"))
 }
 
+fn render_prefix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    let blank = " ".repeat(PREFIX_WIDTH);
+    let Some(prefix) = decoration.and_then(|d| d.prefix.as_ref()) else {
+        return Ok(blank);
+    };
+
+    let text = format!("{:<width$}", prefix.short_id, width = PREFIX_WIDTH);
+    paint_with_color(&text, prefix.color, settings, use_color)
+}
+
+fn render_suffix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<Option<String>, String> {
+    let Some(suffix) = decoration.and_then(|d| d.suffix.as_ref()) else {
+        return Ok(None);
+    };
+
+    let mut parts: Vec<String> = Vec::new();
+
+    if let Some(debug) = &suffix.debug {
+        parts.push(debug.clone());
+    }
+
+    if !suffix.branches.is_empty() {
+        let mut branch_parts = Vec::new();
+        for branch in &suffix.branches {
+            branch_parts.push(paint_with_color(&branch.name, branch.color, settings, use_color)?);
+        }
+        parts.push(branch_parts.join(", "));
+    }
+
+    if !suffix.summary.is_empty() {
+        parts.push(suffix.summary.clone());
+    }
+
+    if parts.is_empty() {
+        Ok(None)
+    } else {
+        Ok(Some(parts.join(" ")))
+    }
+}
+
+fn render_graph_line(
+    chars: &[char],
+    colors: &[u8],
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+        let mut line = String::new();
+        let mut start = 0usize;
+        while start <= last_idx {
+            let color_idx = colors[start];
+            let mut end = start + 1;
+            while end <= last_idx && colors[end] == color_idx {
+                end += 1;
+            }
+            let segment: String = chars[start..end].iter().collect();
+            if use_color {
+                match term_color_for_index(color_idx, settings)? {
+                    Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
+                    None => line.push_str(&segment),
+                }
+            } else {
+                line.push_str(&segment);
+            }
+            start = end;
+        }
+        Ok(line)
+    } else {
+        Ok(String::new())
+    }
+}
+
+fn paint_with_color(
+    text: &str,
+    color_idx: u8,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if !use_color {
+        return Ok(text.to_string());
+    }
+
+    match term_color_for_index(color_idx, settings)? {
+        Some(term_color) => Ok(term_color.paint(text).to_string()),
+        None => Ok(text.to_string()),
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;


[2025-09-21T13:55:57] thinking

**Reviewing color handling and formatting concerns**

I’m walking through how color indices like `COLOR_NONE` and defaults interact with prefix rendering and conditional spacing before suffixes. I want to be sure ANSI sequences don’t confuse empty-string checks and to confirm coloring and trimming logic won’t produce unwanted spaces. Finally, I’m considering running `cargo fmt` for consistent style after these code adjustments.
[2025-09-21T13:55:58] exec bash -lc 'cargo fmt' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:55:58] bash -lc 'cargo fmt' succeeded in 50ms:

[2025-09-21T13:55:58] tokens used: 129,145
[2025-09-21T13:55:58] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 770a37ff9549fd0b39bf41b9e0064c17396ff3fb..a0990b6ed45d7d794944230d35114c8ab003cd52
--- a/src/main.rs
+++ b/src/main.rs
@@ -86,12 +86,14 @@
     }
     let duration_print = now.elapsed().as_micros();
 
-    eprintln!(
-        "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
-        duration_graph as f32 / 1000.0,
-        duration_print as f32 / 1000.0,
-        graph.commits.len()
-    );
+    if settings.debug {
+        eprintln!(
+            "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
+            duration_graph as f32 / 1000.0,
+            duration_print as f32 / 1000.0,
+            graph.commits.len()
+        );
+    }
 
     Ok(())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..9594e2b9e62e17825ebdf460bf6e9b3042122c87
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -22,6 +22,7 @@
 const ARROW_LEFT: char = '◀';
 
 const COLOR_NONE: u8 = u8::MAX;
+const PREFIX_WIDTH: usize = 9;
 
 #[derive(Clone, Debug)]
 struct Insert {
@@ -30,6 +31,31 @@
     layer: usize,
 }
 
+#[derive(Clone, Default)]
+struct LineDecoration {
+    prefix: Option<LinePrefix>,
+    suffix: Option<LineSuffix>,
+}
+
+#[derive(Clone)]
+struct LinePrefix {
+    short_id: String,
+    color: u8,
+}
+
+#[derive(Clone)]
+struct LineSuffix {
+    debug: Option<String>,
+    branches: Vec<LineBranch>,
+    summary: String,
+}
+
+#[derive(Clone)]
+struct LineBranch {
+    name: String,
+    color: u8,
+}
+
 /// Render the git graph as a Unicode string representation suitable for terminals.
 pub fn print_unicode(
     graph: &GitGraph,
@@ -54,7 +80,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,14 +97,47 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit.oid.to_string().chars().take(7).collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        let mut seen = Vec::new();
+        branch_indices.retain(|idx| {
+            if seen.contains(idx) {
+                false
+            } else {
+                seen.push(*idx);
+                true
+            }
+        });
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
+
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
 
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
@@ -180,7 +239,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {
@@ -541,6 +600,15 @@
     branch_settings.color.len()
 }
 
+fn color_index_for_branch(branch_settings: &BranchSettings, branch: &BranchInfo) -> usize {
+    let idx = branch.visual.color_group;
+    if idx < branch_settings.color.len() {
+        idx
+    } else {
+        branch_settings.color.len()
+    }
+}
+
 fn encode_color_index(idx: usize) -> u8 {
     if idx >= COLOR_NONE as usize {
         (COLOR_NONE - 1) as u8
@@ -568,49 +636,142 @@
         .ok_or_else(|| format!("Unknown terminal color: {}", name))
 }
 
-fn to_string_block(
+fn print_graph(
     grid: &CharGrid,
-    labels: &[Option<String>],
+    decorations: &[LineDecoration],
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
         let (chars, colors) = grid.row(row);
-        let mut line = String::new();
-        if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
-            let mut start = 0usize;
-            while start <= last_idx {
-                let color_idx = colors[start];
-                let mut end = start + 1;
-                while end <= last_idx && colors[end] == color_idx {
-                    end += 1;
-                }
-                let segment: String = chars[start..end].iter().collect();
-                if use_color {
-                    match term_color_for_index(color_idx, settings)? {
-                        Some(term_color) => {
-                            line.push_str(&term_color.paint(&segment).to_string());
-                        }
-                        None => line.push_str(&segment),
-                    }
-                } else {
-                    line.push_str(&segment);
-                }
-                start = end;
+        let prefix = render_prefix(decorations.get(row), settings, use_color)?;
+        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let suffix = render_suffix(decorations.get(row), settings, use_color)?;
+
+        let mut line = prefix;
+        let has_graph = !graph.is_empty();
+        if has_graph {
+            if !line.is_empty() {
+                line.push(' ');
             }
+            line.push_str(&graph);
         }
-        if let Some(label) = &labels[row] {
-            if !line.is_empty() {
+
+        if let Some(suffix) = suffix {
+            if has_graph || !line.trim().is_empty() {
                 line.push(' ');
             }
-            line.push_str(label);
+            line.push_str(&suffix);
         }
-        lines.push(line);
+
+        lines.push(line.trim_end().to_string());
     }
+
     Ok(lines.join("\n"))
 }
 
+fn render_prefix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    let blank = " ".repeat(PREFIX_WIDTH);
+    let Some(prefix) = decoration.and_then(|d| d.prefix.as_ref()) else {
+        return Ok(blank);
+    };
+
+    let text = format!("{:<width$}", prefix.short_id, width = PREFIX_WIDTH);
+    paint_with_color(&text, prefix.color, settings, use_color)
+}
+
+fn render_suffix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<Option<String>, String> {
+    let Some(suffix) = decoration.and_then(|d| d.suffix.as_ref()) else {
+        return Ok(None);
+    };
+
+    let mut parts: Vec<String> = Vec::new();
+
+    if let Some(debug) = &suffix.debug {
+        parts.push(debug.clone());
+    }
+
+    if !suffix.branches.is_empty() {
+        let mut branch_parts = Vec::new();
+        for branch in &suffix.branches {
+            branch_parts.push(paint_with_color(
+                &branch.name,
+                branch.color,
+                settings,
+                use_color,
+            )?);
+        }
+        parts.push(branch_parts.join(", "));
+    }
+
+    if !suffix.summary.is_empty() {
+        parts.push(suffix.summary.clone());
+    }
+
+    if parts.is_empty() {
+        Ok(None)
+    } else {
+        Ok(Some(parts.join(" ")))
+    }
+}
+
+fn render_graph_line(
+    chars: &[char],
+    colors: &[u8],
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+        let mut line = String::new();
+        let mut start = 0usize;
+        while start <= last_idx {
+            let color_idx = colors[start];
+            let mut end = start + 1;
+            while end <= last_idx && colors[end] == color_idx {
+                end += 1;
+            }
+            let segment: String = chars[start..end].iter().collect();
+            if use_color {
+                match term_color_for_index(color_idx, settings)? {
+                    Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
+                    None => line.push_str(&segment),
+                }
+            } else {
+                line.push_str(&segment);
+            }
+            start = end;
+        }
+        Ok(line)
+    } else {
+        Ok(String::new())
+    }
+}
+
+fn paint_with_color(
+    text: &str,
+    color_idx: u8,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if !use_color {
+        return Ok(text.to_string());
+    }
+
+    match term_color_for_index(color_idx, settings)? {
+        Some(term_color) => Ok(term_color.paint(text).to_string()),
+        None => Ok(text.to_string()),
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;


[2025-09-21T13:56:01] thinking

**Verifying code formatting**
[2025-09-21T13:56:01] exec bash -lc "sed -n '70,150p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:56:01] bash -lc "sed -n '70,150p' src/print/unicode.rs" succeeded in 33ms:
    let inserts = get_inserts(graph);
    let (row_map, extras) = index_map(graph.commits.len(), &inserts);
    let total_extra: usize = extras.iter().sum();
    let height = graph.commits.len() + total_extra;
    let max_column = graph
        .commits
        .iter()
        .filter_map(|commit| commit_column(graph, commit))
        .max()
        .unwrap_or(0);
    let width = max_column * 2 + 1;

    let mut grid = CharGrid::new(width, height);
    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];

    for (index, commit) in graph.commits.iter().enumerate() {
        let row = row_map[index];
        let column = commit_column(graph, commit).unwrap_or(0);
        let gcol = column * 2;
        let symbol = if commit.is_merge { CIRCLE } else { DOT };
[2025-09-21T13:56:01] tokens used: 129,358
[2025-09-21T13:56:01] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 770a37ff9549fd0b39bf41b9e0064c17396ff3fb..a0990b6ed45d7d794944230d35114c8ab003cd52
--- a/src/main.rs
+++ b/src/main.rs
@@ -86,12 +86,14 @@
     }
     let duration_print = now.elapsed().as_micros();
 
-    eprintln!(
-        "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
-        duration_graph as f32 / 1000.0,
-        duration_print as f32 / 1000.0,
-        graph.commits.len()
-    );
+    if settings.debug {
+        eprintln!(
+            "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
+            duration_graph as f32 / 1000.0,
+            duration_print as f32 / 1000.0,
+            graph.commits.len()
+        );
+    }
 
     Ok(())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..9594e2b9e62e17825ebdf460bf6e9b3042122c87
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -22,6 +22,7 @@
 const ARROW_LEFT: char = '◀';
 
 const COLOR_NONE: u8 = u8::MAX;
+const PREFIX_WIDTH: usize = 9;
 
 #[derive(Clone, Debug)]
 struct Insert {
@@ -30,6 +31,31 @@
     layer: usize,
 }
 
+#[derive(Clone, Default)]
+struct LineDecoration {
+    prefix: Option<LinePrefix>,
+    suffix: Option<LineSuffix>,
+}
+
+#[derive(Clone)]
+struct LinePrefix {
+    short_id: String,
+    color: u8,
+}
+
+#[derive(Clone)]
+struct LineSuffix {
+    debug: Option<String>,
+    branches: Vec<LineBranch>,
+    summary: String,
+}
+
+#[derive(Clone)]
+struct LineBranch {
+    name: String,
+    color: u8,
+}
+
 /// Render the git graph as a Unicode string representation suitable for terminals.
 pub fn print_unicode(
     graph: &GitGraph,
@@ -54,7 +80,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,14 +97,47 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit.oid.to_string().chars().take(7).collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        let mut seen = Vec::new();
+        branch_indices.retain(|idx| {
+            if seen.contains(idx) {
+                false
+            } else {
+                seen.push(*idx);
+                true
+            }
+        });
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
+
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
 
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
@@ -180,7 +239,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {
@@ -541,6 +600,15 @@
     branch_settings.color.len()
 }
 
+fn color_index_for_branch(branch_settings: &BranchSettings, branch: &BranchInfo) -> usize {
+    let idx = branch.visual.color_group;
+    if idx < branch_settings.color.len() {
+        idx
+    } else {
+        branch_settings.color.len()
+    }
+}
+
 fn encode_color_index(idx: usize) -> u8 {
     if idx >= COLOR_NONE as usize {
         (COLOR_NONE - 1) as u8
@@ -568,49 +636,142 @@
         .ok_or_else(|| format!("Unknown terminal color: {}", name))
 }
 
-fn to_string_block(
+fn print_graph(
     grid: &CharGrid,
-    labels: &[Option<String>],
+    decorations: &[LineDecoration],
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
         let (chars, colors) = grid.row(row);
-        let mut line = String::new();
-        if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
-            let mut start = 0usize;
-            while start <= last_idx {
-                let color_idx = colors[start];
-                let mut end = start + 1;
-                while end <= last_idx && colors[end] == color_idx {
-                    end += 1;
-                }
-                let segment: String = chars[start..end].iter().collect();
-                if use_color {
-                    match term_color_for_index(color_idx, settings)? {
-                        Some(term_color) => {
-                            line.push_str(&term_color.paint(&segment).to_string());
-                        }
-                        None => line.push_str(&segment),
-                    }
-                } else {
-                    line.push_str(&segment);
-                }
-                start = end;
+        let prefix = render_prefix(decorations.get(row), settings, use_color)?;
+        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let suffix = render_suffix(decorations.get(row), settings, use_color)?;
+
+        let mut line = prefix;
+        let has_graph = !graph.is_empty();
+        if has_graph {
+            if !line.is_empty() {
+                line.push(' ');
             }
+            line.push_str(&graph);
         }
-        if let Some(label) = &labels[row] {
-            if !line.is_empty() {
+
+        if let Some(suffix) = suffix {
+            if has_graph || !line.trim().is_empty() {
                 line.push(' ');
             }
-            line.push_str(label);
+            line.push_str(&suffix);
         }
-        lines.push(line);
+
+        lines.push(line.trim_end().to_string());
     }
+
     Ok(lines.join("\n"))
 }
 
+fn render_prefix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    let blank = " ".repeat(PREFIX_WIDTH);
+    let Some(prefix) = decoration.and_then(|d| d.prefix.as_ref()) else {
+        return Ok(blank);
+    };
+
+    let text = format!("{:<width$}", prefix.short_id, width = PREFIX_WIDTH);
+    paint_with_color(&text, prefix.color, settings, use_color)
+}
+
+fn render_suffix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<Option<String>, String> {
+    let Some(suffix) = decoration.and_then(|d| d.suffix.as_ref()) else {
+        return Ok(None);
+    };
+
+    let mut parts: Vec<String> = Vec::new();
+
+    if let Some(debug) = &suffix.debug {
+        parts.push(debug.clone());
+    }
+
+    if !suffix.branches.is_empty() {
+        let mut branch_parts = Vec::new();
+        for branch in &suffix.branches {
+            branch_parts.push(paint_with_color(
+                &branch.name,
+                branch.color,
+                settings,
+                use_color,
+            )?);
+        }
+        parts.push(branch_parts.join(", "));
+    }
+
+    if !suffix.summary.is_empty() {
+        parts.push(suffix.summary.clone());
+    }
+
+    if parts.is_empty() {
+        Ok(None)
+    } else {
+        Ok(Some(parts.join(" ")))
+    }
+}
+
+fn render_graph_line(
+    chars: &[char],
+    colors: &[u8],
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+        let mut line = String::new();
+        let mut start = 0usize;
+        while start <= last_idx {
+            let color_idx = colors[start];
+            let mut end = start + 1;
+            while end <= last_idx && colors[end] == color_idx {
+                end += 1;
+            }
+            let segment: String = chars[start..end].iter().collect();
+            if use_color {
+                match term_color_for_index(color_idx, settings)? {
+                    Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
+                    None => line.push_str(&segment),
+                }
+            } else {
+                line.push_str(&segment);
+            }
+            start = end;
+        }
+        Ok(line)
+    } else {
+        Ok(String::new())
+    }
+}
+
+fn paint_with_color(
+    text: &str,
+    color_idx: u8,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if !use_color {
+        return Ok(text.to_string());
+    }
+
+    match term_color_for_index(color_idx, settings)? {
+        Some(term_color) => Ok(term_color.paint(text).to_string()),
+        None => Ok(text.to_string()),
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;


[2025-09-21T13:56:04] thinking

**Verifying mutable reference usage**
[2025-09-21T13:56:04] exec bash -lc "sed -n '560,740p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:56:05] bash -lc "sed -n '560,740p' src/print/unicode.rs" succeeded in 33ms:
            .iter()
            .map(|insert| insert.layer)
            .max()
            .map(|max_layer| max_layer + 1)
            .unwrap_or(0);
        extras[index] = extra_rows;
        offset += extra_rows;
    }

    (rows, extras)
}

fn commit_column(graph: &GitGraph, info: &CommitInfo) -> Option<usize> {
    primary_branch(graph, info).and_then(|branch| branch.visual.column)
}

fn primary_branch<'graph>(
    graph: &'graph GitGraph,
    info: &CommitInfo,
) -> Option<&'graph BranchInfo> {
[2025-09-21T13:56:05] tokens used: 130,267
[2025-09-21T13:56:05] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 770a37ff9549fd0b39bf41b9e0064c17396ff3fb..a0990b6ed45d7d794944230d35114c8ab003cd52
--- a/src/main.rs
+++ b/src/main.rs
@@ -86,12 +86,14 @@
     }
     let duration_print = now.elapsed().as_micros();
 
-    eprintln!(
-        "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
-        duration_graph as f32 / 1000.0,
-        duration_print as f32 / 1000.0,
-        graph.commits.len()
-    );
+    if settings.debug {
+        eprintln!(
+            "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
+            duration_graph as f32 / 1000.0,
+            duration_print as f32 / 1000.0,
+            graph.commits.len()
+        );
+    }
 
     Ok(())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..9594e2b9e62e17825ebdf460bf6e9b3042122c87
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -22,6 +22,7 @@
 const ARROW_LEFT: char = '◀';
 
 const COLOR_NONE: u8 = u8::MAX;
+const PREFIX_WIDTH: usize = 9;
 
 #[derive(Clone, Debug)]
 struct Insert {
@@ -30,6 +31,31 @@
     layer: usize,
 }
 
+#[derive(Clone, Default)]
+struct LineDecoration {
+    prefix: Option<LinePrefix>,
+    suffix: Option<LineSuffix>,
+}
+
+#[derive(Clone)]
+struct LinePrefix {
+    short_id: String,
+    color: u8,
+}
+
+#[derive(Clone)]
+struct LineSuffix {
+    debug: Option<String>,
+    branches: Vec<LineBranch>,
+    summary: String,
+}
+
+#[derive(Clone)]
+struct LineBranch {
+    name: String,
+    color: u8,
+}
+
 /// Render the git graph as a Unicode string representation suitable for terminals.
 pub fn print_unicode(
     graph: &GitGraph,
@@ -54,7 +80,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,14 +97,47 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit.oid.to_string().chars().take(7).collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        let mut seen = Vec::new();
+        branch_indices.retain(|idx| {
+            if seen.contains(idx) {
+                false
+            } else {
+                seen.push(*idx);
+                true
+            }
+        });
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
+
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
 
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
@@ -180,7 +239,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {
@@ -541,6 +600,15 @@
     branch_settings.color.len()
 }
 
+fn color_index_for_branch(branch_settings: &BranchSettings, branch: &BranchInfo) -> usize {
+    let idx = branch.visual.color_group;
+    if idx < branch_settings.color.len() {
+        idx
+    } else {
+        branch_settings.color.len()
+    }
+}
+
 fn encode_color_index(idx: usize) -> u8 {
     if idx >= COLOR_NONE as usize {
         (COLOR_NONE - 1) as u8
@@ -568,49 +636,142 @@
         .ok_or_else(|| format!("Unknown terminal color: {}", name))
 }
 
-fn to_string_block(
+fn print_graph(
     grid: &CharGrid,
-    labels: &[Option<String>],
+    decorations: &[LineDecoration],
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
         let (chars, colors) = grid.row(row);
-        let mut line = String::new();
-        if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
-            let mut start = 0usize;
-            while start <= last_idx {
-                let color_idx = colors[start];
-                let mut end = start + 1;
-                while end <= last_idx && colors[end] == color_idx {
-                    end += 1;
-                }
-                let segment: String = chars[start..end].iter().collect();
-                if use_color {
-                    match term_color_for_index(color_idx, settings)? {
-                        Some(term_color) => {
-                            line.push_str(&term_color.paint(&segment).to_string());
-                        }
-                        None => line.push_str(&segment),
-                    }
-                } else {
-                    line.push_str(&segment);
-                }
-                start = end;
+        let prefix = render_prefix(decorations.get(row), settings, use_color)?;
+        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let suffix = render_suffix(decorations.get(row), settings, use_color)?;
+
+        let mut line = prefix;
+        let has_graph = !graph.is_empty();
+        if has_graph {
+            if !line.is_empty() {
+                line.push(' ');
             }
+            line.push_str(&graph);
         }
-        if let Some(label) = &labels[row] {
-            if !line.is_empty() {
+
+        if let Some(suffix) = suffix {
+            if has_graph || !line.trim().is_empty() {
                 line.push(' ');
             }
-            line.push_str(label);
+            line.push_str(&suffix);
         }
-        lines.push(line);
+
+        lines.push(line.trim_end().to_string());
     }
+
     Ok(lines.join("\n"))
 }
 
+fn render_prefix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    let blank = " ".repeat(PREFIX_WIDTH);
+    let Some(prefix) = decoration.and_then(|d| d.prefix.as_ref()) else {
+        return Ok(blank);
+    };
+
+    let text = format!("{:<width$}", prefix.short_id, width = PREFIX_WIDTH);
+    paint_with_color(&text, prefix.color, settings, use_color)
+}
+
+fn render_suffix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<Option<String>, String> {
+    let Some(suffix) = decoration.and_then(|d| d.suffix.as_ref()) else {
+        return Ok(None);
+    };
+
+    let mut parts: Vec<String> = Vec::new();
+
+    if let Some(debug) = &suffix.debug {
+        parts.push(debug.clone());
+    }
+
+    if !suffix.branches.is_empty() {
+        let mut branch_parts = Vec::new();
+        for branch in &suffix.branches {
+            branch_parts.push(paint_with_color(
+                &branch.name,
+                branch.color,
+                settings,
+                use_color,
+            )?);
+        }
+        parts.push(branch_parts.join(", "));
+    }
+
+    if !suffix.summary.is_empty() {
+        parts.push(suffix.summary.clone());
+    }
+
+    if parts.is_empty() {
+        Ok(None)
+    } else {
+        Ok(Some(parts.join(" ")))
+    }
+}
+
+fn render_graph_line(
+    chars: &[char],
+    colors: &[u8],
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+        let mut line = String::new();
+        let mut start = 0usize;
+        while start <= last_idx {
+            let color_idx = colors[start];
+            let mut end = start + 1;
+            while end <= last_idx && colors[end] == color_idx {
+                end += 1;
+            }
+            let segment: String = chars[start..end].iter().collect();
+            if use_color {
+                match term_color_for_index(color_idx, settings)? {
+                    Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
+                    None => line.push_str(&segment),
+                }
+            } else {
+                line.push_str(&segment);
+            }
+            start = end;
+        }
+        Ok(line)
+    } else {
+        Ok(String::new())
+    }
+}
+
+fn paint_with_color(
+    text: &str,
+    color_idx: u8,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if !use_color {
+        return Ok(text.to_string());
+    }
+
+    match term_color_for_index(color_idx, settings)? {
+        Some(term_color) => Ok(term_color.paint(text).to_string()),
+        None => Ok(text.to_string()),
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;

[2025-09-21T13:56:07] exec bash -lc "sed -n '740,860p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:56:07] bash -lc "sed -n '740,860p' src/print/unicode.rs" succeeded in 26ms:
                end += 1;
            }
            let segment: String = chars[start..end].iter().collect();
            if use_color {
                match term_color_for_index(color_idx, settings)? {
                    Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
                    None => line.push_str(&segment),
                }
            } else {
                line.push_str(&segment);
            }
            start = end;
        }
        Ok(line)
    } else {
        Ok(String::new())
    }
}

fn paint_with_color(
[2025-09-21T13:56:07] tokens used: 131,771
[2025-09-21T13:56:07] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 770a37ff9549fd0b39bf41b9e0064c17396ff3fb..a0990b6ed45d7d794944230d35114c8ab003cd52
--- a/src/main.rs
+++ b/src/main.rs
@@ -86,12 +86,14 @@
     }
     let duration_print = now.elapsed().as_micros();
 
-    eprintln!(
-        "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
-        duration_graph as f32 / 1000.0,
-        duration_print as f32 / 1000.0,
-        graph.commits.len()
-    );
+    if settings.debug {
+        eprintln!(
+            "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
+            duration_graph as f32 / 1000.0,
+            duration_print as f32 / 1000.0,
+            graph.commits.len()
+        );
+    }
 
     Ok(())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..9594e2b9e62e17825ebdf460bf6e9b3042122c87
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -22,6 +22,7 @@
 const ARROW_LEFT: char = '◀';
 
 const COLOR_NONE: u8 = u8::MAX;
+const PREFIX_WIDTH: usize = 9;
 
 #[derive(Clone, Debug)]
 struct Insert {
@@ -30,6 +31,31 @@
     layer: usize,
 }
 
+#[derive(Clone, Default)]
+struct LineDecoration {
+    prefix: Option<LinePrefix>,
+    suffix: Option<LineSuffix>,
+}
+
+#[derive(Clone)]
+struct LinePrefix {
+    short_id: String,
+    color: u8,
+}
+
+#[derive(Clone)]
+struct LineSuffix {
+    debug: Option<String>,
+    branches: Vec<LineBranch>,
+    summary: String,
+}
+
+#[derive(Clone)]
+struct LineBranch {
+    name: String,
+    color: u8,
+}
+
 /// Render the git graph as a Unicode string representation suitable for terminals.
 pub fn print_unicode(
     graph: &GitGraph,
@@ -54,7 +80,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,14 +97,47 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit.oid.to_string().chars().take(7).collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        let mut seen = Vec::new();
+        branch_indices.retain(|idx| {
+            if seen.contains(idx) {
+                false
+            } else {
+                seen.push(*idx);
+                true
+            }
+        });
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
+
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
 
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
@@ -180,7 +239,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {
@@ -541,6 +600,15 @@
     branch_settings.color.len()
 }
 
+fn color_index_for_branch(branch_settings: &BranchSettings, branch: &BranchInfo) -> usize {
+    let idx = branch.visual.color_group;
+    if idx < branch_settings.color.len() {
+        idx
+    } else {
+        branch_settings.color.len()
+    }
+}
+
 fn encode_color_index(idx: usize) -> u8 {
     if idx >= COLOR_NONE as usize {
         (COLOR_NONE - 1) as u8
@@ -568,49 +636,142 @@
         .ok_or_else(|| format!("Unknown terminal color: {}", name))
 }
 
-fn to_string_block(
+fn print_graph(
     grid: &CharGrid,
-    labels: &[Option<String>],
+    decorations: &[LineDecoration],
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
         let (chars, colors) = grid.row(row);
-        let mut line = String::new();
-        if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
-            let mut start = 0usize;
-            while start <= last_idx {
-                let color_idx = colors[start];
-                let mut end = start + 1;
-                while end <= last_idx && colors[end] == color_idx {
-                    end += 1;
-                }
-                let segment: String = chars[start..end].iter().collect();
-                if use_color {
-                    match term_color_for_index(color_idx, settings)? {
-                        Some(term_color) => {
-                            line.push_str(&term_color.paint(&segment).to_string());
-                        }
-                        None => line.push_str(&segment),
-                    }
-                } else {
-                    line.push_str(&segment);
-                }
-                start = end;
+        let prefix = render_prefix(decorations.get(row), settings, use_color)?;
+        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let suffix = render_suffix(decorations.get(row), settings, use_color)?;
+
+        let mut line = prefix;
+        let has_graph = !graph.is_empty();
+        if has_graph {
+            if !line.is_empty() {
+                line.push(' ');
             }
+            line.push_str(&graph);
         }
-        if let Some(label) = &labels[row] {
-            if !line.is_empty() {
+
+        if let Some(suffix) = suffix {
+            if has_graph || !line.trim().is_empty() {
                 line.push(' ');
             }
-            line.push_str(label);
+            line.push_str(&suffix);
         }
-        lines.push(line);
+
+        lines.push(line.trim_end().to_string());
     }
+
     Ok(lines.join("\n"))
 }
 
+fn render_prefix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    let blank = " ".repeat(PREFIX_WIDTH);
+    let Some(prefix) = decoration.and_then(|d| d.prefix.as_ref()) else {
+        return Ok(blank);
+    };
+
+    let text = format!("{:<width$}", prefix.short_id, width = PREFIX_WIDTH);
+    paint_with_color(&text, prefix.color, settings, use_color)
+}
+
+fn render_suffix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<Option<String>, String> {
+    let Some(suffix) = decoration.and_then(|d| d.suffix.as_ref()) else {
+        return Ok(None);
+    };
+
+    let mut parts: Vec<String> = Vec::new();
+
+    if let Some(debug) = &suffix.debug {
+        parts.push(debug.clone());
+    }
+
+    if !suffix.branches.is_empty() {
+        let mut branch_parts = Vec::new();
+        for branch in &suffix.branches {
+            branch_parts.push(paint_with_color(
+                &branch.name,
+                branch.color,
+                settings,
+                use_color,
+            )?);
+        }
+        parts.push(branch_parts.join(", "));
+    }
+
+    if !suffix.summary.is_empty() {
+        parts.push(suffix.summary.clone());
+    }
+
+    if parts.is_empty() {
+        Ok(None)
+    } else {
+        Ok(Some(parts.join(" ")))
+    }
+}
+
+fn render_graph_line(
+    chars: &[char],
+    colors: &[u8],
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+        let mut line = String::new();
+        let mut start = 0usize;
+        while start <= last_idx {
+            let color_idx = colors[start];
+            let mut end = start + 1;
+            while end <= last_idx && colors[end] == color_idx {
+                end += 1;
+            }
+            let segment: String = chars[start..end].iter().collect();
+            if use_color {
+                match term_color_for_index(color_idx, settings)? {
+                    Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
+                    None => line.push_str(&segment),
+                }
+            } else {
+                line.push_str(&segment);
+            }
+            start = end;
+        }
+        Ok(line)
+    } else {
+        Ok(String::new())
+    }
+}
+
+fn paint_with_color(
+    text: &str,
+    color_idx: u8,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if !use_color {
+        return Ok(text.to_string());
+    }
+
+    match term_color_for_index(color_idx, settings)? {
+        Some(term_color) => Ok(term_color.paint(text).to_string()),
+        None => Ok(text.to_string()),
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;


[2025-09-21T13:56:11] thinking

**Preparing to run tests**
[2025-09-21T13:56:12] exec bash -lc 'cargo test' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:56:23] bash -lc 'cargo test' exited -1 in 0ms:
    Updating crates.io index
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
error: failed to get `clap` as a dependency of package `git-graph v0.1.0 (/Users/jqwang/104-CommitLens-codex/.workspace/rust-project)`

Caused by:
  download of config.json failed

Caused by:
  failed to download from `https://index.crates.io/config.json`

Caused by:
  [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
[2025-09-21T13:56:23] tokens used: 132,621
[2025-09-21T13:56:23] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 770a37ff9549fd0b39bf41b9e0064c17396ff3fb..a0990b6ed45d7d794944230d35114c8ab003cd52
--- a/src/main.rs
+++ b/src/main.rs
@@ -86,12 +86,14 @@
     }
     let duration_print = now.elapsed().as_micros();
 
-    eprintln!(
-        "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
-        duration_graph as f32 / 1000.0,
-        duration_print as f32 / 1000.0,
-        graph.commits.len()
-    );
+    if settings.debug {
+        eprintln!(
+            "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
+            duration_graph as f32 / 1000.0,
+            duration_print as f32 / 1000.0,
+            graph.commits.len()
+        );
+    }
 
     Ok(())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..9594e2b9e62e17825ebdf460bf6e9b3042122c87
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -22,6 +22,7 @@
 const ARROW_LEFT: char = '◀';
 
 const COLOR_NONE: u8 = u8::MAX;
+const PREFIX_WIDTH: usize = 9;
 
 #[derive(Clone, Debug)]
 struct Insert {
@@ -30,6 +31,31 @@
     layer: usize,
 }
 
+#[derive(Clone, Default)]
+struct LineDecoration {
+    prefix: Option<LinePrefix>,
+    suffix: Option<LineSuffix>,
+}
+
+#[derive(Clone)]
+struct LinePrefix {
+    short_id: String,
+    color: u8,
+}
+
+#[derive(Clone)]
+struct LineSuffix {
+    debug: Option<String>,
+    branches: Vec<LineBranch>,
+    summary: String,
+}
+
+#[derive(Clone)]
+struct LineBranch {
+    name: String,
+    color: u8,
+}
+
 /// Render the git graph as a Unicode string representation suitable for terminals.
 pub fn print_unicode(
     graph: &GitGraph,
@@ -54,7 +80,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,14 +97,47 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit.oid.to_string().chars().take(7).collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        let mut seen = Vec::new();
+        branch_indices.retain(|idx| {
+            if seen.contains(idx) {
+                false
+            } else {
+                seen.push(*idx);
+                true
+            }
+        });
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
+
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
 
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
@@ -180,7 +239,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {
@@ -541,6 +600,15 @@
     branch_settings.color.len()
 }
 
+fn color_index_for_branch(branch_settings: &BranchSettings, branch: &BranchInfo) -> usize {
+    let idx = branch.visual.color_group;
+    if idx < branch_settings.color.len() {
+        idx
+    } else {
+        branch_settings.color.len()
+    }
+}
+
 fn encode_color_index(idx: usize) -> u8 {
     if idx >= COLOR_NONE as usize {
         (COLOR_NONE - 1) as u8
@@ -568,49 +636,142 @@
         .ok_or_else(|| format!("Unknown terminal color: {}", name))
 }
 
-fn to_string_block(
+fn print_graph(
     grid: &CharGrid,
-    labels: &[Option<String>],
+    decorations: &[LineDecoration],
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
         let (chars, colors) = grid.row(row);
-        let mut line = String::new();
-        if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
-            let mut start = 0usize;
-            while start <= last_idx {
-                let color_idx = colors[start];
-                let mut end = start + 1;
-                while end <= last_idx && colors[end] == color_idx {
-                    end += 1;
-                }
-                let segment: String = chars[start..end].iter().collect();
-                if use_color {
-                    match term_color_for_index(color_idx, settings)? {
-                        Some(term_color) => {
-                            line.push_str(&term_color.paint(&segment).to_string());
-                        }
-                        None => line.push_str(&segment),
-                    }
-                } else {
-                    line.push_str(&segment);
-                }
-                start = end;
+        let prefix = render_prefix(decorations.get(row), settings, use_color)?;
+        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let suffix = render_suffix(decorations.get(row), settings, use_color)?;
+
+        let mut line = prefix;
+        let has_graph = !graph.is_empty();
+        if has_graph {
+            if !line.is_empty() {
+                line.push(' ');
             }
+            line.push_str(&graph);
         }
-        if let Some(label) = &labels[row] {
-            if !line.is_empty() {
+
+        if let Some(suffix) = suffix {
+            if has_graph || !line.trim().is_empty() {
                 line.push(' ');
             }
-            line.push_str(label);
+            line.push_str(&suffix);
         }
-        lines.push(line);
+
+        lines.push(line.trim_end().to_string());
     }
+
     Ok(lines.join("\n"))
 }
 
+fn render_prefix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    let blank = " ".repeat(PREFIX_WIDTH);
+    let Some(prefix) = decoration.and_then(|d| d.prefix.as_ref()) else {
+        return Ok(blank);
+    };
+
+    let text = format!("{:<width$}", prefix.short_id, width = PREFIX_WIDTH);
+    paint_with_color(&text, prefix.color, settings, use_color)
+}
+
+fn render_suffix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<Option<String>, String> {
+    let Some(suffix) = decoration.and_then(|d| d.suffix.as_ref()) else {
+        return Ok(None);
+    };
+
+    let mut parts: Vec<String> = Vec::new();
+
+    if let Some(debug) = &suffix.debug {
+        parts.push(debug.clone());
+    }
+
+    if !suffix.branches.is_empty() {
+        let mut branch_parts = Vec::new();
+        for branch in &suffix.branches {
+            branch_parts.push(paint_with_color(
+                &branch.name,
+                branch.color,
+                settings,
+                use_color,
+            )?);
+        }
+        parts.push(branch_parts.join(", "));
+    }
+
+    if !suffix.summary.is_empty() {
+        parts.push(suffix.summary.clone());
+    }
+
+    if parts.is_empty() {
+        Ok(None)
+    } else {
+        Ok(Some(parts.join(" ")))
+    }
+}
+
+fn render_graph_line(
+    chars: &[char],
+    colors: &[u8],
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+        let mut line = String::new();
+        let mut start = 0usize;
+        while start <= last_idx {
+            let color_idx = colors[start];
+            let mut end = start + 1;
+            while end <= last_idx && colors[end] == color_idx {
+                end += 1;
+            }
+            let segment: String = chars[start..end].iter().collect();
+            if use_color {
+                match term_color_for_index(color_idx, settings)? {
+                    Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
+                    None => line.push_str(&segment),
+                }
+            } else {
+                line.push_str(&segment);
+            }
+            start = end;
+        }
+        Ok(line)
+    } else {
+        Ok(String::new())
+    }
+}
+
+fn paint_with_color(
+    text: &str,
+    color_idx: u8,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if !use_color {
+        return Ok(text.to_string());
+    }
+
+    match term_color_for_index(color_idx, settings)? {
+        Some(term_color) => Ok(term_color.paint(text).to_string()),
+        None => Ok(text.to_string()),
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;


[2025-09-21T13:56:27] thinking

**Noting test failure due to network restrictions**
[2025-09-21T13:56:27] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:56:27] bash -lc 'git status -sb' succeeded in 44ms:
## main
 M src/main.rs
 M src/print/unicode.rs
[2025-09-21T13:56:27] tokens used: 133,094
[2025-09-21T13:56:28] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 770a37ff9549fd0b39bf41b9e0064c17396ff3fb..a0990b6ed45d7d794944230d35114c8ab003cd52
--- a/src/main.rs
+++ b/src/main.rs
@@ -86,12 +86,14 @@
     }
     let duration_print = now.elapsed().as_micros();
 
-    eprintln!(
-        "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
-        duration_graph as f32 / 1000.0,
-        duration_print as f32 / 1000.0,
-        graph.commits.len()
-    );
+    if settings.debug {
+        eprintln!(
+            "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
+            duration_graph as f32 / 1000.0,
+            duration_print as f32 / 1000.0,
+            graph.commits.len()
+        );
+    }
 
     Ok(())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..9594e2b9e62e17825ebdf460bf6e9b3042122c87
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -22,6 +22,7 @@
 const ARROW_LEFT: char = '◀';
 
 const COLOR_NONE: u8 = u8::MAX;
+const PREFIX_WIDTH: usize = 9;
 
 #[derive(Clone, Debug)]
 struct Insert {
@@ -30,6 +31,31 @@
     layer: usize,
 }
 
+#[derive(Clone, Default)]
+struct LineDecoration {
+    prefix: Option<LinePrefix>,
+    suffix: Option<LineSuffix>,
+}
+
+#[derive(Clone)]
+struct LinePrefix {
+    short_id: String,
+    color: u8,
+}
+
+#[derive(Clone)]
+struct LineSuffix {
+    debug: Option<String>,
+    branches: Vec<LineBranch>,
+    summary: String,
+}
+
+#[derive(Clone)]
+struct LineBranch {
+    name: String,
+    color: u8,
+}
+
 /// Render the git graph as a Unicode string representation suitable for terminals.
 pub fn print_unicode(
     graph: &GitGraph,
@@ -54,7 +80,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,14 +97,47 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit.oid.to_string().chars().take(7).collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        let mut seen = Vec::new();
+        branch_indices.retain(|idx| {
+            if seen.contains(idx) {
+                false
+            } else {
+                seen.push(*idx);
+                true
+            }
+        });
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
+
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
 
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
@@ -180,7 +239,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {
@@ -541,6 +600,15 @@
     branch_settings.color.len()
 }
 
+fn color_index_for_branch(branch_settings: &BranchSettings, branch: &BranchInfo) -> usize {
+    let idx = branch.visual.color_group;
+    if idx < branch_settings.color.len() {
+        idx
+    } else {
+        branch_settings.color.len()
+    }
+}
+
 fn encode_color_index(idx: usize) -> u8 {
     if idx >= COLOR_NONE as usize {
         (COLOR_NONE - 1) as u8
@@ -568,49 +636,142 @@
         .ok_or_else(|| format!("Unknown terminal color: {}", name))
 }
 
-fn to_string_block(
+fn print_graph(
     grid: &CharGrid,
-    labels: &[Option<String>],
+    decorations: &[LineDecoration],
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
         let (chars, colors) = grid.row(row);
-        let mut line = String::new();
-        if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
-            let mut start = 0usize;
-            while start <= last_idx {
-                let color_idx = colors[start];
-                let mut end = start + 1;
-                while end <= last_idx && colors[end] == color_idx {
-                    end += 1;
-                }
-                let segment: String = chars[start..end].iter().collect();
-                if use_color {
-                    match term_color_for_index(color_idx, settings)? {
-                        Some(term_color) => {
-                            line.push_str(&term_color.paint(&segment).to_string());
-                        }
-                        None => line.push_str(&segment),
-                    }
-                } else {
-                    line.push_str(&segment);
-                }
-                start = end;
+        let prefix = render_prefix(decorations.get(row), settings, use_color)?;
+        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let suffix = render_suffix(decorations.get(row), settings, use_color)?;
+
+        let mut line = prefix;
+        let has_graph = !graph.is_empty();
+        if has_graph {
+            if !line.is_empty() {
+                line.push(' ');
             }
+            line.push_str(&graph);
         }
-        if let Some(label) = &labels[row] {
-            if !line.is_empty() {
+
+        if let Some(suffix) = suffix {
+            if has_graph || !line.trim().is_empty() {
                 line.push(' ');
             }
-            line.push_str(label);
+            line.push_str(&suffix);
         }
-        lines.push(line);
+
+        lines.push(line.trim_end().to_string());
     }
+
     Ok(lines.join("\n"))
 }
 
+fn render_prefix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    let blank = " ".repeat(PREFIX_WIDTH);
+    let Some(prefix) = decoration.and_then(|d| d.prefix.as_ref()) else {
+        return Ok(blank);
+    };
+
+    let text = format!("{:<width$}", prefix.short_id, width = PREFIX_WIDTH);
+    paint_with_color(&text, prefix.color, settings, use_color)
+}
+
+fn render_suffix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<Option<String>, String> {
+    let Some(suffix) = decoration.and_then(|d| d.suffix.as_ref()) else {
+        return Ok(None);
+    };
+
+    let mut parts: Vec<String> = Vec::new();
+
+    if let Some(debug) = &suffix.debug {
+        parts.push(debug.clone());
+    }
+
+    if !suffix.branches.is_empty() {
+        let mut branch_parts = Vec::new();
+        for branch in &suffix.branches {
+            branch_parts.push(paint_with_color(
+                &branch.name,
+                branch.color,
+                settings,
+                use_color,
+            )?);
+        }
+        parts.push(branch_parts.join(", "));
+    }
+
+    if !suffix.summary.is_empty() {
+        parts.push(suffix.summary.clone());
+    }
+
+    if parts.is_empty() {
+        Ok(None)
+    } else {
+        Ok(Some(parts.join(" ")))
+    }
+}
+
+fn render_graph_line(
+    chars: &[char],
+    colors: &[u8],
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+        let mut line = String::new();
+        let mut start = 0usize;
+        while start <= last_idx {
+            let color_idx = colors[start];
+            let mut end = start + 1;
+            while end <= last_idx && colors[end] == color_idx {
+                end += 1;
+            }
+            let segment: String = chars[start..end].iter().collect();
+            if use_color {
+                match term_color_for_index(color_idx, settings)? {
+                    Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
+                    None => line.push_str(&segment),
+                }
+            } else {
+                line.push_str(&segment);
+            }
+            start = end;
+        }
+        Ok(line)
+    } else {
+        Ok(String::new())
+    }
+}
+
+fn paint_with_color(
+    text: &str,
+    color_idx: u8,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if !use_color {
+        return Ok(text.to_string());
+    }
+
+    match term_color_for_index(color_idx, settings)? {
+        Some(term_color) => Ok(term_color.paint(text).to_string()),
+        None => Ok(text.to_string()),
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;


[2025-09-21T13:56:31] thinking

**Preparing to commit changes**
[2025-09-21T13:56:31] exec bash -lc 'git add -A' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:56:31] bash -lc 'git add -A' succeeded in 56ms:

[2025-09-21T13:56:31] tokens used: 133,365
[2025-09-21T13:56:31] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 770a37ff9549fd0b39bf41b9e0064c17396ff3fb..a0990b6ed45d7d794944230d35114c8ab003cd52
--- a/src/main.rs
+++ b/src/main.rs
@@ -86,12 +86,14 @@
     }
     let duration_print = now.elapsed().as_micros();
 
-    eprintln!(
-        "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
-        duration_graph as f32 / 1000.0,
-        duration_print as f32 / 1000.0,
-        graph.commits.len()
-    );
+    if settings.debug {
+        eprintln!(
+            "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
+            duration_graph as f32 / 1000.0,
+            duration_print as f32 / 1000.0,
+            graph.commits.len()
+        );
+    }
 
     Ok(())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..9594e2b9e62e17825ebdf460bf6e9b3042122c87
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -22,6 +22,7 @@
 const ARROW_LEFT: char = '◀';
 
 const COLOR_NONE: u8 = u8::MAX;
+const PREFIX_WIDTH: usize = 9;
 
 #[derive(Clone, Debug)]
 struct Insert {
@@ -30,6 +31,31 @@
     layer: usize,
 }
 
+#[derive(Clone, Default)]
+struct LineDecoration {
+    prefix: Option<LinePrefix>,
+    suffix: Option<LineSuffix>,
+}
+
+#[derive(Clone)]
+struct LinePrefix {
+    short_id: String,
+    color: u8,
+}
+
+#[derive(Clone)]
+struct LineSuffix {
+    debug: Option<String>,
+    branches: Vec<LineBranch>,
+    summary: String,
+}
+
+#[derive(Clone)]
+struct LineBranch {
+    name: String,
+    color: u8,
+}
+
 /// Render the git graph as a Unicode string representation suitable for terminals.
 pub fn print_unicode(
     graph: &GitGraph,
@@ -54,7 +80,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,14 +97,47 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit.oid.to_string().chars().take(7).collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        let mut seen = Vec::new();
+        branch_indices.retain(|idx| {
+            if seen.contains(idx) {
+                false
+            } else {
+                seen.push(*idx);
+                true
+            }
+        });
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
+
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
 
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
@@ -180,7 +239,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {
@@ -541,6 +600,15 @@
     branch_settings.color.len()
 }
 
+fn color_index_for_branch(branch_settings: &BranchSettings, branch: &BranchInfo) -> usize {
+    let idx = branch.visual.color_group;
+    if idx < branch_settings.color.len() {
+        idx
+    } else {
+        branch_settings.color.len()
+    }
+}
+
 fn encode_color_index(idx: usize) -> u8 {
     if idx >= COLOR_NONE as usize {
         (COLOR_NONE - 1) as u8
@@ -568,49 +636,142 @@
         .ok_or_else(|| format!("Unknown terminal color: {}", name))
 }
 
-fn to_string_block(
+fn print_graph(
     grid: &CharGrid,
-    labels: &[Option<String>],
+    decorations: &[LineDecoration],
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
         let (chars, colors) = grid.row(row);
-        let mut line = String::new();
-        if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
-            let mut start = 0usize;
-            while start <= last_idx {
-                let color_idx = colors[start];
-                let mut end = start + 1;
-                while end <= last_idx && colors[end] == color_idx {
-                    end += 1;
-                }
-                let segment: String = chars[start..end].iter().collect();
-                if use_color {
-                    match term_color_for_index(color_idx, settings)? {
-                        Some(term_color) => {
-                            line.push_str(&term_color.paint(&segment).to_string());
-                        }
-                        None => line.push_str(&segment),
-                    }
-                } else {
-                    line.push_str(&segment);
-                }
-                start = end;
+        let prefix = render_prefix(decorations.get(row), settings, use_color)?;
+        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let suffix = render_suffix(decorations.get(row), settings, use_color)?;
+
+        let mut line = prefix;
+        let has_graph = !graph.is_empty();
+        if has_graph {
+            if !line.is_empty() {
+                line.push(' ');
             }
+            line.push_str(&graph);
         }
-        if let Some(label) = &labels[row] {
-            if !line.is_empty() {
+
+        if let Some(suffix) = suffix {
+            if has_graph || !line.trim().is_empty() {
                 line.push(' ');
             }
-            line.push_str(label);
+            line.push_str(&suffix);
         }
-        lines.push(line);
+
+        lines.push(line.trim_end().to_string());
     }
+
     Ok(lines.join("\n"))
 }
 
+fn render_prefix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    let blank = " ".repeat(PREFIX_WIDTH);
+    let Some(prefix) = decoration.and_then(|d| d.prefix.as_ref()) else {
+        return Ok(blank);
+    };
+
+    let text = format!("{:<width$}", prefix.short_id, width = PREFIX_WIDTH);
+    paint_with_color(&text, prefix.color, settings, use_color)
+}
+
+fn render_suffix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<Option<String>, String> {
+    let Some(suffix) = decoration.and_then(|d| d.suffix.as_ref()) else {
+        return Ok(None);
+    };
+
+    let mut parts: Vec<String> = Vec::new();
+
+    if let Some(debug) = &suffix.debug {
+        parts.push(debug.clone());
+    }
+
+    if !suffix.branches.is_empty() {
+        let mut branch_parts = Vec::new();
+        for branch in &suffix.branches {
+            branch_parts.push(paint_with_color(
+                &branch.name,
+                branch.color,
+                settings,
+                use_color,
+            )?);
+        }
+        parts.push(branch_parts.join(", "));
+    }
+
+    if !suffix.summary.is_empty() {
+        parts.push(suffix.summary.clone());
+    }
+
+    if parts.is_empty() {
+        Ok(None)
+    } else {
+        Ok(Some(parts.join(" ")))
+    }
+}
+
+fn render_graph_line(
+    chars: &[char],
+    colors: &[u8],
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+        let mut line = String::new();
+        let mut start = 0usize;
+        while start <= last_idx {
+            let color_idx = colors[start];
+            let mut end = start + 1;
+            while end <= last_idx && colors[end] == color_idx {
+                end += 1;
+            }
+            let segment: String = chars[start..end].iter().collect();
+            if use_color {
+                match term_color_for_index(color_idx, settings)? {
+                    Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
+                    None => line.push_str(&segment),
+                }
+            } else {
+                line.push_str(&segment);
+            }
+            start = end;
+        }
+        Ok(line)
+    } else {
+        Ok(String::new())
+    }
+}
+
+fn paint_with_color(
+    text: &str,
+    color_idx: u8,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if !use_color {
+        return Ok(text.to_string());
+    }
+
+    match term_color_for_index(color_idx, settings)? {
+        Some(term_color) => Ok(term_color.paint(text).to_string()),
+        None => Ok(text.to_string()),
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;


[2025-09-21T13:56:33] thinking

**Committing changes**
[2025-09-21T13:56:33] exec bash -lc 'git commit -m "025-d6cd9f1：复现提交代码内容。"' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:56:33] bash -lc 'git commit -m "025-d6cd9f1：复现提交代码内容。"' succeeded in 26ms:
[main 61d6cb8] 025-d6cd9f1：复现提交代码内容。
 2 files changed, 206 insertions(+), 43 deletions(-)
[2025-09-21T13:56:33] tokens used: 133,611
[2025-09-21T13:56:33] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 770a37ff9549fd0b39bf41b9e0064c17396ff3fb..a0990b6ed45d7d794944230d35114c8ab003cd52
--- a/src/main.rs
+++ b/src/main.rs
@@ -86,12 +86,14 @@
     }
     let duration_print = now.elapsed().as_micros();
 
-    eprintln!(
-        "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
-        duration_graph as f32 / 1000.0,
-        duration_print as f32 / 1000.0,
-        graph.commits.len()
-    );
+    if settings.debug {
+        eprintln!(
+            "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
+            duration_graph as f32 / 1000.0,
+            duration_print as f32 / 1000.0,
+            graph.commits.len()
+        );
+    }
 
     Ok(())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..9594e2b9e62e17825ebdf460bf6e9b3042122c87
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -22,6 +22,7 @@
 const ARROW_LEFT: char = '◀';
 
 const COLOR_NONE: u8 = u8::MAX;
+const PREFIX_WIDTH: usize = 9;
 
 #[derive(Clone, Debug)]
 struct Insert {
@@ -30,6 +31,31 @@
     layer: usize,
 }
 
+#[derive(Clone, Default)]
+struct LineDecoration {
+    prefix: Option<LinePrefix>,
+    suffix: Option<LineSuffix>,
+}
+
+#[derive(Clone)]
+struct LinePrefix {
+    short_id: String,
+    color: u8,
+}
+
+#[derive(Clone)]
+struct LineSuffix {
+    debug: Option<String>,
+    branches: Vec<LineBranch>,
+    summary: String,
+}
+
+#[derive(Clone)]
+struct LineBranch {
+    name: String,
+    color: u8,
+}
+
 /// Render the git graph as a Unicode string representation suitable for terminals.
 pub fn print_unicode(
     graph: &GitGraph,
@@ -54,7 +80,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,14 +97,47 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit.oid.to_string().chars().take(7).collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        let mut seen = Vec::new();
+        branch_indices.retain(|idx| {
+            if seen.contains(idx) {
+                false
+            } else {
+                seen.push(*idx);
+                true
+            }
+        });
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
+
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
 
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
@@ -180,7 +239,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {
@@ -541,6 +600,15 @@
     branch_settings.color.len()
 }
 
+fn color_index_for_branch(branch_settings: &BranchSettings, branch: &BranchInfo) -> usize {
+    let idx = branch.visual.color_group;
+    if idx < branch_settings.color.len() {
+        idx
+    } else {
+        branch_settings.color.len()
+    }
+}
+
 fn encode_color_index(idx: usize) -> u8 {
     if idx >= COLOR_NONE as usize {
         (COLOR_NONE - 1) as u8
@@ -568,49 +636,142 @@
         .ok_or_else(|| format!("Unknown terminal color: {}", name))
 }
 
-fn to_string_block(
+fn print_graph(
     grid: &CharGrid,
-    labels: &[Option<String>],
+    decorations: &[LineDecoration],
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
         let (chars, colors) = grid.row(row);
-        let mut line = String::new();
-        if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
-            let mut start = 0usize;
-            while start <= last_idx {
-                let color_idx = colors[start];
-                let mut end = start + 1;
-                while end <= last_idx && colors[end] == color_idx {
-                    end += 1;
-                }
-                let segment: String = chars[start..end].iter().collect();
-                if use_color {
-                    match term_color_for_index(color_idx, settings)? {
-                        Some(term_color) => {
-                            line.push_str(&term_color.paint(&segment).to_string());
-                        }
-                        None => line.push_str(&segment),
-                    }
-                } else {
-                    line.push_str(&segment);
-                }
-                start = end;
+        let prefix = render_prefix(decorations.get(row), settings, use_color)?;
+        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let suffix = render_suffix(decorations.get(row), settings, use_color)?;
+
+        let mut line = prefix;
+        let has_graph = !graph.is_empty();
+        if has_graph {
+            if !line.is_empty() {
+                line.push(' ');
             }
+            line.push_str(&graph);
         }
-        if let Some(label) = &labels[row] {
-            if !line.is_empty() {
+
+        if let Some(suffix) = suffix {
+            if has_graph || !line.trim().is_empty() {
                 line.push(' ');
             }
-            line.push_str(label);
+            line.push_str(&suffix);
         }
-        lines.push(line);
+
+        lines.push(line.trim_end().to_string());
     }
+
     Ok(lines.join("\n"))
 }
 
+fn render_prefix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    let blank = " ".repeat(PREFIX_WIDTH);
+    let Some(prefix) = decoration.and_then(|d| d.prefix.as_ref()) else {
+        return Ok(blank);
+    };
+
+    let text = format!("{:<width$}", prefix.short_id, width = PREFIX_WIDTH);
+    paint_with_color(&text, prefix.color, settings, use_color)
+}
+
+fn render_suffix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<Option<String>, String> {
+    let Some(suffix) = decoration.and_then(|d| d.suffix.as_ref()) else {
+        return Ok(None);
+    };
+
+    let mut parts: Vec<String> = Vec::new();
+
+    if let Some(debug) = &suffix.debug {
+        parts.push(debug.clone());
+    }
+
+    if !suffix.branches.is_empty() {
+        let mut branch_parts = Vec::new();
+        for branch in &suffix.branches {
+            branch_parts.push(paint_with_color(
+                &branch.name,
+                branch.color,
+                settings,
+                use_color,
+            )?);
+        }
+        parts.push(branch_parts.join(", "));
+    }
+
+    if !suffix.summary.is_empty() {
+        parts.push(suffix.summary.clone());
+    }
+
+    if parts.is_empty() {
+        Ok(None)
+    } else {
+        Ok(Some(parts.join(" ")))
+    }
+}
+
+fn render_graph_line(
+    chars: &[char],
+    colors: &[u8],
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+        let mut line = String::new();
+        let mut start = 0usize;
+        while start <= last_idx {
+            let color_idx = colors[start];
+            let mut end = start + 1;
+            while end <= last_idx && colors[end] == color_idx {
+                end += 1;
+            }
+            let segment: String = chars[start..end].iter().collect();
+            if use_color {
+                match term_color_for_index(color_idx, settings)? {
+                    Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
+                    None => line.push_str(&segment),
+                }
+            } else {
+                line.push_str(&segment);
+            }
+            start = end;
+        }
+        Ok(line)
+    } else {
+        Ok(String::new())
+    }
+}
+
+fn paint_with_color(
+    text: &str,
+    color_idx: u8,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if !use_color {
+        return Ok(text.to_string());
+    }
+
+    match term_color_for_index(color_idx, settings)? {
+        Some(term_color) => Ok(term_color.paint(text).to_string()),
+        None => Ok(text.to_string()),
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;


[2025-09-21T13:56:35] thinking

**Checking git status**
[2025-09-21T13:56:35] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:56:35] bash -lc 'git status -sb' succeeded in 33ms:
## main
[2025-09-21T13:56:35] tokens used: 133,871
[2025-09-21T13:56:35] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 770a37ff9549fd0b39bf41b9e0064c17396ff3fb..a0990b6ed45d7d794944230d35114c8ab003cd52
--- a/src/main.rs
+++ b/src/main.rs
@@ -86,12 +86,14 @@
     }
     let duration_print = now.elapsed().as_micros();
 
-    eprintln!(
-        "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
-        duration_graph as f32 / 1000.0,
-        duration_print as f32 / 1000.0,
-        graph.commits.len()
-    );
+    if settings.debug {
+        eprintln!(
+            "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
+            duration_graph as f32 / 1000.0,
+            duration_print as f32 / 1000.0,
+            graph.commits.len()
+        );
+    }
 
     Ok(())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..9594e2b9e62e17825ebdf460bf6e9b3042122c87
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -22,6 +22,7 @@
 const ARROW_LEFT: char = '◀';
 
 const COLOR_NONE: u8 = u8::MAX;
+const PREFIX_WIDTH: usize = 9;
 
 #[derive(Clone, Debug)]
 struct Insert {
@@ -30,6 +31,31 @@
     layer: usize,
 }
 
+#[derive(Clone, Default)]
+struct LineDecoration {
+    prefix: Option<LinePrefix>,
+    suffix: Option<LineSuffix>,
+}
+
+#[derive(Clone)]
+struct LinePrefix {
+    short_id: String,
+    color: u8,
+}
+
+#[derive(Clone)]
+struct LineSuffix {
+    debug: Option<String>,
+    branches: Vec<LineBranch>,
+    summary: String,
+}
+
+#[derive(Clone)]
+struct LineBranch {
+    name: String,
+    color: u8,
+}
+
 /// Render the git graph as a Unicode string representation suitable for terminals.
 pub fn print_unicode(
     graph: &GitGraph,
@@ -54,7 +80,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,14 +97,47 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit.oid.to_string().chars().take(7).collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        let mut seen = Vec::new();
+        branch_indices.retain(|idx| {
+            if seen.contains(idx) {
+                false
+            } else {
+                seen.push(*idx);
+                true
+            }
+        });
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
+
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
 
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
@@ -180,7 +239,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {
@@ -541,6 +600,15 @@
     branch_settings.color.len()
 }
 
+fn color_index_for_branch(branch_settings: &BranchSettings, branch: &BranchInfo) -> usize {
+    let idx = branch.visual.color_group;
+    if idx < branch_settings.color.len() {
+        idx
+    } else {
+        branch_settings.color.len()
+    }
+}
+
 fn encode_color_index(idx: usize) -> u8 {
     if idx >= COLOR_NONE as usize {
         (COLOR_NONE - 1) as u8
@@ -568,49 +636,142 @@
         .ok_or_else(|| format!("Unknown terminal color: {}", name))
 }
 
-fn to_string_block(
+fn print_graph(
     grid: &CharGrid,
-    labels: &[Option<String>],
+    decorations: &[LineDecoration],
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
         let (chars, colors) = grid.row(row);
-        let mut line = String::new();
-        if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
-            let mut start = 0usize;
-            while start <= last_idx {
-                let color_idx = colors[start];
-                let mut end = start + 1;
-                while end <= last_idx && colors[end] == color_idx {
-                    end += 1;
-                }
-                let segment: String = chars[start..end].iter().collect();
-                if use_color {
-                    match term_color_for_index(color_idx, settings)? {
-                        Some(term_color) => {
-                            line.push_str(&term_color.paint(&segment).to_string());
-                        }
-                        None => line.push_str(&segment),
-                    }
-                } else {
-                    line.push_str(&segment);
-                }
-                start = end;
+        let prefix = render_prefix(decorations.get(row), settings, use_color)?;
+        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let suffix = render_suffix(decorations.get(row), settings, use_color)?;
+
+        let mut line = prefix;
+        let has_graph = !graph.is_empty();
+        if has_graph {
+            if !line.is_empty() {
+                line.push(' ');
             }
+            line.push_str(&graph);
         }
-        if let Some(label) = &labels[row] {
-            if !line.is_empty() {
+
+        if let Some(suffix) = suffix {
+            if has_graph || !line.trim().is_empty() {
                 line.push(' ');
             }
-            line.push_str(label);
+            line.push_str(&suffix);
         }
-        lines.push(line);
+
+        lines.push(line.trim_end().to_string());
     }
+
     Ok(lines.join("\n"))
 }
 
+fn render_prefix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    let blank = " ".repeat(PREFIX_WIDTH);
+    let Some(prefix) = decoration.and_then(|d| d.prefix.as_ref()) else {
+        return Ok(blank);
+    };
+
+    let text = format!("{:<width$}", prefix.short_id, width = PREFIX_WIDTH);
+    paint_with_color(&text, prefix.color, settings, use_color)
+}
+
+fn render_suffix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<Option<String>, String> {
+    let Some(suffix) = decoration.and_then(|d| d.suffix.as_ref()) else {
+        return Ok(None);
+    };
+
+    let mut parts: Vec<String> = Vec::new();
+
+    if let Some(debug) = &suffix.debug {
+        parts.push(debug.clone());
+    }
+
+    if !suffix.branches.is_empty() {
+        let mut branch_parts = Vec::new();
+        for branch in &suffix.branches {
+            branch_parts.push(paint_with_color(
+                &branch.name,
+                branch.color,
+                settings,
+                use_color,
+            )?);
+        }
+        parts.push(branch_parts.join(", "));
+    }
+
+    if !suffix.summary.is_empty() {
+        parts.push(suffix.summary.clone());
+    }
+
+    if parts.is_empty() {
+        Ok(None)
+    } else {
+        Ok(Some(parts.join(" ")))
+    }
+}
+
+fn render_graph_line(
+    chars: &[char],
+    colors: &[u8],
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+        let mut line = String::new();
+        let mut start = 0usize;
+        while start <= last_idx {
+            let color_idx = colors[start];
+            let mut end = start + 1;
+            while end <= last_idx && colors[end] == color_idx {
+                end += 1;
+            }
+            let segment: String = chars[start..end].iter().collect();
+            if use_color {
+                match term_color_for_index(color_idx, settings)? {
+                    Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
+                    None => line.push_str(&segment),
+                }
+            } else {
+                line.push_str(&segment);
+            }
+            start = end;
+        }
+        Ok(line)
+    } else {
+        Ok(String::new())
+    }
+}
+
+fn paint_with_color(
+    text: &str,
+    color_idx: u8,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if !use_color {
+        return Ok(text.to_string());
+    }
+
+    match term_color_for_index(color_idx, settings)? {
+        Some(term_color) => Ok(term_color.paint(text).to_string()),
+        None => Ok(text.to_string()),
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;


[2025-09-21T13:56:39] thinking

**Collecting line numbers for references**
[2025-09-21T13:56:39] exec bash -lc "nl -ba src/print/unicode.rs | sed -n '20,140p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:56:39] bash -lc "nl -ba src/print/unicode.rs | sed -n '20,140p'" succeeded in 12ms:
    20	const CROSS: char = '┼';
    21	const ARROW_RIGHT: char = '▶';
    22	const ARROW_LEFT: char = '◀';
    23	
    24	const COLOR_NONE: u8 = u8::MAX;
    25	const PREFIX_WIDTH: usize = 9;
    26	
    27	#[derive(Clone, Debug)]
    28	struct Insert {
    29	    parent_index: usize,
    30	    to_col: usize,
    31	    layer: usize,
    32	}
    33	
    34	#[derive(Clone, Default)]
    35	struct LineDecoration {
    36	    prefix: Option<LinePrefix>,
    37	    suffix: Option<LineSuffix>,
    38	}
    39	
[2025-09-21T13:56:39] tokens used: 134,175
[2025-09-21T13:56:39] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 770a37ff9549fd0b39bf41b9e0064c17396ff3fb..a0990b6ed45d7d794944230d35114c8ab003cd52
--- a/src/main.rs
+++ b/src/main.rs
@@ -86,12 +86,14 @@
     }
     let duration_print = now.elapsed().as_micros();
 
-    eprintln!(
-        "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
-        duration_graph as f32 / 1000.0,
-        duration_print as f32 / 1000.0,
-        graph.commits.len()
-    );
+    if settings.debug {
+        eprintln!(
+            "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
+            duration_graph as f32 / 1000.0,
+            duration_print as f32 / 1000.0,
+            graph.commits.len()
+        );
+    }
 
     Ok(())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..9594e2b9e62e17825ebdf460bf6e9b3042122c87
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -22,6 +22,7 @@
 const ARROW_LEFT: char = '◀';
 
 const COLOR_NONE: u8 = u8::MAX;
+const PREFIX_WIDTH: usize = 9;
 
 #[derive(Clone, Debug)]
 struct Insert {
@@ -30,6 +31,31 @@
     layer: usize,
 }
 
+#[derive(Clone, Default)]
+struct LineDecoration {
+    prefix: Option<LinePrefix>,
+    suffix: Option<LineSuffix>,
+}
+
+#[derive(Clone)]
+struct LinePrefix {
+    short_id: String,
+    color: u8,
+}
+
+#[derive(Clone)]
+struct LineSuffix {
+    debug: Option<String>,
+    branches: Vec<LineBranch>,
+    summary: String,
+}
+
+#[derive(Clone)]
+struct LineBranch {
+    name: String,
+    color: u8,
+}
+
 /// Render the git graph as a Unicode string representation suitable for terminals.
 pub fn print_unicode(
     graph: &GitGraph,
@@ -54,7 +80,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,14 +97,47 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit.oid.to_string().chars().take(7).collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        let mut seen = Vec::new();
+        branch_indices.retain(|idx| {
+            if seen.contains(idx) {
+                false
+            } else {
+                seen.push(*idx);
+                true
+            }
+        });
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
+
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
 
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
@@ -180,7 +239,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {
@@ -541,6 +600,15 @@
     branch_settings.color.len()
 }
 
+fn color_index_for_branch(branch_settings: &BranchSettings, branch: &BranchInfo) -> usize {
+    let idx = branch.visual.color_group;
+    if idx < branch_settings.color.len() {
+        idx
+    } else {
+        branch_settings.color.len()
+    }
+}
+
 fn encode_color_index(idx: usize) -> u8 {
     if idx >= COLOR_NONE as usize {
         (COLOR_NONE - 1) as u8
@@ -568,49 +636,142 @@
         .ok_or_else(|| format!("Unknown terminal color: {}", name))
 }
 
-fn to_string_block(
+fn print_graph(
     grid: &CharGrid,
-    labels: &[Option<String>],
+    decorations: &[LineDecoration],
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
         let (chars, colors) = grid.row(row);
-        let mut line = String::new();
-        if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
-            let mut start = 0usize;
-            while start <= last_idx {
-                let color_idx = colors[start];
-                let mut end = start + 1;
-                while end <= last_idx && colors[end] == color_idx {
-                    end += 1;
-                }
-                let segment: String = chars[start..end].iter().collect();
-                if use_color {
-                    match term_color_for_index(color_idx, settings)? {
-                        Some(term_color) => {
-                            line.push_str(&term_color.paint(&segment).to_string());
-                        }
-                        None => line.push_str(&segment),
-                    }
-                } else {
-                    line.push_str(&segment);
-                }
-                start = end;
+        let prefix = render_prefix(decorations.get(row), settings, use_color)?;
+        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let suffix = render_suffix(decorations.get(row), settings, use_color)?;
+
+        let mut line = prefix;
+        let has_graph = !graph.is_empty();
+        if has_graph {
+            if !line.is_empty() {
+                line.push(' ');
             }
+            line.push_str(&graph);
         }
-        if let Some(label) = &labels[row] {
-            if !line.is_empty() {
+
+        if let Some(suffix) = suffix {
+            if has_graph || !line.trim().is_empty() {
                 line.push(' ');
             }
-            line.push_str(label);
+            line.push_str(&suffix);
         }
-        lines.push(line);
+
+        lines.push(line.trim_end().to_string());
     }
+
     Ok(lines.join("\n"))
 }
 
+fn render_prefix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    let blank = " ".repeat(PREFIX_WIDTH);
+    let Some(prefix) = decoration.and_then(|d| d.prefix.as_ref()) else {
+        return Ok(blank);
+    };
+
+    let text = format!("{:<width$}", prefix.short_id, width = PREFIX_WIDTH);
+    paint_with_color(&text, prefix.color, settings, use_color)
+}
+
+fn render_suffix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<Option<String>, String> {
+    let Some(suffix) = decoration.and_then(|d| d.suffix.as_ref()) else {
+        return Ok(None);
+    };
+
+    let mut parts: Vec<String> = Vec::new();
+
+    if let Some(debug) = &suffix.debug {
+        parts.push(debug.clone());
+    }
+
+    if !suffix.branches.is_empty() {
+        let mut branch_parts = Vec::new();
+        for branch in &suffix.branches {
+            branch_parts.push(paint_with_color(
+                &branch.name,
+                branch.color,
+                settings,
+                use_color,
+            )?);
+        }
+        parts.push(branch_parts.join(", "));
+    }
+
+    if !suffix.summary.is_empty() {
+        parts.push(suffix.summary.clone());
+    }
+
+    if parts.is_empty() {
+        Ok(None)
+    } else {
+        Ok(Some(parts.join(" ")))
+    }
+}
+
+fn render_graph_line(
+    chars: &[char],
+    colors: &[u8],
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+        let mut line = String::new();
+        let mut start = 0usize;
+        while start <= last_idx {
+            let color_idx = colors[start];
+            let mut end = start + 1;
+            while end <= last_idx && colors[end] == color_idx {
+                end += 1;
+            }
+            let segment: String = chars[start..end].iter().collect();
+            if use_color {
+                match term_color_for_index(color_idx, settings)? {
+                    Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
+                    None => line.push_str(&segment),
+                }
+            } else {
+                line.push_str(&segment);
+            }
+            start = end;
+        }
+        Ok(line)
+    } else {
+        Ok(String::new())
+    }
+}
+
+fn paint_with_color(
+    text: &str,
+    color_idx: u8,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if !use_color {
+        return Ok(text.to_string());
+    }
+
+    match term_color_for_index(color_idx, settings)? {
+        Some(term_color) => Ok(term_color.paint(text).to_string()),
+        None => Ok(text.to_string()),
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;


[2025-09-21T13:56:42] thinking

**Identifying print_graph references**
[2025-09-21T13:56:42] exec bash -lc "nl -ba src/print/unicode.rs | sed -n '520,780p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:56:42] bash -lc "nl -ba src/print/unicode.rs | sed -n '520,780p'" succeeded in 36ms:
   520	
   521	    for (child_index, commit) in graph.commits.iter().enumerate() {
   522	        let from_col = match commit_column(graph, commit) {
   523	            Some(col) => col,
   524	            None => continue,
   525	        };
   526	
   527	        let mut edges: Vec<Insert> = Vec::new();
   528	
   529	        for parent_oid in commit.parents.iter().flatten() {
   530	            if let Some(&parent_index) = graph.indices.get(parent_oid) {
   531	                if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
   532	                    if parent_col == from_col {
   533	                        continue;
   534	                    }
   535	                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
   536	                    edges.push(Insert {
   537	                        parent_index,
   538	                        to_col: parent_col,
   539	                        layer,
[2025-09-21T13:56:42] tokens used: 135,803
[2025-09-21T13:56:42] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 770a37ff9549fd0b39bf41b9e0064c17396ff3fb..a0990b6ed45d7d794944230d35114c8ab003cd52
--- a/src/main.rs
+++ b/src/main.rs
@@ -86,12 +86,14 @@
     }
     let duration_print = now.elapsed().as_micros();
 
-    eprintln!(
-        "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
-        duration_graph as f32 / 1000.0,
-        duration_print as f32 / 1000.0,
-        graph.commits.len()
-    );
+    if settings.debug {
+        eprintln!(
+            "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
+            duration_graph as f32 / 1000.0,
+            duration_print as f32 / 1000.0,
+            graph.commits.len()
+        );
+    }
 
     Ok(())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..9594e2b9e62e17825ebdf460bf6e9b3042122c87
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -22,6 +22,7 @@
 const ARROW_LEFT: char = '◀';
 
 const COLOR_NONE: u8 = u8::MAX;
+const PREFIX_WIDTH: usize = 9;
 
 #[derive(Clone, Debug)]
 struct Insert {
@@ -30,6 +31,31 @@
     layer: usize,
 }
 
+#[derive(Clone, Default)]
+struct LineDecoration {
+    prefix: Option<LinePrefix>,
+    suffix: Option<LineSuffix>,
+}
+
+#[derive(Clone)]
+struct LinePrefix {
+    short_id: String,
+    color: u8,
+}
+
+#[derive(Clone)]
+struct LineSuffix {
+    debug: Option<String>,
+    branches: Vec<LineBranch>,
+    summary: String,
+}
+
+#[derive(Clone)]
+struct LineBranch {
+    name: String,
+    color: u8,
+}
+
 /// Render the git graph as a Unicode string representation suitable for terminals.
 pub fn print_unicode(
     graph: &GitGraph,
@@ -54,7 +80,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,14 +97,47 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit.oid.to_string().chars().take(7).collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        let mut seen = Vec::new();
+        branch_indices.retain(|idx| {
+            if seen.contains(idx) {
+                false
+            } else {
+                seen.push(*idx);
+                true
+            }
+        });
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
+
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
 
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
@@ -180,7 +239,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {
@@ -541,6 +600,15 @@
     branch_settings.color.len()
 }
 
+fn color_index_for_branch(branch_settings: &BranchSettings, branch: &BranchInfo) -> usize {
+    let idx = branch.visual.color_group;
+    if idx < branch_settings.color.len() {
+        idx
+    } else {
+        branch_settings.color.len()
+    }
+}
+
 fn encode_color_index(idx: usize) -> u8 {
     if idx >= COLOR_NONE as usize {
         (COLOR_NONE - 1) as u8
@@ -568,49 +636,142 @@
         .ok_or_else(|| format!("Unknown terminal color: {}", name))
 }
 
-fn to_string_block(
+fn print_graph(
     grid: &CharGrid,
-    labels: &[Option<String>],
+    decorations: &[LineDecoration],
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
         let (chars, colors) = grid.row(row);
-        let mut line = String::new();
-        if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
-            let mut start = 0usize;
-            while start <= last_idx {
-                let color_idx = colors[start];
-                let mut end = start + 1;
-                while end <= last_idx && colors[end] == color_idx {
-                    end += 1;
-                }
-                let segment: String = chars[start..end].iter().collect();
-                if use_color {
-                    match term_color_for_index(color_idx, settings)? {
-                        Some(term_color) => {
-                            line.push_str(&term_color.paint(&segment).to_string());
-                        }
-                        None => line.push_str(&segment),
-                    }
-                } else {
-                    line.push_str(&segment);
-                }
-                start = end;
+        let prefix = render_prefix(decorations.get(row), settings, use_color)?;
+        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let suffix = render_suffix(decorations.get(row), settings, use_color)?;
+
+        let mut line = prefix;
+        let has_graph = !graph.is_empty();
+        if has_graph {
+            if !line.is_empty() {
+                line.push(' ');
             }
+            line.push_str(&graph);
         }
-        if let Some(label) = &labels[row] {
-            if !line.is_empty() {
+
+        if let Some(suffix) = suffix {
+            if has_graph || !line.trim().is_empty() {
                 line.push(' ');
             }
-            line.push_str(label);
+            line.push_str(&suffix);
         }
-        lines.push(line);
+
+        lines.push(line.trim_end().to_string());
     }
+
     Ok(lines.join("\n"))
 }
 
+fn render_prefix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    let blank = " ".repeat(PREFIX_WIDTH);
+    let Some(prefix) = decoration.and_then(|d| d.prefix.as_ref()) else {
+        return Ok(blank);
+    };
+
+    let text = format!("{:<width$}", prefix.short_id, width = PREFIX_WIDTH);
+    paint_with_color(&text, prefix.color, settings, use_color)
+}
+
+fn render_suffix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<Option<String>, String> {
+    let Some(suffix) = decoration.and_then(|d| d.suffix.as_ref()) else {
+        return Ok(None);
+    };
+
+    let mut parts: Vec<String> = Vec::new();
+
+    if let Some(debug) = &suffix.debug {
+        parts.push(debug.clone());
+    }
+
+    if !suffix.branches.is_empty() {
+        let mut branch_parts = Vec::new();
+        for branch in &suffix.branches {
+            branch_parts.push(paint_with_color(
+                &branch.name,
+                branch.color,
+                settings,
+                use_color,
+            )?);
+        }
+        parts.push(branch_parts.join(", "));
+    }
+
+    if !suffix.summary.is_empty() {
+        parts.push(suffix.summary.clone());
+    }
+
+    if parts.is_empty() {
+        Ok(None)
+    } else {
+        Ok(Some(parts.join(" ")))
+    }
+}
+
+fn render_graph_line(
+    chars: &[char],
+    colors: &[u8],
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+        let mut line = String::new();
+        let mut start = 0usize;
+        while start <= last_idx {
+            let color_idx = colors[start];
+            let mut end = start + 1;
+            while end <= last_idx && colors[end] == color_idx {
+                end += 1;
+            }
+            let segment: String = chars[start..end].iter().collect();
+            if use_color {
+                match term_color_for_index(color_idx, settings)? {
+                    Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
+                    None => line.push_str(&segment),
+                }
+            } else {
+                line.push_str(&segment);
+            }
+            start = end;
+        }
+        Ok(line)
+    } else {
+        Ok(String::new())
+    }
+}
+
+fn paint_with_color(
+    text: &str,
+    color_idx: u8,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if !use_color {
+        return Ok(text.to_string());
+    }
+
+    match term_color_for_index(color_idx, settings)? {
+        Some(term_color) => Ok(term_color.paint(text).to_string()),
+        None => Ok(text.to_string()),
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;


[2025-09-21T13:56:45] thinking

**Identifying debug condition lines**
[2025-09-21T13:56:46] exec bash -lc "nl -ba src/main.rs | sed -n '1,160p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T13:56:46] bash -lc "nl -ba src/main.rs | sed -n '1,160p'" succeeded in 17ms:
     1	use clap::{App, Arg};
     2	use git_graph::graph::{CommitInfo, GitGraph};
     3	use git_graph::print::svg::print_svg;
     4	use git_graph::print::unicode::print_unicode;
     5	use git_graph::settings::{BranchOrder, BranchSettings, MergePatterns, Settings};
     6	use std::process;
     7	use std::time::Instant;
     8	
     9	fn main() {
    10	    let matches = App::new("git-graph")
    11	        .version(env!("CARGO_PKG_VERSION"))
    12	        .about("Render git commit graphs as Unicode or SVG")
    13	        .arg(
    14	            Arg::with_name("svg")
    15	                .long("svg")
    16	                .help("Render SVG output instead of console output"),
    17	        )
    18	        .arg(
    19	            Arg::with_name("no-color")
    20	                .long("no-color")
[2025-09-21T13:56:46] tokens used: 138,929
[2025-09-21T13:56:46] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 770a37ff9549fd0b39bf41b9e0064c17396ff3fb..a0990b6ed45d7d794944230d35114c8ab003cd52
--- a/src/main.rs
+++ b/src/main.rs
@@ -86,12 +86,14 @@
     }
     let duration_print = now.elapsed().as_micros();
 
-    eprintln!(
-        "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
-        duration_graph as f32 / 1000.0,
-        duration_print as f32 / 1000.0,
-        graph.commits.len()
-    );
+    if settings.debug {
+        eprintln!(
+            "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
+            duration_graph as f32 / 1000.0,
+            duration_print as f32 / 1000.0,
+            graph.commits.len()
+        );
+    }
 
     Ok(())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..9594e2b9e62e17825ebdf460bf6e9b3042122c87
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -22,6 +22,7 @@
 const ARROW_LEFT: char = '◀';
 
 const COLOR_NONE: u8 = u8::MAX;
+const PREFIX_WIDTH: usize = 9;
 
 #[derive(Clone, Debug)]
 struct Insert {
@@ -30,6 +31,31 @@
     layer: usize,
 }
 
+#[derive(Clone, Default)]
+struct LineDecoration {
+    prefix: Option<LinePrefix>,
+    suffix: Option<LineSuffix>,
+}
+
+#[derive(Clone)]
+struct LinePrefix {
+    short_id: String,
+    color: u8,
+}
+
+#[derive(Clone)]
+struct LineSuffix {
+    debug: Option<String>,
+    branches: Vec<LineBranch>,
+    summary: String,
+}
+
+#[derive(Clone)]
+struct LineBranch {
+    name: String,
+    color: u8,
+}
+
 /// Render the git graph as a Unicode string representation suitable for terminals.
 pub fn print_unicode(
     graph: &GitGraph,
@@ -54,7 +80,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,14 +97,47 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit.oid.to_string().chars().take(7).collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        let mut seen = Vec::new();
+        branch_indices.retain(|idx| {
+            if seen.contains(idx) {
+                false
+            } else {
+                seen.push(*idx);
+                true
+            }
+        });
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
+
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
 
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
@@ -180,7 +239,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {
@@ -541,6 +600,15 @@
     branch_settings.color.len()
 }
 
+fn color_index_for_branch(branch_settings: &BranchSettings, branch: &BranchInfo) -> usize {
+    let idx = branch.visual.color_group;
+    if idx < branch_settings.color.len() {
+        idx
+    } else {
+        branch_settings.color.len()
+    }
+}
+
 fn encode_color_index(idx: usize) -> u8 {
     if idx >= COLOR_NONE as usize {
         (COLOR_NONE - 1) as u8
@@ -568,49 +636,142 @@
         .ok_or_else(|| format!("Unknown terminal color: {}", name))
 }
 
-fn to_string_block(
+fn print_graph(
     grid: &CharGrid,
-    labels: &[Option<String>],
+    decorations: &[LineDecoration],
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
         let (chars, colors) = grid.row(row);
-        let mut line = String::new();
-        if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
-            let mut start = 0usize;
-            while start <= last_idx {
-                let color_idx = colors[start];
-                let mut end = start + 1;
-                while end <= last_idx && colors[end] == color_idx {
-                    end += 1;
-                }
-                let segment: String = chars[start..end].iter().collect();
-                if use_color {
-                    match term_color_for_index(color_idx, settings)? {
-                        Some(term_color) => {
-                            line.push_str(&term_color.paint(&segment).to_string());
-                        }
-                        None => line.push_str(&segment),
-                    }
-                } else {
-                    line.push_str(&segment);
-                }
-                start = end;
+        let prefix = render_prefix(decorations.get(row), settings, use_color)?;
+        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let suffix = render_suffix(decorations.get(row), settings, use_color)?;
+
+        let mut line = prefix;
+        let has_graph = !graph.is_empty();
+        if has_graph {
+            if !line.is_empty() {
+                line.push(' ');
             }
+            line.push_str(&graph);
         }
-        if let Some(label) = &labels[row] {
-            if !line.is_empty() {
+
+        if let Some(suffix) = suffix {
+            if has_graph || !line.trim().is_empty() {
                 line.push(' ');
             }
-            line.push_str(label);
+            line.push_str(&suffix);
         }
-        lines.push(line);
+
+        lines.push(line.trim_end().to_string());
     }
+
     Ok(lines.join("\n"))
 }
 
+fn render_prefix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    let blank = " ".repeat(PREFIX_WIDTH);
+    let Some(prefix) = decoration.and_then(|d| d.prefix.as_ref()) else {
+        return Ok(blank);
+    };
+
+    let text = format!("{:<width$}", prefix.short_id, width = PREFIX_WIDTH);
+    paint_with_color(&text, prefix.color, settings, use_color)
+}
+
+fn render_suffix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<Option<String>, String> {
+    let Some(suffix) = decoration.and_then(|d| d.suffix.as_ref()) else {
+        return Ok(None);
+    };
+
+    let mut parts: Vec<String> = Vec::new();
+
+    if let Some(debug) = &suffix.debug {
+        parts.push(debug.clone());
+    }
+
+    if !suffix.branches.is_empty() {
+        let mut branch_parts = Vec::new();
+        for branch in &suffix.branches {
+            branch_parts.push(paint_with_color(
+                &branch.name,
+                branch.color,
+                settings,
+                use_color,
+            )?);
+        }
+        parts.push(branch_parts.join(", "));
+    }
+
+    if !suffix.summary.is_empty() {
+        parts.push(suffix.summary.clone());
+    }
+
+    if parts.is_empty() {
+        Ok(None)
+    } else {
+        Ok(Some(parts.join(" ")))
+    }
+}
+
+fn render_graph_line(
+    chars: &[char],
+    colors: &[u8],
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+        let mut line = String::new();
+        let mut start = 0usize;
+        while start <= last_idx {
+            let color_idx = colors[start];
+            let mut end = start + 1;
+            while end <= last_idx && colors[end] == color_idx {
+                end += 1;
+            }
+            let segment: String = chars[start..end].iter().collect();
+            if use_color {
+                match term_color_for_index(color_idx, settings)? {
+                    Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
+                    None => line.push_str(&segment),
+                }
+            } else {
+                line.push_str(&segment);
+            }
+            start = end;
+        }
+        Ok(line)
+    } else {
+        Ok(String::new())
+    }
+}
+
+fn paint_with_color(
+    text: &str,
+    color_idx: u8,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if !use_color {
+        return Ok(text.to_string());
+    }
+
+    match term_color_for_index(color_idx, settings)? {
+        Some(term_color) => Ok(term_color.paint(text).to_string()),
+        None => Ok(text.to_string()),
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;


[2025-09-21T13:57:02] thinking

**Preparing detailed final summary**

I'll gather results for a clear final message that explains the main changes, highlights file paths with line references, notes the test failures due to network issues, and suggests natural next steps like rerunning tests once the network is available, while ensuring transparency about assumptions made in the implementation.
[2025-09-21T13:57:03] codex

扩展了文本模式渲染，让每一行同时携带短 SHA、分支名和提交摘要，并把耗时统计放到 `--debug` 模式下。

- src/print/unicode.rs:25-139 定义行装饰结构，按行采集短 SHA、调试序号、分支颜色与摘要，供图形串联输出。
- src/print/unicode.rs:639-772 新增 `print_graph`/`render_*` 管道，将前缀(9 列短 SHA)、主体(彩色图形)与后缀(调试索引、彩色分支名、摘要)拼接，并统一颜色处理。
- src/main.rs:9-96 加入 `--debug` 参数并将构建/渲染耗时打印限定在调试模式。

假设调试信息仍需保留，因此把 `#索引` 继续放在右侧说明中；若需要其他格式，可再调整。

验证：
- `cargo test`（因离线环境无法访问 crates.io，依赖拉取失败）

下一步建议：
1. 联网环境下重新执行 `cargo test`，确认新输出逻辑通过现有用例。
[2025-09-21T13:57:04] tokens used: 141,738
[2025-09-21T13:57:04] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 770a37ff9549fd0b39bf41b9e0064c17396ff3fb..a0990b6ed45d7d794944230d35114c8ab003cd52
--- a/src/main.rs
+++ b/src/main.rs
@@ -86,12 +86,14 @@
     }
     let duration_print = now.elapsed().as_micros();
 
-    eprintln!(
-        "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
-        duration_graph as f32 / 1000.0,
-        duration_print as f32 / 1000.0,
-        graph.commits.len()
-    );
+    if settings.debug {
+        eprintln!(
+            "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
+            duration_graph as f32 / 1000.0,
+            duration_print as f32 / 1000.0,
+            graph.commits.len()
+        );
+    }
 
     Ok(())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 217c9efa85003f87af3351241287dccdd40176aa..9594e2b9e62e17825ebdf460bf6e9b3042122c87
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -22,6 +22,7 @@
 const ARROW_LEFT: char = '◀';
 
 const COLOR_NONE: u8 = u8::MAX;
+const PREFIX_WIDTH: usize = 9;
 
 #[derive(Clone, Debug)]
 struct Insert {
@@ -30,6 +31,31 @@
     layer: usize,
 }
 
+#[derive(Clone, Default)]
+struct LineDecoration {
+    prefix: Option<LinePrefix>,
+    suffix: Option<LineSuffix>,
+}
+
+#[derive(Clone)]
+struct LinePrefix {
+    short_id: String,
+    color: u8,
+}
+
+#[derive(Clone)]
+struct LineSuffix {
+    debug: Option<String>,
+    branches: Vec<LineBranch>,
+    summary: String,
+}
+
+#[derive(Clone)]
+struct LineBranch {
+    name: String,
+    color: u8,
+}
+
 /// Render the git graph as a Unicode string representation suitable for terminals.
 pub fn print_unicode(
     graph: &GitGraph,
@@ -54,7 +80,7 @@
     let width = max_column * 2 + 1;
 
     let mut grid = CharGrid::new(width, height);
-    let mut labels: Vec<Option<String>> = vec![None; height];
+    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
@@ -71,14 +97,47 @@
             .ok()
             .and_then(|commit_obj| commit_obj.summary().map(|s| s.to_string()))
             .unwrap_or_else(|| String::from("---"));
-        let short_id = commit.oid.to_string();
-        let short_id = short_id.chars().take(7).collect::<String>();
-        let label = if debug {
-            format!("#{index:03} {short_id} {summary}")
-        } else {
-            format!("{short_id} {summary}")
-        };
-        labels[row] = Some(label);
+        let short_id = commit.oid.to_string().chars().take(7).collect::<String>();
+
+        let mut branch_indices = commit.branches.clone();
+        if let Some(trace) = commit.branch_trace {
+            if let Some(pos) = branch_indices.iter().position(|idx| *idx == trace) {
+                branch_indices.remove(pos);
+            }
+            branch_indices.insert(0, trace);
+        }
+
+        let mut seen = Vec::new();
+        branch_indices.retain(|idx| {
+            if seen.contains(idx) {
+                false
+            } else {
+                seen.push(*idx);
+                true
+            }
+        });
+
+        let mut branches = Vec::new();
+        for branch_idx in branch_indices {
+            if let Some(branch) = graph.branches.get(branch_idx) {
+                let color = encode_color_index(color_index_for_branch(branch_settings, branch));
+                branches.push(LineBranch {
+                    name: branch.name.clone(),
+                    color,
+                });
+            }
+        }
+
+        let mut line = &mut decorations[row];
+        line.prefix = Some(LinePrefix {
+            short_id,
+            color: commit_color,
+        });
+        line.suffix = Some(LineSuffix {
+            debug: debug.then(|| format!("#{index:03}")),
+            branches,
+            summary,
+        });
 
         for (parent_position, parent_oid_opt) in commit.parents.iter().enumerate() {
             let parent_oid = match parent_oid_opt {
@@ -180,7 +239,7 @@
         }
     }
 
-    to_string_block(&grid, &labels, branch_settings, color_enabled)
+    print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
 struct CharGrid {
@@ -541,6 +600,15 @@
     branch_settings.color.len()
 }
 
+fn color_index_for_branch(branch_settings: &BranchSettings, branch: &BranchInfo) -> usize {
+    let idx = branch.visual.color_group;
+    if idx < branch_settings.color.len() {
+        idx
+    } else {
+        branch_settings.color.len()
+    }
+}
+
 fn encode_color_index(idx: usize) -> u8 {
     if idx >= COLOR_NONE as usize {
         (COLOR_NONE - 1) as u8
@@ -568,49 +636,142 @@
         .ok_or_else(|| format!("Unknown terminal color: {}", name))
 }
 
-fn to_string_block(
+fn print_graph(
     grid: &CharGrid,
-    labels: &[Option<String>],
+    decorations: &[LineDecoration],
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
         let (chars, colors) = grid.row(row);
-        let mut line = String::new();
-        if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
-            let mut start = 0usize;
-            while start <= last_idx {
-                let color_idx = colors[start];
-                let mut end = start + 1;
-                while end <= last_idx && colors[end] == color_idx {
-                    end += 1;
-                }
-                let segment: String = chars[start..end].iter().collect();
-                if use_color {
-                    match term_color_for_index(color_idx, settings)? {
-                        Some(term_color) => {
-                            line.push_str(&term_color.paint(&segment).to_string());
-                        }
-                        None => line.push_str(&segment),
-                    }
-                } else {
-                    line.push_str(&segment);
-                }
-                start = end;
+        let prefix = render_prefix(decorations.get(row), settings, use_color)?;
+        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let suffix = render_suffix(decorations.get(row), settings, use_color)?;
+
+        let mut line = prefix;
+        let has_graph = !graph.is_empty();
+        if has_graph {
+            if !line.is_empty() {
+                line.push(' ');
             }
+            line.push_str(&graph);
         }
-        if let Some(label) = &labels[row] {
-            if !line.is_empty() {
+
+        if let Some(suffix) = suffix {
+            if has_graph || !line.trim().is_empty() {
                 line.push(' ');
             }
-            line.push_str(label);
+            line.push_str(&suffix);
         }
-        lines.push(line);
+
+        lines.push(line.trim_end().to_string());
     }
+
     Ok(lines.join("\n"))
 }
 
+fn render_prefix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    let blank = " ".repeat(PREFIX_WIDTH);
+    let Some(prefix) = decoration.and_then(|d| d.prefix.as_ref()) else {
+        return Ok(blank);
+    };
+
+    let text = format!("{:<width$}", prefix.short_id, width = PREFIX_WIDTH);
+    paint_with_color(&text, prefix.color, settings, use_color)
+}
+
+fn render_suffix(
+    decoration: Option<&LineDecoration>,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<Option<String>, String> {
+    let Some(suffix) = decoration.and_then(|d| d.suffix.as_ref()) else {
+        return Ok(None);
+    };
+
+    let mut parts: Vec<String> = Vec::new();
+
+    if let Some(debug) = &suffix.debug {
+        parts.push(debug.clone());
+    }
+
+    if !suffix.branches.is_empty() {
+        let mut branch_parts = Vec::new();
+        for branch in &suffix.branches {
+            branch_parts.push(paint_with_color(
+                &branch.name,
+                branch.color,
+                settings,
+                use_color,
+            )?);
+        }
+        parts.push(branch_parts.join(", "));
+    }
+
+    if !suffix.summary.is_empty() {
+        parts.push(suffix.summary.clone());
+    }
+
+    if parts.is_empty() {
+        Ok(None)
+    } else {
+        Ok(Some(parts.join(" ")))
+    }
+}
+
+fn render_graph_line(
+    chars: &[char],
+    colors: &[u8],
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+        let mut line = String::new();
+        let mut start = 0usize;
+        while start <= last_idx {
+            let color_idx = colors[start];
+            let mut end = start + 1;
+            while end <= last_idx && colors[end] == color_idx {
+                end += 1;
+            }
+            let segment: String = chars[start..end].iter().collect();
+            if use_color {
+                match term_color_for_index(color_idx, settings)? {
+                    Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
+                    None => line.push_str(&segment),
+                }
+            } else {
+                line.push_str(&segment);
+            }
+            start = end;
+        }
+        Ok(line)
+    } else {
+        Ok(String::new())
+    }
+}
+
+fn paint_with_color(
+    text: &str,
+    color_idx: u8,
+    settings: &BranchSettings,
+    use_color: bool,
+) -> Result<String, String> {
+    if !use_color {
+        return Ok(text.to_string());
+    }
+
+    match term_color_for_index(color_idx, settings)? {
+        Some(term_color) => Ok(term_color.paint(text).to_string()),
+        None => Ok(text.to_string()),
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;


=== 最终状态 ===
返回码: 0
状态: ✅ 执行成功
