=== 任务 027-e2bedd3 执行日志 ===
时间: 2025-09-21 22:45:34.376314
Prompt:
请在 .workspace 内，依据 .workspace/todolist/todolist-027-e2bedd3.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/027-e2bedd3/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："027-e2bedd3：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 027-e2bedd3

=== 输出 ===
[2025-09-21T14:34:49] OpenAI Codex v0.39.0 (research preview)
--------
workdir: /Users/jqwang/104-CommitLens-codex/.workspace
model: gpt-5-codex-high
provider: codex
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
--------
[2025-09-21T14:34:49] User instructions:
请在 .workspace 内，依据 .workspace/todolist/todolist-027-e2bedd3.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/027-e2bedd3/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："027-e2bedd3：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 027-e2bedd3

[2025-09-21T14:34:59] thinking

**Preparing to replicate commit****Preparing to replicate commit instructions**
[2025-09-21T14:34:59] exec bash -lc 'ls -la' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T14:34:59] bash -lc 'ls -la' succeeded in 19ms:
total 12312
drwxr-xr-x@  9 jqwang  staff      288 Sep 21 15:57 .
drwxr-xr-x@ 29 jqwang  staff      928 Sep 21 07:49 ..
-rw-r--r--@  1 jqwang  staff        0 Sep 21 22:34 codex_error.txt
-rw-r--r--@  1 jqwang  staff  6005883 Sep 21 22:34 codex_output.txt
-rw-r--r--@  1 jqwang  staff        7 Sep 21 22:34 codex_status.txt
drwxr-xr-x@ 29 jqwang  staff      928 Sep 21 22:11 logs
drwxr-xr-x@ 12 jqwang  staff      384 Sep 21 20:54 rust-project
-rw-r--r--@  1 jqwang  staff      636 Sep 21 22:34 task_status.json
drwxr-xr-x@  5 jqwang  staff      160 Sep 21 22:34 todolist
[2025-09-21T14:34:59] tokens used: 1,928

[2025-09-21T14:35:01] thinking

**Preparing to read tex file**
[2025-09-21T14:35:01] exec bash -lc "sed -n '1,160p' todolist/todolist-027-e2bedd3.tex" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T14:35:01] bash -lc "sed -n '1,160p' todolist/todolist-027-e2bedd3.tex" succeeded in 9ms:
\section{提交考古：027-e2bedd3}

\subsection*{Commit 元信息}
\begin{itemize}
  \item 标题：restructured char grid, respect branch persistence during coloring
  \item 作者：Martin Lange \texttt{<martin\_lange\_@gmx.net>}
  \item 日期：2020-12-25T00:24:08+01:00
\end{itemize}

\subsection*{变更摘要（阅读提示）}
\begin{verbatim}
HEAD:    src/graph.rs         |  13 ++-
 src/main.rs          |   3 +-
 src/print/unicode.rs | 304 +++++++++++++++++++++++++++++++--------------------
 src/settings.rs      |  14 +++
 4 files changed, 207 insertions(+), 127 deletions(-)
HEAD-1:  src/graph.rs         |  2 ++
 src/main.rs          | 31 +++++++++++++++++++++----------
 src/print/mod.rs     |  2 ++
 src/print/svg.rs     | 12 +++++++-----
[2025-09-21T14:35:01] tokens used: 2,336

[2025-09-21T14:35:03] thinking

**Requesting more file content**
[2025-09-21T14:35:03] exec bash -lc "sed -n '160,320p' todolist/todolist-027-e2bedd3.tex" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T14:35:03] bash -lc "sed -n '160,320p' todolist/todolist-027-e2bedd3.tex" succeeded in 11ms:

[2025-09-21T14:35:03] tokens used: 3,941

[2025-09-21T14:35:14] thinking

**Preparing to replicate commit changes**
[2025-09-21T14:35:15] exec bash -lc ls in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:35:15] bash -lc ls succeeded in 19ms:
Cargo.lock
Cargo.toml
LICENSE
README.md
scripts
src
target
[2025-09-21T14:35:15] tokens used: 4,416

[2025-09-21T14:35:17] thinking

**Opening relevant source files**
[2025-09-21T14:35:17] exec bash -lc "sed -n '1,200p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:35:17] bash -lc "sed -n '1,200p' src/graph.rs" succeeded in 21ms:
use crate::settings::{BranchOrder, BranchSettings, Settings};
use crate::text;
use git2::{BranchType, Commit, Error, Oid, Repository};
use itertools::Itertools;
use std::collections::{HashMap, VecDeque};

/// Represents a git history graph.
pub struct GitGraph {
    pub repository: Repository,
    pub commits: Vec<CommitInfo>,
    pub indices: HashMap<Oid, usize>,
    pub branches: Vec<BranchInfo>,
}

impl GitGraph {
    pub fn new(path: &str, settings: &Settings) -> Result<Self, Error> {
        let repository = Repository::open(path)?;
        let mut walk = repository.revwalk()?;

        walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)?;
[2025-09-21T14:35:17] tokens used: 4,623

[2025-09-21T14:35:19] thinking

**Checking file consistency**
[2025-09-21T14:35:20] exec bash -lc "sed -n '200,400p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:35:20] bash -lc "sed -n '200,400p' src/graph.rs" succeeded in 20ms:
            }
        }
    }
}

/// Extracts branches from repository and merge summaries, assigns branches and branch traces to commits.
///
/// Algorithm:
/// * Find all actual branches (incl. target oid) and all extract branches from merge summaries (incl. parent oid)
/// * Sort all branches by persistence
/// * Iterating over all branches in persistence order, trace back over commit parents until a trace is already assigned
fn assign_branches(
    repository: &Repository,
    commits: &mut [CommitInfo],
    indices: &HashMap<Oid, usize>,
    settings: &Settings,
) -> Result<Vec<BranchInfo>, Error> {
    let mut branch_idx = 0;
    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
        .into_iter()
[2025-09-21T14:35:20] tokens used: 6,356

[2025-09-21T14:35:22] thinking

**Verifying repository consistency**
[2025-09-21T14:35:22] exec bash -lc "sed -n '1,200p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:35:22] bash -lc "sed -n '1,200p' src/main.rs" succeeded in 22ms:
use clap::{App, Arg};
use git_graph::graph::{CommitInfo, GitGraph};
use git_graph::print::svg::print_svg;
use git_graph::print::unicode::print_unicode;
use git_graph::settings::{BranchOrder, BranchSettings, Characters, MergePatterns, Settings};
use std::process;
use std::time::Instant;

fn main() {
    let matches = App::new("git-graph")
        .version(env!("CARGO_PKG_VERSION"))
        .about("Render git commit graphs as Unicode or SVG")
        .arg(
            Arg::with_name("svg")
                .long("svg")
                .help("Render SVG output instead of console output"),
        )
        .arg(
            Arg::with_name("compact")
                .long("compact")
[2025-09-21T14:35:22] tokens used: 8,213

[2025-09-21T14:35:24] thinking

**Reviewing print/unicode file for grid integration**
[2025-09-21T14:35:24] exec bash -lc "sed -n '1,200p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:35:24] bash -lc "sed -n '1,200p' src/print/unicode.rs" succeeded in 8ms:
use crate::{
    graph::{BranchInfo, CommitInfo, GitGraph},
    print::{colors, get_deviate_index},
    settings::{BranchSettings, Settings},
};
use term_painter::{Color as PainterColor, ToStyle};

const DOT: char = '●';
const CIRCLE: char = '○';
const HOR: char = '─';
const VER: char = '│';
const TURN_UP_RIGHT: char = '└';
const TURN_UP_LEFT: char = '┘';
const TURN_DOWN_RIGHT: char = '┌';
const TURN_DOWN_LEFT: char = '┐';
const T_UP: char = '┴';
const T_DOWN: char = '┬';
const T_RIGHT: char = '├';
const T_LEFT: char = '┤';
const CROSS: char = '┼';
[2025-09-21T14:35:24] tokens used: 9,745

[2025-09-21T14:35:27] thinking

**Continuing analysis**
[2025-09-21T14:35:27] exec bash -lc "sed -n '200,400p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:35:27] bash -lc "sed -n '200,400p' src/print/unicode.rs" succeeded in 14ms:
                None
            };

            if gcol < parent_gcol {
                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
                if gcol + 1 <= parent_gcol.saturating_sub(1) {
                    grid.hline(
                        insert_row,
                        gcol + 1,
                        parent_gcol - 1,
                        arrow,
                        Some(parent_color),
                    );
                }
                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
            } else {
                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
                if parent_gcol + 1 <= gcol.saturating_sub(1) {
                    grid.hline(
                        insert_row,
[2025-09-21T14:35:27] tokens used: 11,597

[2025-09-21T14:35:29] thinking

**Verifying new grid features**
[2025-09-21T14:35:29] exec bash -lc "sed -n '400,800p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:35:29] bash -lc "sed -n '400,800p' src/print/unicode.rs" succeeded in 19ms:
                ..Default::default()
            },
            HOR => LineBits {
                left: true,
                right: true,
                ..Default::default()
            },
            TURN_UP_RIGHT => LineBits {
                up: true,
                right: true,
                ..Default::default()
            },
            TURN_UP_LEFT => LineBits {
                up: true,
                left: true,
                ..Default::default()
            },
            TURN_DOWN_RIGHT => LineBits {
                down: true,
                right: true,
[2025-09-21T14:35:29] tokens used: 13,172

[2025-09-21T14:35:32] thinking

**Retrieving truncated code segment**
[2025-09-21T14:35:33] exec bash -lc "sed -n '800,1200p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:35:33] bash -lc "sed -n '800,1200p' src/print/unicode.rs" succeeded in 21ms:
        assert_eq!(merge_chars(DOT, HOR), DOT);
        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
    }

    #[test]
    fn index_map_accumulates_layers() {
        let inserts = vec![
            vec![Insert {
                parent_index: 0,
                to_col: 1,
                layer: 0,
            }],
            vec![
                Insert {
                    parent_index: 0,
                    to_col: 2,
                    layer: 0,
                },
                Insert {
                    parent_index: 0,
[2025-09-21T14:35:33] tokens used: 15,359

[2025-09-21T14:35:47] thinking

**Analyzing discrepancy in CharGrid implementation**

I’m noticing the current CharGrid design has only two arrays for chars and colors, but the summary describes a tri-array structure with glyph indexes and persistence. This suggests the file I have might be an older version before restructuring. I want to explore the truncated code sections and search for struct definitions like `Grid` to uncover if the new design is elsewhere or if I’ll need to reconstruct the code from the high-level summary alone. Let’s try to pinpoint code around lines 172-336 for persistence-related logic mentioned in the summary.
[2025-09-21T14:35:48] exec bash -lc 'rg "struct Grid" -n src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:35:48] bash -lc 'rg "struct Grid" -n src/print/unicode.rs' exited 1 in 10ms:

[2025-09-21T14:35:48] tokens used: 16,369

[2025-09-21T14:35:51] thinking

**Identifying naming mismatches**
[2025-09-21T14:35:51] exec bash -lc "sed -n '1,200p' src/settings.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:35:51] bash -lc "sed -n '1,200p' src/settings.rs" succeeded in 7ms:
use regex::Regex;

/// Character table for terminal rendering.
pub struct Characters {
    glyphs: Vec<char>,
}

impl Characters {
    /// Returns the predefined thin-line character table used by the Unicode renderer.
    pub fn thin() -> Self {
        // Index 0 must remain the space so that empty cells render correctly.
        const GLYPHS: &[char] = &[
            ' ', // Empty cell
            '●', // Filled node
            '○', // Merge node
            '─', // Horizontal line
            '│', // Vertical line
            '└', // Turn up-right
            '┘', // Turn up-left
            '┌', // Turn down-right
[2025-09-21T14:35:51] tokens used: 16,686

[2025-09-21T14:35:55] thinking

**Verifying usage of new Characters struct**
[2025-09-21T14:35:56] exec bash -lc 'rg "settings.characters" -n src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:35:56] bash -lc 'rg "settings.characters" -n src/print/unicode.rs' exited 1 in 14ms:

[2025-09-21T14:35:56] tokens used: 18,459

[2025-09-21T14:36:15] thinking

**Planning major print_unicode rewrite**

I'm mapping out a detailed multi-step plan to revamp the `print_unicode` module and related components, focusing on a new `Grid` structure with glyph, color, and persistence layers referencing `settings.characters`. I want to handle overlay rules that prioritize branches by persistence, ensure compatibility with existing code parts like `BranchInfo` and coloring, and break the work into manageable updates across several source files. Let's explore how to tackle this carefully!
[2025-09-21T14:36:16] exec bash -lc "sed -n '1,200p' src/print/mod.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:36:16] bash -lc "sed -n '1,200p' src/print/mod.rs" succeeded in 21ms:
pub mod colors;
pub mod svg;
pub mod unicode;

use crate::graph::GitGraph;

/// Determine the zero-based position of `child_index` within the visible children of
/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
/// when multiple edges leave the same parent column.
pub fn get_deviate_index(
    graph: &GitGraph,
    parent_index: usize,
    child_index: usize,
) -> Option<usize> {
    let parent = graph.commits.get(parent_index)?;
    let child_oid = graph.commits.get(child_index)?.oid;

    let mut ordinal = 0usize;
    for candidate_oid in &parent.children {
        if let Some(&idx) = graph.indices.get(candidate_oid) {
[2025-09-21T14:36:16] tokens used: 19,754

[2025-09-21T14:36:19] thinking

**Preparing to create implementation plan**
[2025-09-21T14:36:21] exec bash -lc 'echo "Plan: 1) Update graph.rs to ensure persistence is used for sorting etc (verify). 2) Rewrite print/unicode.rs to use new Grid with glyph indices/persistence logic referencing settings.characters. 3) Ensure settings.rs and main.rs align (characters usage). 4) Run cargo fmt/build/tests. 5) git status/add/commit."' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:36:21] bash -lc 'echo "Plan: 1) Update graph.rs to ensure persistence is used for sorting etc (verify). 2) Rewrite print/unicode.rs to use new Grid with glyph indices/persistence logic referencing settings.characters. 3) Ensure settings.rs and main.rs align (characters usage). 4) Run cargo fmt/build/tests. 5) git status/add/commit."' succeeded in 16ms:
Plan: 1) Update graph.rs to ensure persistence is used for sorting etc (verify). 2) Rewrite print/unicode.rs to use new Grid with glyph indices/persistence logic referencing settings.characters. 3) Ensure settings.rs and main.rs align (characters usage). 4) Run cargo fmt/build/tests. 5) git status/add/commit.
[2025-09-21T14:36:21] tokens used: 20,353

[2025-09-21T14:36:27] thinking

**Clarifying plan update expectations**
[2025-09-21T14:36:27] exec bash -lc 'rg "branch_persistence" -n src' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:36:27] bash -lc 'rg "branch_persistence" -n src' succeeded in 11ms:
src/graph.rs:273:                    let persistence = branch_persistence(name, &settings.branches.persistence);
src/graph.rs:313:                    branch_persistence(&branch_name, &settings.branches.persistence),
src/graph.rs:592:fn branch_persistence(name: &str, persistence: &[String]) -> u8 {
[2025-09-21T14:36:27] tokens used: 20,998

[2025-09-21T14:36:29] thinking

**Checking a function**
[2025-09-21T14:36:29] exec bash -lc "sed -n '560,640p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:36:29] bash -lc "sed -n '560,640p' src/graph.rs" succeeded in 18ms:
    for branch in branches {
        if let Some(column) = branch.visual.column {
            let offset = if branch.visual.order_group == 0 {
                0
            } else {
                group_offset[branch.visual.order_group - 1]
            };
            branch.visual.column = Some(column + offset);
        }
    }
}

/// Finds the index for a branch name from a slice of prefixes
fn branch_order(name: &str, order: &[String]) -> usize {
    order
        .iter()
        .position(|b| {
            name.starts_with(b) || (name.starts_with("origin/") && name[7..].starts_with(b))
        })
        .unwrap_or(order.len())
[2025-09-21T14:36:29] tokens used: 21,318

[2025-09-21T14:36:34] thinking

**Verifying graph.rs build and planning print/unicode.rs rewrite**
[2025-09-21T14:36:35] exec bash -lc 'rg "fn color_index_for_commit" -n src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:36:35] bash -lc 'rg "fn color_index_for_commit" -n src/print/unicode.rs' succeeded in 22ms:
602:fn color_index_for_commit(
[2025-09-21T14:36:35] tokens used: 21,912

[2025-09-21T14:36:38] thinking

**Reviewing code around lines 600-720**
[2025-09-21T14:36:38] exec bash -lc "sed -n '600,720p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:36:38] bash -lc "sed -n '600,720p' src/print/unicode.rs" succeeded in 21ms:
}

fn color_index_for_commit(
    graph: &GitGraph,
    branch_settings: &BranchSettings,
    info: &CommitInfo,
) -> usize {
    if let Some(branch) = primary_branch(graph, info) {
        let idx = branch.visual.color_group;
        if idx < branch_settings.color.len() {
            return idx;
        }
    }
    branch_settings.color.len()
}

fn color_index_for_branch(branch_settings: &BranchSettings, branch: &BranchInfo) -> usize {
    let idx = branch.visual.color_group;
    if idx < branch_settings.color.len() {
        idx
[2025-09-21T14:36:38] tokens used: 22,095

[2025-09-21T14:37:17] thinking

**Designing grid data restructure and overlay logic**

This chunk dives deep into revamping the grid structure from chars to glyph indexes, adding persistence to track branch priority, and carefully redefining overlay merging rules so merged glyphs combine line shapes while color respects the dominant branch’s persistence. I’m sketching new Grid methods like `set`, `set_opt`, and `overlay`, rethinking glyph constants aligned to settings, and planning how drawing functions adapt to the new triple data arrays for glyphs, colors, and persistence. There is a lot here on preserving existing merging behavior while syncing to the updated data model and branch-aware priority system. Let’s explore this carefully to implement the complex redraw logic properly!
[2025-09-21T14:37:18] exec bash -lc 'rg "fn primary_branch" -n src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:37:18] bash -lc 'rg "fn primary_branch" -n src/print/unicode.rs' succeeded in 26ms:
589:fn primary_branch<'graph>(
[2025-09-21T14:37:19] tokens used: 25,800
[2025-09-21T14:37:21] exec bash -lc "sed -n '560,620p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:37:21] bash -lc "sed -n '560,620p' src/print/unicode.rs" succeeded in 19ms:
    }

    inserts
}

fn index_map(len: usize, inserts: &[Vec<Insert>]) -> (Vec<usize>, Vec<usize>) {
    let mut rows = vec![0usize; len];
    let mut extras = vec![0usize; len];

    let mut offset = 0usize;
    for index in 0..len {
        rows[index] = index + offset;
        let extra_rows = inserts[index]
            .iter()
            .map(|insert| insert.layer)
            .max()
            .map(|max_layer| max_layer + 1)
            .unwrap_or(0);
        extras[index] = extra_rows;
        offset += extra_rows;
[2025-09-21T14:37:21] tokens used: 26,074

[2025-09-21T14:38:18] thinking

**Refactoring glyph rendering with persistence**

I’m working through a major update to use glyph indexes instead of chars in the grid, adding persistence handling for commits and edges to control overlay priority. I’ll redefine glyph constants, update merging logic via new `LineBits` methods, revise grid drawing functions (`vline`, `hline`, `overlay`) to accept persistence, and ensure colors and glyphs stay consistent while preserving node glyph priority. This also involves adjusting rendering lines to convert glyph indexes to chars based on settings and changing several method signatures to handle persistence alongside colors. It’s quite detailed, but this refactor should make line drawing and coloring more flexible and accurate!
**Planning stepwise grid and rendering updates**

I’m organizing a multi-step plan to rename and refactor constants and the `CharGrid` struct to `Grid`, updating methods to handle persistence and glyph indexes, and adapting all references accordingly. Since the file is large, I’ll approach it incrementally, starting with replacing char constants by glyph indexes, then swapping the struct and its methods, and finally adjusting functions like `print_graph` to pass necessary parameters. Using incremental patches should help keep the big rewrite manageable and ensure correctness.
[2025-09-21T14:38:28] codex
**Planning stepwise grid and rendering updates**

I’m organizing a multi-step plan to rename and refactor constants and the `CharGrid` struct to `Grid`, updating methods to handle persistence and glyph indexes, and adapting all references accordingly. Since the file is large, I’ll approach it incrementally, starting with replacing char constants by glyph indexes, then swapping the struct and its methods, and finally adjusting functions like `print_graph` to pass necessary parameters. Using incremental patches should help keep the big rewrite manageable and ensure correctness.
[2025-09-21T14:38:33] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -3,3 +3,3 @@
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
@@ -7,17 +7,18 @@
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
[2025-09-21T14:38:33] apply_patch(auto_approved=true) exited 0 in 37ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T14:38:33] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..fc4a4d67509865130323dec0f840b47c5845c600
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;

[2025-09-21T14:38:33] tokens used: 32,469
[2025-09-21T14:38:33] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..fc4a4d67509865130323dec0f840b47c5845c600
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;


[2025-09-21T14:39:00] thinking

**Redefining CharGrid to Grid structure with new fields and methods**
[2025-09-21T14:39:38] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -243,10 +243,11 @@
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
@@ -254,7 +255,8 @@
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
@@ -266,7 +268,22 @@
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
@@ -275,12 +292,10 @@
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
@@ -289,3 +304,3 @@
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
@@ -305,3 +320,6 @@
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
@@ -309,2 +327,3 @@
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
@@ -316,2 +335,3 @@
         color: Option<u8>,
+        persistence: u8,
     ) {
@@ -325,8 +345,6 @@
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
@@ -338,8 +356,6 @@
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
@@ -347,3 +363,3 @@
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
@@ -354,3 +370,3 @@
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
[2025-09-21T14:39:38] apply_patch(auto_approved=true) exited 0 in 48ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T14:39:38] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..588e016c8e20d670b403fa8ef076d08b87bf8f3c
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -240,22 +241,24 @@
     print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +266,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
+    }
+
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +318,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +333,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +343,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +354,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }

[2025-09-21T14:39:38] tokens used: 37,240
[2025-09-21T14:39:38] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..588e016c8e20d670b403fa8ef076d08b87bf8f3c
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -240,22 +241,24 @@
     print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +266,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
+    }
+
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +318,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +333,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +343,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +354,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }


[2025-09-21T14:39:42] thinking

**Updating references from CharGrid to Grid**
[2025-09-21T14:39:42] exec bash -lc 'rg "CharGrid" -n src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:39:43] bash -lc 'rg "CharGrid" -n src/print/unicode.rs' succeeded in 13ms:
81:    let mut grid = CharGrid::new(width, height);
670:    grid: &CharGrid,
[2025-09-21T14:39:43] tokens used: 39,578
[2025-09-21T14:39:43] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..588e016c8e20d670b403fa8ef076d08b87bf8f3c
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -240,22 +241,24 @@
     print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +266,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
+    }
+
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +318,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +333,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +343,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +354,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }


[2025-09-21T14:39:53] thinking

**Renaming to Grid**
[2025-09-21T14:39:54] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -80,3 +80,3 @@
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
[2025-09-21T14:39:54] apply_patch(auto_approved=true) exited 0 in 48ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T14:39:54] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..fc23c79c1011c45a93427e106b852d8af447bef5
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,7 +78,7 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
@@ -240,22 +241,24 @@
     print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +266,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
+    }
+
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +318,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +333,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +343,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +354,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }

[2025-09-21T14:39:54] tokens used: 39,888
[2025-09-21T14:39:54] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..fc23c79c1011c45a93427e106b852d8af447bef5
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,7 +78,7 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
@@ -240,22 +241,24 @@
     print_graph(&grid, &decorations, branch_settings, color_enabled)
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +266,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
+    }
+
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +318,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +333,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +343,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +354,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }


[2025-09-21T14:39:58] thinking

**Preparing to update print_graph arguments**
[2025-09-21T14:39:59] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -240,3 +240,9 @@
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
[2025-09-21T14:39:59] apply_patch(auto_approved=true) exited 0 in 34ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T14:39:59] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..200b4c3a7fe0ce28837a33cc8095256e2cce10aa
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,7 +78,7 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
@@ -237,25 +238,33 @@
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +272,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
+    }
+
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +324,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +339,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +349,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +360,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }

[2025-09-21T14:39:59] tokens used: 40,323
[2025-09-21T14:39:59] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..200b4c3a7fe0ce28837a33cc8095256e2cce10aa
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,7 +78,7 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
@@ -237,25 +238,33 @@
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +272,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
+    }
+
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +324,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +339,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +349,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +360,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }


[2025-09-21T14:40:05] thinking

**Updating print_graph and render_graph_line signatures**
[2025-09-21T14:40:10] tokens used: 41,503
[2025-09-21T14:40:10] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..200b4c3a7fe0ce28837a33cc8095256e2cce10aa
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,7 +78,7 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
@@ -237,25 +238,33 @@
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +272,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
+    }
+
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +324,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +339,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +349,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +360,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }


[2025-09-21T14:40:13] thinking

**Correcting working directory for patch**
[2025-09-21T14:40:16] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -675,5 +675,6 @@
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
@@ -682,5 +683,5 @@
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
@@ -763,4 +764,5 @@
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
@@ -768,3 +770,3 @@
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
@@ -777,3 +779,6 @@
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
[2025-09-21T14:40:16] apply_patch(auto_approved=true) exited 0 in 50ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T14:40:16] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..c13462cc38498e117928d79c94b5ace8dd734139
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,7 +78,7 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
@@ -237,25 +238,33 @@
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +272,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +324,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +339,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +349,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +360,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
@@ -650,16 +673,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +762,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +777,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),

[2025-09-21T14:40:16] tokens used: 42,868
[2025-09-21T14:40:16] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..c13462cc38498e117928d79c94b5ace8dd734139
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,7 +78,7 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
@@ -237,25 +238,33 @@
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +272,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +324,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +339,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +349,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +360,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
@@ -650,16 +673,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +762,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +777,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),


[2025-09-21T14:40:21] thinking

**Updating Arrow and grid references**
[2025-09-21T14:40:23] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -389,6 +389,6 @@
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
[2025-09-21T14:40:23] apply_patch(auto_approved=true) exited 0 in 41ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T14:40:23] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..4efd53f68ef38a8f2a59a8b655447a73d5530c2e
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,7 +78,7 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
@@ -237,25 +238,33 @@
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +272,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +324,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +339,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +349,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +360,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
@@ -364,10 +387,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -650,16 +673,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +762,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +777,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),

[2025-09-21T14:40:23] tokens used: 43,912
[2025-09-21T14:40:23] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..4efd53f68ef38a8f2a59a8b655447a73d5530c2e
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,7 +78,7 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
@@ -237,25 +238,33 @@
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +272,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +324,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +339,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +349,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +360,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
@@ -364,10 +387,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -650,16 +673,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +762,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +777,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),


[2025-09-21T14:40:34] thinking

**Updating LineBits for glyph indexes**
[2025-09-21T14:40:46] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -405,3 +405,3 @@
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
@@ -409,13 +409,13 @@
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
@@ -424,3 +424,3 @@
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
@@ -429,3 +429,3 @@
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
@@ -434,3 +434,3 @@
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
@@ -439,3 +439,3 @@
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
@@ -444,3 +444,3 @@
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
@@ -449,3 +449,3 @@
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
@@ -455,3 +455,3 @@
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
@@ -461,3 +461,3 @@
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
@@ -467,3 +467,3 @@
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
@@ -473,3 +473,3 @@
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
@@ -480,3 +480,3 @@
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
@@ -485,3 +485,3 @@
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
@@ -506,3 +506,3 @@
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
@@ -512,6 +512,6 @@
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
@@ -519,18 +519,18 @@
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
@@ -539,3 +539,3 @@
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
@@ -543,5 +543,5 @@
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
[2025-09-21T14:40:46] apply_patch(auto_approved=true) exited 0 in 46ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T14:40:46] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..ed107155848daf2526c08b527cc2d230384f980f
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,7 +78,7 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
@@ -237,25 +238,33 @@
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +272,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +324,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +339,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +349,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +360,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
@@ -364,10 +387,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +403,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +504,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -650,16 +673,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +762,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +777,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),

[2025-09-21T14:40:46] tokens used: 46,669
[2025-09-21T14:40:46] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..ed107155848daf2526c08b527cc2d230384f980f
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,7 +78,7 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
@@ -237,25 +238,33 @@
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +272,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +324,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +339,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +349,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +360,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
@@ -364,10 +387,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +403,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +504,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -650,16 +673,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +762,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +777,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),


[2025-09-21T14:40:53] thinking

**Updating test cases with new glyph constants**
[2025-09-21T14:40:55] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -820,5 +820,5 @@
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
@@ -826,5 +826,5 @@
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
[2025-09-21T14:40:55] apply_patch(auto_approved=true) exited 0 in 30ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T14:40:55] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..464ac4988b8558596fe24e2f0a4805f42a7869dd
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,7 +78,7 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
@@ -237,25 +238,33 @@
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +272,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +324,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +339,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +349,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +360,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
@@ -364,10 +387,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +403,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +504,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -650,16 +673,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +762,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +777,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +818,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]

[2025-09-21T14:40:55] tokens used: 49,127
[2025-09-21T14:40:55] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..464ac4988b8558596fe24e2f0a4805f42a7869dd
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,7 +78,7 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
@@ -237,25 +238,33 @@
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +272,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +324,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +339,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +349,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +360,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
@@ -364,10 +387,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +403,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +504,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -650,16 +673,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +762,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +777,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +818,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:41:00] thinking

**Updating drawing logic to new grid methods**
[2025-09-21T14:41:00] exec bash -lc 'rg "DOT" src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:41:00] bash -lc 'rg "DOT" src/print/unicode.rs' succeeded in 29ms:
const GLYPH_DOT: u8 = 1;
        let symbol = if commit.is_merge { CIRCLE } else { DOT };
            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
            GLYPH_DOT => LineBits {
                node: Some(GLYPH_DOT),
        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
[2025-09-21T14:41:00] tokens used: 49,611
[2025-09-21T14:41:00] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..464ac4988b8558596fe24e2f0a4805f42a7869dd
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,7 +78,7 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
@@ -237,25 +238,33 @@
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +272,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +324,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +339,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +349,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +360,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
@@ -364,10 +387,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +403,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +504,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -650,16 +673,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +762,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +777,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +818,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:41:04] thinking

**Updating glyph constants for symbols**
[2025-09-21T14:41:04] exec bash -lc 'rg "CIRCLE" src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:41:04] bash -lc 'rg "CIRCLE" src/print/unicode.rs' succeeded in 22ms:
const GLYPH_CIRCLE: u8 = 2;
        let symbol = if commit.is_merge { CIRCLE } else { DOT };
            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
            GLYPH_CIRCLE => LineBits {
                node: Some(GLYPH_CIRCLE),
        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
[2025-09-21T14:41:04] tokens used: 49,975
[2025-09-21T14:41:04] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..464ac4988b8558596fe24e2f0a4805f42a7869dd
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,7 +78,7 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
@@ -237,25 +238,33 @@
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +272,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +324,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +339,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +349,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +360,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
@@ -364,10 +387,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +403,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +504,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -650,16 +673,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +762,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +777,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +818,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:41:09] thinking

**Updating glyph constants and types**
[2025-09-21T14:41:09] exec bash -lc 'rg "TURN_" src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:41:09] bash -lc 'rg "TURN_" src/print/unicode.rs' succeeded in 16ms:
const GLYPH_TURN_UP_RIGHT: u8 = 5;
const GLYPH_TURN_UP_LEFT: u8 = 6;
const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
const GLYPH_TURN_DOWN_LEFT: u8 = 8;
                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
            GLYPH_TURN_UP_RIGHT => LineBits {
            GLYPH_TURN_UP_LEFT => LineBits {
            GLYPH_TURN_DOWN_RIGHT => LineBits {
            GLYPH_TURN_DOWN_LEFT => LineBits {
            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
[2025-09-21T14:41:09] tokens used: 50,449
[2025-09-21T14:41:09] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..464ac4988b8558596fe24e2f0a4805f42a7869dd
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,7 +78,7 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
@@ -237,25 +238,33 @@
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +272,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +324,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +339,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +349,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +360,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
@@ -364,10 +387,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +403,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +504,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -650,16 +673,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +762,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +777,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +818,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:41:17] thinking

**Updating overlay calls to new API**
[2025-09-21T14:41:17] exec bash -lc "sed -n '40,220p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:41:17] bash -lc "sed -n '40,220p' src/print/unicode.rs" succeeded in 38ms:

#[derive(Clone)]
struct LinePrefix {
    short_id: String,
    color: u8,
}

#[derive(Clone)]
struct LineSuffix {
    debug: Option<String>,
    branches: Vec<LineBranch>,
    summary: String,
}

#[derive(Clone)]
struct LineBranch {
    name: String,
    color: u8,
}

[2025-09-21T14:41:17] tokens used: 51,019
[2025-09-21T14:41:17] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..464ac4988b8558596fe24e2f0a4805f42a7869dd
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,7 +78,7 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
@@ -237,25 +238,33 @@
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +272,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +324,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +339,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +349,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +360,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
@@ -364,10 +387,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +403,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +504,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -650,16 +673,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +762,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +777,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +818,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:41:20] thinking

**Verifying overlay and hline usage**
[2025-09-21T14:41:20] exec bash -lc "sed -n '220,400p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:41:20] bash -lc "sed -n '220,400p' src/print/unicode.rs" succeeded in 34ms:
                        insert_row,
                        parent_gcol + 1,
                        gcol - 1,
                        arrow,
                        Some(parent_color),
                    );
                }
                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
            }

            if insert_row + 1 <= parent_row.saturating_sub(1) {
                grid.vline(
                    parent_gcol,
                    insert_row + 1,
                    parent_row - 1,
                    Some(parent_color),
                );
            }
        }
    }
[2025-09-21T14:41:20] tokens used: 52,675
[2025-09-21T14:41:20] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..464ac4988b8558596fe24e2f0a4805f42a7869dd
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,7 +78,7 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
@@ -237,25 +238,33 @@
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +272,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +324,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +339,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +349,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +360,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
@@ -364,10 +387,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +403,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +504,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -650,16 +673,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +762,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +777,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +818,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:41:35] thinking

**Updating grid drawing with persistence**

I’m planning to replace removed grid methods like `place_node` and `overlay` with the new `grid.set` method that requires a persistence value. To do this properly, I need to compute persistence for commits and edges using a new helper function, `persistence_for_commit`, and then update all relevant grid calls to include this persistence argument alongside colors. This will ensure the drawing reflects the intended visual persistence of commits and their connections.
[2025-09-21T14:41:43] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -87,3 +87,7 @@
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
@@ -91,3 +95,4 @@
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
@@ -170,2 +175,7 @@
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
@@ -174,3 +184,3 @@
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(gcol, row, parent_row, Some(parent_color), parent_persistence);
                 continue;
@@ -190,3 +200,9 @@
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
@@ -204,3 +220,9 @@
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
@@ -212,7 +234,20 @@
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
@@ -224,5 +259,12 @@
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
@@ -235,2 +277,3 @@
                     Some(parent_color),
+                    parent_persistence,
                 );
[2025-09-21T14:41:43] apply_patch(auto_approved=true) exited 0 in 44ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T14:41:43] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..1b83c60a5410c994168969ba2e821ecea589d51a
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,16 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(gcol, row, parent_row, Some(parent_color), parent_persistence);
                 continue;
             }
 
@@ -187,7 +198,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +218,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +232,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +257,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +275,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +315,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
+    }
+
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +367,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +382,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +392,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +403,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
@@ -364,10 +430,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +446,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +547,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -650,16 +716,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +805,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +820,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +861,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]

[2025-09-21T14:41:43] tokens used: 56,094
[2025-09-21T14:41:43] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..1b83c60a5410c994168969ba2e821ecea589d51a
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,16 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(gcol, row, parent_row, Some(parent_color), parent_persistence);
                 continue;
             }
 
@@ -187,7 +198,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +218,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +232,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +257,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +275,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +315,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
+    }
+
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +367,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +382,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +392,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +403,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
@@ -364,10 +430,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +446,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +547,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -650,16 +716,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +805,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +820,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +861,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:41:47] thinking

**Checking for remaining grid calls**
[2025-09-21T14:41:47] exec bash -lc "rg \"grid\\.overlay\" -n src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:41:47] bash -lc "rg \"grid\\.overlay\" -n src/print/unicode.rs" exited 1 in 10ms:

[2025-09-21T14:41:47] tokens used: 57,472
[2025-09-21T14:41:47] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..1b83c60a5410c994168969ba2e821ecea589d51a
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,16 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(gcol, row, parent_row, Some(parent_color), parent_persistence);
                 continue;
             }
 
@@ -187,7 +198,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +218,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +232,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +257,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +275,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +315,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
+    }
+
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +367,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +382,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +392,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +403,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
@@ -364,10 +430,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +446,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +547,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -650,16 +716,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +805,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +820,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +861,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:41:53] thinking

**Verifying all grid.hline calls**
[2025-09-21T14:41:53] exec bash -lc "rg \"grid\\.hline\" -n src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:41:53] bash -lc "rg \"grid\\.hline\" -n src/print/unicode.rs" succeeded in 32ms:
229:                    grid.hline(
254:                    grid.hline(
[2025-09-21T14:41:53] tokens used: 57,700
[2025-09-21T14:41:53] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..1b83c60a5410c994168969ba2e821ecea589d51a
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,16 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(gcol, row, parent_row, Some(parent_color), parent_persistence);
                 continue;
             }
 
@@ -187,7 +198,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +218,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +232,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +257,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +275,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +315,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
+    }
+
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +367,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +382,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +392,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +403,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
@@ -364,10 +430,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +446,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +547,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -650,16 +716,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +805,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +820,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +861,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:41:58] thinking

**Verifying function calls for new argument**
[2025-09-21T14:41:58] exec bash -lc "rg \"grid\\.vline\" -n src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:41:58] bash -lc "rg \"grid\\.vline\" -n src/print/unicode.rs" succeeded in 36ms:
185:                grid.vline(gcol, row, parent_row, Some(parent_color), parent_persistence);
201:                grid.vline(
273:                grid.vline(
[2025-09-21T14:41:58] tokens used: 57,942
[2025-09-21T14:41:58] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..1b83c60a5410c994168969ba2e821ecea589d51a
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,16 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(gcol, row, parent_row, Some(parent_color), parent_persistence);
                 continue;
             }
 
@@ -187,7 +198,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +218,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +232,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +257,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +275,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +315,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
+    }
+
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +367,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +382,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +392,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +403,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
@@ -364,10 +430,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +446,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +547,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -650,16 +716,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +805,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +820,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +861,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:42:05] thinking

**Implementing persistence_for_commit helper**
[2025-09-21T14:42:09] tokens used: 58,486
[2025-09-21T14:42:09] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..1b83c60a5410c994168969ba2e821ecea589d51a
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,16 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(gcol, row, parent_row, Some(parent_color), parent_persistence);
                 continue;
             }
 
@@ -187,7 +198,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +218,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +232,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +257,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +275,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +315,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
+    }
+
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +367,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +382,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +392,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +403,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
@@ -364,10 +430,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +446,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +547,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -650,16 +716,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +805,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +820,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +861,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:42:12] thinking

**Remembering to include workdir**
[2025-09-21T14:42:14] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -667,2 +667,8 @@
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
[2025-09-21T14:42:14] apply_patch(auto_approved=true) exited 0 in 51ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T14:42:14] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..882c95da2766b3e554b3d61a778ec5e4eb6afd2a
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,16 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(gcol, row, parent_row, Some(parent_color), parent_persistence);
                 continue;
             }
 
@@ -187,7 +198,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +218,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +232,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +257,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +275,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +315,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
+    }
+
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +367,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +382,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +392,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +403,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
@@ -364,10 +430,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +446,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +547,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +665,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +722,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +811,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +826,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +867,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]

[2025-09-21T14:42:14] tokens used: 59,066
[2025-09-21T14:42:14] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..882c95da2766b3e554b3d61a778ec5e4eb6afd2a
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,16 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(gcol, row, parent_row, Some(parent_color), parent_persistence);
                 continue;
             }
 
@@ -187,7 +198,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +218,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +232,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +257,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +275,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +315,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
+    }
+
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +367,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +382,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +392,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +403,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
@@ -364,10 +430,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +446,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +547,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +665,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +722,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +811,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +826,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +867,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:42:19] thinking

**Searching for character constants**
[2025-09-21T14:42:19] exec bash -lc 'rg "HOR" src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:42:19] bash -lc 'rg "HOR" src/print/unicode.rs' succeeded in 9ms:
const GLYPH_HOR: u8 = 3;
            self.set(row, col, GLYPH_HOR, color, persistence);
            GLYPH_HOR => LineBits {
            (false, false, true, true) => GLYPH_HOR,
            (false, false, true, false) => GLYPH_HOR,
            (false, false, false, true) => GLYPH_HOR,
        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
[2025-09-21T14:42:19] tokens used: 59,497
[2025-09-21T14:42:19] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..882c95da2766b3e554b3d61a778ec5e4eb6afd2a
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,16 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(gcol, row, parent_row, Some(parent_color), parent_persistence);
                 continue;
             }
 
@@ -187,7 +198,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +218,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +232,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +257,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +275,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +315,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
+    }
+
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +367,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +382,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +392,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,23 +403,21 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
@@ -364,10 +430,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +446,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +547,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +665,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +722,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +811,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +826,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +867,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:42:34] thinking

**Implementing Grid get_tuple method**
[2025-09-21T14:42:36] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -423,2 +423,15 @@
     }
+
+    #[allow(dead_code)]
+    fn get_tuple(&self, row: usize, col: usize) -> (u8, u8, u8) {
+        if row >= self.height || col >= self.width {
+            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
+        }
+        let idx = self.index(row, col);
+        (
+            self.glyphs[idx],
+            self.colors[idx],
+            self.persistence[idx],
+        )
+    }
 }
[2025-09-21T14:42:36] apply_patch(auto_approved=true) exited 0 in 45ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T14:42:36] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..c336fb3d9117a1c76c8bcd5d7b89d0ae1eab6ce5
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,16 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(gcol, row, parent_row, Some(parent_color), parent_persistence);
                 continue;
             }
 
@@ -187,7 +198,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +218,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +232,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +257,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +275,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +315,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +367,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +382,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +392,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,26 +403,37 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
+
+    #[allow(dead_code)]
+    fn get_tuple(&self, row: usize, col: usize) -> (u8, u8, u8) {
+        if row >= self.height || col >= self.width {
+            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
+        }
+        let idx = self.index(row, col);
+        (
+            self.glyphs[idx],
+            self.colors[idx],
+            self.persistence[idx],
+        )
+    }
 }
 
 #[derive(Clone, Copy)]
@@ -364,10 +443,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +459,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +560,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +678,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +735,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +824,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +839,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +880,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]

[2025-09-21T14:42:36] tokens used: 60,753
[2025-09-21T14:42:36] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..c336fb3d9117a1c76c8bcd5d7b89d0ae1eab6ce5
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,16 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(gcol, row, parent_row, Some(parent_color), parent_persistence);
                 continue;
             }
 
@@ -187,7 +198,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +218,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +232,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +257,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +275,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +315,43 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>, persistence: u8) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +367,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +382,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +392,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,26 +403,37 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
+
+    #[allow(dead_code)]
+    fn get_tuple(&self, row: usize, col: usize) -> (u8, u8, u8) {
+        if row >= self.height || col >= self.width {
+            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
+        }
+        let idx = self.index(row, col);
+        (
+            self.glyphs[idx],
+            self.colors[idx],
+            self.persistence[idx],
+        )
+    }
 }
 
 #[derive(Clone, Copy)]
@@ -364,10 +443,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +459,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +560,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +678,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +735,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +824,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +839,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +880,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:42:42] thinking

**Refining space character usage and formatting**
[2025-09-21T14:42:43] exec bash -lc 'cargo fmt' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:42:43] bash -lc 'cargo fmt' succeeded in 102ms:

[2025-09-21T14:42:43] tokens used: 61,397
[2025-09-21T14:42:43] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..d1c7a388baae1e153d8ced84c3b7be9876f9c549
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,22 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    parent_row,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 continue;
             }
 
@@ -187,7 +204,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +224,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +238,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +263,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +281,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +321,50 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(
+        &mut self,
+        col: usize,
+        from_row: usize,
+        to_row: usize,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +380,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +395,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +405,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,26 +416,33 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
+
+    #[allow(dead_code)]
+    fn get_tuple(&self, row: usize, col: usize) -> (u8, u8, u8) {
+        if row >= self.height || col >= self.width {
+            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
+        }
+        let idx = self.index(row, col);
+        (self.glyphs[idx], self.colors[idx], self.persistence[idx])
+    }
 }
 
 #[derive(Clone, Copy)]
@@ -364,10 +452,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +468,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +569,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +687,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +744,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +833,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +848,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +889,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:42:48] thinking

**Deciding between build and test commands**
[2025-09-21T14:42:49] exec bash -lc 'cargo test' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:42:59] bash -lc 'cargo test' exited -1 in 0ms:
    Updating crates.io index
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
error: failed to get `clap` as a dependency of package `git-graph v0.1.0 (/Users/jqwang/104-CommitLens-codex/.workspace/rust-project)`

Caused by:
  download of config.json failed

Caused by:
  failed to download from `https://index.crates.io/config.json`

Caused by:
  [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
[2025-09-21T14:42:59] tokens used: 61,598
[2025-09-21T14:42:59] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..d1c7a388baae1e153d8ced84c3b7be9876f9c549
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,22 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    parent_row,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 continue;
             }
 
@@ -187,7 +204,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +224,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +238,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +263,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +281,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +321,50 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(
+        &mut self,
+        col: usize,
+        from_row: usize,
+        to_row: usize,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +380,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +395,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +405,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,26 +416,33 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
+
+    #[allow(dead_code)]
+    fn get_tuple(&self, row: usize, col: usize) -> (u8, u8, u8) {
+        if row >= self.height || col >= self.width {
+            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
+        }
+        let idx = self.index(row, col);
+        (self.glyphs[idx], self.colors[idx], self.persistence[idx])
+    }
 }
 
 #[derive(Clone, Copy)]
@@ -364,10 +452,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +468,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +569,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +687,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +744,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +833,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +848,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +889,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:43:06] thinking

**Handling network restriction on tests**
[2025-09-21T14:43:07] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:43:07] bash -lc 'git status -sb' succeeded in 53ms:
## main
 M src/graph.rs
 M src/main.rs
 M src/print/unicode.rs
 M src/settings.rs
[2025-09-21T14:43:07] tokens used: 62,065
[2025-09-21T14:43:07] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..d1c7a388baae1e153d8ced84c3b7be9876f9c549
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,22 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    parent_row,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 continue;
             }
 
@@ -187,7 +204,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +224,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +238,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +263,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +281,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +321,50 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(
+        &mut self,
+        col: usize,
+        from_row: usize,
+        to_row: usize,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +380,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +395,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +405,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,26 +416,33 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
+
+    #[allow(dead_code)]
+    fn get_tuple(&self, row: usize, col: usize) -> (u8, u8, u8) {
+        if row >= self.height || col >= self.width {
+            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
+        }
+        let idx = self.index(row, col);
+        (self.glyphs[idx], self.colors[idx], self.persistence[idx])
+    }
 }
 
 #[derive(Clone, Copy)]
@@ -364,10 +452,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +468,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +569,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +687,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +744,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +833,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +848,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +889,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:43:17] thinking

**Verifying unstaged file changes**
[2025-09-21T14:43:17] exec bash -lc 'git diff src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:43:17] bash -lc 'git diff src/print/unicode.rs' succeeded in 24ms:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1d..d1c7a38 100644
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
[2025-09-21T14:43:17] tokens used: 62,597
[2025-09-21T14:43:17] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..d1c7a388baae1e153d8ced84c3b7be9876f9c549
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,22 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    parent_row,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 continue;
             }
 
@@ -187,7 +204,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +224,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +238,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +263,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +281,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +321,50 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(
+        &mut self,
+        col: usize,
+        from_row: usize,
+        to_row: usize,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +380,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +395,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +405,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,26 +416,33 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
+
+    #[allow(dead_code)]
+    fn get_tuple(&self, row: usize, col: usize) -> (u8, u8, u8) {
+        if row >= self.height || col >= self.width {
+            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
+        }
+        let idx = self.index(row, col);
+        (self.glyphs[idx], self.colors[idx], self.persistence[idx])
+    }
 }
 
 #[derive(Clone, Copy)]
@@ -364,10 +452,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +468,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +569,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +687,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +744,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +833,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +848,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +889,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:43:32] thinking

**Reviewing code changes and build constraints**

I'm verifying that all relevant changes were made, especially around grid handling, color persistence, and rendering updates. I notice some network issues prevent running tests, so I'll consider offline checks and plan to confirm file diffs before staging and committing.
[2025-09-21T14:43:33] exec bash -lc 'git diff src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:43:33] bash -lc 'git diff src/main.rs' succeeded in 45ms:
diff --git a/src/main.rs b/src/main.rs
index 49472bf..4a18ad0 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -2,7 +2,7 @@ use clap::{App, Arg};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
-use git_graph::settings::{BranchOrder, BranchSettings, MergePatterns, Settings};
+use git_graph::settings::{BranchOrder, BranchSettings, Characters, MergePatterns, Settings};
 use std::process;
 use std::time::Instant;
 
@@ -51,6 +51,7 @@ fn main() {
         branch_order: BranchOrder::ShortestFirst(true),
         branches: BranchSettings::git_flow(),
         merge_patterns: MergePatterns::default(),
+        characters: Characters::thin(),
     };
 
[2025-09-21T14:43:33] tokens used: 66,359
[2025-09-21T14:43:33] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..d1c7a388baae1e153d8ced84c3b7be9876f9c549
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,22 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    parent_row,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 continue;
             }
 
@@ -187,7 +204,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +224,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +238,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +263,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +281,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +321,50 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(
+        &mut self,
+        col: usize,
+        from_row: usize,
+        to_row: usize,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +380,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +395,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +405,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,26 +416,33 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
+
+    #[allow(dead_code)]
+    fn get_tuple(&self, row: usize, col: usize) -> (u8, u8, u8) {
+        if row >= self.height || col >= self.width {
+            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
+        }
+        let idx = self.index(row, col);
+        (self.glyphs[idx], self.colors[idx], self.persistence[idx])
+    }
 }
 
 #[derive(Clone, Copy)]
@@ -364,10 +452,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +468,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +569,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +687,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +744,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +833,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +848,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +889,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:43:39] thinking

**Reviewing recent code changes**
[2025-09-21T14:43:39] exec bash -lc 'git diff src/settings.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:43:39] bash -lc 'git diff src/settings.rs' succeeded in 17ms:
diff --git a/src/settings.rs b/src/settings.rs
index aeb76fd..ee3af71 100644
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -1,5 +1,44 @@
 use regex::Regex;
 
+/// Character table for terminal rendering.
+pub struct Characters {
+    glyphs: Vec<char>,
+}
+
+impl Characters {
+    /// Returns the predefined thin-line character table used by the Unicode renderer.
+    pub fn thin() -> Self {
+        // Index 0 must remain the space so that empty cells render correctly.
+        const GLYPHS: &[char] = &[
+            ' ', // Empty cell
+            '●', // Filled node
+            '○', // Merge node
[2025-09-21T14:43:39] tokens used: 66,744
[2025-09-21T14:43:39] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..d1c7a388baae1e153d8ced84c3b7be9876f9c549
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,22 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    parent_row,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 continue;
             }
 
@@ -187,7 +204,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +224,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +238,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +263,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +281,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +321,50 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(
+        &mut self,
+        col: usize,
+        from_row: usize,
+        to_row: usize,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +380,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +395,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +405,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,26 +416,33 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
+
+    #[allow(dead_code)]
+    fn get_tuple(&self, row: usize, col: usize) -> (u8, u8, u8) {
+        if row >= self.height || col >= self.width {
+            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
+        }
+        let idx = self.index(row, col);
+        (self.glyphs[idx], self.colors[idx], self.persistence[idx])
+    }
 }
 
 #[derive(Clone, Copy)]
@@ -364,10 +452,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +468,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +569,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +687,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +744,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +833,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +848,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +889,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:43:56] thinking

**Verifying commit changes**
[2025-09-21T14:43:57] exec bash -lc 'git diff src/graph.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:43:57] bash -lc 'git diff src/graph.rs' succeeded in 19ms:
diff --git a/src/graph.rs b/src/graph.rs
index 2227385..c19e228 100644
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -143,6 +143,7 @@ pub struct BranchInfo {
     pub visual: BranchVis,
     pub deleted: bool,
     pub range: (Option<usize>, Option<usize>),
+    pub persistence: u8,
 }
 impl BranchInfo {
     fn new(
@@ -153,6 +154,7 @@ impl BranchInfo {
         visual: BranchVis,
         deleted: bool,
         end_index: Option<usize>,
+        persistence: u8,
     ) -> Self {
         BranchInfo {
             target,
[2025-09-21T14:43:57] tokens used: 67,507
[2025-09-21T14:43:57] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..d1c7a388baae1e153d8ced84c3b7be9876f9c549
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,22 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    parent_row,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 continue;
             }
 
@@ -187,7 +204,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +224,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +238,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +263,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +281,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +321,50 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(
+        &mut self,
+        col: usize,
+        from_row: usize,
+        to_row: usize,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +380,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +395,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +405,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,26 +416,33 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
+
+    #[allow(dead_code)]
+    fn get_tuple(&self, row: usize, col: usize) -> (u8, u8, u8) {
+        if row >= self.height || col >= self.width {
+            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
+        }
+        let idx = self.index(row, col);
+        (self.glyphs[idx], self.colors[idx], self.persistence[idx])
+    }
 }
 
 #[derive(Clone, Copy)]
@@ -364,10 +452,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +468,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +569,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +687,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +744,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +833,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +848,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +889,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:44:04] thinking

**Preparing to stage and commit changes**

[2025-09-21T14:44:04] thinking

**Staging changes after formatting**
[2025-09-21T14:44:04] exec bash -lc 'git add -A' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:44:04] bash -lc 'git add -A' succeeded in 21ms:

[2025-09-21T14:44:04] tokens used: 68,594
[2025-09-21T14:44:04] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..d1c7a388baae1e153d8ced84c3b7be9876f9c549
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,22 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    parent_row,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 continue;
             }
 
@@ -187,7 +204,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +224,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +238,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +263,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +281,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +321,50 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(
+        &mut self,
+        col: usize,
+        from_row: usize,
+        to_row: usize,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +380,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +395,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +405,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,26 +416,33 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
+
+    #[allow(dead_code)]
+    fn get_tuple(&self, row: usize, col: usize) -> (u8, u8, u8) {
+        if row >= self.height || col >= self.width {
+            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
+        }
+        let idx = self.index(row, col);
+        (self.glyphs[idx], self.colors[idx], self.persistence[idx])
+    }
 }
 
 #[derive(Clone, Copy)]
@@ -364,10 +452,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +468,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +569,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +687,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +744,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +833,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +848,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +889,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:44:09] thinking

**Checking status**
[2025-09-21T14:44:09] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:44:09] bash -lc 'git status -sb' succeeded in 44ms:
## main
M  src/graph.rs
M  src/main.rs
M  src/print/unicode.rs
M  src/settings.rs
[2025-09-21T14:44:09] tokens used: 68,775
[2025-09-21T14:44:09] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..d1c7a388baae1e153d8ced84c3b7be9876f9c549
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,22 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    parent_row,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 continue;
             }
 
@@ -187,7 +204,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +224,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +238,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +263,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +281,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +321,50 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(
+        &mut self,
+        col: usize,
+        from_row: usize,
+        to_row: usize,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +380,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +395,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +405,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,26 +416,33 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
+
+    #[allow(dead_code)]
+    fn get_tuple(&self, row: usize, col: usize) -> (u8, u8, u8) {
+        if row >= self.height || col >= self.width {
+            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
+        }
+        let idx = self.index(row, col);
+        (self.glyphs[idx], self.colors[idx], self.persistence[idx])
+    }
 }
 
 #[derive(Clone, Copy)]
@@ -364,10 +452,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +468,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +569,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +687,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +744,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +833,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +848,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +889,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:44:15] thinking

**Committing changes**
[2025-09-21T14:44:15] exec bash -lc 'git commit -m "027-e2bedd3：复现提交代码内容。"' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:44:15] bash -lc 'git commit -m "027-e2bedd3：复现提交代码内容。"' succeeded in 62ms:
[main 7a7a830] 027-e2bedd3：复现提交代码内容。
 4 files changed, 273 insertions(+), 119 deletions(-)
[2025-09-21T14:44:15] tokens used: 68,956
[2025-09-21T14:44:15] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..d1c7a388baae1e153d8ced84c3b7be9876f9c549
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,22 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    parent_row,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 continue;
             }
 
@@ -187,7 +204,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +224,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +238,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +263,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +281,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +321,50 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(
+        &mut self,
+        col: usize,
+        from_row: usize,
+        to_row: usize,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +380,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +395,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +405,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,26 +416,33 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
+
+    #[allow(dead_code)]
+    fn get_tuple(&self, row: usize, col: usize) -> (u8, u8, u8) {
+        if row >= self.height || col >= self.width {
+            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
+        }
+        let idx = self.index(row, col);
+        (self.glyphs[idx], self.colors[idx], self.persistence[idx])
+    }
 }
 
 #[derive(Clone, Copy)]
@@ -364,10 +452,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +468,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +569,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +687,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +744,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +833,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +848,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +889,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:44:19] thinking

**Verifying clean status**
[2025-09-21T14:44:19] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:44:19] bash -lc 'git status -sb' succeeded in 27ms:
## main
[2025-09-21T14:44:19] tokens used: 69,264
[2025-09-21T14:44:19] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..d1c7a388baae1e153d8ced84c3b7be9876f9c549
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,22 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    parent_row,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 continue;
             }
 
@@ -187,7 +204,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +224,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +238,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +263,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +281,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +321,50 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(
+        &mut self,
+        col: usize,
+        from_row: usize,
+        to_row: usize,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +380,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +395,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +405,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,26 +416,33 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
+
+    #[allow(dead_code)]
+    fn get_tuple(&self, row: usize, col: usize) -> (u8, u8, u8) {
+        if row >= self.height || col >= self.width {
+            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
+        }
+        let idx = self.index(row, col);
+        (self.glyphs[idx], self.colors[idx], self.persistence[idx])
+    }
 }
 
 #[derive(Clone, Copy)]
@@ -364,10 +452,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +468,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +569,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +687,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +744,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +833,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +848,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +889,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:44:28] thinking

**Summarizing modifications with file references**

I’m preparing the final message to summarize the key code changes, especially the major restructure in `src/print/unicode.rs`, and I’ll include approximate line numbers for the references by using line-number tools like `nl`. I also plan to mention the test failures caused by network issues along with any important assumptions made during the work.
[2025-09-21T14:44:29] exec bash -lc "nl -ba src/print/unicode.rs | sed -n '70,220p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:44:29] bash -lc "nl -ba src/print/unicode.rs | sed -n '70,220p'" succeeded in 19ms:
    70	    let (row_map, extras) = index_map(graph.commits.len(), &inserts);
    71	    let total_extra: usize = extras.iter().sum();
    72	    let height = graph.commits.len() + total_extra;
    73	    let max_column = graph
    74	        .commits
    75	        .iter()
    76	        .filter_map(|commit| commit_column(graph, commit))
    77	        .max()
    78	        .unwrap_or(0);
    79	    let width = max_column * 2 + 1;
    80	
    81	    let mut grid = Grid::new(width, height);
    82	    let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
    83	
    84	    for (index, commit) in graph.commits.iter().enumerate() {
    85	        let row = row_map[index];
    86	        let column = commit_column(graph, commit).unwrap_or(0);
    87	        let gcol = column * 2;
    88	        let symbol = if commit.is_merge {
    89	            GLYPH_CIRCLE
[2025-09-21T14:44:29] tokens used: 69,678
[2025-09-21T14:44:29] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..d1c7a388baae1e153d8ced84c3b7be9876f9c549
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,22 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    parent_row,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 continue;
             }
 
@@ -187,7 +204,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +224,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +238,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +263,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +281,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +321,50 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(
+        &mut self,
+        col: usize,
+        from_row: usize,
+        to_row: usize,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +380,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +395,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +405,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,26 +416,33 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
+
+    #[allow(dead_code)]
+    fn get_tuple(&self, row: usize, col: usize) -> (u8, u8, u8) {
+        if row >= self.height || col >= self.width {
+            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
+        }
+        let idx = self.index(row, col);
+        (self.glyphs[idx], self.colors[idx], self.persistence[idx])
+    }
 }
 
 #[derive(Clone, Copy)]
@@ -364,10 +452,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +468,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +569,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +687,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +744,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +833,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +848,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +889,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:44:33] thinking

**Reviewing grid structure**
[2025-09-21T14:44:33] exec bash -lc "nl -ba src/print/unicode.rs | sed -n '220,400p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:44:33] bash -lc "nl -ba src/print/unicode.rs | sed -n '220,400p'" succeeded in 33ms:
   220	                    Some(Arrow::Left)
   221	                }
   222	            } else {
   223	                None
   224	            };
   225	
   226	            if gcol < parent_gcol {
   227	                grid.set(
   228	                    insert_row,
   229	                    gcol,
   230	                    GLYPH_TURN_UP_RIGHT,
   231	                    Some(parent_color),
   232	                    parent_persistence,
   233	                );
   234	                if gcol + 1 <= parent_gcol.saturating_sub(1) {
   235	                    grid.hline(
   236	                        insert_row,
   237	                        gcol + 1,
   238	                        parent_gcol - 1,
   239	                        arrow,
[2025-09-21T14:44:33] tokens used: 71,741
[2025-09-21T14:44:33] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..d1c7a388baae1e153d8ced84c3b7be9876f9c549
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,22 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    parent_row,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 continue;
             }
 
@@ -187,7 +204,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +224,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +238,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +263,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +281,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +321,50 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(
+        &mut self,
+        col: usize,
+        from_row: usize,
+        to_row: usize,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +380,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +395,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +405,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,26 +416,33 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
+
+    #[allow(dead_code)]
+    fn get_tuple(&self, row: usize, col: usize) -> (u8, u8, u8) {
+        if row >= self.height || col >= self.width {
+            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
+        }
+        let idx = self.index(row, col);
+        (self.glyphs[idx], self.colors[idx], self.persistence[idx])
+    }
 }
 
 #[derive(Clone, Copy)]
@@ -364,10 +452,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +468,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +569,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +687,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +744,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +833,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +848,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +889,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:44:45] thinking

**Continuing to explore get_tuple**
[2025-09-21T14:44:45] exec bash -lc "nl -ba src/print/unicode.rs | sed -n '400,520p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:44:45] bash -lc "nl -ba src/print/unicode.rs | sed -n '400,520p'" succeeded in 26ms:
   400	        if row >= self.height {
   401	            return;
   402	        }
   403	        if start_col > end_col {
   404	            return;
   405	        }
   406	
   407	        for col in start_col..=end_col {
   408	            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
   409	                continue;
   410	            }
   411	            self.set(row, col, GLYPH_HOR, color, persistence);
   412	        }
   413	
   414	        if let Some(arrow) = arrow {
   415	            let arrow_col = match arrow {
   416	                Arrow::Right => end_col,
   417	                Arrow::Left => start_col,
   418	            };
   419	            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
[2025-09-21T14:44:45] tokens used: 73,940
[2025-09-21T14:44:45] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..d1c7a388baae1e153d8ced84c3b7be9876f9c549
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,22 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    parent_row,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 continue;
             }
 
@@ -187,7 +204,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +224,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +238,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +263,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +281,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +321,50 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(
+        &mut self,
+        col: usize,
+        from_row: usize,
+        to_row: usize,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +380,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +395,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +405,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,26 +416,33 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
+
+    #[allow(dead_code)]
+    fn get_tuple(&self, row: usize, col: usize) -> (u8, u8, u8) {
+        if row >= self.height || col >= self.width {
+            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
+        }
+        let idx = self.index(row, col);
+        (self.glyphs[idx], self.colors[idx], self.persistence[idx])
+    }
 }
 
 #[derive(Clone, Copy)]
@@ -364,10 +452,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +468,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +569,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +687,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +744,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +833,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +848,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +889,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:44:50] thinking

**Preparing file references for summary**
[2025-09-21T14:44:50] exec bash -lc "nl -ba src/settings.rs | sed -n '1,160p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:44:50] bash -lc "nl -ba src/settings.rs | sed -n '1,160p'" succeeded in 20ms:
     1	use regex::Regex;
     2	
     3	/// Character table for terminal rendering.
     4	pub struct Characters {
     5	    glyphs: Vec<char>,
     6	}
     7	
     8	impl Characters {
     9	    /// Returns the predefined thin-line character table used by the Unicode renderer.
    10	    pub fn thin() -> Self {
    11	        // Index 0 must remain the space so that empty cells render correctly.
    12	        const GLYPHS: &[char] = &[
    13	            ' ', // Empty cell
    14	            '●', // Filled node
    15	            '○', // Merge node
    16	            '─', // Horizontal line
    17	            '│', // Vertical line
    18	            '└', // Turn up-right
    19	            '┘', // Turn up-left
    20	            '┌', // Turn down-right
[2025-09-21T14:44:50] tokens used: 75,572
[2025-09-21T14:44:50] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..d1c7a388baae1e153d8ced84c3b7be9876f9c549
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,22 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    parent_row,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 continue;
             }
 
@@ -187,7 +204,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +224,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +238,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +263,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +281,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +321,50 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(
+        &mut self,
+        col: usize,
+        from_row: usize,
+        to_row: usize,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +380,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +395,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +405,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,26 +416,33 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
+
+    #[allow(dead_code)]
+    fn get_tuple(&self, row: usize, col: usize) -> (u8, u8, u8) {
+        if row >= self.height || col >= self.width {
+            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
+        }
+        let idx = self.index(row, col);
+        (self.glyphs[idx], self.colors[idx], self.persistence[idx])
+    }
 }
 
 #[derive(Clone, Copy)]
@@ -364,10 +452,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +468,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +569,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +687,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +744,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +833,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +848,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +889,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:44:55] thinking

**Preparing line number details for src/main.rs**
[2025-09-21T14:44:56] exec bash -lc "nl -ba src/main.rs | sed -n '1,160p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:44:56] bash -lc "nl -ba src/main.rs | sed -n '1,160p'" succeeded in 14ms:
     1	use clap::{App, Arg};
     2	use git_graph::graph::{CommitInfo, GitGraph};
     3	use git_graph::print::svg::print_svg;
     4	use git_graph::print::unicode::print_unicode;
     5	use git_graph::settings::{BranchOrder, BranchSettings, Characters, MergePatterns, Settings};
     6	use std::process;
     7	use std::time::Instant;
     8	
     9	fn main() {
    10	    let matches = App::new("git-graph")
    11	        .version(env!("CARGO_PKG_VERSION"))
    12	        .about("Render git commit graphs as Unicode or SVG")
    13	        .arg(
    14	            Arg::with_name("svg")
    15	                .long("svg")
    16	                .help("Render SVG output instead of console output"),
    17	        )
    18	        .arg(
    19	            Arg::with_name("compact")
    20	                .long("compact")
[2025-09-21T14:44:56] tokens used: 77,748
[2025-09-21T14:44:56] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..d1c7a388baae1e153d8ced84c3b7be9876f9c549
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,22 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    parent_row,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 continue;
             }
 
@@ -187,7 +204,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +224,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +238,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +263,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +281,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +321,50 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(
+        &mut self,
+        col: usize,
+        from_row: usize,
+        to_row: usize,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +380,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +395,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +405,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,26 +416,33 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
+
+    #[allow(dead_code)]
+    fn get_tuple(&self, row: usize, col: usize) -> (u8, u8, u8) {
+        if row >= self.height || col >= self.width {
+            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
+        }
+        let idx = self.index(row, col);
+        (self.glyphs[idx], self.colors[idx], self.persistence[idx])
+    }
 }
 
 #[derive(Clone, Copy)]
@@ -364,10 +452,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +468,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +569,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +687,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +744,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +833,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +848,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +889,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:45:02] thinking

**Checking line numbers in src/graph.rs**
[2025-09-21T14:45:03] exec bash -lc "nl -ba src/graph.rs | sed -n '120,220p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:45:03] bash -lc "nl -ba src/graph.rs | sed -n '120,220p'" succeeded in 12ms:
   120	    pub branches: Vec<usize>,
   121	    pub branch_trace: Option<usize>,
   122	}
   123	
   124	impl CommitInfo {
   125	    fn new(commit: &Commit) -> Self {
   126	        CommitInfo {
   127	            oid: commit.id(),
   128	            is_merge: commit.parent_count() > 1,
   129	            parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
   130	            children: Vec::new(),
   131	            branches: Vec::new(),
   132	            branch_trace: None,
   133	        }
   134	    }
   135	}
   136	
   137	/// Represents a branch (real or derived from merge summary).
   138	pub struct BranchInfo {
   139	    pub target: Oid,
[2025-09-21T14:45:03] tokens used: 79,956
[2025-09-21T14:45:03] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..d1c7a388baae1e153d8ced84c3b7be9876f9c549
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,22 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    parent_row,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 continue;
             }
 
@@ -187,7 +204,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +224,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +238,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +263,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +281,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +321,50 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(
+        &mut self,
+        col: usize,
+        from_row: usize,
+        to_row: usize,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +380,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +395,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +405,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,26 +416,33 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
+
+    #[allow(dead_code)]
+    fn get_tuple(&self, row: usize, col: usize) -> (u8, u8, u8) {
+        if row >= self.height || col >= self.width {
+            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
+        }
+        let idx = self.index(row, col);
+        (self.glyphs[idx], self.colors[idx], self.persistence[idx])
+    }
 }
 
 #[derive(Clone, Copy)]
@@ -364,10 +452,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +468,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +569,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +687,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +744,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +833,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +848,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +889,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:45:08] thinking

**Extracting specific source lines with numbers**
[2025-09-21T14:45:09] exec bash -lc "nl -ba src/graph.rs | sed -n '260,360p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:45:09] bash -lc "nl -ba src/graph.rs | sed -n '260,360p'" succeeded in 17ms:
   260	        .collect::<Result<Vec<_>, Error>>()?;
   261	
   262	    let mut valid_branches = actual_branches
   263	        .iter()
   264	        .filter_map(|(br, tp)| {
   265	            br.get().name().and_then(|n| {
   266	                br.get().target().map(|t| {
   267	                    let start_index = match tp {
   268	                        BranchType::Local => 11,
   269	                        BranchType::Remote => 13,
   270	                    };
   271	                    let name = &n[start_index..];
   272	                    let end_index = indices.get(&t).cloned();
   273	                    let persistence = branch_persistence(name, &settings.branches.persistence);
   274	
   275	                    BranchInfo::new(
   276	                        t,
   277	                        name.to_string(),
   278	                        &BranchType::Remote == tp,
   279	                        false,
[2025-09-21T14:45:09] tokens used: 81,401
[2025-09-21T14:45:09] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..d1c7a388baae1e153d8ced84c3b7be9876f9c549
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,22 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    parent_row,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 continue;
             }
 
@@ -187,7 +204,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +224,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +238,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +263,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +281,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +321,50 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(
+        &mut self,
+        col: usize,
+        from_row: usize,
+        to_row: usize,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +380,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +395,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +405,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,26 +416,33 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
+
+    #[allow(dead_code)]
+    fn get_tuple(&self, row: usize, col: usize) -> (u8, u8, u8) {
+        if row >= self.height || col >= self.width {
+            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
+        }
+        let idx = self.index(row, col);
+        (self.glyphs[idx], self.colors[idx], self.persistence[idx])
+    }
 }
 
 #[derive(Clone, Copy)]
@@ -364,10 +452,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +468,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +569,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +687,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +744,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +833,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +848,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +889,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:45:13] thinking

**Locating branch_persistence**
[2025-09-21T14:45:14] exec bash -lc "nl -ba src/graph.rs | sed -n '560,640p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:45:14] bash -lc "nl -ba src/graph.rs | sed -n '560,640p'" succeeded in 41ms:
   560	    for branch in branches {
   561	        if let Some(column) = branch.visual.column {
   562	            let offset = if branch.visual.order_group == 0 {
   563	                0
   564	            } else {
   565	                group_offset[branch.visual.order_group - 1]
   566	            };
   567	            branch.visual.column = Some(column + offset);
   568	        }
   569	    }
   570	}
   571	
   572	/// Finds the index for a branch name from a slice of prefixes
   573	fn branch_order(name: &str, order: &[String]) -> usize {
   574	    order
   575	        .iter()
   576	        .position(|b| {
   577	            name.starts_with(b) || (name.starts_with("origin/") && name[7..].starts_with(b))
   578	        })
   579	        .unwrap_or(order.len())
[2025-09-21T14:45:14] tokens used: 82,808
[2025-09-21T14:45:14] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..d1c7a388baae1e153d8ced84c3b7be9876f9c549
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,22 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    parent_row,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 continue;
             }
 
@@ -187,7 +204,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +224,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +238,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +263,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +281,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +321,50 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(
+        &mut self,
+        col: usize,
+        from_row: usize,
+        to_row: usize,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +380,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +395,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +405,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,26 +416,33 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
+
+    #[allow(dead_code)]
+    fn get_tuple(&self, row: usize, col: usize) -> (u8, u8, u8) {
+        if row >= self.height || col >= self.width {
+            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
+        }
+        let idx = self.index(row, col);
+        (self.glyphs[idx], self.colors[idx], self.persistence[idx])
+    }
 }
 
 #[derive(Clone, Copy)]
@@ -364,10 +452,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +468,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +569,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +687,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +744,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +833,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +848,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +889,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


[2025-09-21T14:45:30] thinking

**Summarizing final modifications and next steps**

Now I’m preparing a clear final message summarizing key file changes with line references, noting the test failures due to offline status, highlighting assumptions like overwrite-on-tie for persistence, and confirming the commit was recorded. I’ll include verification suggestions advising rerunning tests with network access, all organized with a bold header and bullet points conforming to the user’s style.
[2025-09-21T14:45:31] codex

**复现结果**
- `src/print/unicode.rs:81` 起重写文本渲染流程：改用 `Grid` 三元栅格（字形索引/颜色/持久度），所有绘制 API 现携带分支持久度并据此决定覆盖，同时输出阶段通过 `settings.characters` 映射字形。
- `src/settings.rs:3` 新增 `Characters` 表并在 `Settings` 中暴露，薄线字形集与报告一致，供 Unicode 渲染统一取字形。
- `src/main.rs:1` 注入 `Characters::thin()` 至默认配置，确保 CLI 传入新的字符表。
- `src/graph.rs:138` 引入 `BranchInfo.persistence`，在 `extract_branches`/排序与辅助函数 `branch_persistence` 中计算持久度，为渲染覆盖策略提供优先级。

**验证**
- `cargo test`（受限网络无法拉取 crates.io，命令因 DNS 解析失败未运行）。

**假设/限制**
- 分支持久度数值并列时仍允许后写覆盖颜色（`<=` 判定），与报告中“较小持久度优先”一致但未见更细约束。

1. 建议在具备缓存或网络的环境下执行 `cargo test`/`cargo build` 以确认依赖装载后编译无误。
[2025-09-21T14:45:34] tokens used: 84,214
[2025-09-21T14:45:34] turn diff:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index da22e1dc3731ebafca356b555b9eeafe16b14394..d1c7a388baae1e153d8ced84c3b7be9876f9c549
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,25 +1,26 @@
 use crate::{
     graph::{BranchInfo, CommitInfo, GitGraph},
     print::{colors, get_deviate_index},
-    settings::{BranchSettings, Settings},
+    settings::{BranchSettings, Characters, Settings},
 };
 use term_painter::{Color as PainterColor, ToStyle};
 
-const DOT: char = '●';
-const CIRCLE: char = '○';
-const HOR: char = '─';
-const VER: char = '│';
-const TURN_UP_RIGHT: char = '└';
-const TURN_UP_LEFT: char = '┘';
-const TURN_DOWN_RIGHT: char = '┌';
-const TURN_DOWN_LEFT: char = '┐';
-const T_UP: char = '┴';
-const T_DOWN: char = '┬';
-const T_RIGHT: char = '├';
-const T_LEFT: char = '┤';
-const CROSS: char = '┼';
-const ARROW_RIGHT: char = '▶';
-const ARROW_LEFT: char = '◀';
+const GLYPH_SPACE: u8 = 0;
+const GLYPH_DOT: u8 = 1;
+const GLYPH_CIRCLE: u8 = 2;
+const GLYPH_HOR: u8 = 3;
+const GLYPH_VER: u8 = 4;
+const GLYPH_TURN_UP_RIGHT: u8 = 5;
+const GLYPH_TURN_UP_LEFT: u8 = 6;
+const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
+const GLYPH_TURN_DOWN_LEFT: u8 = 8;
+const GLYPH_T_UP: u8 = 9;
+const GLYPH_T_DOWN: u8 = 10;
+const GLYPH_T_RIGHT: u8 = 11;
+const GLYPH_T_LEFT: u8 = 12;
+const GLYPH_CROSS: u8 = 13;
+const GLYPH_ARROW_RIGHT: u8 = 14;
+const GLYPH_ARROW_LEFT: u8 = 15;
 
 const COLOR_NONE: u8 = u8::MAX;
 const PREFIX_WIDTH: usize = 9;
@@ -77,18 +78,23 @@
         .unwrap_or(0);
     let width = max_column * 2 + 1;
 
-    let mut grid = CharGrid::new(width, height);
+    let mut grid = Grid::new(width, height);
     let mut decorations: Vec<LineDecoration> = vec![LineDecoration::default(); height];
 
     for (index, commit) in graph.commits.iter().enumerate() {
         let row = row_map[index];
         let column = commit_column(graph, commit).unwrap_or(0);
         let gcol = column * 2;
-        let symbol = if commit.is_merge { CIRCLE } else { DOT };
+        let symbol = if commit.is_merge {
+            GLYPH_CIRCLE
+        } else {
+            GLYPH_DOT
+        };
 
         let commit_color =
             encode_color_index(color_index_for_commit(graph, &settings.branches, commit));
-        grid.place_node(row, gcol, symbol, Some(commit_color));
+        let commit_persistence = persistence_for_commit(graph, commit);
+        grid.set(row, gcol, symbol, Some(commit_color), commit_persistence);
 
         let summary = graph
             .commit(commit.oid)
@@ -167,11 +173,22 @@
                     &graph.commits[parent_index],
                 ))
             };
+            let parent_persistence = if parent_position == 0 {
+                commit_persistence
+            } else {
+                persistence_for_commit(graph, &graph.commits[parent_index])
+            };
 
             let child_col = column;
 
             if parent_col == child_col {
-                grid.vline(gcol, row, parent_row, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    parent_row,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 continue;
             }
 
@@ -187,7 +204,13 @@
             let insert_row = row + layer + 1;
 
             if row + 1 <= insert_row.saturating_sub(1) {
-                grid.vline(gcol, row, insert_row - 1, Some(parent_color));
+                grid.vline(
+                    gcol,
+                    row,
+                    insert_row - 1,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             let arrow = if parent_position > 0 {
@@ -201,7 +224,13 @@
             };
 
             if gcol < parent_gcol {
-                grid.overlay(insert_row, gcol, TURN_UP_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if gcol + 1 <= parent_gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -209,11 +238,24 @@
                         parent_gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             } else {
-                grid.overlay(insert_row, gcol, TURN_UP_LEFT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    gcol,
+                    GLYPH_TURN_UP_LEFT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
                 if parent_gcol + 1 <= gcol.saturating_sub(1) {
                     grid.hline(
                         insert_row,
@@ -221,9 +263,16 @@
                         gcol - 1,
                         arrow,
                         Some(parent_color),
+                        parent_persistence,
                     );
                 }
-                grid.overlay(insert_row, parent_gcol, TURN_DOWN_RIGHT, Some(parent_color));
+                grid.set(
+                    insert_row,
+                    parent_gcol,
+                    GLYPH_TURN_DOWN_RIGHT,
+                    Some(parent_color),
+                    parent_persistence,
+                );
             }
 
             if insert_row + 1 <= parent_row.saturating_sub(1) {
@@ -232,30 +281,39 @@
                     insert_row + 1,
                     parent_row - 1,
                     Some(parent_color),
+                    parent_persistence,
                 );
             }
         }
     }
 
-    print_graph(&grid, &decorations, branch_settings, color_enabled)
+    print_graph(
+        &grid,
+        &decorations,
+        branch_settings,
+        &settings.characters,
+        color_enabled,
+    )
 }
 
-struct CharGrid {
+struct Grid {
     width: usize,
     height: usize,
-    cells: Vec<char>,
+    glyphs: Vec<u8>,
     colors: Vec<u8>,
+    persistence: Vec<u8>,
 }
 
-impl CharGrid {
+impl Grid {
     fn new(width: usize, height: usize) -> Self {
         let width = width.max(1);
         let height = height.max(1);
-        CharGrid {
+        Grid {
             width,
             height,
-            cells: vec![' '; width * height],
+            glyphs: vec![GLYPH_SPACE; width * height],
             colors: vec![COLOR_NONE; width * height],
+            persistence: vec![u8::MAX; width * height],
         }
     }
 
@@ -263,30 +321,50 @@
         row * self.width + col
     }
 
-    fn place_node(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
-        self.overlay(row, col, ch, color);
+    fn glyph(&self, row: usize, col: usize) -> u8 {
+        if row >= self.height || col >= self.width {
+            return GLYPH_SPACE;
+        }
+        let idx = self.index(row, col);
+        self.glyphs[idx]
+    }
+
+    fn set(&mut self, row: usize, col: usize, glyph: u8, color: Option<u8>, persistence: u8) {
+        self.set_opt(row, col, Some(glyph), color, persistence);
     }
 
-    fn overlay(&mut self, row: usize, col: usize, ch: char, color: Option<u8>) {
+    fn set_opt(
+        &mut self,
+        row: usize,
+        col: usize,
+        glyph: Option<u8>,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if row >= self.height || col >= self.width {
             return;
         }
         let idx = self.index(row, col);
-        let current = self.cells[idx];
-        let merged = if current == ' ' {
-            ch
-        } else {
-            merge_chars(current, ch)
-        };
-        self.cells[idx] = merged;
+        if let Some(glyph) = glyph {
+            let merged = merge_glyphs(self.glyphs[idx], glyph);
+            self.glyphs[idx] = merged;
+        }
         if let Some(color) = color {
-            if merged != ' ' {
+            if persistence <= self.persistence[idx] {
                 self.colors[idx] = color;
+                self.persistence[idx] = persistence;
             }
         }
     }
 
-    fn vline(&mut self, col: usize, from_row: usize, to_row: usize, color: Option<u8>) {
+    fn vline(
+        &mut self,
+        col: usize,
+        from_row: usize,
+        to_row: usize,
+        color: Option<u8>,
+        persistence: u8,
+    ) {
         if col >= self.width || from_row == to_row {
             return;
         }
@@ -302,10 +380,14 @@
         }
 
         for row in start..end {
-            self.overlay(row, col, VER, color);
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
+                continue;
+            }
+            self.set(row, col, GLYPH_VER, color, persistence);
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn hline(
         &mut self,
         row: usize,
@@ -313,6 +395,7 @@
         end_col: usize,
         arrow: Option<Arrow>,
         color: Option<u8>,
+        persistence: u8,
     ) {
         if row >= self.height {
             return;
@@ -322,12 +405,10 @@
         }
 
         for col in start_col..=end_col {
-            let idx = self.index(row, col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                 continue;
             }
-            self.overlay(row, col, HOR, color);
+            self.set(row, col, GLYPH_HOR, color, persistence);
         }
 
         if let Some(arrow) = arrow {
@@ -335,26 +416,33 @@
                 Arrow::Right => end_col,
                 Arrow::Left => start_col,
             };
-            let idx = self.index(row, arrow_col);
-            let existing = self.cells[idx];
-            if matches!(existing, DOT | CIRCLE) {
+            if matches!(self.glyph(row, arrow_col), GLYPH_DOT | GLYPH_CIRCLE) {
                 return;
             }
-            self.overlay(row, arrow_col, arrow.char(), color);
+            self.set(row, arrow_col, arrow.glyph(), color, persistence);
         }
     }
 
-    fn row(&self, row: usize) -> (Vec<char>, Vec<u8>) {
+    fn row(&self, row: usize) -> (Vec<u8>, Vec<u8>) {
         if row >= self.height {
             return (Vec::new(), Vec::new());
         }
         let start = self.index(row, 0);
         let end = self.index(row, self.width - 1) + 1;
         (
-            self.cells[start..end].to_vec(),
+            self.glyphs[start..end].to_vec(),
             self.colors[start..end].to_vec(),
         )
     }
+
+    #[allow(dead_code)]
+    fn get_tuple(&self, row: usize, col: usize) -> (u8, u8, u8) {
+        if row >= self.height || col >= self.width {
+            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
+        }
+        let idx = self.index(row, col);
+        (self.glyphs[idx], self.colors[idx], self.persistence[idx])
+    }
 }
 
 #[derive(Clone, Copy)]
@@ -364,10 +452,10 @@
 }
 
 impl Arrow {
-    fn char(self) -> char {
+    fn glyph(self) -> u8 {
         match self {
-            Arrow::Left => ARROW_LEFT,
-            Arrow::Right => ARROW_RIGHT,
+            Arrow::Left => GLYPH_ARROW_LEFT,
+            Arrow::Right => GLYPH_ARROW_RIGHT,
         }
     }
 }
@@ -380,87 +468,87 @@
     right: bool,
     arrow_left: bool,
     arrow_right: bool,
-    node: Option<char>,
+    node: Option<u8>,
 }
 
 impl LineBits {
-    fn from_char(ch: char) -> Self {
-        match ch {
-            DOT => LineBits {
-                node: Some(DOT),
+    fn from_glyph(glyph: u8) -> Self {
+        match glyph {
+            GLYPH_DOT => LineBits {
+                node: Some(GLYPH_DOT),
                 ..Default::default()
             },
-            CIRCLE => LineBits {
-                node: Some(CIRCLE),
+            GLYPH_CIRCLE => LineBits {
+                node: Some(GLYPH_CIRCLE),
                 ..Default::default()
             },
-            VER => LineBits {
+            GLYPH_VER => LineBits {
                 up: true,
                 down: true,
                 ..Default::default()
             },
-            HOR => LineBits {
+            GLYPH_HOR => LineBits {
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_RIGHT => LineBits {
+            GLYPH_TURN_UP_RIGHT => LineBits {
                 up: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_UP_LEFT => LineBits {
+            GLYPH_TURN_UP_LEFT => LineBits {
                 up: true,
                 left: true,
                 ..Default::default()
             },
-            TURN_DOWN_RIGHT => LineBits {
+            GLYPH_TURN_DOWN_RIGHT => LineBits {
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            TURN_DOWN_LEFT => LineBits {
+            GLYPH_TURN_DOWN_LEFT => LineBits {
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            T_UP => LineBits {
+            GLYPH_T_UP => LineBits {
                 up: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_DOWN => LineBits {
+            GLYPH_T_DOWN => LineBits {
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            T_RIGHT => LineBits {
+            GLYPH_T_RIGHT => LineBits {
                 up: true,
                 down: true,
                 right: true,
                 ..Default::default()
             },
-            T_LEFT => LineBits {
+            GLYPH_T_LEFT => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 ..Default::default()
             },
-            CROSS => LineBits {
+            GLYPH_CROSS => LineBits {
                 up: true,
                 down: true,
                 left: true,
                 right: true,
                 ..Default::default()
             },
-            ARROW_RIGHT => LineBits {
+            GLYPH_ARROW_RIGHT => LineBits {
                 right: true,
                 arrow_right: true,
                 ..Default::default()
             },
-            ARROW_LEFT => LineBits {
+            GLYPH_ARROW_LEFT => LineBits {
                 left: true,
                 arrow_left: true,
                 ..Default::default()
@@ -481,46 +569,46 @@
         bits
     }
 
-    fn to_char(self) -> char {
+    fn to_glyph(self) -> u8 {
         if let Some(node) = self.node {
             return node;
         }
 
         if self.arrow_left {
-            return ARROW_LEFT;
+            return GLYPH_ARROW_LEFT;
         }
         if self.arrow_right {
-            return ARROW_RIGHT;
+            return GLYPH_ARROW_RIGHT;
         }
 
         match (self.up, self.down, self.left, self.right) {
-            (true, true, true, true) => CROSS,
-            (true, true, true, false) => T_LEFT,
-            (true, true, false, true) => T_RIGHT,
-            (true, false, true, true) => T_UP,
-            (false, true, true, true) => T_DOWN,
-            (true, true, false, false) => VER,
-            (false, false, true, true) => HOR,
-            (true, false, false, true) => TURN_UP_RIGHT,
-            (true, false, true, false) => TURN_UP_LEFT,
-            (false, true, false, true) => TURN_DOWN_RIGHT,
-            (false, true, true, false) => TURN_DOWN_LEFT,
-            (true, false, false, false) => VER,
-            (false, true, false, false) => VER,
-            (false, false, true, false) => HOR,
-            (false, false, false, true) => HOR,
-            _ => ' ',
+            (true, true, true, true) => GLYPH_CROSS,
+            (true, true, true, false) => GLYPH_T_LEFT,
+            (true, true, false, true) => GLYPH_T_RIGHT,
+            (true, false, true, true) => GLYPH_T_UP,
+            (false, true, true, true) => GLYPH_T_DOWN,
+            (true, true, false, false) => GLYPH_VER,
+            (false, false, true, true) => GLYPH_HOR,
+            (true, false, false, true) => GLYPH_TURN_UP_RIGHT,
+            (true, false, true, false) => GLYPH_TURN_UP_LEFT,
+            (false, true, false, true) => GLYPH_TURN_DOWN_RIGHT,
+            (false, true, true, false) => GLYPH_TURN_DOWN_LEFT,
+            (true, false, false, false) => GLYPH_VER,
+            (false, true, false, false) => GLYPH_VER,
+            (false, false, true, false) => GLYPH_HOR,
+            (false, false, false, true) => GLYPH_HOR,
+            _ => GLYPH_SPACE,
         }
     }
 }
 
-fn merge_chars(current: char, new: char) -> char {
+fn merge_glyphs(current: u8, new: u8) -> u8 {
     if current == new {
         return current;
     }
-    let current_bits = LineBits::from_char(current);
-    let new_bits = LineBits::from_char(new);
-    current_bits.merge(new_bits).to_char()
+    let current_bits = LineBits::from_glyph(current);
+    let new_bits = LineBits::from_glyph(new);
+    current_bits.merge(new_bits).to_glyph()
 }
 
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
@@ -599,6 +687,12 @@
         .find_map(|index| graph.branches.get(*index))
 }
 
+fn persistence_for_commit(graph: &GitGraph, info: &CommitInfo) -> u8 {
+    primary_branch(graph, info)
+        .map(|branch| branch.persistence)
+        .unwrap_or(u8::MAX)
+}
+
 fn color_index_for_commit(
     graph: &GitGraph,
     branch_settings: &BranchSettings,
@@ -650,16 +744,17 @@
 }
 
 fn print_graph(
-    grid: &CharGrid,
+    grid: &Grid,
     decorations: &[LineDecoration],
     settings: &BranchSettings,
+    characters: &Characters,
     use_color: bool,
 ) -> Result<String, String> {
     let mut lines = Vec::with_capacity(grid.height);
     for row in 0..grid.height {
-        let (chars, colors) = grid.row(row);
+        let (glyphs, colors) = grid.row(row);
         let prefix = render_prefix(decorations.get(row), settings, use_color)?;
-        let graph = render_graph_line(&chars, &colors, settings, use_color)?;
+        let graph = render_graph_line(&glyphs, &colors, characters, settings, use_color)?;
         let suffix = render_suffix(decorations.get(row), settings, use_color)?;
 
         let mut line = prefix;
@@ -738,12 +833,13 @@
 }
 
 fn render_graph_line(
-    chars: &[char],
+    glyphs: &[u8],
     colors: &[u8],
+    characters: &Characters,
     settings: &BranchSettings,
     use_color: bool,
 ) -> Result<String, String> {
-    if let Some(last_idx) = chars.iter().rposition(|ch| *ch != ' ') {
+    if let Some(last_idx) = glyphs.iter().rposition(|glyph| *glyph != GLYPH_SPACE) {
         let mut line = String::new();
         let mut start = 0usize;
         while start <= last_idx {
@@ -752,7 +848,10 @@
             while end <= last_idx && colors[end] == color_idx {
                 end += 1;
             }
-            let segment: String = chars[start..end].iter().collect();
+            let segment: String = glyphs[start..end]
+                .iter()
+                .map(|glyph| characters.glyph(*glyph))
+                .collect();
             if use_color {
                 match term_color_for_index(color_idx, settings)? {
                     Some(term_color) => line.push_str(&term_color.paint(&segment).to_string()),
@@ -790,15 +889,15 @@
     use super::*;
 
     #[test]
-    fn merge_chars_combines_perpendicular_lines() {
-        assert_eq!(merge_chars(VER, HOR), CROSS);
-        assert_eq!(merge_chars(HOR, VER), CROSS);
+    fn merge_glyphs_combines_perpendicular_lines() {
+        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
+        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
     }
 
     #[test]
-    fn merge_chars_keeps_nodes() {
-        assert_eq!(merge_chars(DOT, HOR), DOT);
-        assert_eq!(merge_chars(CIRCLE, VER), CIRCLE);
+    fn merge_glyphs_keeps_nodes() {
+        assert_eq!(merge_glyphs(GLYPH_DOT, GLYPH_HOR), GLYPH_DOT);
+        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
     }
 
     #[test]


=== 最终状态 ===
返回码: 0
状态: ✅ 执行成功
