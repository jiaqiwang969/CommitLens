=== 任务 029-265dfe6 执行日志 ===
时间: 2025-09-21 23:06:59.968779
Prompt:
请在 .workspace 内，依据 .workspace/todolist/todolist-029-265dfe6.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/029-265dfe6/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："029-265dfe6：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 029-265dfe6

=== 输出 ===
[2025-09-21T14:57:23] OpenAI Codex v0.39.0 (research preview)
--------
workdir: /Users/jqwang/104-CommitLens-codex/.workspace
model: gpt-5-codex-high
provider: codex
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
--------
[2025-09-21T14:57:23] User instructions:
请在 .workspace 内，依据 .workspace/todolist/todolist-029-265dfe6.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/029-265dfe6/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："029-265dfe6：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 029-265dfe6

[2025-09-21T14:57:32] thinking

**Outlining multi-step approach**
[2025-09-21T14:57:32] exec bash -lc 'ls -la' in /Users/jqwang/104-CommitLens-codex/.workspace/.workspace
[2025-09-21T14:57:32] bash -lc 'ls -la' exited -1 in 0ms:
No such file or directory (os error 2)
[2025-09-21T14:57:32] tokens used: 975

[2025-09-21T14:57:35] thinking

**Clarifying working directory path**
[2025-09-21T14:57:35] exec bash -lc 'ls -la' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T14:57:35] bash -lc 'ls -la' succeeded in 17ms:
total 16416
drwxr-xr-x@  9 jqwang  staff      288 Sep 21 15:57 .
drwxr-xr-x@ 29 jqwang  staff      928 Sep 21 07:49 ..
-rw-r--r--@  1 jqwang  staff      103 Sep 21 22:57 codex_error.txt
-rw-r--r--@  1 jqwang  staff  7353497 Sep 21 22:57 codex_output.txt
-rw-r--r--@  1 jqwang  staff        7 Sep 21 22:57 codex_status.txt
drwxr-xr-x@ 30 jqwang  staff      960 Sep 21 22:57 logs
drwxr-xr-x@ 12 jqwang  staff      384 Sep 21 20:54 rust-project
-rw-r--r--@  1 jqwang  staff      674 Sep 21 22:57 task_status.json
drwxr-xr-x@  5 jqwang  staff      160 Sep 21 22:57 todolist
[2025-09-21T14:57:35] tokens used: 1,298

[2025-09-21T14:57:37] thinking

**Deciding how to read a LaTeX file**
[2025-09-21T14:57:38] exec bash -lc "sed -n '1,160p' todolist/todolist-029-265dfe6.tex" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T14:57:38] bash -lc "sed -n '1,160p' todolist/todolist-029-265dfe6.tex" succeeded in 16ms:
% 明确说明（非常重要），tex必须以\section开头，不能有其他内容，不能使用begin「document」
\section{提交考古：029-265dfe6}

\subsection*{Commit 元信息}
\begin{itemize}
  \item 标题：prevent branches for being in same column as merge target
  \item 作者：Martin Lange \verb|<martin_lange_@gmx.net>|
  \item 日期：2020-12-25T03:03:30+01:00
\end{itemize}

\subsection*{变更摘要（阅读提示）}
本次变更聚焦于“分支列分配”的正确性：当一个分支与其合并目标处在同一可视分组时，避免将二者分配到同一列；同时补充了若干字符渲染的边界处理。CLI 也从 \verb|--head| 切换为 \verb|--all| 语义更清晰。

\subsection*{差异解读（证据）}
\paragraph{改了什么}
\begin{itemize}
  \item 列分配避免与合并目标同列：在 \verb|assign_branch_columns_branch_length| 内新增对分支 \verb|merge_target| 的列占用检查，若候选列与合并目标列相同则视为占用，继续搜索下一列（src/graph.rs:523、555–568）。并为此函数补充了 \verb|commits| 与 \verb|indices| 参数（src/graph.rs:523–555）。
  \item 模型扩充：\verb|BranchInfo| 新增 \verb|merge_target: Option<Oid>| 字段，并在抽取分支时填充（合并摘要派生的“临时分支”设置其 \verb|merge_target| 为被合并的提交；普通分支置 \verb|None|）（src/graph.rs:152–178、294–326）。
  \item 渲染修正：在字符渲染里，水平线遇到竖线左右端帽时改为十字交叉，避免丢笔划；同时在插入线段的判定中，允许首父（\verb|p == 0|）不被压制（src/print/unicode.rs:256–328、375–377）。
  \item 次要：CLI 选项从 \verb|--head/-h|（仅从 HEAD 起）改为 \verb|--all/-a|（打印整个图），并相应调整布尔逻辑（src/main.rs:25–115）。
[2025-09-21T14:57:38] tokens used: 2,868

[2025-09-21T14:57:40] thinking

**Checking for additional instructions**
[2025-09-21T14:57:40] exec bash -lc "sed -n '160,320p' todolist/todolist-029-265dfe6.tex" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T14:57:40] bash -lc "sed -n '160,320p' todolist/todolist-029-265dfe6.tex" succeeded in 10ms:

[2025-09-21T14:57:40] tokens used: 5,206

[2025-09-21T14:57:49] thinking

**Outlining commit reconstruction plan**
[2025-09-21T14:57:49] exec bash -lc 'git status --short' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:57:49] bash -lc 'git status --short' succeeded in 19ms:

[2025-09-21T14:57:49] tokens used: 9,199

[2025-09-21T14:57:51] thinking

**Inspecting source directory**
[2025-09-21T14:57:52] exec bash -lc 'ls src' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:57:52] bash -lc 'ls src' succeeded in 19ms:
graph.rs
lib.rs
main.rs
print
settings.rs
text.rs
[2025-09-21T14:57:52] tokens used: 9,349

[2025-09-21T14:57:54] thinking

**Starting to review src/graph.rs**
[2025-09-21T14:57:54] exec bash -lc "sed -n '1,200p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:57:54] bash -lc "sed -n '1,200p' src/graph.rs" succeeded in 8ms:
use crate::settings::{BranchOrder, BranchSettings, Settings};
use crate::text;
use git2::{BranchType, Commit, Error, Oid, Repository};
use itertools::Itertools;
use std::collections::{HashMap, VecDeque};

/// Represents a git history graph.
pub struct GitGraph {
    pub repository: Repository,
    pub commits: Vec<CommitInfo>,
    pub indices: HashMap<Oid, usize>,
    pub branches: Vec<BranchInfo>,
}

impl GitGraph {
    pub fn new(
        path: &str,
        settings: &Settings,
        all: bool,
        max_count: Option<usize>,
[2025-09-21T14:57:54] tokens used: 13,588

[2025-09-21T14:57:57] thinking

**Inspecting specified code sections**
[2025-09-21T14:57:58] exec bash -lc "sed -n '200,400p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:57:58] bash -lc "sed -n '200,400p' src/graph.rs" succeeded in 7ms:
        }
    }
}

/// Walks through the commits and adds each commit's Oid to the children of its parents.
fn assign_children(commits: &mut [CommitInfo], indices: &HashMap<Oid, usize>) {
    for idx in 0..commits.len() {
        let (oid, parents) = {
            let info = &commits[idx];
            (info.oid, info.parents)
        };
        for par_oid in &parents {
            if let Some(par_oid) = par_oid {
                if let Some(&par_idx) = indices.get(par_oid) {
                    if let Some(parent) = commits.get_mut(par_idx) {
                        parent.children.push(oid);
                    }
                }
            }
        }
[2025-09-21T14:57:58] tokens used: 15,968

[2025-09-21T14:58:00] thinking

**Continuing function improvements**
[2025-09-21T14:58:00] exec bash -lc "sed -n '400,800p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:58:00] bash -lc "sed -n '400,800p' src/graph.rs" succeeded in 13ms:
    }
    if let Some(end) = branch.range.0 {
        if start_index < end as i32 {
            // TODO: find a better solution (bool field?) to identify non-deleted branches that were not assigned to any commits, and thus should not occupy a column.
            branch.range = (None, None);
        } else {
            branch.range = (branch.range.0, Some(start_index as usize));
        }
    } else {
        branch.range = (branch.range.0, Some(start_index as usize));
    }
    Ok(any_assigned)
}

/// Sorts branches into columns for visualization, that all branches can be
/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
fn assign_branch_columns_fcfs(
    commits: &[CommitInfo],
    branches: &mut [BranchInfo],
    settings: &BranchSettings,
[2025-09-21T14:58:00] tokens used: 17,790

[2025-09-21T14:58:08] thinking

**Updating function signature and BranchInfo struct**
[2025-09-21T14:58:08] exec bash -lc 'rg "BranchInfo::new" -n src/graph.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:58:08] bash -lc 'rg "BranchInfo::new" -n src/graph.rs' succeeded in 21ms:
293:                    BranchInfo::new(
323:                let branch_info = BranchInfo::new(
[2025-09-21T14:58:08] tokens used: 20,236

[2025-09-21T14:58:31] thinking

**Planning branch info and merge target updates**
[2025-09-21T14:58:31] exec bash -lc "sed -n '200,380p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:58:32] bash -lc "sed -n '200,380p' src/print/unicode.rs" succeeded in 20ms:
                .find(|insert| insert.parent_index == parent_index && insert.to_col == parent_col)
                .map(|insert| insert.layer)
                .unwrap_or(split);

            let insert_row = row + layer + 1;

            if row + 1 <= insert_row.saturating_sub(1) {
                grid.vline(
                    gcol,
                    row,
                    insert_row - 1,
                    Some(parent_color),
                    parent_persistence,
                );
            }

            let arrow = if parent_position > 0 {
                if gcol < parent_gcol {
                    Some(Arrow::Right)
                } else {
[2025-09-21T14:58:32] tokens used: 21,958

[2025-09-21T14:58:35] thinking

**Searching for merge_glyphs function**
[2025-09-21T14:58:35] exec bash -lc 'rg "VER" -n src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:58:35] bash -lc 'rg "VER" -n src/print/unicode.rs' succeeded in 11ms:
12:const GLYPH_VER: u8 = 4;
386:            self.set(row, col, GLYPH_VER, color, persistence);
485:            GLYPH_VER => LineBits {
590:            (true, true, false, false) => GLYPH_VER,
596:            (true, false, false, false) => GLYPH_VER,
597:            (false, true, false, false) => GLYPH_VER,
893:        assert_eq!(merge_glyphs(GLYPH_VER, GLYPH_HOR), GLYPH_CROSS);
894:        assert_eq!(merge_glyphs(GLYPH_HOR, GLYPH_VER), GLYPH_CROSS);
900:        assert_eq!(merge_glyphs(GLYPH_CIRCLE, GLYPH_VER), GLYPH_CIRCLE);
[2025-09-21T14:58:35] tokens used: 23,348

[2025-09-21T14:58:38] thinking

**Searching for glyph-related code sections**
[2025-09-21T14:58:39] exec bash -lc "sed -n '440,620p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:58:39] bash -lc "sed -n '440,620p' src/print/unicode.rs" succeeded in 17ms:
        if row >= self.height || col >= self.width {
            return (GLYPH_SPACE, COLOR_NONE, u8::MAX);
        }
        let idx = self.index(row, col);
        (self.glyphs[idx], self.colors[idx], self.persistence[idx])
    }
}

#[derive(Clone, Copy)]
enum Arrow {
    Left,
    Right,
}

impl Arrow {
    fn glyph(self) -> u8 {
        match self {
            Arrow::Left => GLYPH_ARROW_LEFT,
            Arrow::Right => GLYPH_ARROW_RIGHT,
        }
[2025-09-21T14:58:39] tokens used: 23,787

[2025-09-21T14:58:42] thinking

**Searching for 'compact' usage**
[2025-09-21T14:58:42] exec bash -lc 'rg "if !compact" -n src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:58:42] bash -lc 'rg "if !compact" -n src/print/unicode.rs' exited 1 in 21ms:

[2025-09-21T14:58:42] tokens used: 25,431

[2025-09-21T14:58:45] thinking

**Searching for insert lines**
[2025-09-21T14:58:45] exec bash -lc 'rg "insert_line" -n src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:58:45] bash -lc 'rg "insert_line" -n src/print/unicode.rs' exited 1 in 21ms:

[2025-09-21T14:58:45] tokens used: 36,281

[2025-09-21T14:58:47] thinking

**Locating specific code range**
[2025-09-21T14:58:47] exec bash -lc "sed -n '240,360p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:58:47] bash -lc "sed -n '240,360p' src/print/unicode.rs" succeeded in 19ms:
                        Some(parent_color),
                        parent_persistence,
                    );
                }
                grid.set(
                    insert_row,
                    parent_gcol,
                    GLYPH_TURN_DOWN_LEFT,
                    Some(parent_color),
                    parent_persistence,
                );
            } else {
                grid.set(
                    insert_row,
                    gcol,
                    GLYPH_TURN_UP_LEFT,
                    Some(parent_color),
                    parent_persistence,
                );
                if parent_gcol + 1 <= gcol.saturating_sub(1) {
[2025-09-21T14:58:47] tokens used: 36,501

[2025-09-21T14:58:52] thinking

**Searching for grid.set_opt usages**
[2025-09-21T14:58:52] exec bash -lc 'rg "set_opt" -n src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:58:52] bash -lc 'rg "set_opt" -n src/print/unicode.rs' succeeded in 15ms:
333:        self.set_opt(row, col, Some(glyph), color, persistence);
336:    fn set_opt(
[2025-09-21T14:58:52] tokens used: 37,904

[2025-09-21T14:58:57] thinking

**Analyzing glyph constants and enumerations**
[2025-09-21T14:58:58] exec bash -lc 'rg "VER_R" src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:58:58] bash -lc 'rg "VER_R" src/print/unicode.rs' exited 1 in 15ms:

[2025-09-21T14:58:58] tokens used: 38,330

[2025-09-21T14:59:01] thinking

**Investigating constant naming discrepancies**
[2025-09-21T14:59:02] exec bash -lc "sed -n '1,200p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:59:02] bash -lc "sed -n '1,200p' src/print/unicode.rs" succeeded in 19ms:
use crate::{
    graph::{BranchInfo, CommitInfo, GitGraph},
    print::{colors, get_deviate_index},
    settings::{BranchSettings, Characters, Settings},
};
use term_painter::{Color as PainterColor, ToStyle};

const GLYPH_SPACE: u8 = 0;
const GLYPH_DOT: u8 = 1;
const GLYPH_CIRCLE: u8 = 2;
const GLYPH_HOR: u8 = 3;
const GLYPH_VER: u8 = 4;
const GLYPH_TURN_UP_RIGHT: u8 = 5;
const GLYPH_TURN_UP_LEFT: u8 = 6;
const GLYPH_TURN_DOWN_RIGHT: u8 = 7;
const GLYPH_TURN_DOWN_LEFT: u8 = 8;
const GLYPH_T_UP: u8 = 9;
const GLYPH_T_DOWN: u8 = 10;
const GLYPH_T_RIGHT: u8 = 11;
const GLYPH_T_LEFT: u8 = 12;
[2025-09-21T14:59:02] tokens used: 38,640

[2025-09-21T14:59:04] thinking

**Searching for hline function**
[2025-09-21T14:59:04] exec bash -lc 'rg "fn hline" -n src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:59:04] bash -lc 'rg "fn hline" -n src/print/unicode.rs' succeeded in 24ms:
391:    fn hline(
[2025-09-21T14:59:04] tokens used: 42,081
[2025-09-21T14:59:07] exec bash -lc "sed -n '380,460p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:59:07] bash -lc "sed -n '380,460p' src/print/unicode.rs" succeeded in 19ms:
        }

        for row in start..end {
            if matches!(self.glyph(row, col), GLYPH_DOT | GLYPH_CIRCLE) {
                continue;
            }
            self.set(row, col, GLYPH_VER, color, persistence);
        }
    }

    #[allow(clippy::too_many_arguments)]
    fn hline(
        &mut self,
        row: usize,
        start_col: usize,
        end_col: usize,
        arrow: Option<Arrow>,
        color: Option<u8>,
        persistence: u8,
    ) {
[2025-09-21T14:59:07] tokens used: 42,316

[2025-09-21T14:59:23] thinking

**Analyzing glyph merging and line crossing logic**
[2025-09-21T14:59:23] exec bash -lc "sed -n '1,200p' src/print/ascii.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:59:23] bash -lc "sed -n '1,200p' src/print/ascii.rs" exited 1 in 20ms:
sed: src/print/ascii.rs: No such file or directory
[2025-09-21T14:59:23] tokens used: 44,226

[2025-09-21T14:59:26] thinking

**Checking src/print directory**
[2025-09-21T14:59:26] exec bash -lc 'ls src/print' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:59:26] bash -lc 'ls src/print' succeeded in 9ms:
colors.rs
mod.rs
svg.rs
unicode.rs
[2025-09-21T14:59:26] tokens used: 44,462

[2025-09-21T14:59:28] thinking

**Investigating snippet name origins**
[2025-09-21T14:59:28] exec bash -lc 'rg "VER_" -n src/print' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:59:28] bash -lc 'rg "VER_" -n src/print' exited 1 in 18ms:

[2025-09-21T14:59:28] tokens used: 44,678

[2025-09-21T14:59:48] thinking

**Analyzing glyph merging logic for line intersections**
[2025-09-21T14:59:48] exec bash -lc "sed -n '620,820p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:59:48] bash -lc "sed -n '620,820p' src/print/unicode.rs" succeeded in 19ms:
            None => continue,
        };

        let mut edges: Vec<Insert> = Vec::new();

        for parent_oid in commit.parents.iter().flatten() {
            if let Some(&parent_index) = graph.indices.get(parent_oid) {
                if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                    if parent_col == from_col {
                        continue;
                    }
                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
                    if compact {
                        // TODO(026-23e2c76): Original heuristics for compact mode are
                        // unavailable in the report. We keep the edge while relying on
                        // standard layering so that merges remain connected.
                    }
                    edges.push(Insert {
                        parent_index,
                        to_col: parent_col,
[2025-09-21T14:59:48] tokens used: 46,422

[2025-09-21T14:59:52] thinking

**Investigating get_inserts behavior**
[2025-09-21T14:59:52] exec bash -lc "sed -n '1,200p' src/print/mod.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T14:59:52] bash -lc "sed -n '1,200p' src/print/mod.rs" succeeded in 12ms:
pub mod colors;
pub mod svg;
pub mod unicode;

use crate::graph::GitGraph;

/// Determine the zero-based position of `child_index` within the visible children of
/// `parent_index`. Rendering uses this offset to introduce slight horizontal deviations
/// when multiple edges leave the same parent column.
pub fn get_deviate_index(
    graph: &GitGraph,
    parent_index: usize,
    child_index: usize,
) -> Option<usize> {
    let parent = graph.commits.get(parent_index)?;
    let child_oid = graph.commits.get(child_index)?.oid;

    let mut ordinal = 0usize;
    for candidate_oid in &parent.children {
        if let Some(&idx) = graph.indices.get(candidate_oid) {
[2025-09-21T14:59:52] tokens used: 48,197

[2025-09-21T15:00:29] thinking

**Analyzing edge insertion and glyph merging**
[2025-09-21T15:00:30] exec bash -lc 'rg "compact" -n src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T15:00:30] bash -lc 'rg "compact" -n src/print/unicode.rs' succeeded in 21ms:
69:    let inserts = get_inserts(graph, settings.compact);
614:fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
632:                    if compact {
633:                        // TODO(026-23e2c76): Original heuristics for compact mode are
[2025-09-21T15:00:30] tokens used: 51,112

[2025-09-21T15:00:49] thinking

**Analyzing compact mode edge logic**
[2025-09-21T15:00:49] exec bash -lc 'rg "target_index" -n src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T15:00:49] bash -lc 'rg "target_index" -n src/print/unicode.rs' exited 1 in 20ms:

[2025-09-21T15:00:49] tokens used: 52,286

[2025-09-21T15:00:53] thinking

**Planning branch logic and CLI updates**
[2025-09-21T15:00:54] exec bash -lc "sed -n '1,200p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T15:00:54] bash -lc "sed -n '1,200p' src/main.rs" succeeded in 20ms:
use clap::{App, AppSettings, Arg};
use git_graph::graph::{CommitInfo, GitGraph};
use git_graph::print::svg::print_svg;
use git_graph::print::unicode::print_unicode;
use git_graph::settings::{BranchOrder, BranchSettings, Characters, MergePatterns, Settings};
use std::process;
use std::time::Instant;

fn main() {
    let mut app = App::new("git-graph")
        .setting(AppSettings::DisableHelpFlags)
        .version(env!("CARGO_PKG_VERSION"))
        .about("Render git commit graphs as Unicode or SVG")
        .arg(
            Arg::with_name("svg")
                .long("svg")
                .help("Render SVG output instead of console output"),
        )
        .arg(
            Arg::with_name("compact")
[2025-09-21T15:00:54] tokens used: 52,606

[2025-09-21T15:01:36] thinking

**Reworking CLI option and branch column logic**

I'm sorting out renaming the CLI flag from `--head` to `--all` while flipping its meaning so the default shows only HEAD commits and `--all` includes the full graph. Then, I’m planning detailed code changes to the branch assignment logic to add a `merge_target` field and ensure branch columns avoid conflicting with their merge targets, updating function signatures and internal checks accordingly.
[2025-09-21T15:01:37] exec bash -lc 'rg "merge_target" -n src' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T15:01:37] bash -lc 'rg "merge_target" -n src' exited 2 in 15ms:
src: No such file or directory (os error 2)
[2025-09-21T15:01:37] tokens used: 58,049

[2025-09-21T15:01:40] thinking

**Setting the working directory**
[2025-09-21T15:01:40] exec bash -lc 'rg "merge_target" -n src' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T15:01:40] bash -lc 'rg "merge_target" -n src' exited 1 in 13ms:

[2025-09-21T15:01:40] tokens used: 58,212

[2025-09-21T15:01:46] thinking

**Preparing branch-related code modifications**
[2025-09-21T15:01:48] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -154,2 +154,3 @@
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
@@ -165,2 +166,3 @@
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
@@ -175,2 +177,3 @@
             target,
+            merge_target,
             name,
[2025-09-21T15:01:48] apply_patch(auto_approved=true) exited 0 in 28ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T15:01:48] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..f895c889de807d8eef1a6d92b662c4ba89e65c6c
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -152,6 +152,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +164,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +175,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,

[2025-09-21T15:01:48] tokens used: 58,804
[2025-09-21T15:01:48] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..f895c889de807d8eef1a6d92b662c4ba89e65c6c
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -152,6 +152,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +164,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +175,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,


[2025-09-21T15:01:52] thinking

**Updating extract_branches with new parameter**
[2025-09-21T15:01:53] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -297,2 +297,3 @@
                         t,
+                        None,
                         name.to_string(),
@@ -327,2 +328,3 @@
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
[2025-09-21T15:01:53] apply_patch(auto_approved=true) exited 0 in 30ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T15:01:53] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4da1595eacfa888447795dbcb38e6d5ae8e91953
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -152,6 +152,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +164,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +175,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +295,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +326,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,

[2025-09-21T15:01:53] tokens used: 59,358
[2025-09-21T15:01:53] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4da1595eacfa888447795dbcb38e6d5ae8e91953
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -152,6 +152,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +164,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +175,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +295,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +326,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,


[2025-09-21T15:01:58] thinking

**Updating function signature and call sites**
[2025-09-21T15:02:00] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -55,2 +55,3 @@
                 &commits,
+                &indices,
                 &mut branches,
@@ -62,2 +63,3 @@
                 &commits,
+                &indices,
                 &mut branches,
[2025-09-21T15:02:00] apply_patch(auto_approved=true) exited 0 in 25ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T15:02:00] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..ab5dab6ba63cb31a7ef54b52b0b4610e0dd7e487
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,

[2025-09-21T15:02:00] tokens used: 59,897
[2025-09-21T15:02:00] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..ab5dab6ba63cb31a7ef54b52b0b4610e0dd7e487
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,


[2025-09-21T15:02:29] thinking

**Revising branch assignment function**
[2025-09-21T15:02:42] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -524,3 +524,4 @@
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -555,17 +556,35 @@
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
+                }
+            }
+            if !occ {
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
                 }
             }
+
             if !occ {
-                found = i;
+                found = Some(candidate);
                 break;
@@ -573,7 +592,10 @@
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
[2025-09-21T15:02:42] apply_patch(auto_approved=true) exited 0 in 31ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T15:02:42] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied

[2025-09-21T15:02:42] tokens used: 62,649
[2025-09-21T15:02:42] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied


[2025-09-21T15:03:57] thinking

**Ensuring vector imports and refining glyph merging**
**Adjusting edge insertion logic in get_inserts**
[2025-09-21T15:04:00] codex
**Adjusting edge insertion logic in get_inserts**
[2025-09-21T15:04:06] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -616,4 +616,4 @@
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
@@ -622,5 +622,16 @@
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
@@ -630,8 +641,10 @@
                     }
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
+                    }
                     let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
-                    }
                     edges.push(Insert {
[2025-09-21T15:04:06] apply_patch(auto_approved=true) exited 0 in 30ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T15:04:06] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..0b835535acb3615f1a04f3c973b4543dfb7fc909
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -614,26 +614,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
+                    }
                     let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
-                    }
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,

[2025-09-21T15:04:06] tokens used: 68,400
[2025-09-21T15:04:06] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..0b835535acb3615f1a04f3c973b4543dfb7fc909
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -614,26 +614,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
+                    }
                     let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
-                    }
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,


[2025-09-21T15:04:17] thinking

**Enhancing merge_glyphs with crossing logic**
[2025-09-21T15:04:20] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -608,2 +608,16 @@
     }
+
+    let connects_vertically = |glyph| {
+        matches!(
+            glyph,
+            GLYPH_TURN_UP_RIGHT | GLYPH_TURN_UP_LEFT | GLYPH_TURN_DOWN_RIGHT | GLYPH_TURN_DOWN_LEFT
+        )
+    };
+
+    if (connects_vertically(current) && new == GLYPH_HOR)
+        || (connects_vertically(new) && current == GLYPH_HOR)
+    {
+        return GLYPH_CROSS;
+    }
+
     let current_bits = LineBits::from_glyph(current);
[2025-09-21T15:04:20] apply_patch(auto_approved=true) exited 0 in 38ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T15:04:20] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..3b875dc3be93b11197a69ae6bc00fb8d8562d52d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -606,6 +606,20 @@
     if current == new {
         return current;
     }
+
+    let connects_vertically = |glyph| {
+        matches!(
+            glyph,
+            GLYPH_TURN_UP_RIGHT | GLYPH_TURN_UP_LEFT | GLYPH_TURN_DOWN_RIGHT | GLYPH_TURN_DOWN_LEFT
+        )
+    };
+
+    if (connects_vertically(current) && new == GLYPH_HOR)
+        || (connects_vertically(new) && current == GLYPH_HOR)
+    {
+        return GLYPH_CROSS;
+    }
+
     let current_bits = LineBits::from_glyph(current);
     let new_bits = LineBits::from_glyph(new);
     current_bits.merge(new_bits).to_glyph()
@@ -614,26 +628,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
-                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
                     }
+                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,

[2025-09-21T15:04:20] tokens used: 69,823
[2025-09-21T15:04:21] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..3b875dc3be93b11197a69ae6bc00fb8d8562d52d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -606,6 +606,20 @@
     if current == new {
         return current;
     }
+
+    let connects_vertically = |glyph| {
+        matches!(
+            glyph,
+            GLYPH_TURN_UP_RIGHT | GLYPH_TURN_UP_LEFT | GLYPH_TURN_DOWN_RIGHT | GLYPH_TURN_DOWN_LEFT
+        )
+    };
+
+    if (connects_vertically(current) && new == GLYPH_HOR)
+        || (connects_vertically(new) && current == GLYPH_HOR)
+    {
+        return GLYPH_CROSS;
+    }
+
     let current_bits = LineBits::from_glyph(current);
     let new_bits = LineBits::from_glyph(new);
     current_bits.merge(new_bits).to_glyph()
@@ -614,26 +628,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
-                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
                     }
+                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,


[2025-09-21T15:04:30] thinking

**Preparing CLI argument refactor**
[2025-09-21T15:04:32] tokens used: 70,815
[2025-09-21T15:04:32] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..3b875dc3be93b11197a69ae6bc00fb8d8562d52d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -606,6 +606,20 @@
     if current == new {
         return current;
     }
+
+    let connects_vertically = |glyph| {
+        matches!(
+            glyph,
+            GLYPH_TURN_UP_RIGHT | GLYPH_TURN_UP_LEFT | GLYPH_TURN_DOWN_RIGHT | GLYPH_TURN_DOWN_LEFT
+        )
+    };
+
+    if (connects_vertically(current) && new == GLYPH_HOR)
+        || (connects_vertically(new) && current == GLYPH_HOR)
+    {
+        return GLYPH_CROSS;
+    }
+
     let current_bits = LineBits::from_glyph(current);
     let new_bits = LineBits::from_glyph(new);
     current_bits.merge(new_bits).to_glyph()
@@ -614,26 +628,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
-                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
                     }
+                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,


[2025-09-21T15:04:36] thinking

**Correcting working directory**
[2025-09-21T15:04:38] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -52,6 +52,6 @@
         .arg(
-            Arg::with_name("head")
-                .long("head")
-                .short("h")
-                .help("Traverse commits reachable from HEAD only"),
+            Arg::with_name("all")
+                .long("all")
+                .short("a")
+                .help("Traverse commits reachable from all references"),
         )
@@ -80,3 +80,3 @@
     let colored = !matches.is_present("no-color");
-    let head_only = matches.is_present("head");
+    let traverse_all = matches.is_present("all");
     let path = matches.value_of("repository").unwrap_or(".");
@@ -120,3 +120,3 @@
 
-    match run(path, &settings, svg_out, !head_only, commit_limit) {
+    match run(path, &settings, svg_out, traverse_all, commit_limit) {
         Ok(_) => process::exit(0),
[2025-09-21T15:04:38] apply_patch(auto_approved=true) exited 0 in 29ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T15:04:38] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/main.rs b/src/main.rs
index 9a219bd44671407db7c27974d477f49946626499..72221a1a33480b43ce3319ba5f943257cd6f2062
--- a/src/main.rs
+++ b/src/main.rs
@@ -50,10 +50,10 @@
                 .help("Limit the number of commits to traverse"),
         )
         .arg(
-            Arg::with_name("head")
-                .long("head")
-                .short("h")
-                .help("Traverse commits reachable from HEAD only"),
+            Arg::with_name("all")
+                .long("all")
+                .short("a")
+                .help("Traverse commits reachable from all references"),
         )
         .arg(
             Arg::with_name("help")
@@ -78,7 +78,7 @@
     let debug = matches.is_present("debug");
     let compact = matches.is_present("compact");
     let colored = !matches.is_present("no-color");
-    let head_only = matches.is_present("head");
+    let traverse_all = matches.is_present("all");
     let path = matches.value_of("repository").unwrap_or(".");
 
     let characters = match matches.value_of("style") {
@@ -118,7 +118,7 @@
         characters,
     };
 
-    match run(path, &settings, svg_out, !head_only, commit_limit) {
+    match run(path, &settings, svg_out, traverse_all, commit_limit) {
         Ok(_) => process::exit(0),
         Err(err) => {
             eprintln!("{}", err);
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..3b875dc3be93b11197a69ae6bc00fb8d8562d52d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -606,6 +606,20 @@
     if current == new {
         return current;
     }
+
+    let connects_vertically = |glyph| {
+        matches!(
+            glyph,
+            GLYPH_TURN_UP_RIGHT | GLYPH_TURN_UP_LEFT | GLYPH_TURN_DOWN_RIGHT | GLYPH_TURN_DOWN_LEFT
+        )
+    };
+
+    if (connects_vertically(current) && new == GLYPH_HOR)
+        || (connects_vertically(new) && current == GLYPH_HOR)
+    {
+        return GLYPH_CROSS;
+    }
+
     let current_bits = LineBits::from_glyph(current);
     let new_bits = LineBits::from_glyph(new);
     current_bits.merge(new_bits).to_glyph()
@@ -614,26 +628,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
-                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
                     }
+                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,

[2025-09-21T15:04:38] tokens used: 71,408
[2025-09-21T15:04:38] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/main.rs b/src/main.rs
index 9a219bd44671407db7c27974d477f49946626499..72221a1a33480b43ce3319ba5f943257cd6f2062
--- a/src/main.rs
+++ b/src/main.rs
@@ -50,10 +50,10 @@
                 .help("Limit the number of commits to traverse"),
         )
         .arg(
-            Arg::with_name("head")
-                .long("head")
-                .short("h")
-                .help("Traverse commits reachable from HEAD only"),
+            Arg::with_name("all")
+                .long("all")
+                .short("a")
+                .help("Traverse commits reachable from all references"),
         )
         .arg(
             Arg::with_name("help")
@@ -78,7 +78,7 @@
     let debug = matches.is_present("debug");
     let compact = matches.is_present("compact");
     let colored = !matches.is_present("no-color");
-    let head_only = matches.is_present("head");
+    let traverse_all = matches.is_present("all");
     let path = matches.value_of("repository").unwrap_or(".");
 
     let characters = match matches.value_of("style") {
@@ -118,7 +118,7 @@
         characters,
     };
 
-    match run(path, &settings, svg_out, !head_only, commit_limit) {
+    match run(path, &settings, svg_out, traverse_all, commit_limit) {
         Ok(_) => process::exit(0),
         Err(err) => {
             eprintln!("{}", err);
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..3b875dc3be93b11197a69ae6bc00fb8d8562d52d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -606,6 +606,20 @@
     if current == new {
         return current;
     }
+
+    let connects_vertically = |glyph| {
+        matches!(
+            glyph,
+            GLYPH_TURN_UP_RIGHT | GLYPH_TURN_UP_LEFT | GLYPH_TURN_DOWN_RIGHT | GLYPH_TURN_DOWN_LEFT
+        )
+    };
+
+    if (connects_vertically(current) && new == GLYPH_HOR)
+        || (connects_vertically(new) && current == GLYPH_HOR)
+    {
+        return GLYPH_CROSS;
+    }
+
     let current_bits = LineBits::from_glyph(current);
     let new_bits = LineBits::from_glyph(new);
     current_bits.merge(new_bits).to_glyph()
@@ -614,26 +628,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
-                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
                     }
+                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,


[2025-09-21T15:04:47] thinking

**Verifying default commit traversal behavior**
[2025-09-21T15:04:47] exec bash -lc "rg \"\\\"head\\\"\" src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T15:04:47] bash -lc "rg \"\\\"head\\\"\" src/main.rs" exited 1 in 19ms:

[2025-09-21T15:04:47] tokens used: 115,513
[2025-09-21T15:04:47] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/main.rs b/src/main.rs
index 9a219bd44671407db7c27974d477f49946626499..72221a1a33480b43ce3319ba5f943257cd6f2062
--- a/src/main.rs
+++ b/src/main.rs
@@ -50,10 +50,10 @@
                 .help("Limit the number of commits to traverse"),
         )
         .arg(
-            Arg::with_name("head")
-                .long("head")
-                .short("h")
-                .help("Traverse commits reachable from HEAD only"),
+            Arg::with_name("all")
+                .long("all")
+                .short("a")
+                .help("Traverse commits reachable from all references"),
         )
         .arg(
             Arg::with_name("help")
@@ -78,7 +78,7 @@
     let debug = matches.is_present("debug");
     let compact = matches.is_present("compact");
     let colored = !matches.is_present("no-color");
-    let head_only = matches.is_present("head");
+    let traverse_all = matches.is_present("all");
     let path = matches.value_of("repository").unwrap_or(".");
 
     let characters = match matches.value_of("style") {
@@ -118,7 +118,7 @@
         characters,
     };
 
-    match run(path, &settings, svg_out, !head_only, commit_limit) {
+    match run(path, &settings, svg_out, traverse_all, commit_limit) {
         Ok(_) => process::exit(0),
         Err(err) => {
             eprintln!("{}", err);
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..3b875dc3be93b11197a69ae6bc00fb8d8562d52d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -606,6 +606,20 @@
     if current == new {
         return current;
     }
+
+    let connects_vertically = |glyph| {
+        matches!(
+            glyph,
+            GLYPH_TURN_UP_RIGHT | GLYPH_TURN_UP_LEFT | GLYPH_TURN_DOWN_RIGHT | GLYPH_TURN_DOWN_LEFT
+        )
+    };
+
+    if (connects_vertically(current) && new == GLYPH_HOR)
+        || (connects_vertically(new) && current == GLYPH_HOR)
+    {
+        return GLYPH_CROSS;
+    }
+
     let current_bits = LineBits::from_glyph(current);
     let new_bits = LineBits::from_glyph(new);
     current_bits.merge(new_bits).to_glyph()
@@ -614,26 +628,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
-                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
                     }
+                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,


[2025-09-21T15:04:50] thinking

**Checking for leftover 'head_only' references**
[2025-09-21T15:04:50] exec bash -lc 'rg "head_only" -n' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T15:04:50] bash -lc 'rg "head_only" -n' exited 1 in 24ms:

[2025-09-21T15:04:50] tokens used: 115,676
[2025-09-21T15:04:50] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/main.rs b/src/main.rs
index 9a219bd44671407db7c27974d477f49946626499..72221a1a33480b43ce3319ba5f943257cd6f2062
--- a/src/main.rs
+++ b/src/main.rs
@@ -50,10 +50,10 @@
                 .help("Limit the number of commits to traverse"),
         )
         .arg(
-            Arg::with_name("head")
-                .long("head")
-                .short("h")
-                .help("Traverse commits reachable from HEAD only"),
+            Arg::with_name("all")
+                .long("all")
+                .short("a")
+                .help("Traverse commits reachable from all references"),
         )
         .arg(
             Arg::with_name("help")
@@ -78,7 +78,7 @@
     let debug = matches.is_present("debug");
     let compact = matches.is_present("compact");
     let colored = !matches.is_present("no-color");
-    let head_only = matches.is_present("head");
+    let traverse_all = matches.is_present("all");
     let path = matches.value_of("repository").unwrap_or(".");
 
     let characters = match matches.value_of("style") {
@@ -118,7 +118,7 @@
         characters,
     };
 
-    match run(path, &settings, svg_out, !head_only, commit_limit) {
+    match run(path, &settings, svg_out, traverse_all, commit_limit) {
         Ok(_) => process::exit(0),
         Err(err) => {
             eprintln!("{}", err);
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..3b875dc3be93b11197a69ae6bc00fb8d8562d52d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -606,6 +606,20 @@
     if current == new {
         return current;
     }
+
+    let connects_vertically = |glyph| {
+        matches!(
+            glyph,
+            GLYPH_TURN_UP_RIGHT | GLYPH_TURN_UP_LEFT | GLYPH_TURN_DOWN_RIGHT | GLYPH_TURN_DOWN_LEFT
+        )
+    };
+
+    if (connects_vertically(current) && new == GLYPH_HOR)
+        || (connects_vertically(new) && current == GLYPH_HOR)
+    {
+        return GLYPH_CROSS;
+    }
+
     let current_bits = LineBits::from_glyph(current);
     let new_bits = LineBits::from_glyph(new);
     current_bits.merge(new_bits).to_glyph()
@@ -614,26 +628,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
-                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
                     }
+                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,


[2025-09-21T15:04:57] thinking

**Preparing code adjustments and formatting**
[2025-09-21T15:04:58] exec bash -lc 'cargo fmt' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T15:04:58] bash -lc 'cargo fmt' succeeded in 75ms:

[2025-09-21T15:04:58] tokens used: 116,016
[2025-09-21T15:04:58] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/main.rs b/src/main.rs
index 9a219bd44671407db7c27974d477f49946626499..72221a1a33480b43ce3319ba5f943257cd6f2062
--- a/src/main.rs
+++ b/src/main.rs
@@ -50,10 +50,10 @@
                 .help("Limit the number of commits to traverse"),
         )
         .arg(
-            Arg::with_name("head")
-                .long("head")
-                .short("h")
-                .help("Traverse commits reachable from HEAD only"),
+            Arg::with_name("all")
+                .long("all")
+                .short("a")
+                .help("Traverse commits reachable from all references"),
         )
         .arg(
             Arg::with_name("help")
@@ -78,7 +78,7 @@
     let debug = matches.is_present("debug");
     let compact = matches.is_present("compact");
     let colored = !matches.is_present("no-color");
-    let head_only = matches.is_present("head");
+    let traverse_all = matches.is_present("all");
     let path = matches.value_of("repository").unwrap_or(".");
 
     let characters = match matches.value_of("style") {
@@ -118,7 +118,7 @@
         characters,
     };
 
-    match run(path, &settings, svg_out, !head_only, commit_limit) {
+    match run(path, &settings, svg_out, traverse_all, commit_limit) {
         Ok(_) => process::exit(0),
         Err(err) => {
             eprintln!("{}", err);
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..3b875dc3be93b11197a69ae6bc00fb8d8562d52d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -606,6 +606,20 @@
     if current == new {
         return current;
     }
+
+    let connects_vertically = |glyph| {
+        matches!(
+            glyph,
+            GLYPH_TURN_UP_RIGHT | GLYPH_TURN_UP_LEFT | GLYPH_TURN_DOWN_RIGHT | GLYPH_TURN_DOWN_LEFT
+        )
+    };
+
+    if (connects_vertically(current) && new == GLYPH_HOR)
+        || (connects_vertically(new) && current == GLYPH_HOR)
+    {
+        return GLYPH_CROSS;
+    }
+
     let current_bits = LineBits::from_glyph(current);
     let new_bits = LineBits::from_glyph(new);
     current_bits.merge(new_bits).to_glyph()
@@ -614,26 +628,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
-                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
                     }
+                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,


[2025-09-21T15:05:04] thinking

**Preparing to run cargo fmt and verify formatting**
[2025-09-21T15:05:05] exec bash -lc "sed -n '120,220p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T15:05:05] bash -lc "sed -n '120,220p' src/graph.rs" succeeded in 20ms:
            }
        };

        Ok(graph)
    }

    pub fn commit(&self, id: Oid) -> Result<Commit, Error> {
        self.repository.find_commit(id)
    }
}

/// Represents a commit.
pub struct CommitInfo {
    pub oid: Oid,
    pub is_merge: bool,
    pub parents: [Option<Oid>; 2],
    pub children: Vec<Oid>,
    pub branches: Vec<usize>,
    pub branch_trace: Option<usize>,
}
[2025-09-21T15:05:05] tokens used: 160,609
[2025-09-21T15:05:05] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/main.rs b/src/main.rs
index 9a219bd44671407db7c27974d477f49946626499..72221a1a33480b43ce3319ba5f943257cd6f2062
--- a/src/main.rs
+++ b/src/main.rs
@@ -50,10 +50,10 @@
                 .help("Limit the number of commits to traverse"),
         )
         .arg(
-            Arg::with_name("head")
-                .long("head")
-                .short("h")
-                .help("Traverse commits reachable from HEAD only"),
+            Arg::with_name("all")
+                .long("all")
+                .short("a")
+                .help("Traverse commits reachable from all references"),
         )
         .arg(
             Arg::with_name("help")
@@ -78,7 +78,7 @@
     let debug = matches.is_present("debug");
     let compact = matches.is_present("compact");
     let colored = !matches.is_present("no-color");
-    let head_only = matches.is_present("head");
+    let traverse_all = matches.is_present("all");
     let path = matches.value_of("repository").unwrap_or(".");
 
     let characters = match matches.value_of("style") {
@@ -118,7 +118,7 @@
         characters,
     };
 
-    match run(path, &settings, svg_out, !head_only, commit_limit) {
+    match run(path, &settings, svg_out, traverse_all, commit_limit) {
         Ok(_) => process::exit(0),
         Err(err) => {
             eprintln!("{}", err);
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..3b875dc3be93b11197a69ae6bc00fb8d8562d52d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -606,6 +606,20 @@
     if current == new {
         return current;
     }
+
+    let connects_vertically = |glyph| {
+        matches!(
+            glyph,
+            GLYPH_TURN_UP_RIGHT | GLYPH_TURN_UP_LEFT | GLYPH_TURN_DOWN_RIGHT | GLYPH_TURN_DOWN_LEFT
+        )
+    };
+
+    if (connects_vertically(current) && new == GLYPH_HOR)
+        || (connects_vertically(new) && current == GLYPH_HOR)
+    {
+        return GLYPH_CROSS;
+    }
+
     let current_bits = LineBits::from_glyph(current);
     let new_bits = LineBits::from_glyph(new);
     current_bits.merge(new_bits).to_glyph()
@@ -614,26 +628,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
-                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
                     }
+                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,


[2025-09-21T15:05:09] thinking

**Reviewing BranchInfo::new calls**
[2025-09-21T15:05:09] exec bash -lc "sed -n '260,360p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T15:05:09] bash -lc "sed -n '260,360p' src/graph.rs" succeeded in 10ms:
            } else {
                None
            }
        })
        .collect();

    Ok(branches_ordered)
}

/// Extracts (real or derived from merge summary) and assigns basic properties.
fn extract_branches(
    repository: &Repository,
    commits: &[CommitInfo],
    indices: &HashMap<Oid, usize>,
    settings: &Settings,
) -> Result<Vec<BranchInfo>, Error> {
    let filter = if settings.include_remote {
        None
    } else {
        Some(BranchType::Local)
[2025-09-21T15:05:09] tokens used: 161,636
[2025-09-21T15:05:09] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/main.rs b/src/main.rs
index 9a219bd44671407db7c27974d477f49946626499..72221a1a33480b43ce3319ba5f943257cd6f2062
--- a/src/main.rs
+++ b/src/main.rs
@@ -50,10 +50,10 @@
                 .help("Limit the number of commits to traverse"),
         )
         .arg(
-            Arg::with_name("head")
-                .long("head")
-                .short("h")
-                .help("Traverse commits reachable from HEAD only"),
+            Arg::with_name("all")
+                .long("all")
+                .short("a")
+                .help("Traverse commits reachable from all references"),
         )
         .arg(
             Arg::with_name("help")
@@ -78,7 +78,7 @@
     let debug = matches.is_present("debug");
     let compact = matches.is_present("compact");
     let colored = !matches.is_present("no-color");
-    let head_only = matches.is_present("head");
+    let traverse_all = matches.is_present("all");
     let path = matches.value_of("repository").unwrap_or(".");
 
     let characters = match matches.value_of("style") {
@@ -118,7 +118,7 @@
         characters,
     };
 
-    match run(path, &settings, svg_out, !head_only, commit_limit) {
+    match run(path, &settings, svg_out, traverse_all, commit_limit) {
         Ok(_) => process::exit(0),
         Err(err) => {
             eprintln!("{}", err);
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..3b875dc3be93b11197a69ae6bc00fb8d8562d52d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -606,6 +606,20 @@
     if current == new {
         return current;
     }
+
+    let connects_vertically = |glyph| {
+        matches!(
+            glyph,
+            GLYPH_TURN_UP_RIGHT | GLYPH_TURN_UP_LEFT | GLYPH_TURN_DOWN_RIGHT | GLYPH_TURN_DOWN_LEFT
+        )
+    };
+
+    if (connects_vertically(current) && new == GLYPH_HOR)
+        || (connects_vertically(new) && current == GLYPH_HOR)
+    {
+        return GLYPH_CROSS;
+    }
+
     let current_bits = LineBits::from_glyph(current);
     let new_bits = LineBits::from_glyph(new);
     current_bits.merge(new_bits).to_glyph()
@@ -614,26 +628,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
-                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
                     }
+                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,


[2025-09-21T15:05:13] thinking

**Verifying renamed function usage**
[2025-09-21T15:05:13] exec bash -lc "sed -n '480,620p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T15:05:13] bash -lc "sed -n '480,620p' src/graph.rs" succeeded in 11ms:
            }
        }

        loop {
            let end = end_queue.pop_front();
            if let Some(end) = end {
                if end.1 == idx {
                    let branch = &mut branches[end.0];
                    let group = &mut occupied[branch.visual.order_group];
                    if let Some(column) = branch.visual.column {
                        group[column] = false;
                    }
                } else {
                    end_queue.push_front(end);
                    break;
                }
            } else {
                break;
            }
        }
[2025-09-21T15:05:13] tokens used: 162,648
[2025-09-21T15:05:13] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/main.rs b/src/main.rs
index 9a219bd44671407db7c27974d477f49946626499..72221a1a33480b43ce3319ba5f943257cd6f2062
--- a/src/main.rs
+++ b/src/main.rs
@@ -50,10 +50,10 @@
                 .help("Limit the number of commits to traverse"),
         )
         .arg(
-            Arg::with_name("head")
-                .long("head")
-                .short("h")
-                .help("Traverse commits reachable from HEAD only"),
+            Arg::with_name("all")
+                .long("all")
+                .short("a")
+                .help("Traverse commits reachable from all references"),
         )
         .arg(
             Arg::with_name("help")
@@ -78,7 +78,7 @@
     let debug = matches.is_present("debug");
     let compact = matches.is_present("compact");
     let colored = !matches.is_present("no-color");
-    let head_only = matches.is_present("head");
+    let traverse_all = matches.is_present("all");
     let path = matches.value_of("repository").unwrap_or(".");
 
     let characters = match matches.value_of("style") {
@@ -118,7 +118,7 @@
         characters,
     };
 
-    match run(path, &settings, svg_out, !head_only, commit_limit) {
+    match run(path, &settings, svg_out, traverse_all, commit_limit) {
         Ok(_) => process::exit(0),
         Err(err) => {
             eprintln!("{}", err);
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..3b875dc3be93b11197a69ae6bc00fb8d8562d52d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -606,6 +606,20 @@
     if current == new {
         return current;
     }
+
+    let connects_vertically = |glyph| {
+        matches!(
+            glyph,
+            GLYPH_TURN_UP_RIGHT | GLYPH_TURN_UP_LEFT | GLYPH_TURN_DOWN_RIGHT | GLYPH_TURN_DOWN_LEFT
+        )
+    };
+
+    if (connects_vertically(current) && new == GLYPH_HOR)
+        || (connects_vertically(new) && current == GLYPH_HOR)
+    {
+        return GLYPH_CROSS;
+    }
+
     let current_bits = LineBits::from_glyph(current);
     let new_bits = LineBits::from_glyph(new);
     current_bits.merge(new_bits).to_glyph()
@@ -614,26 +628,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
-                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
                     }
+                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,


[2025-09-21T15:05:19] thinking

**Verifying merge_branch and code formatting**
[2025-09-21T15:05:20] exec bash -lc "sed -n '560,700p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T15:05:20] bash -lc "sed -n '560,700p' src/print/unicode.rs" succeeded in 21ms:
    fn merge(self, other: LineBits) -> LineBits {
        let mut bits = self;
        bits.up |= other.up;
        bits.down |= other.down;
        bits.left |= other.left;
        bits.right |= other.right;
        bits.arrow_left |= other.arrow_left;
        bits.arrow_right |= other.arrow_right;
        bits.node = bits.node.or(other.node);
        bits
    }

    fn to_glyph(self) -> u8 {
        if let Some(node) = self.node {
            return node;
        }

        if self.arrow_left {
            return GLYPH_ARROW_LEFT;
        }
[2025-09-21T15:05:20] tokens used: 164,029
[2025-09-21T15:05:20] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/main.rs b/src/main.rs
index 9a219bd44671407db7c27974d477f49946626499..72221a1a33480b43ce3319ba5f943257cd6f2062
--- a/src/main.rs
+++ b/src/main.rs
@@ -50,10 +50,10 @@
                 .help("Limit the number of commits to traverse"),
         )
         .arg(
-            Arg::with_name("head")
-                .long("head")
-                .short("h")
-                .help("Traverse commits reachable from HEAD only"),
+            Arg::with_name("all")
+                .long("all")
+                .short("a")
+                .help("Traverse commits reachable from all references"),
         )
         .arg(
             Arg::with_name("help")
@@ -78,7 +78,7 @@
     let debug = matches.is_present("debug");
     let compact = matches.is_present("compact");
     let colored = !matches.is_present("no-color");
-    let head_only = matches.is_present("head");
+    let traverse_all = matches.is_present("all");
     let path = matches.value_of("repository").unwrap_or(".");
 
     let characters = match matches.value_of("style") {
@@ -118,7 +118,7 @@
         characters,
     };
 
-    match run(path, &settings, svg_out, !head_only, commit_limit) {
+    match run(path, &settings, svg_out, traverse_all, commit_limit) {
         Ok(_) => process::exit(0),
         Err(err) => {
             eprintln!("{}", err);
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..3b875dc3be93b11197a69ae6bc00fb8d8562d52d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -606,6 +606,20 @@
     if current == new {
         return current;
     }
+
+    let connects_vertically = |glyph| {
+        matches!(
+            glyph,
+            GLYPH_TURN_UP_RIGHT | GLYPH_TURN_UP_LEFT | GLYPH_TURN_DOWN_RIGHT | GLYPH_TURN_DOWN_LEFT
+        )
+    };
+
+    if (connects_vertically(current) && new == GLYPH_HOR)
+        || (connects_vertically(new) && current == GLYPH_HOR)
+    {
+        return GLYPH_CROSS;
+    }
+
     let current_bits = LineBits::from_glyph(current);
     let new_bits = LineBits::from_glyph(new);
     current_bits.merge(new_bits).to_glyph()
@@ -614,26 +628,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
-                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
                     }
+                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,


[2025-09-21T15:05:28] thinking

**Preparing to build and test changes**
[2025-09-21T15:05:28] exec bash -lc 'cargo build' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T15:05:38] bash -lc 'cargo build' exited 124 in 10.01s:
    Updating crates.io index
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
[2025-09-21T15:05:38] tokens used: 165,705
[2025-09-21T15:05:38] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/main.rs b/src/main.rs
index 9a219bd44671407db7c27974d477f49946626499..72221a1a33480b43ce3319ba5f943257cd6f2062
--- a/src/main.rs
+++ b/src/main.rs
@@ -50,10 +50,10 @@
                 .help("Limit the number of commits to traverse"),
         )
         .arg(
-            Arg::with_name("head")
-                .long("head")
-                .short("h")
-                .help("Traverse commits reachable from HEAD only"),
+            Arg::with_name("all")
+                .long("all")
+                .short("a")
+                .help("Traverse commits reachable from all references"),
         )
         .arg(
             Arg::with_name("help")
@@ -78,7 +78,7 @@
     let debug = matches.is_present("debug");
     let compact = matches.is_present("compact");
     let colored = !matches.is_present("no-color");
-    let head_only = matches.is_present("head");
+    let traverse_all = matches.is_present("all");
     let path = matches.value_of("repository").unwrap_or(".");
 
     let characters = match matches.value_of("style") {
@@ -118,7 +118,7 @@
         characters,
     };
 
-    match run(path, &settings, svg_out, !head_only, commit_limit) {
+    match run(path, &settings, svg_out, traverse_all, commit_limit) {
         Ok(_) => process::exit(0),
         Err(err) => {
             eprintln!("{}", err);
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..3b875dc3be93b11197a69ae6bc00fb8d8562d52d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -606,6 +606,20 @@
     if current == new {
         return current;
     }
+
+    let connects_vertically = |glyph| {
+        matches!(
+            glyph,
+            GLYPH_TURN_UP_RIGHT | GLYPH_TURN_UP_LEFT | GLYPH_TURN_DOWN_RIGHT | GLYPH_TURN_DOWN_LEFT
+        )
+    };
+
+    if (connects_vertically(current) && new == GLYPH_HOR)
+        || (connects_vertically(new) && current == GLYPH_HOR)
+    {
+        return GLYPH_CROSS;
+    }
+
     let current_bits = LineBits::from_glyph(current);
     let new_bits = LineBits::from_glyph(new);
     current_bits.merge(new_bits).to_glyph()
@@ -614,26 +628,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
-                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
                     }
+                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,


[2025-09-21T15:05:43] thinking

**Handling network-restricted build failure**
[2025-09-21T15:05:44] exec bash -lc 'git status --short' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T15:05:44] bash -lc 'git status --short' succeeded in 18ms:
 M src/graph.rs
 M src/main.rs
 M src/print/unicode.rs
[2025-09-21T15:05:44] tokens used: 166,159
[2025-09-21T15:05:44] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/main.rs b/src/main.rs
index 9a219bd44671407db7c27974d477f49946626499..72221a1a33480b43ce3319ba5f943257cd6f2062
--- a/src/main.rs
+++ b/src/main.rs
@@ -50,10 +50,10 @@
                 .help("Limit the number of commits to traverse"),
         )
         .arg(
-            Arg::with_name("head")
-                .long("head")
-                .short("h")
-                .help("Traverse commits reachable from HEAD only"),
+            Arg::with_name("all")
+                .long("all")
+                .short("a")
+                .help("Traverse commits reachable from all references"),
         )
         .arg(
             Arg::with_name("help")
@@ -78,7 +78,7 @@
     let debug = matches.is_present("debug");
     let compact = matches.is_present("compact");
     let colored = !matches.is_present("no-color");
-    let head_only = matches.is_present("head");
+    let traverse_all = matches.is_present("all");
     let path = matches.value_of("repository").unwrap_or(".");
 
     let characters = match matches.value_of("style") {
@@ -118,7 +118,7 @@
         characters,
     };
 
-    match run(path, &settings, svg_out, !head_only, commit_limit) {
+    match run(path, &settings, svg_out, traverse_all, commit_limit) {
         Ok(_) => process::exit(0),
         Err(err) => {
             eprintln!("{}", err);
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..3b875dc3be93b11197a69ae6bc00fb8d8562d52d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -606,6 +606,20 @@
     if current == new {
         return current;
     }
+
+    let connects_vertically = |glyph| {
+        matches!(
+            glyph,
+            GLYPH_TURN_UP_RIGHT | GLYPH_TURN_UP_LEFT | GLYPH_TURN_DOWN_RIGHT | GLYPH_TURN_DOWN_LEFT
+        )
+    };
+
+    if (connects_vertically(current) && new == GLYPH_HOR)
+        || (connects_vertically(new) && current == GLYPH_HOR)
+    {
+        return GLYPH_CROSS;
+    }
+
     let current_bits = LineBits::from_glyph(current);
     let new_bits = LineBits::from_glyph(new);
     current_bits.merge(new_bits).to_glyph()
@@ -614,26 +628,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
-                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
                     }
+                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,


[2025-09-21T15:05:49] thinking

**Preparing to stage and commit changes**
[2025-09-21T15:05:49] exec bash -lc 'git add -A' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T15:05:49] bash -lc 'git add -A' succeeded in 28ms:

[2025-09-21T15:05:49] tokens used: 166,392
[2025-09-21T15:05:49] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/main.rs b/src/main.rs
index 9a219bd44671407db7c27974d477f49946626499..72221a1a33480b43ce3319ba5f943257cd6f2062
--- a/src/main.rs
+++ b/src/main.rs
@@ -50,10 +50,10 @@
                 .help("Limit the number of commits to traverse"),
         )
         .arg(
-            Arg::with_name("head")
-                .long("head")
-                .short("h")
-                .help("Traverse commits reachable from HEAD only"),
+            Arg::with_name("all")
+                .long("all")
+                .short("a")
+                .help("Traverse commits reachable from all references"),
         )
         .arg(
             Arg::with_name("help")
@@ -78,7 +78,7 @@
     let debug = matches.is_present("debug");
     let compact = matches.is_present("compact");
     let colored = !matches.is_present("no-color");
-    let head_only = matches.is_present("head");
+    let traverse_all = matches.is_present("all");
     let path = matches.value_of("repository").unwrap_or(".");
 
     let characters = match matches.value_of("style") {
@@ -118,7 +118,7 @@
         characters,
     };
 
-    match run(path, &settings, svg_out, !head_only, commit_limit) {
+    match run(path, &settings, svg_out, traverse_all, commit_limit) {
         Ok(_) => process::exit(0),
         Err(err) => {
             eprintln!("{}", err);
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..3b875dc3be93b11197a69ae6bc00fb8d8562d52d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -606,6 +606,20 @@
     if current == new {
         return current;
     }
+
+    let connects_vertically = |glyph| {
+        matches!(
+            glyph,
+            GLYPH_TURN_UP_RIGHT | GLYPH_TURN_UP_LEFT | GLYPH_TURN_DOWN_RIGHT | GLYPH_TURN_DOWN_LEFT
+        )
+    };
+
+    if (connects_vertically(current) && new == GLYPH_HOR)
+        || (connects_vertically(new) && current == GLYPH_HOR)
+    {
+        return GLYPH_CROSS;
+    }
+
     let current_bits = LineBits::from_glyph(current);
     let new_bits = LineBits::from_glyph(new);
     current_bits.merge(new_bits).to_glyph()
@@ -614,26 +628,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
-                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
                     }
+                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,


[2025-09-21T15:05:53] thinking

**Committing with provided message**
[2025-09-21T15:05:53] exec bash -lc 'git commit -m "029-265dfe6：复现提交代码内容。"' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T15:05:53] bash -lc 'git commit -m "029-265dfe6：复现提交代码内容。"' succeeded in 31ms:
[main bd6976d] 029-265dfe6：复现提交代码内容。
 3 files changed, 84 insertions(+), 28 deletions(-)
[2025-09-21T15:05:53] tokens used: 166,612
[2025-09-21T15:05:53] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/main.rs b/src/main.rs
index 9a219bd44671407db7c27974d477f49946626499..72221a1a33480b43ce3319ba5f943257cd6f2062
--- a/src/main.rs
+++ b/src/main.rs
@@ -50,10 +50,10 @@
                 .help("Limit the number of commits to traverse"),
         )
         .arg(
-            Arg::with_name("head")
-                .long("head")
-                .short("h")
-                .help("Traverse commits reachable from HEAD only"),
+            Arg::with_name("all")
+                .long("all")
+                .short("a")
+                .help("Traverse commits reachable from all references"),
         )
         .arg(
             Arg::with_name("help")
@@ -78,7 +78,7 @@
     let debug = matches.is_present("debug");
     let compact = matches.is_present("compact");
     let colored = !matches.is_present("no-color");
-    let head_only = matches.is_present("head");
+    let traverse_all = matches.is_present("all");
     let path = matches.value_of("repository").unwrap_or(".");
 
     let characters = match matches.value_of("style") {
@@ -118,7 +118,7 @@
         characters,
     };
 
-    match run(path, &settings, svg_out, !head_only, commit_limit) {
+    match run(path, &settings, svg_out, traverse_all, commit_limit) {
         Ok(_) => process::exit(0),
         Err(err) => {
             eprintln!("{}", err);
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..3b875dc3be93b11197a69ae6bc00fb8d8562d52d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -606,6 +606,20 @@
     if current == new {
         return current;
     }
+
+    let connects_vertically = |glyph| {
+        matches!(
+            glyph,
+            GLYPH_TURN_UP_RIGHT | GLYPH_TURN_UP_LEFT | GLYPH_TURN_DOWN_RIGHT | GLYPH_TURN_DOWN_LEFT
+        )
+    };
+
+    if (connects_vertically(current) && new == GLYPH_HOR)
+        || (connects_vertically(new) && current == GLYPH_HOR)
+    {
+        return GLYPH_CROSS;
+    }
+
     let current_bits = LineBits::from_glyph(current);
     let new_bits = LineBits::from_glyph(new);
     current_bits.merge(new_bits).to_glyph()
@@ -614,26 +628,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
-                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
                     }
+                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,


[2025-09-21T15:06:01] thinking

**Preparing line references for summary**
[2025-09-21T15:06:01] exec bash -lc "nl -ba src/graph.rs | sed -n '130,220p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T15:06:01] bash -lc "nl -ba src/graph.rs | sed -n '130,220p'" succeeded in 29ms:
   130	
   131	/// Represents a commit.
   132	pub struct CommitInfo {
   133	    pub oid: Oid,
   134	    pub is_merge: bool,
   135	    pub parents: [Option<Oid>; 2],
   136	    pub children: Vec<Oid>,
   137	    pub branches: Vec<usize>,
   138	    pub branch_trace: Option<usize>,
   139	}
   140	
   141	impl CommitInfo {
   142	    fn new(commit: &Commit) -> Self {
   143	        CommitInfo {
   144	            oid: commit.id(),
   145	            is_merge: commit.parent_count() > 1,
   146	            parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
   147	            children: Vec::new(),
   148	            branches: Vec::new(),
   149	            branch_trace: None,
[2025-09-21T15:06:01] tokens used: 167,106
[2025-09-21T15:06:01] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/main.rs b/src/main.rs
index 9a219bd44671407db7c27974d477f49946626499..72221a1a33480b43ce3319ba5f943257cd6f2062
--- a/src/main.rs
+++ b/src/main.rs
@@ -50,10 +50,10 @@
                 .help("Limit the number of commits to traverse"),
         )
         .arg(
-            Arg::with_name("head")
-                .long("head")
-                .short("h")
-                .help("Traverse commits reachable from HEAD only"),
+            Arg::with_name("all")
+                .long("all")
+                .short("a")
+                .help("Traverse commits reachable from all references"),
         )
         .arg(
             Arg::with_name("help")
@@ -78,7 +78,7 @@
     let debug = matches.is_present("debug");
     let compact = matches.is_present("compact");
     let colored = !matches.is_present("no-color");
-    let head_only = matches.is_present("head");
+    let traverse_all = matches.is_present("all");
     let path = matches.value_of("repository").unwrap_or(".");
 
     let characters = match matches.value_of("style") {
@@ -118,7 +118,7 @@
         characters,
     };
 
-    match run(path, &settings, svg_out, !head_only, commit_limit) {
+    match run(path, &settings, svg_out, traverse_all, commit_limit) {
         Ok(_) => process::exit(0),
         Err(err) => {
             eprintln!("{}", err);
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..3b875dc3be93b11197a69ae6bc00fb8d8562d52d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -606,6 +606,20 @@
     if current == new {
         return current;
     }
+
+    let connects_vertically = |glyph| {
+        matches!(
+            glyph,
+            GLYPH_TURN_UP_RIGHT | GLYPH_TURN_UP_LEFT | GLYPH_TURN_DOWN_RIGHT | GLYPH_TURN_DOWN_LEFT
+        )
+    };
+
+    if (connects_vertically(current) && new == GLYPH_HOR)
+        || (connects_vertically(new) && current == GLYPH_HOR)
+    {
+        return GLYPH_CROSS;
+    }
+
     let current_bits = LineBits::from_glyph(current);
     let new_bits = LineBits::from_glyph(new);
     current_bits.merge(new_bits).to_glyph()
@@ -614,26 +628,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
-                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
                     }
+                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,


[2025-09-21T15:06:06] thinking

**Finding relevant code snippet**
[2025-09-21T15:06:07] exec bash -lc "nl -ba src/graph.rs | sed -n '460,620p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T15:06:07] bash -lc "nl -ba src/graph.rs | sed -n '460,620p'" succeeded in 13ms:
   460	                if start.1 == idx {
   461	                    let branch = &mut branches[start.0];
   462	                    let group = &mut occupied[branch.visual.order_group];
   463	                    let column = group
   464	                        .iter()
   465	                        .find_position(|val| !**val)
   466	                        .unwrap_or_else(|| (group.len(), &false))
   467	                        .0;
   468	                    branch.visual.column = Some(column);
   469	                    if column < group.len() {
   470	                        group[column] = true;
   471	                    } else {
   472	                        group.push(true);
   473	                    }
   474	                } else {
   475	                    start_queue.push_front(start);
   476	                    break;
   477	                }
   478	            } else {
   479	                break;
[2025-09-21T15:06:07] tokens used: 168,344
[2025-09-21T15:06:07] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/main.rs b/src/main.rs
index 9a219bd44671407db7c27974d477f49946626499..72221a1a33480b43ce3319ba5f943257cd6f2062
--- a/src/main.rs
+++ b/src/main.rs
@@ -50,10 +50,10 @@
                 .help("Limit the number of commits to traverse"),
         )
         .arg(
-            Arg::with_name("head")
-                .long("head")
-                .short("h")
-                .help("Traverse commits reachable from HEAD only"),
+            Arg::with_name("all")
+                .long("all")
+                .short("a")
+                .help("Traverse commits reachable from all references"),
         )
         .arg(
             Arg::with_name("help")
@@ -78,7 +78,7 @@
     let debug = matches.is_present("debug");
     let compact = matches.is_present("compact");
     let colored = !matches.is_present("no-color");
-    let head_only = matches.is_present("head");
+    let traverse_all = matches.is_present("all");
     let path = matches.value_of("repository").unwrap_or(".");
 
     let characters = match matches.value_of("style") {
@@ -118,7 +118,7 @@
         characters,
     };
 
-    match run(path, &settings, svg_out, !head_only, commit_limit) {
+    match run(path, &settings, svg_out, traverse_all, commit_limit) {
         Ok(_) => process::exit(0),
         Err(err) => {
             eprintln!("{}", err);
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..3b875dc3be93b11197a69ae6bc00fb8d8562d52d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -606,6 +606,20 @@
     if current == new {
         return current;
     }
+
+    let connects_vertically = |glyph| {
+        matches!(
+            glyph,
+            GLYPH_TURN_UP_RIGHT | GLYPH_TURN_UP_LEFT | GLYPH_TURN_DOWN_RIGHT | GLYPH_TURN_DOWN_LEFT
+        )
+    };
+
+    if (connects_vertically(current) && new == GLYPH_HOR)
+        || (connects_vertically(new) && current == GLYPH_HOR)
+    {
+        return GLYPH_CROSS;
+    }
+
     let current_bits = LineBits::from_glyph(current);
     let new_bits = LineBits::from_glyph(new);
     current_bits.merge(new_bits).to_glyph()
@@ -614,26 +628,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
-                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
                     }
+                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,


[2025-09-21T15:06:12] thinking

**Preparing to add line numbers**
[2025-09-21T15:06:13] exec bash -lc "nl -ba src/print/unicode.rs | sed -n '560,720p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T15:06:13] bash -lc "nl -ba src/print/unicode.rs | sed -n '560,720p'" succeeded in 28ms:
   560	    fn merge(self, other: LineBits) -> LineBits {
   561	        let mut bits = self;
   562	        bits.up |= other.up;
   563	        bits.down |= other.down;
   564	        bits.left |= other.left;
   565	        bits.right |= other.right;
   566	        bits.arrow_left |= other.arrow_left;
   567	        bits.arrow_right |= other.arrow_right;
   568	        bits.node = bits.node.or(other.node);
   569	        bits
   570	    }
   571	
   572	    fn to_glyph(self) -> u8 {
   573	        if let Some(node) = self.node {
   574	            return node;
   575	        }
   576	
   577	        if self.arrow_left {
   578	            return GLYPH_ARROW_LEFT;
   579	        }
[2025-09-21T15:06:13] tokens used: 170,432
[2025-09-21T15:06:13] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/main.rs b/src/main.rs
index 9a219bd44671407db7c27974d477f49946626499..72221a1a33480b43ce3319ba5f943257cd6f2062
--- a/src/main.rs
+++ b/src/main.rs
@@ -50,10 +50,10 @@
                 .help("Limit the number of commits to traverse"),
         )
         .arg(
-            Arg::with_name("head")
-                .long("head")
-                .short("h")
-                .help("Traverse commits reachable from HEAD only"),
+            Arg::with_name("all")
+                .long("all")
+                .short("a")
+                .help("Traverse commits reachable from all references"),
         )
         .arg(
             Arg::with_name("help")
@@ -78,7 +78,7 @@
     let debug = matches.is_present("debug");
     let compact = matches.is_present("compact");
     let colored = !matches.is_present("no-color");
-    let head_only = matches.is_present("head");
+    let traverse_all = matches.is_present("all");
     let path = matches.value_of("repository").unwrap_or(".");
 
     let characters = match matches.value_of("style") {
@@ -118,7 +118,7 @@
         characters,
     };
 
-    match run(path, &settings, svg_out, !head_only, commit_limit) {
+    match run(path, &settings, svg_out, traverse_all, commit_limit) {
         Ok(_) => process::exit(0),
         Err(err) => {
             eprintln!("{}", err);
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..3b875dc3be93b11197a69ae6bc00fb8d8562d52d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -606,6 +606,20 @@
     if current == new {
         return current;
     }
+
+    let connects_vertically = |glyph| {
+        matches!(
+            glyph,
+            GLYPH_TURN_UP_RIGHT | GLYPH_TURN_UP_LEFT | GLYPH_TURN_DOWN_RIGHT | GLYPH_TURN_DOWN_LEFT
+        )
+    };
+
+    if (connects_vertically(current) && new == GLYPH_HOR)
+        || (connects_vertically(new) && current == GLYPH_HOR)
+    {
+        return GLYPH_CROSS;
+    }
+
     let current_bits = LineBits::from_glyph(current);
     let new_bits = LineBits::from_glyph(new);
     current_bits.merge(new_bits).to_glyph()
@@ -614,26 +628,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
-                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
                     }
+                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,


[2025-09-21T15:06:18] thinking

**Preparing to review main.rs**
[2025-09-21T15:06:18] exec bash -lc "nl -ba src/main.rs | sed -n '1,220p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T15:06:18] bash -lc "nl -ba src/main.rs | sed -n '1,220p'" succeeded in 15ms:
     1	use clap::{App, AppSettings, Arg};
     2	use git_graph::graph::{CommitInfo, GitGraph};
     3	use git_graph::print::svg::print_svg;
     4	use git_graph::print::unicode::print_unicode;
     5	use git_graph::settings::{BranchOrder, BranchSettings, Characters, MergePatterns, Settings};
     6	use std::process;
     7	use std::time::Instant;
     8	
     9	fn main() {
    10	    let mut app = App::new("git-graph")
    11	        .setting(AppSettings::DisableHelpFlags)
    12	        .version(env!("CARGO_PKG_VERSION"))
    13	        .about("Render git commit graphs as Unicode or SVG")
    14	        .arg(
    15	            Arg::with_name("svg")
    16	                .long("svg")
    17	                .help("Render SVG output instead of console output"),
    18	        )
    19	        .arg(
    20	            Arg::with_name("compact")
[2025-09-21T15:06:18] tokens used: 172,692
[2025-09-21T15:06:18] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/main.rs b/src/main.rs
index 9a219bd44671407db7c27974d477f49946626499..72221a1a33480b43ce3319ba5f943257cd6f2062
--- a/src/main.rs
+++ b/src/main.rs
@@ -50,10 +50,10 @@
                 .help("Limit the number of commits to traverse"),
         )
         .arg(
-            Arg::with_name("head")
-                .long("head")
-                .short("h")
-                .help("Traverse commits reachable from HEAD only"),
+            Arg::with_name("all")
+                .long("all")
+                .short("a")
+                .help("Traverse commits reachable from all references"),
         )
         .arg(
             Arg::with_name("help")
@@ -78,7 +78,7 @@
     let debug = matches.is_present("debug");
     let compact = matches.is_present("compact");
     let colored = !matches.is_present("no-color");
-    let head_only = matches.is_present("head");
+    let traverse_all = matches.is_present("all");
     let path = matches.value_of("repository").unwrap_or(".");
 
     let characters = match matches.value_of("style") {
@@ -118,7 +118,7 @@
         characters,
     };
 
-    match run(path, &settings, svg_out, !head_only, commit_limit) {
+    match run(path, &settings, svg_out, traverse_all, commit_limit) {
         Ok(_) => process::exit(0),
         Err(err) => {
             eprintln!("{}", err);
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..3b875dc3be93b11197a69ae6bc00fb8d8562d52d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -606,6 +606,20 @@
     if current == new {
         return current;
     }
+
+    let connects_vertically = |glyph| {
+        matches!(
+            glyph,
+            GLYPH_TURN_UP_RIGHT | GLYPH_TURN_UP_LEFT | GLYPH_TURN_DOWN_RIGHT | GLYPH_TURN_DOWN_LEFT
+        )
+    };
+
+    if (connects_vertically(current) && new == GLYPH_HOR)
+        || (connects_vertically(new) && current == GLYPH_HOR)
+    {
+        return GLYPH_CROSS;
+    }
+
     let current_bits = LineBits::from_glyph(current);
     let new_bits = LineBits::from_glyph(new);
     current_bits.merge(new_bits).to_glyph()
@@ -614,26 +628,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
-                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
                     }
+                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,


[2025-09-21T15:06:23] thinking

**Preparing final summary details**
[2025-09-21T15:06:24] exec bash -lc 'git status --short' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T15:06:24] bash -lc 'git status --short' succeeded in 24ms:

[2025-09-21T15:06:24] tokens used: 175,631
[2025-09-21T15:06:24] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/main.rs b/src/main.rs
index 9a219bd44671407db7c27974d477f49946626499..72221a1a33480b43ce3319ba5f943257cd6f2062
--- a/src/main.rs
+++ b/src/main.rs
@@ -50,10 +50,10 @@
                 .help("Limit the number of commits to traverse"),
         )
         .arg(
-            Arg::with_name("head")
-                .long("head")
-                .short("h")
-                .help("Traverse commits reachable from HEAD only"),
+            Arg::with_name("all")
+                .long("all")
+                .short("a")
+                .help("Traverse commits reachable from all references"),
         )
         .arg(
             Arg::with_name("help")
@@ -78,7 +78,7 @@
     let debug = matches.is_present("debug");
     let compact = matches.is_present("compact");
     let colored = !matches.is_present("no-color");
-    let head_only = matches.is_present("head");
+    let traverse_all = matches.is_present("all");
     let path = matches.value_of("repository").unwrap_or(".");
 
     let characters = match matches.value_of("style") {
@@ -118,7 +118,7 @@
         characters,
     };
 
-    match run(path, &settings, svg_out, !head_only, commit_limit) {
+    match run(path, &settings, svg_out, traverse_all, commit_limit) {
         Ok(_) => process::exit(0),
         Err(err) => {
             eprintln!("{}", err);
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..3b875dc3be93b11197a69ae6bc00fb8d8562d52d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -606,6 +606,20 @@
     if current == new {
         return current;
     }
+
+    let connects_vertically = |glyph| {
+        matches!(
+            glyph,
+            GLYPH_TURN_UP_RIGHT | GLYPH_TURN_UP_LEFT | GLYPH_TURN_DOWN_RIGHT | GLYPH_TURN_DOWN_LEFT
+        )
+    };
+
+    if (connects_vertically(current) && new == GLYPH_HOR)
+        || (connects_vertically(new) && current == GLYPH_HOR)
+    {
+        return GLYPH_CROSS;
+    }
+
     let current_bits = LineBits::from_glyph(current);
     let new_bits = LineBits::from_glyph(new);
     current_bits.merge(new_bits).to_glyph()
@@ -614,26 +628,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
-                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
                     }
+                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,


[2025-09-21T15:06:56] thinking

**Composing final detailed response**

I'm preparing a clear final message that explains the changes with line-specific file references, verification status including build attempt results, key assumptions made, and natural next step suggestions like retrying `cargo build` when network is available. I will format the message with concise headers and bullet points, strictly following the specified style and content guidelines.
[2025-09-21T15:06:57] codex

**复现内容**
- src/graph.rs:155 增加 `merge_target` 字段，并在 src/graph.rs:524 的列分配中依据合并目标避让列位，同时在分支抽取时填充对应的合并信息，避免分支与合并目标同列。
- src/print/unicode.rs:605 调整 `merge_glyphs` 让横线与竖线端帽相交时渲染为十字；src/print/unicode.rs:631 在紧凑模式下仍保留首父插入线，贴合报告中的渲染修正。
- src/main.rs:53 将 CLI 开关改为 `--all/-a`，并默认仅遍历 HEAD，从而与提交说明一致地改进参数语义。

**说明**
- src/print/unicode.rs:637 依据分支追踪目标 Oid 推导插入判定所需的 `target_index`，以复现报告中对合并目标的处理逻辑。
- 已按要求完成提交 `029-265dfe6：复现提交代码内容。`.

**验证**
- `cargo build`（失败：离线环境无法更新 crates.io 索引，构建未完成）。

**后续建议**
- 1. 在可访问 crates.io 的环境中重试 `cargo build` 或 `cargo test`，确认编译与渲染路径均正常。
[2025-09-21T15:06:59] tokens used: 177,832
[2025-09-21T15:06:59] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 846d7c1b8b2f98d6a63ada3be524b78940571216..4f88d8d70c6945f5d2977224b3eb75c0ade02892
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -53,6 +53,7 @@
             }
             BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -60,6 +61,7 @@
             ),
             BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                 &commits,
+                &indices,
                 &mut branches,
                 &settings.branches,
                 forward,
@@ -152,6 +154,7 @@
 /// Represents a branch (real or derived from merge summary).
 pub struct BranchInfo {
     pub target: Oid,
+    pub merge_target: Option<Oid>,
     pub name: String,
     pub is_remote: bool,
     pub is_merged: bool,
@@ -163,6 +166,7 @@
 impl BranchInfo {
     fn new(
         target: Oid,
+        merge_target: Option<Oid>,
         name: String,
         is_remote: bool,
         is_merged: bool,
@@ -173,6 +177,7 @@
     ) -> Self {
         BranchInfo {
             target,
+            merge_target,
             name,
             is_remote,
             is_merged,
@@ -292,6 +297,7 @@
 
                     BranchInfo::new(
                         t,
+                        None,
                         name.to_string(),
                         &BranchType::Remote == tp,
                         false,
@@ -322,6 +328,7 @@
 
                 let branch_info = BranchInfo::new(
                     parent_oid,
+                    Some(info.oid),
                     branch_name,
                     false,
                     true,
@@ -515,7 +522,8 @@
 /// Sorts branches into columns for visualization, that all branches can be
 /// visualizes linearly and without overlaps. Uses Shortest-First or Longest-First scheduling.
 fn assign_branch_columns_branch_length(
-    _commits: &[CommitInfo],
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
     settings: &BranchSettings,
     forward: bool,
@@ -546,29 +554,50 @@
         .collect();
 
     for (branch_idx, start, end) in branches_sort {
-        let branch = &mut branches[branch_idx];
-        let group = branch.visual.order_group;
+        let group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
         let group_occ = &mut occupied[group];
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
+        let mut found = None;
+        for candidate in 0..=group_occ.len() {
             let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
+            if let Some(column_occ) = group_occ.get(candidate) {
+                for (s, e) in column_occ {
+                    if start <= *e && end >= *s {
+                        occ = true;
+                        break;
+                    }
                 }
             }
             if !occ {
-                found = i;
+                if let Some(merge_trace) = merge_target
+                    .and_then(|target| indices.get(&target).copied())
+                    .and_then(|target_idx| commits[target_idx].branch_trace)
+                {
+                    let merge_branch = &branches[merge_trace];
+                    if merge_branch.visual.order_group == group {
+                        if let Some(merge_column) = merge_branch.visual.column {
+                            if merge_column == candidate {
+                                occ = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if !occ {
+                found = Some(candidate);
                 break;
             }
         }
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+        let column = found.unwrap_or(group_occ.len());
+        if column == group_occ.len() {
+            group_occ.push(Vec::new());
         }
-        group_occ[found].push((start, end));
+        group_occ[column].push((start, end));
+
+        branches[branch_idx].visual.column = Some(column);
     }
 
     let group_offset: Vec<usize> = occupied
diff --git a/src/main.rs b/src/main.rs
index 9a219bd44671407db7c27974d477f49946626499..72221a1a33480b43ce3319ba5f943257cd6f2062
--- a/src/main.rs
+++ b/src/main.rs
@@ -50,10 +50,10 @@
                 .help("Limit the number of commits to traverse"),
         )
         .arg(
-            Arg::with_name("head")
-                .long("head")
-                .short("h")
-                .help("Traverse commits reachable from HEAD only"),
+            Arg::with_name("all")
+                .long("all")
+                .short("a")
+                .help("Traverse commits reachable from all references"),
         )
         .arg(
             Arg::with_name("help")
@@ -78,7 +78,7 @@
     let debug = matches.is_present("debug");
     let compact = matches.is_present("compact");
     let colored = !matches.is_present("no-color");
-    let head_only = matches.is_present("head");
+    let traverse_all = matches.is_present("all");
     let path = matches.value_of("repository").unwrap_or(".");
 
     let characters = match matches.value_of("style") {
@@ -118,7 +118,7 @@
         characters,
     };
 
-    match run(path, &settings, svg_out, !head_only, commit_limit) {
+    match run(path, &settings, svg_out, traverse_all, commit_limit) {
         Ok(_) => process::exit(0),
         Err(err) => {
             eprintln!("{}", err);
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index d1c7a388baae1e153d8ced84c3b7be9876f9c549..3b875dc3be93b11197a69ae6bc00fb8d8562d52d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -606,6 +606,20 @@
     if current == new {
         return current;
     }
+
+    let connects_vertically = |glyph| {
+        matches!(
+            glyph,
+            GLYPH_TURN_UP_RIGHT | GLYPH_TURN_UP_LEFT | GLYPH_TURN_DOWN_RIGHT | GLYPH_TURN_DOWN_LEFT
+        )
+    };
+
+    if (connects_vertically(current) && new == GLYPH_HOR)
+        || (connects_vertically(new) && current == GLYPH_HOR)
+    {
+        return GLYPH_CROSS;
+    }
+
     let current_bits = LineBits::from_glyph(current);
     let new_bits = LineBits::from_glyph(new);
     current_bits.merge(new_bits).to_glyph()
@@ -614,26 +628,39 @@
 fn get_inserts(graph: &GitGraph, compact: bool) -> Vec<Vec<Insert>> {
     let mut inserts: Vec<Vec<Insert>> = vec![Vec::new(); graph.commits.len()];
 
-    for (child_index, commit) in graph.commits.iter().enumerate() {
-        let from_col = match commit_column(graph, commit) {
+    for (child_index, info) in graph.commits.iter().enumerate() {
+        let from_col = match commit_column(graph, info) {
             Some(col) => col,
             None => continue,
         };
 
+        let target_index = info.branch_trace.and_then(|branch_idx| {
+            graph
+                .branches
+                .get(branch_idx)
+                .and_then(|branch| graph.indices.get(&branch.target).copied())
+        });
+
         let mut edges: Vec<Insert> = Vec::new();
 
-        for parent_oid in commit.parents.iter().flatten() {
+        for (p, parent_oid_opt) in info.parents.iter().enumerate() {
+            let Some(parent_oid) = parent_oid_opt else {
+                continue;
+            };
+
             if let Some(&parent_index) = graph.indices.get(parent_oid) {
                 if let Some(parent_col) = commit_column(graph, &graph.commits[parent_index]) {
                     if parent_col == from_col {
                         continue;
                     }
-                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
-                    if compact {
-                        // TODO(026-23e2c76): Original heuristics for compact mode are
-                        // unavailable in the report. We keep the edge while relying on
-                        // standard layering so that merges remain connected.
+                    if compact
+                        && info.is_merge
+                        && target_index.map_or(false, |t| t == parent_index)
+                        && p != 0
+                    {
+                        continue;
                     }
+                    let layer = get_deviate_index(graph, parent_index, child_index).unwrap_or(0);
                     edges.push(Insert {
                         parent_index,
                         to_col: parent_col,


=== 错误 ===
2025-09-21T14:57:32.407496Z ERROR codex_core::exec: exec error: No such file or directory (os error 2)

=== 最终状态 ===
返回码: 0
状态: ✅ 执行成功
