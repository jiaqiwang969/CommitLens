=== 任务 042-5e631c2 执行日志 ===
时间: 2025-09-22 00:55:36.108960
Prompt:
请在 .workspace 内，依据 .workspace/todolist/todolist-042-5e631c2.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/042-5e631c2/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："042-5e631c2：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 042-5e631c2

=== 输出 ===
[2025-09-21T16:30:37] OpenAI Codex v0.39.0 (research preview)
--------
workdir: /Users/jqwang/104-CommitLens-codex/.workspace
model: gpt-5-codex-high
provider: codex
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
--------
[2025-09-21T16:30:37] User instructions:
请在 .workspace 内，依据 .workspace/todolist/todolist-042-5e631c2.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/042-5e631c2/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："042-5e631c2：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 042-5e631c2

[2025-09-21T16:30:49] thinking

**Deciding on planning approach**
[2025-09-21T16:30:49] exec bash -lc pwd in /Users/jqwang/104-CommitLens-codex/.workspace/.workspace
[2025-09-21T16:30:49] bash -lc pwd exited -1 in 0ms:
No such file or directory (os error 2)
[2025-09-21T16:30:49] tokens used: 849

[2025-09-21T16:30:56] thinking

**Adjusting workdir to absolute path**
[2025-09-21T16:30:56] exec bash -lc pwd in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T16:30:56] bash -lc pwd succeeded in 17ms:
/Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T16:30:56] tokens used: 1,985

[2025-09-21T16:31:05] thinking

**Formulating task plan**

I’m working out a step-by-step plan since there’s no dedicated plan tool. I’ll outline inspecting the report and figures, identifying file changes, reconstructing in the project directory, running build and tests, and then committing the updates. This plan will guide the next actions clearly.

[2025-09-21T16:31:07] thinking

**Outlining task plan**
[2025-09-21T16:31:08] exec bash -lc 'ls -la' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T16:31:08] bash -lc 'ls -la' succeeded in 10ms:
total 22560
drwxr-xr-x@  9 jqwang  staff       288 Sep 21 15:57 .
drwxr-xr-x@ 29 jqwang  staff       928 Sep 21 07:49 ..
-rw-r--r--@  1 jqwang  staff       103 Sep 22 00:30 codex_error.txt
-rw-r--r--@  1 jqwang  staff  11210006 Sep 22 00:31 codex_output.txt
-rw-r--r--@  1 jqwang  staff         7 Sep 22 00:30 codex_status.txt
drwxr-xr-x@ 43 jqwang  staff      1376 Sep 22 00:30 logs
drwxr-xr-x@ 12 jqwang  staff       384 Sep 21 20:54 rust-project
-rw-r--r--@  1 jqwang  staff       921 Sep 22 00:30 task_status.json
drwxr-xr-x@  5 jqwang  staff       160 Sep 22 00:30 todolist
[2025-09-21T16:31:08] tokens used: 3,691

[2025-09-21T16:31:10] thinking

**Reading TeX file**
[2025-09-21T16:31:10] exec bash -lc "sed -n '1,160p' todolist/todolist-042-5e631c2.tex" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T16:31:10] bash -lc "sed -n '1,160p' todolist/todolist-042-5e631c2.tex" succeeded in 9ms:
\section{提交考古：042-5e631c2}

\subsection*{Commit 元信息}
\begin{itemize}
  \item 标题：trace tags, display tags and HEAD
  % Escape underscores in email to avoid math-mode errors
  \item 作者：Martin Lange <martin\_lange\_@gmx.net>
  \item 日期：2020-12-26T23:06:07+01:00
\end{itemize}

\subsection*{变更摘要（阅读提示）}
本次提交聚焦“在文本图中标识 HEAD、显示 Git 标签(tags)”，并移除 CLI 选项 \verb|--all|。从 \verb|HEAD.diff| 可见：5 files changed, 130 insertions(+), 46 deletions(-)。核心改动：
(1) 追踪 \verb|HEAD|（新增字段并用于输出高亮）；(2) 解析仓库标签并打到对应提交；(3) 终端/SVG 颜色规则与排序中新增 \verb|tags/.*| 分组；(4) 移除 \verb|--all|，统一以 \verb|walk.push_glob("*")| 遍历。

\subsection*{差异解读（证据）}
\textbf{改了什么}
\begin{itemize}
  \item 追踪 HEAD：在 \verb|GitGraph| 结构体中新增 \verb|head: Oid|，并在构建时读取 \verb|repository.head()|（证据：head/src/graph.rs:15, 26--31）。文本输出阶段根据 \verb|head| 推导 \verb|head_idx|，并在该行打印 \verb|HEAD ->|（证据：head/src/print/unicode.rs:426, 513--525）。
  \item 标签可视化：为提交新增 \verb|tags: Vec<usize>|，为分支信息新增 \verb|is_tag: bool|（证据：head/src/graph.rs:141, 167）。在 \verb|extract_branches| 中遍历标签 \verb|tag_foreach|，对命中提交构造 \verb|BranchInfo{ is_tag=true }| 并追加到分支集合，同时记录到目标提交的 \verb|tags|（证据：head/src/graph.rs:396--437）。在文本渲染 \verb|write_post| 中以方括号输出标签名，着色策略优先沿用当前分支色（证据：head/src/print/unicode.rs:527--545）。
  \item CLI/遍历策略调整：移除 \verb|--all| 选项及相关分支逻辑，统一改为 \verb|revwalk.push_glob("*")|（证据：HEAD.diff: src/main.rs 与 src/graph.rs 中函数签名与调用移除 \verb|all|；head/src/graph.rs:26）。
[2025-09-21T16:31:10] tokens used: 4,118

[2025-09-21T16:31:13] thinking

**Deciding on next steps**
[2025-09-21T16:31:13] exec bash -lc "sed -n '160,320p' todolist/todolist-042-5e631c2.tex" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T16:31:13] bash -lc "sed -n '160,320p' todolist/todolist-042-5e631c2.tex" succeeded in 20ms:

[2025-09-21T16:31:13] tokens used: 6,714

[2025-09-21T16:31:21] thinking

**Analyzing reconstruction strategy**
[2025-09-21T16:31:21] exec bash -lc 'rg -n "042-5e631c2" -g"*"' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T16:31:21] bash -lc 'rg -n "042-5e631c2" -g"*"' succeeded in 59ms:
task_status.json:48:  "current": "042-5e631c2",
todolist/task_meta.json:2:  "task_id": "042-5e631c2",
todolist/task_meta.json:4:  "source_report": ".artifacts/reports/042-5e631c2.tex",
todolist/task_meta.json:5:  "source_figs": ".artifacts/figs/042-5e631c2",
todolist/todolist-042-5e631c2.tex:1:\section{提交考古：042-5e631c2}
todolist/todolist-042-5e631c2.tex:48:  \includegraphics[width=0.56\linewidth]{{042-5e631c2/architecture.pdf}}
todolist/todolist-042-5e631c2.tex:54:  \includegraphics[width=0.56\linewidth]{{042-5e631c2/algorithm_flow.pdf}}
codex_output.txt:322896:请在 .workspace 内，依据 .workspace/todolist/todolist-042-5e631c2.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。
codex_output.txt:322901:- 打开 tex 报告；如有，参考 .workspace/todolist/figs/042-5e631c2/ 下的图示（类图/序列图/流程图/状态图）
codex_output.txt:322913:- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："042-5e631c2：复现提交代码内容。"
codex_output.txt:322931:任务ID: 042-5e631c2
codex_output.txt:322975:[2025-09-21T16:31:10] exec bash -lc "sed -n '1,160p' todolist/todolist-042-5e631c2.tex" in /Users/jqwang/104-CommitLens-codex/.workspace
codex_output.txt:322976:[2025-09-21T16:31:10] bash -lc "sed -n '1,160p' todolist/todolist-042-5e631c2.tex" succeeded in 9ms:
codex_output.txt:322977:\section{提交考古：042-5e631c2}
codex_output.txt:323002:[2025-09-21T16:31:13] exec bash -lc "sed -n '160,320p' todolist/todolist-042-5e631c2.tex" in /Users/jqwang/104-CommitLens-codex/.workspace
codex_output.txt:323003:[2025-09-21T16:31:13] bash -lc "sed -n '160,320p' todolist/todolist-042-5e631c2.tex" succeeded in 20ms:
codex_output.txt:323010:[2025-09-21T16:31:21] exec bash -lc 'rg -n "042-5e631c2" -g"*"' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T16:31:21] tokens used: 7,294

[2025-09-21T16:31:26] thinking

**Checking for PDF artifacts**
[2025-09-21T16:31:26] exec bash -lc 'ls todolist/figs/042-5e631c2' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T16:31:26] bash -lc 'ls todolist/figs/042-5e631c2' exited 1 in 18ms:
ls: todolist/figs/042-5e631c2: No such file or directory
[2025-09-21T16:31:26] tokens used: 8,235

[2025-09-21T16:31:29] thinking

**Investigating hidden artifact paths**
[2025-09-21T16:31:29] exec bash -lc 'ls -a' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T16:31:29] bash -lc 'ls -a' succeeded in 11ms:
.
..
codex_error.txt
codex_output.txt
codex_status.txt
logs
rust-project
task_status.json
todolist
[2025-09-21T16:31:29] tokens used: 8,450

[2025-09-21T16:31:33] thinking

**Searching for code references**
[2025-09-21T16:31:33] exec bash -lc 'rg -n "GitGraph"' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T16:31:33] bash -lc 'rg -n "GitGraph"' succeeded in 31ms:
todolist/figs/architecture.puml:5:class GitGraph {
todolist/figs/architecture.puml:20:GitGraph "1" o-- "*" CommitInfo
todolist/figs/architecture.puml:21:GitGraph "1" o-- "*" BranchInfo
todolist/figs/architecture.puml:24:note right of GitGraph
todolist/figs/architecture.puml:25:  GitGraph::new 改动:
todolist/figs/architecture.puml:33:UnicodePrinter ..> GitGraph
logs/032-b597e06.log:249:pub struct GitGraph {
logs/032-b597e06.log:256:impl GitGraph {
logs/032-b597e06.log:4550:pub struct GitGraph {
logs/032-b597e06.log:4557:impl GitGraph {
logs/021-573b442.log:216:pub struct GitGraph {
logs/021-573b442.log:223:impl GitGraph {
logs/021-573b442.log:279:    graph::{BranchInfo, CommitInfo, GitGraph},
logs/021-573b442.log:320:**Checking for GitGraph definition**
logs/021-573b442.log:335:use git_graph::graph::{CommitInfo, GitGraph};
logs/021-573b442.log:384:**Exploring GitGraph methods**
logs/021-573b442.log:404:**Investigating GitGraph methods and branches access**
logs/021-573b442.log:484:I'm settling on `get_deviate_index` returning an ordinal to offset the SVG path’s control point horizontally, helping avoid line overlaps by nudging curves sideways based on sibling order. I’ll update `svg.rs` to replace method calls with direct field access on `GitGraph`, adjust loops to use actual commit parent fields, and modify `print_svg` to compute edges using the new helper and path logic with `split_idx`. This should align compilation and improve commit edge routing with a clear TODO about perfecting deviation once full original context or layout details are available.
logs/021-573b442.log:492:I'm settling on `get_deviate_index` returning an ordinal to offset the SVG path’s control point horizontally, helping avoid line overlaps by nudging curves sideways based on sibling order. I’ll update `svg.rs` to replace method calls with direct field access on `GitGraph`, adjust loops to use actual commit parent fields, and modify `print_svg` to compute edges using the new helper and path logic with `split_idx`. This should align compilation and improve commit edge routing with a clear TODO about perfecting deviation once full original context or layout details are available.
logs/021-573b442.log:517:    graph: &'graph GitGraph,
[2025-09-21T16:31:33] tokens used: 8,728

[2025-09-21T16:31:36] thinking

**Exploring architecture diagram file**
[2025-09-21T16:31:36] exec bash -lc "sed -n '1,160p' todolist/figs/architecture.puml" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T16:31:36] bash -lc "sed -n '1,160p' todolist/figs/architecture.puml" succeeded in 8ms:
@startuml
skinparam monochrome false
skinparam defaultFontName Courier

class GitGraph {
  +commits: Vec<CommitInfo>
  +branches: Vec<BranchInfo>
  +head: Oid
}
class CommitInfo {
  +branches: Vec<usize>
  +tags: Vec<usize>
}
class BranchInfo {
  +is_tag: bool
  +name: String
  +term_color: u8
}

GitGraph "1" o-- "*" CommitInfo
[2025-09-21T16:31:36] tokens used: 12,046

[2025-09-21T16:31:38] thinking

**Noticing flow diagram**
[2025-09-21T16:31:38] exec bash -lc "sed -n '1,160p' todolist/figs/algorithm_flow.puml" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T16:31:38] bash -lc "sed -n '1,160p' todolist/figs/algorithm_flow.puml" succeeded in 16ms:
@startuml
start
:extract_branches();
:repository.branches();
if (include_remote?) then (yes)
  :保留本地与远程分支;
else (no)
  :仅保留本地分支;
endif
:repository.tag_foreach();
while (还有 tag?) is (yes)
  :find_tag(oid) -> target_id;
  if (target_id in indices?) then (yes)
    :new BranchInfo(is_tag=true, name="tags/...");
    :commits[target].tags.push(branch_idx);
  endif
endwhile
stop
@enduml
[2025-09-21T16:31:38] tokens used: 12,561

[2025-09-21T16:31:41] thinking

**Examining workspace configuration**
[2025-09-21T16:31:41] exec bash -lc ls in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:31:41] bash -lc ls succeeded in 14ms:
Cargo.lock
Cargo.toml
LICENSE
README.md
scripts
src
target
[2025-09-21T16:31:41] tokens used: 12,918

[2025-09-21T16:31:44] thinking

**Inspecting source directory structure**
[2025-09-21T16:31:44] exec bash -lc 'ls src' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:31:44] bash -lc 'ls src' succeeded in 22ms:
graph.rs
lib.rs
main.rs
print
settings.rs
text.rs
[2025-09-21T16:31:44] tokens used: 13,150

[2025-09-21T16:31:47] thinking

**Examining graph.rs for changes**
[2025-09-21T16:31:48] exec bash -lc "sed -n '1,200p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:31:48] bash -lc "sed -n '1,200p' src/graph.rs" succeeded in 14ms:
use crate::print::colors::to_terminal_color;
use crate::settings::{BranchOrder, BranchSettings, Settings};
use crate::text;
use git2::{BranchType, Commit, Error, Oid, Repository};
use itertools::Itertools;
use regex::Regex;
use std::collections::{HashMap, VecDeque};

/// Represents a git history graph.
pub struct GitGraph {
    pub repository: Repository,
    pub commits: Vec<CommitInfo>,
    pub indices: HashMap<Oid, usize>,
    pub branches: Vec<BranchInfo>,
}

impl GitGraph {
    pub fn new(
        path: &str,
        settings: &Settings,
[2025-09-21T16:31:48] tokens used: 24,921

[2025-09-21T16:31:51] thinking

**Reviewing full file for changes**
[2025-09-21T16:31:51] exec bash -lc "sed -n '200,400p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:31:51] bash -lc "sed -n '200,400p' src/graph.rs" succeeded in 11ms:

impl BranchVis {
    fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
        BranchVis {
            order_group,
            term_color,
            svg_color,
            column: None,
        }
    }
}

/// Walks through the commits and adds each commit's Oid to the children of its parents.
fn assign_children(commits: &mut [CommitInfo], indices: &HashMap<Oid, usize>) {
    for idx in 0..commits.len() {
        let (oid, parents) = {
            let info = &commits[idx];
            (info.oid, info.parents)
        };
        for par_oid in &parents {
[2025-09-21T16:31:51] tokens used: 26,847

[2025-09-21T16:31:54] thinking

**Continuing process**
[2025-09-21T16:31:55] exec bash -lc "sed -n '400,800p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:31:55] bash -lc "sed -n '400,800p' src/graph.rs" succeeded in 19ms:
) -> Result<bool, Error> {
    let mut curr_oid = oid;
    let mut prev_index: Option<usize> = None;
    let mut start_index: Option<i32> = None;
    let mut any_assigned = false;
    while let Some(index) = indices.get(&curr_oid) {
        let info = &mut commits[*index];
        if info.branch_trace.is_some() {
            match prev_index {
                None => start_index = Some(*index as i32 - 1),
                Some(prev_index) => {
                    // TODO: in cases where no crossings occur, the rule for merge commits can also be applied to normal commits
                    // see also print::get_deviate_index()
                    if commits[prev_index].is_merge {
                        let mut temp_index = prev_index;
                        for sibling_oid in &commits[*index].children {
                            if sibling_oid != &curr_oid {
                                let sibling_index = indices[&sibling_oid];
                                if sibling_index > temp_index {
                                    temp_index = sibling_index;
[2025-09-21T16:31:55] tokens used: 38,785

[2025-09-21T16:32:01] thinking

**Planning code modifications**
[2025-09-21T16:32:01] exec bash -lc 'ls src/print' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:32:01] bash -lc 'ls src/print' succeeded in 16ms:
colors.rs
mod.rs
svg.rs
unicode.rs
[2025-09-21T16:32:01] tokens used: 44,730

[2025-09-21T16:32:04] thinking

**Opening unicode.rs**
[2025-09-21T16:32:04] exec bash -lc "sed -n '1,200p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:32:04] bash -lc "sed -n '1,200p' src/print/unicode.rs" succeeded in 8ms:
use crate::graph::GitGraph;
use crate::settings::{Characters, Settings};
use atty::Stream;
use std::collections::hash_map::Entry::{Occupied, Vacant};
use std::collections::HashMap;
use yansi::Paint;

const SPACE: u8 = 0;
const DOT: u8 = 1;
const CIRCLE: u8 = 2;
const VER: u8 = 3;
const HOR: u8 = 4;
const CROSS: u8 = 5;
const R_U: u8 = 6;
const R_D: u8 = 7;
const L_D: u8 = 8;
const L_U: u8 = 9;
const VER_L: u8 = 10;
const VER_R: u8 = 11;
const HOR_U: u8 = 12;
[2025-09-21T16:32:04] tokens used: 62,431

[2025-09-21T16:32:06] thinking

**Checking existing structure**
[2025-09-21T16:32:06] exec bash -lc "sed -n '200,400p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:32:06] bash -lc "sed -n '200,400p' src/print/unicode.rs" succeeded in 19ms:
    color: u8,
    pers: u8,
) {
    if from == to {
        return;
    }
    let from_2 = from * 2;
    let to_2 = to * 2;
    if from < to {
        for column in (from_2 + 1)..to_2 {
            if merge && column == to_2 - 1 {
                grid.set(column, index, ARR_R, color, pers);
            } else {
                let (curr, _, old_pers) = grid.get_tuple(column, index);
                let (new_col, new_pers) = if pers < old_pers {
                    (Some(color), Some(pers))
                } else {
                    (None, None)
                };
                match curr {
[2025-09-21T16:32:06] tokens used: 68,596

[2025-09-21T16:32:09] thinking

**Continuing process**
[2025-09-21T16:32:10] exec bash -lc "sed -n '400,800p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:32:10] bash -lc "sed -n '400,800p' src/print/unicode.rs" succeeded in 12ms:
                                    entry.insert(vec![vec![Occ::Range(
                                        idx,
                                        *par_idx,
                                        column_range.0,
                                        column_range.1,
                                    )]]);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    inserts
}

fn write_graph(
    graph: &GitGraph,
[2025-09-21T16:32:10] tokens used: 87,924

[2025-09-21T16:32:13] thinking

**Investigating potential bug in Grid::get_pers**
[2025-09-21T16:32:14] exec bash -lc "sed -n '1,200p' src/settings.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:32:14] bash -lc "sed -n '1,200p' src/settings.rs" succeeded in 9ms:
use regex::{Error, Regex};
use serde_derive::{Deserialize, Serialize};
use std::str::FromStr;

#[derive(Serialize, Deserialize)]
pub struct RepoSettings {
    /// The repository's branching model
    pub model: String,
}

/// Ordering policy for branches in visual columns.
pub enum BranchOrder {
    /// Recommended! Shortest branches are inserted left-most.
    ///
    /// For branches with equal length, branches ending last are inserted first.
    /// Reverse (arg = false): Branches ending first are inserted first.
    ShortestFirst(bool),
    /// Longest branches are inserted left-most.
    ///
    /// For branches with equal length, branches ending last are inserted first.
[2025-09-21T16:32:14] tokens used: 93,786

[2025-09-21T16:32:17] thinking

**Checking array structures for tags**
[2025-09-21T16:32:18] exec bash -lc "sed -n '200,400p' src/settings.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:32:18] bash -lc "sed -n '200,400p' src/settings.rs" succeeded in 10ms:
            .collect::<Result<Vec<_>, Error>>()?;

        let order = def
            .order
            .iter()
            .map(|str| Regex::new(str))
            .collect::<Result<Vec<_>, Error>>()?;

        let terminal_colors = def
            .terminal_colors
            .matches
            .into_iter()
            .map(|(str, vec)| Regex::new(&str).map(|re| (re, vec)))
            .collect::<Result<Vec<_>, Error>>()?;

        let terminal_colors_unknown = def.terminal_colors.unknown;

        let svg_colors = def
            .svg_colors
            .matches
[2025-09-21T16:32:18] tokens used: 104,154

[2025-09-21T16:32:21] thinking

**Preparing release changes**
[2025-09-21T16:32:21] exec bash -lc "sed -n '1,200p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:32:21] bash -lc "sed -n '1,200p' src/main.rs" succeeded in 20ms:
use clap::{crate_version, App, Arg, SubCommand};
use git2::{Error, Repository};
use git_graph::graph::{CommitInfo, GitGraph};
use git_graph::print::svg::print_svg;
use git_graph::print::unicode::print_unicode;
use git_graph::settings::{
    BranchOrder, BranchSettings, BranchSettingsDef, Characters, MergePatterns, RepoSettings,
    Settings,
};
use platform_dirs::AppDirs;
use std::path::PathBuf;
use std::str::FromStr;
use std::time::Instant;

fn main() {
    std::process::exit(match from_args() {
        Ok(_) => 0,
        Err(err) => {
            eprintln!("{}", err);
            1
[2025-09-21T16:32:21] tokens used: 107,239

[2025-09-21T16:32:25] thinking

**Reviewing run function location**
[2025-09-21T16:32:25] exec bash -lc "sed -n '1,200p' src/lib.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:32:25] bash -lc "sed -n '1,200p' src/lib.rs" succeeded in 16ms:
pub mod graph;
pub mod print;
pub mod settings;
pub mod text;
[2025-09-21T16:32:25] tokens used: 117,875

[2025-09-21T16:32:27] thinking

**Searching for run function**
[2025-09-21T16:32:27] exec bash -lc 'rg -n "fn run" src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:32:27] bash -lc 'rg -n "fn run" src/main.rs' succeeded in 9ms:
315:fn run(
[2025-09-21T16:32:27] tokens used: 118,039
[2025-09-21T16:32:30] exec bash -lc "sed -n '280,360p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:32:30] bash -lc "sed -n '280,360p' src/main.rs" succeeded in 13ms:

    let config = RepoSettings {
        model: model.to_string(),
    };

    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;

    Ok(())
}

fn create_config() -> Result<(), String> {
    let app_dir = AppDirs::new(Some("git-graph"), false).unwrap().config_dir;
    let mut models_dir = app_dir;
    models_dir.push("models");

    if !models_dir.exists() {
        std::fs::create_dir_all(&models_dir).map_err(|err| err.to_string())?;

        let models = [
[2025-09-21T16:32:30] tokens used: 118,182

[2025-09-21T16:32:32] thinking

**Preparing to remove parameters**
[2025-09-21T16:32:32] exec bash -lc "sed -n '360,520p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:32:32] bash -lc "sed -n '360,520p' src/main.rs" succeeded in 9ms:
        eprintln!(
            "Graph construction: {:.1} ms, printing: {:.1} ms ({} commits)",
            duration_graph as f32 / 1000.0,
            duration_print as f32 / 1000.0,
            graph.commits.len()
        );
    }
    Ok(())
}

fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
    let commit = &graph.commit(info.oid)?;
    let symbol = if commit.parents().len() > 1 { "o" } else { "*" };

    let branch_str = if info.branches.is_empty() {
        "".to_string()
    } else {
        format!(
            " ({})",
            itertools::join(
[2025-09-21T16:32:32] tokens used: 119,080

[2025-09-21T16:32:36] thinking

**Checking source file for updates**
[2025-09-21T16:32:36] exec bash -lc "sed -n '1,200p' src/print/mod.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:32:36] bash -lc "sed -n '1,200p' src/print/mod.rs" succeeded in 14ms:
use crate::graph::GitGraph;
use std::cmp::max;

pub mod colors;
pub mod svg;
pub mod unicode;

/// Find the index at which a between-branch connection
/// has to deviate from the current branch's column.
///
/// Returns the last index on the current column.
fn get_deviate_index(graph: &GitGraph, index: usize, par_index: usize) -> usize {
    let info = &graph.commits[index];

    let par_info = &graph.commits[par_index];
    let par_branch = &graph.branches[par_info.branch_trace.unwrap()];

    let mut min_split_idx = index;
    for sibling_oid in &par_info.children {
        if let Some(&sibling_index) = graph.indices.get(sibling_oid) {
[2025-09-21T16:32:36] tokens used: 119,772

[2025-09-21T16:33:00] thinking

**Analyzing commit changes to GitGraph structure**
[2025-09-21T16:33:01] exec bash -lc 'rg -n "is_tag"' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T16:33:01] bash -lc 'rg -n "is_tag"' succeeded in 19ms:
todolist/figs/architecture.puml:15:  +is_tag: bool
todolist/figs/algorithm_flow.puml:14:    :new BranchInfo(is_tag=true, name="tags/...");
todolist/todolist-042-5e631c2.tex:19:  \item 标签可视化：为提交新增 \verb|tags: Vec<usize>|，为分支信息新增 \verb|is_tag: bool|（证据：head/src/graph.rs:141, 167）。在 \verb|extract_branches| 中遍历标签 \verb|tag_foreach|，对命中提交构造 \verb|BranchInfo{ is_tag=true }| 并追加到分支集合，同时记录到目标提交的 \verb|tags|（证据：head/src/graph.rs:396--437）。在文本渲染 \verb|write_post| 中以方括号输出标签名，着色策略优先沿用当前分支色（证据：head/src/print/unicode.rs:527--545）。
codex_output.txt:322995:  \item 标签可视化：为提交新增 \verb|tags: Vec<usize>|，为分支信息新增 \verb|is_tag: bool|（证据：head/src/graph.rs:141, 167）。在 \verb|extract_branches| 中遍历标签 \verb|tag_foreach|，对命中提交构造 \verb|BranchInfo{ is_tag=true }| 并追加到分支集合，同时记录到目标提交的 \verb|tags|（证据：head/src/graph.rs:396--437）。在文本渲染 \verb|write_post| 中以方括号输出标签名，着色策略优先沿用当前分支色（证据：head/src/print/unicode.rs:527--545）。
codex_output.txt:323101:  +is_tag: bool
codex_output.txt:323127:    :new BranchInfo(is_tag=true, name="tags/...");
codex_output.txt:323515:[2025-09-21T16:33:01] exec bash -lc 'rg -n "is_tag"' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T16:33:01] tokens used: 121,828

[2025-09-21T16:33:06] thinking

**Checking git remotes for code retrieval**
[2025-09-21T16:33:06] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:33:06] bash -lc 'git status -sb' succeeded in 32ms:
## main
[2025-09-21T16:33:06] tokens used: 129,050

[2025-09-21T16:33:09] thinking

**Checking for git remotes**
[2025-09-21T16:33:10] exec bash -lc 'git remote -v' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:33:10] bash -lc 'git remote -v' succeeded in 32ms:

[2025-09-21T16:33:10] tokens used: 129,860

[2025-09-21T16:35:33] thinking

**Implementing GitGraph head and tag support**
**Refining output formatting and settings for HEAD and tags**

This is a hefty chunk laying out updates to how the code prints the HEAD arrow and tags alongside branch names, plus how tags get integrated into branch sorting and coloring rules. I'll tune the printing functions to detect HEAD commits, show "HEAD ->" with the branch color, and append tags in brackets with their own colors. Also, the branch settings (like persistence, order, and terminal colors) get new regex patterns for tags, so tags get consistent ordering and color schemes too. On top of that, CLI `--all` flags get removed and constructor signatures simplified. It’s a detailed balancing act to ensure printing and data structures elegantly handle tags and HEAD highlights while keeping the coloring logic tidy. This part also covers safely identifying the repository’s HEAD commit and making sure calls handle that gracefully. Overall, I’m preparing a solid integration of tags into the graph’s colors and outputs with careful attention to color priority and formatting nuances.
**Designing tag extraction and commit association**

This section lays out a detailed plan to extract tags using `tag_foreach`, identify their target commits, and integrate them as branch-like entities with proper colors and ordering. I'll carefully handle annotated vs. lightweight tags via a helper function, then incrementally build `BranchInfo` for each tag while managing color assignment with the existing counter. Crucially, tags get linked back to their commits, and to avoid scheduling conflicts, I'll make sure tags are either excluded or treated specially in branch-column assignment steps. This approach balances faithfully replicating the described strategy while managing edge cases like commit absence or index mappings. It's a thoughtful orchestration of Git metadata representation tied nicely to the graph visualization logic.
[2025-09-21T16:36:26] codex
**Refining output formatting and settings for HEAD and tags**

This is a hefty chunk laying out updates to how the code prints the HEAD arrow and tags alongside branch names, plus how tags get integrated into branch sorting and coloring rules. I'll tune the printing functions to detect HEAD commits, show "HEAD ->" with the branch color, and append tags in brackets with their own colors. Also, the branch settings (like persistence, order, and terminal colors) get new regex patterns for tags, so tags get consistent ordering and color schemes too. On top of that, CLI `--all` flags get removed and constructor signatures simplified. It’s a detailed balancing act to ensure printing and data structures elegantly handle tags and HEAD highlights while keeping the coloring logic tidy. This part also covers safely identifying the repository’s HEAD commit and making sure calls handle that gracefully. Overall, I’m preparing a solid integration of tags into the graph’s colors and outputs with careful attention to color priority and formatting nuances.
[2025-09-21T16:36:26] codex
**Designing tag extraction and commit association**

This section lays out a detailed plan to extract tags using `tag_foreach`, identify their target commits, and integrate them as branch-like entities with proper colors and ordering. I'll carefully handle annotated vs. lightweight tags via a helper function, then incrementally build `BranchInfo` for each tag while managing color assignment with the existing counter. Crucially, tags get linked back to their commits, and to avoid scheduling conflicts, I'll make sure tags are either excluded or treated specially in branch-column assignment steps. This approach balances faithfully replicating the described strategy while managing edge cases like commit absence or index mappings. It's a thoughtful orchestration of Git metadata representation tied nicely to the graph visualization logic.
[2025-09-21T16:36:26] exec bash -lc 'rg -n "HEAD ->" codex_output.txt' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T16:36:26] bash -lc 'rg -n "HEAD ->" codex_output.txt' succeeded in 28ms:
240:6930eda (HEAD -> linear3) initial
284667:    *    dd90e4f (HEAD -> develop) Merge branch 'release/0.1.1' into develop
322994:  \item 追踪 HEAD：在 \verb|GitGraph| 结构体中新增 \verb|head: Oid|，并在构建时读取 \verb|repository.head()|（证据：head/src/graph.rs:15, 26--31）。文本输出阶段根据 \verb|head| 推导 \verb|head_idx|，并在该行打印 \verb|HEAD ->|（证据：head/src/print/unicode.rs:426, 513--525）。
323547:This is a hefty chunk laying out updates to how the code prints the HEAD arrow and tags alongside branch names, plus how tags get integrated into branch sorting and coloring rules. I'll tune the printing functions to detect HEAD commits, show "HEAD ->" with the branch color, and append tags in brackets with their own colors. Also, the branch settings (like persistence, order, and terminal colors) get new regex patterns for tags, so tags get consistent ordering and color schemes too. On top of that, CLI `--all` flags get removed and constructor signatures simplified. It’s a detailed balancing act to ensure printing and data structures elegantly handle tags and HEAD highlights while keeping the coloring logic tidy. This part also covers safely identifying the repository’s HEAD commit and making sure calls handle that gracefully. Overall, I’m preparing a solid integration of tags into the graph’s colors and outputs with careful attention to color priority and formatting nuances.
323554:This is a hefty chunk laying out updates to how the code prints the HEAD arrow and tags alongside branch names, plus how tags get integrated into branch sorting and coloring rules. I'll tune the printing functions to detect HEAD commits, show "HEAD ->" with the branch color, and append tags in brackets with their own colors. Also, the branch settings (like persistence, order, and terminal colors) get new regex patterns for tags, so tags get consistent ordering and color schemes too. On top of that, CLI `--all` flags get removed and constructor signatures simplified. It’s a detailed balancing act to ensure printing and data structures elegantly handle tags and HEAD highlights while keeping the coloring logic tidy. This part also covers safely identifying the repository’s HEAD commit and making sure calls handle that gracefully. Overall, I’m preparing a solid integration of tags into the graph’s colors and outputs with careful attention to color priority and formatting nuances.
323559:[2025-09-21T16:36:26] exec bash -lc 'rg -n "HEAD ->" codex_output.txt' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T16:36:27] tokens used: 154,448

[2025-09-21T16:37:55] thinking

**Detailing GitGraph struct and branch/tag handling**

I'm planning extensive changes in `graph.rs` to add a `head` field to `GitGraph`, update `GitGraph::new` to use `walk.push_glob("*")`, handle tags as special branches with `is_tag` flags, and maintain tags on commits properly through filtering and indexing. I also need to add `use std::str` and potentially `git2::ObjectType`, carefully restructure `assign_branches`, and ensure proper updates of branch/tag ranges, names (with `tags/` prefix), and coloring, while preserving existing filtering and ordering behavior. This requires handling commit index remapping and skipping tags in certain branch operations to keep behavior consistent. I'll apply these in a patch modifying multiple files.
**Refining branch column assignment and tagging logic**

I’m ensuring tag branches are excluded from column assignment functions by filtering out `is_tag` branches, updating loops accordingly, and adding an `is_tag` field to `BranchInfo`. I'll also adjust `use` statements to import necessary modules before applying changes in a structured patch.
[2025-09-21T16:38:03] codex
**Refining branch column assignment and tagging logic**

I’m ensuring tag branches are excluded from column assignment functions by filtering out `is_tag` branches, updating loops accordingly, and adding an `is_tag` field to `BranchInfo`. I'll also adjust `use` statements to import necessary modules before applying changes in a structured patch.
[2025-09-21T16:38:05] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -3,3 +3,3 @@
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
@@ -7,2 +7,3 @@
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
[2025-09-21T16:38:05] apply_patch(auto_approved=true) exited 0 in 29ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T16:38:05] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..bcfe5b53a214d20c991f37b4047a7a7d2b9c7dd6
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,10 +1,11 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {

[2025-09-21T16:38:05] tokens used: 171,065
[2025-09-21T16:38:05] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..bcfe5b53a214d20c991f37b4047a7a7d2b9c7dd6
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,10 +1,11 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {


[2025-09-21T16:38:10] thinking

**Modifying GitGraph struct and constructor**
[2025-09-21T16:38:16] tokens used: 176,948
[2025-09-21T16:38:16] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..bcfe5b53a214d20c991f37b4047a7a7d2b9c7dd6
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,10 +1,11 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {


[2025-09-21T16:38:22] thinking

**Correcting missing working directory setting**
[2025-09-21T16:38:31] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -12,2 +12,3 @@
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
@@ -18,9 +19,9 @@
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
@@ -29,7 +30,3 @@
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
[2025-09-21T16:38:31] apply_patch(auto_approved=true) exited 0 in 25ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T16:38:31] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..8c09b40eba4c77492273eb8b94e508ff1708be1f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();

[2025-09-21T16:38:31] tokens used: 205,644
[2025-09-21T16:38:31] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..8c09b40eba4c77492273eb8b94e508ff1708be1f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();


[2025-09-21T16:39:02] thinking

**Updating GitGraph struct and CommitInfo**
[2025-09-21T16:39:07] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -138,2 +138,3 @@
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
@@ -149,2 +150,3 @@
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
[2025-09-21T16:39:07] apply_patch(auto_approved=true) exited 0 in 39ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T16:39:07] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..4b639354361c927c9f42516ddc6b9f490ba22ff0
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }

[2025-09-21T16:39:07] tokens used: 207,608
[2025-09-21T16:39:07] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..4b639354361c927c9f42516ddc6b9f490ba22ff0
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }


[2025-09-21T16:39:13] thinking

**Extending BranchInfo with is_tag field**
[2025-09-21T16:39:20] tokens used: 208,400
[2025-09-21T16:39:20] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..4b639354361c927c9f42516ddc6b9f490ba22ff0
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }


[2025-09-21T16:39:26] thinking

**Retrying command with working directory**
[2025-09-21T16:39:31] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -164,2 +164,3 @@
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
@@ -176,2 +177,3 @@
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
@@ -186,2 +188,3 @@
             is_merged,
+            is_tag,
             visual,
[2025-09-21T16:39:31] apply_patch(auto_approved=true) exited 0 in 22ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T16:39:31] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..e286552d9dadbd0a8a9447e25ea5d3717aff9727
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +162,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +175,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +186,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }

[2025-09-21T16:39:31] tokens used: 233,902
[2025-09-21T16:39:31] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..e286552d9dadbd0a8a9447e25ea5d3717aff9727
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +162,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +175,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +186,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }


[2025-09-21T16:39:34] thinking

**Updating BranchInfo::new call sites**
[2025-09-21T16:39:35] exec bash -lc 'rg -n "BranchInfo::new" src/graph.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:39:35] bash -lc 'rg -n "BranchInfo::new" src/graph.rs' succeeded in 13ms:
319:                    Ok(BranchInfo::new(
374:                let branch_info = BranchInfo::new(
[2025-09-21T16:39:35] tokens used: 236,477
[2025-09-21T16:39:35] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..e286552d9dadbd0a8a9447e25ea5d3717aff9727
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +162,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +175,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +186,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }


[2025-09-21T16:39:42] thinking

**Adding is_tag argument to call sites**
[2025-09-21T16:39:44] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -325,2 +325,3 @@
                         false,
+                        false,
                         BranchVis::new(
@@ -380,2 +381,3 @@
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
[2025-09-21T16:39:44] apply_patch(auto_approved=true) exited 0 in 27ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T16:39:44] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..9f2dd1c36b0cffe36875cb5b9b4f7f764c31ceac
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +162,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +175,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +186,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -320,6 +323,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +379,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );

[2025-09-21T16:39:44] tokens used: 237,716
[2025-09-21T16:39:44] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..9f2dd1c36b0cffe36875cb5b9b4f7f764c31ceac
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +162,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +175,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +186,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -320,6 +323,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +379,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );


[2025-09-21T16:40:30] thinking

**Adding tag processing to branch extraction**
[2025-09-21T16:40:31] exec bash -lc "sed -n '320,440p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:40:31] bash -lc "sed -n '320,440p' src/graph.rs" succeeded in 20ms:
                        t,
                        None,
                        name.to_string(),
                        branch_order(name, &settings.branches.persistence) as u8,
                        &BranchType::Remote == tp,
                        false,
                        false,
                        BranchVis::new(
                            branch_order(name, &settings.branches.order),
                            term_color,
                            branch_color(
                                name,
                                &settings.branches.svg_colors,
                                &settings.branches.svg_colors_unknown,
                                counter,
                            ),
                        ),
                        end_index,
                    ))
                })
[2025-09-21T16:40:31] tokens used: 241,158
[2025-09-21T16:40:31] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..9f2dd1c36b0cffe36875cb5b9b4f7f764c31ceac
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +162,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +175,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +186,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -320,6 +323,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +379,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );


[2025-09-21T16:40:36] thinking

**Preparing to insert new code block**
[2025-09-21T16:40:55] tokens used: 246,766
[2025-09-21T16:40:55] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..9f2dd1c36b0cffe36875cb5b9b4f7f764c31ceac
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +162,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +175,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +186,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -320,6 +323,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +379,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );


[2025-09-21T16:41:00] thinking

**Adding missing working directory**
[2025-09-21T16:41:05] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -390,2 +390,77 @@
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
[2025-09-21T16:41:05] apply_patch(auto_approved=true) exited 0 in 24ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T16:41:05] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..b5d8baa32d26f9cec6c6d662a5655946d04e9035
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +162,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +175,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +186,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -320,6 +323,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +379,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +388,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)

[2025-09-21T16:41:05] tokens used: 248,515
[2025-09-21T16:41:05] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..b5d8baa32d26f9cec6c6d662a5655946d04e9035
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +162,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +175,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +186,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -320,6 +323,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +379,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +388,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)


[2025-09-21T16:41:16] thinking

**Adding helper function for tag targets**
[2025-09-21T16:41:19] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -767 +767,24 @@
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
[2025-09-21T16:41:19] apply_patch(auto_approved=true) exited 0 in 20ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T16:41:19] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..93200c23d5cdd5b6872f4ced07eb841844fc148b
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +162,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +175,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +186,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -320,6 +323,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +379,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +388,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -685,3 +765,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}

[2025-09-21T16:41:19] tokens used: 250,554
[2025-09-21T16:41:19] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..93200c23d5cdd5b6872f4ced07eb841844fc148b
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +162,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +175,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +186,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -320,6 +323,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +379,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +388,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -685,3 +765,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}


[2025-09-21T16:41:26] thinking

**Checking object methods and planning branch assignment updates**
[2025-09-21T16:41:26] exec bash -lc "sed -n '240,340p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:41:26] bash -lc "sed -n '240,340p' src/graph.rs" succeeded in 19ms:
    commits: &mut [CommitInfo],
    indices: &HashMap<Oid, usize>,
    settings: &Settings,
) -> Result<Vec<BranchInfo>, String> {
    let mut branch_idx = 0;
    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
        .into_iter()
        .filter_map(|mut branch| {
            if let Some(&idx) = &indices.get(&branch.target) {
                let info = &mut commits[idx];
                if !branch.is_merged {
                    info.branches.push(branch_idx);
                }
                let oid = info.oid;
                let any_assigned =
                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
                        .ok()?;

                if any_assigned || !branch.is_merged {
                    branch_idx += 1;
[2025-09-21T16:41:26] tokens used: 251,305
[2025-09-21T16:41:26] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..93200c23d5cdd5b6872f4ced07eb841844fc148b
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +162,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +175,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +186,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -320,6 +323,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +379,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +388,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -685,3 +765,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}


[2025-09-21T16:41:51] thinking

**Updating branch and tag handling logic**
[2025-09-21T16:42:03] tokens used: 262,045
[2025-09-21T16:42:03] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..93200c23d5cdd5b6872f4ced07eb841844fc148b
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +162,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +175,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +186,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -320,6 +323,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +379,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +388,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -685,3 +765,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}


[2025-09-21T16:42:09] thinking

**Setting working directory**
[2025-09-21T16:42:22] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -244,26 +244,40 @@
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
[2025-09-21T16:42:22] apply_patch(auto_approved=true) exited 0 in 42ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T16:42:22] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..079800a373c7cd10d9fb3d9846280c5c5779d20f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +162,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +175,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +186,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +242,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
+
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +337,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +393,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +402,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -685,3 +779,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}

[2025-09-21T16:42:22] tokens used: 269,544
[2025-09-21T16:42:22] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..079800a373c7cd10d9fb3d9846280c5c5779d20f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +162,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +175,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +186,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +242,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
+
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +337,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +393,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +402,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -685,3 +779,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}


[2025-09-21T16:42:36] thinking

**Refining branch handling logic**
[2025-09-21T16:42:41] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -573,3 +573,5 @@
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
@@ -581,3 +583,5 @@
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
@@ -648,2 +652,5 @@
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
@@ -677,3 +684,5 @@
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|(_idx, br)| {
+            !br.is_tag && (br.range.0.is_some() || br.range.1.is_some())
+        })
         .map(|(idx, br)| {
@@ -746,2 +755,5 @@
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
[2025-09-21T16:42:41] apply_patch(auto_approved=true) exited 0 in 32ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T16:42:41] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..92b5e1a2f1cbd3015da32bb569e7eb4de9304018
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +162,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +175,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +186,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +242,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
-                }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+    let mut branches_ordered = Vec::new();
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-            } else {
-                None
             }
-        })
-        .collect();
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
+
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
+            }
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +337,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +393,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +402,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +571,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +581,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +650,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +682,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|(_idx, br)| {
+            !br.is_tag && (br.range.0.is_some() || br.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +753,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +791,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}

[2025-09-21T16:42:41] tokens used: 271,640
[2025-09-21T16:42:41] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..92b5e1a2f1cbd3015da32bb569e7eb4de9304018
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +162,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +175,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +186,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +242,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
-                }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+    let mut branches_ordered = Vec::new();
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-            } else {
-                None
             }
-        })
-        .collect();
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
+
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
+            }
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +337,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +393,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +402,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +571,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +581,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +650,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +682,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|(_idx, br)| {
+            !br.is_tag && (br.range.0.is_some() || br.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +753,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +791,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}


[2025-09-21T16:42:55] thinking

**Clarifying iterator filter patterns**
[2025-09-21T16:42:55] exec bash -lc "sed -n '440,620p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:42:55] bash -lc "sed -n '440,620p' src/graph.rs" succeeded in 9ms:
                        tag_error = Some(err.to_string());
                        return false;
                    }
                };

                let svg_color = branch_color(
                    &full_name,
                    &settings.branches.svg_colors,
                    &settings.branches.svg_colors_unknown,
                    counter,
                );

                let mut branch_info = BranchInfo::new(
                    target_oid,
                    None,
                    full_name,
                    branch_order(&full_name, &settings.branches.persistence) as u8,
                    false,
                    false,
                    true,
[2025-09-21T16:42:55] tokens used: 275,302
[2025-09-21T16:42:55] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..92b5e1a2f1cbd3015da32bb569e7eb4de9304018
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +162,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +175,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +186,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +242,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
-                }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+    let mut branches_ordered = Vec::new();
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-            } else {
-                None
             }
-        })
-        .collect();
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
+
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
+            }
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +337,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +393,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +402,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +571,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +581,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +650,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +682,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|(_idx, br)| {
+            !br.is_tag && (br.range.0.is_some() || br.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +753,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +791,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}


[2025-09-21T16:43:00] thinking

**Verifying filter usage in branch length function**
[2025-09-21T16:43:00] exec bash -lc "sed -n '620,780p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:43:00] bash -lc "sed -n '620,780p' src/graph.rs" succeeded in 9ms:
            } else {
                break;
            }
        }

        loop {
            let end = end_queue.pop_front();
            if let Some(end) = end {
                if end.1 == idx {
                    let branch = &mut branches[end.0];
                    let group = &mut occupied[branch.visual.order_group];
                    if let Some(column) = branch.visual.column {
                        group[column] = false;
                    }
                } else {
                    end_queue.push_front(end);
                    break;
                }
            } else {
                break;
[2025-09-21T16:43:00] tokens used: 277,034
[2025-09-21T16:43:00] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..92b5e1a2f1cbd3015da32bb569e7eb4de9304018
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +162,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +175,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +186,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +242,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
-                }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+    let mut branches_ordered = Vec::new();
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-            } else {
-                None
             }
-        })
-        .collect();
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
+
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
+            }
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +337,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +393,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +402,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +571,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +581,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +650,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +682,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|(_idx, br)| {
+            !br.is_tag && (br.range.0.is_some() || br.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +753,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +791,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}


[2025-09-21T16:43:09] thinking

**Adjusting filter closure to fix pattern issue**
[2025-09-21T16:43:13] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -684,4 +684,4 @@
         .enumerate()
-        .filter(|(_idx, br)| {
-            !br.is_tag && (br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
         })
[2025-09-21T16:43:13] apply_patch(auto_approved=true) exited 0 in 26ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T16:43:13] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..4cf08a0577a78a1bae15596ea766ad9c62808d7e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +162,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +175,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +186,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +242,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
-                }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+    let mut branches_ordered = Vec::new();
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-            } else {
-                None
             }
-        })
-        .collect();
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
+
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
+            }
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +337,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +393,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +402,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +571,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +581,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +650,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +682,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +753,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +791,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}

[2025-09-21T16:43:13] tokens used: 295,781
[2025-09-21T16:43:13] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..4cf08a0577a78a1bae15596ea766ad9c62808d7e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +162,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +175,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +186,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +242,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
-                }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+    let mut branches_ordered = Vec::new();
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-            } else {
-                None
             }
-        })
-        .collect();
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
+
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
+            }
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +337,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +393,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +402,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +571,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +581,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +650,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +682,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +753,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +791,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}


[2025-09-21T16:43:20] thinking

**Reviewing GitGraph struct initialization**
[2025-09-21T16:43:20] exec bash -lc "rg -n \"GitGraph \\{\" src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:43:20] bash -lc "rg -n \"GitGraph \\{\" src/graph.rs" succeeded in 22ms:
11:pub struct GitGraph {
19:impl GitGraph {
74:            GitGraph {
116:            GitGraph {
[2025-09-21T16:43:20] tokens used: 297,682
[2025-09-21T16:43:20] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..4cf08a0577a78a1bae15596ea766ad9c62808d7e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +162,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +175,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +186,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +242,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
-                }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+    let mut branches_ordered = Vec::new();
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-            } else {
-                None
             }
-        })
-        .collect();
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
+
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
+            }
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +337,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +393,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +402,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +571,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +581,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +650,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +682,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +753,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +791,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}


[2025-09-21T16:43:27] thinking

**Reviewing struct instantiations**
[2025-09-21T16:43:27] exec bash -lc "sed -n '60,140p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:43:27] bash -lc "sed -n '60,140p' src/graph.rs" succeeded in 17ms:
                true,
                forward,
            ),
            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
                &commits,
                &indices,
                &mut branches,
                &settings.branches,
                false,
                forward,
            ),
        }

        let graph = if settings.include_remote {
            GitGraph {
                repository,
                commits,
                indices,
                branches,
            }
[2025-09-21T16:43:27] tokens used: 303,039
[2025-09-21T16:43:27] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..4cf08a0577a78a1bae15596ea766ad9c62808d7e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -138,6 +136,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +148,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +162,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +175,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +186,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +242,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
-                }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+    let mut branches_ordered = Vec::new();
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-            } else {
-                None
             }
-        })
-        .collect();
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
+
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
+            }
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +337,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +393,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +402,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +571,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +581,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +650,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +682,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +753,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +791,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}


[2025-09-21T16:43:36] thinking

**Adding head field to GitGraph initializations**
[2025-09-21T16:43:38] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -75,2 +75,3 @@
                 repository,
+                head,
                 commits,
@@ -117,2 +118,3 @@
                 repository,
+                head,
                 commits: filtered_commits,
[2025-09-21T16:43:38] apply_patch(auto_approved=true) exited 0 in 33ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T16:43:38] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}

[2025-09-21T16:43:38] tokens used: 304,028
[2025-09-21T16:43:38] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}


[2025-09-21T16:43:52] thinking

**Analyzing commit and tag filtering complexities**

I'm sorting through how filtering commits affects references like `head`, `tags`, and branch indices, checking that moving and filtering don’t break access or cause mismatches. I’m also planning to adjust `assign_branch_columns` to skip tags and prepare for updating `print_unicode` and other modules depending on changes to `GitGraph::new`.
[2025-09-21T16:43:53] exec bash -lc 'rg -n "GitGraph::new" -g"*.rs"' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:43:53] bash -lc 'rg -n "GitGraph::new" -g"*.rs"' succeeded in 33ms:
src/main.rs:324:    let graph = GitGraph::new(path, settings, all, max_commits)?;
[2025-09-21T16:43:53] tokens used: 305,809
[2025-09-21T16:43:53] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}


[2025-09-21T16:44:47] thinking

**Planning print_unicode and graph updates**
[2025-09-21T16:44:47] exec bash -lc "sed -n '120,220p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:44:47] bash -lc "sed -n '120,220p' src/print/unicode.rs" succeeded in 8ms:
                                                );
                                                hline(
                                                    &mut grid,
                                                    split_idx_map + insert_idx,
                                                    (par_column, column),
                                                    info.is_merge && p > 0,
                                                    color,
                                                    pers,
                                                );
                                                vline(
                                                    &mut grid,
                                                    (split_idx_map + insert_idx, par_idx_map),
                                                    par_column,
                                                    color,
                                                    pers,
                                                );
                                            }
                                        }
                                    }
                                }
[2025-09-21T16:44:47] tokens used: 309,721
[2025-09-21T16:44:47] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}


[2025-09-21T16:44:57] thinking

**Updating write_graph call with head_commit_index**
[2025-09-21T16:45:01] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -153,2 +153,4 @@
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
@@ -157,2 +159,3 @@
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
[2025-09-21T16:45:01] apply_patch(auto_approved=true) exited 0 in 33ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T16:45:01] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..4a0ef6a3d12b9f89cb1b606dc699777e672d2469
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,

[2025-09-21T16:45:01] tokens used: 325,609
[2025-09-21T16:45:01] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..4a0ef6a3d12b9f89cb1b606dc699777e672d2469
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,


[2025-09-21T16:45:10] thinking

**Updating write_graph function signature**
[2025-09-21T16:45:11] exec bash -lc 'rg -n "fn write_graph" src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:45:11] bash -lc 'rg -n "fn write_graph" src/print/unicode.rs' succeeded in 22ms:
421:fn write_graph(
[2025-09-21T16:45:11] tokens used: 326,125
[2025-09-21T16:45:11] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..4a0ef6a3d12b9f89cb1b606dc699777e672d2469
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,


[2025-09-21T16:45:17] thinking

**Modifying function signature and calls**
[2025-09-21T16:45:21] tokens used: 328,549
[2025-09-21T16:45:21] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..4a0ef6a3d12b9f89cb1b606dc699777e672d2469
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,


[2025-09-21T16:45:30] thinking

**Noting missing working directory**
[2025-09-21T16:45:34] tokens used: 329,895
[2025-09-21T16:45:34] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..4a0ef6a3d12b9f89cb1b606dc699777e672d2469
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,


[2025-09-21T16:45:40] thinking

**Adjusting working directory for patch application**
[2025-09-21T16:45:44] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -423,2 +423,3 @@
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
@@ -432,2 +433,5 @@
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
@@ -440,3 +444,3 @@
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
@@ -446,2 +450,5 @@
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
@@ -452,3 +459,3 @@
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
[2025-09-21T16:45:44] apply_patch(auto_approved=true) exited 0 in 36ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T16:45:44] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..9631cbc99b88546054cd42bdd3cd31798d6430bd
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }

[2025-09-21T16:45:44] tokens used: 331,300
[2025-09-21T16:45:44] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..9631cbc99b88546054cd42bdd3cd31798d6430bd
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }


[2025-09-21T16:45:50] thinking

**Preparing to update write_post function**
[2025-09-21T16:45:50] exec bash -lc 'rg -n "fn write_post" src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:45:50] bash -lc 'rg -n "fn write_post" src/print/unicode.rs' succeeded in 25ms:
491:fn write_post(
[2025-09-21T16:45:50] tokens used: 333,872
[2025-09-21T16:45:50] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..9631cbc99b88546054cd42bdd3cd31798d6430bd
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }


[2025-09-21T16:46:01] thinking

**Opening target function for review**
[2025-09-21T16:46:04] exec bash -lc "sed -n '488,560p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:46:04] bash -lc "sed -n '488,560p' src/print/unicode.rs" succeeded in 20ms:
    }
}

fn write_post(
    graph: &GitGraph,
    index: Option<&usize>,
    color: bool,
    out: &mut String,
) -> Result<(), String> {
    if let Some(index) = index {
        let info = &graph.commits[*index];
        let commit = match graph.repository.find_commit(info.oid) {
            Ok(c) => c,
            Err(err) => return Err(err.to_string()),
        };
        out.push_str("  ");
        if !info.branches.is_empty() {
            out.push('(');
            for (idx, branch_index) in info.branches.iter().enumerate() {
                let branch = &graph.branches[*branch_index];
[2025-09-21T16:46:04] tokens used: 342,590
[2025-09-21T16:46:04] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..9631cbc99b88546054cd42bdd3cd31798d6430bd
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }


[2025-09-21T16:46:16] thinking

**Modifying write_post signature and body**
[2025-09-21T16:46:20] tokens used: 344,632
[2025-09-21T16:46:20] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..9631cbc99b88546054cd42bdd3cd31798d6430bd
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }


[2025-09-21T16:46:26] thinking

**Remembering to set working directory**
[2025-09-21T16:46:30] tokens used: 347,510
[2025-09-21T16:46:30] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..9631cbc99b88546054cd42bdd3cd31798d6430bd
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }


[2025-09-21T16:46:37] thinking

**Verifying patch application**
[2025-09-21T16:46:37] exec bash -lc "sed -n '500,540p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:46:37] bash -lc "sed -n '500,540p' src/print/unicode.rs" succeeded in 20ms:
            Ok(c) => c,
            Err(err) => return Err(err.to_string()),
        };
        out.push_str("  ");
        if !info.branches.is_empty() {
            out.push('(');
            for (idx, branch_index) in info.branches.iter().enumerate() {
                let branch = &graph.branches[*branch_index];
                let branch_color = branch.visual.term_color;
                if color {
                    write_colored_str(out, &branch.name, branch_color);
                } else {
                    out.push_str(&branch.name);
                }
                if idx < info.branches.len() - 1 {
                    out.push_str(", ");
                }
            }
            out.push_str(") ");
        }
[2025-09-21T16:46:37] tokens used: 348,466
[2025-09-21T16:46:37] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..9631cbc99b88546054cd42bdd3cd31798d6430bd
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }


[2025-09-21T16:46:45] thinking

**Preparing to replace function via patch**
[2025-09-21T16:46:52] tokens used: 349,943
[2025-09-21T16:46:52] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..9631cbc99b88546054cd42bdd3cd31798d6430bd
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }


[2025-09-21T16:47:10] thinking

**Noticing missing working directory setting**
[2025-09-21T16:47:23] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -494,2 +494,3 @@
     color: bool,
+    is_head: bool,
     out: &mut String,
@@ -503,2 +504,18 @@
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
@@ -519,2 +536,24 @@
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
[2025-09-21T16:47:23] apply_patch(auto_approved=true) exited 0 in 26ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T16:47:23] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())

[2025-09-21T16:47:23] tokens used: 354,058
[2025-09-21T16:47:23] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())


[2025-09-21T16:47:46] thinking

**Planning branch settings updates**
[2025-09-21T16:47:59] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/settings.rs
@@ -76,2 +76,3 @@
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
@@ -82,2 +83,3 @@
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
@@ -96,2 +98,3 @@
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
@@ -113,2 +116,3 @@
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
[2025-09-21T16:47:59] apply_patch(auto_approved=true) exited 0 in 30ms:
Success. Updated the following files:
M src/settings.rs
[2025-09-21T16:47:59] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..3caebc5997368c61c7f4519618b0a3f5b37f4988
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },

[2025-09-21T16:47:59] tokens used: 371,253
[2025-09-21T16:47:59] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..3caebc5997368c61c7f4519618b0a3f5b37f4988
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },


[2025-09-21T16:48:07] thinking

**Modifying simple block patterns**
[2025-09-21T16:48:16] tokens used: 379,960
[2025-09-21T16:48:16] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..3caebc5997368c61c7f4519618b0a3f5b37f4988
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },


[2025-09-21T16:48:23] thinking

**Correcting working directory**
[2025-09-21T16:48:26] tokens used: 383,986
[2025-09-21T16:48:26] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..3caebc5997368c61c7f4519618b0a3f5b37f4988
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },


[2025-09-21T16:48:33] thinking

**Checking patch failure reasons**
[2025-09-21T16:48:33] exec bash -lc "sed -n '100,200p' src/settings.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:48:33] bash -lc "sed -n '100,200p' src/settings.rs" succeeded in 9ms:
                ],
                unknown: vec!["bright_white".to_string()],
            },

            svg_colors: ColorsDef {
                matches: vec![
                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                    (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                    (
                        r"^feature/.*$".to_string(),
                        vec!["purple".to_string(), "turquoise".to_string()],
                    ),
                    (r"^release/.*$".to_string(), vec!["green".to_string()]),
                    (
                        r"^(bugfix)|(hotfix)/.*$".to_string(),
                        vec!["red".to_string()],
                    ),
                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                ],
                unknown: vec!["gray".to_string()],
[2025-09-21T16:48:33] tokens used: 384,864
[2025-09-21T16:48:33] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..3caebc5997368c61c7f4519618b0a3f5b37f4988
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },


[2025-09-21T16:48:42] thinking

**Patching configuration sections**
[2025-09-21T16:48:45] tokens used: 391,658
[2025-09-21T16:48:45] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..3caebc5997368c61c7f4519618b0a3f5b37f4988
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },


[2025-09-21T16:48:51] thinking

**Resetting directory and re-running**
[2025-09-21T16:48:54] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/settings.rs
@@ -125,4 +125,10 @@
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
[2025-09-21T16:48:54] apply_patch(auto_approved=true) exited 0 in 53ms:
Success. Updated the following files:
M src/settings.rs
[2025-09-21T16:48:54] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..2165545e0cc8eaff44a6662f1fcfd5ae4702af85
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,8 +123,14 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
                 matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
                 unknown: vec![

[2025-09-21T16:48:54] tokens used: 395,501
[2025-09-21T16:48:54] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..2165545e0cc8eaff44a6662f1fcfd5ae4702af85
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,8 +123,14 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
                 matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
                 unknown: vec![


[2025-09-21T16:49:02] thinking

**Updating color match patterns**
[2025-09-21T16:49:04] tokens used: 396,582
[2025-09-21T16:49:04] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..2165545e0cc8eaff44a6662f1fcfd5ae4702af85
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,8 +123,14 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
                 matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
                 unknown: vec![


[2025-09-21T16:49:20] thinking

**Diagnosing missing workdir in patch application**

I'm figuring out why applying the patch fails with a "file not found" error; it looks like the working directory isn't set correctly in the command, causing paths like `src/settings.rs` to not resolve properly. I suspect the `workdir` parameter is missing or incorrect in the patch command, so I'll verify and ensure it points to the intended project directory to fix the file path resolution.
[2025-09-21T16:49:23] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/settings.rs
@@ -134,3 +134,6 @@
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
@@ -145,3 +148,6 @@
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
[2025-09-21T16:49:23] apply_patch(auto_approved=true) exited 0 in 42ms:
Success. Updated the following files:
M src/settings.rs
[2025-09-21T16:49:23] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..ea6ed086652bca44da613eccb4ac29b14d559d95
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +123,19 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +146,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),

[2025-09-21T16:49:23] tokens used: 401,079
[2025-09-21T16:49:23] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..ea6ed086652bca44da613eccb4ac29b14d559d95
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +123,19 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +146,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:49:34] thinking

**Preparing to remove 'all' argument from Clap setup**
[2025-09-21T16:49:37] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -34,10 +34,2 @@
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
[2025-09-21T16:49:37] apply_patch(auto_approved=true) exited 0 in 41ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T16:49:37] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..5d64a3a73df28273882d786627b9ec41e6b1623a
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..ea6ed086652bca44da613eccb4ac29b14d559d95
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +123,19 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +146,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),

[2025-09-21T16:49:37] tokens used: 403,103
[2025-09-21T16:49:37] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..5d64a3a73df28273882d786627b9ec41e6b1623a
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..ea6ed086652bca44da613eccb4ac29b14d559d95
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +123,19 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +146,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:49:44] thinking

**Removing unused variable and adjusting run**
[2025-09-21T16:49:44] exec bash -lc "rg -n \"is_present\\(\\\"all\\\"\" src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:49:44] bash -lc "rg -n \"is_present\\(\\\"all\\\"\" src/main.rs" succeeded in 23ms:
147:    let all = matches.is_present("all");
[2025-09-21T16:49:44] tokens used: 405,669
[2025-09-21T16:49:44] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..5d64a3a73df28273882d786627b9ec41e6b1623a
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..ea6ed086652bca44da613eccb4ac29b14d559d95
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +123,19 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +146,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:49:52] thinking

**Removing a line**
[2025-09-21T16:49:54] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -146,3 +146,2 @@
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
[2025-09-21T16:49:54] apply_patch(auto_approved=true) exited 0 in 39ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T16:49:54] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..834758220b810dd5e40a3d452ab1da63023a1cf9
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..ea6ed086652bca44da613eccb4ac29b14d559d95
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +123,19 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +146,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),

[2025-09-21T16:49:54] tokens used: 409,847
[2025-09-21T16:49:54] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..834758220b810dd5e40a3d452ab1da63023a1cf9
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..ea6ed086652bca44da613eccb4ac29b14d559d95
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +123,19 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +146,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:50:01] thinking

**Modifying run function signature and calls**
[2025-09-21T16:50:01] exec bash -lc "rg -n \"run\\(&settings\" src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T16:50:01] bash -lc "rg -n \"run\\(&settings\" src/main.rs" exited 2 in 23ms:
src/main.rs: No such file or directory (os error 2)
[2025-09-21T16:50:01] tokens used: 410,587
[2025-09-21T16:50:01] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..834758220b810dd5e40a3d452ab1da63023a1cf9
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..ea6ed086652bca44da613eccb4ac29b14d559d95
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +123,19 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +146,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:50:06] thinking

**Setting working directory**
[2025-09-21T16:50:07] exec bash -lc "rg -n \"run\\(&settings\" src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:50:07] bash -lc "rg -n \"run\\(&settings\" src/main.rs" succeeded in 20ms:
180:    run(&settings, svg, all, commit_limit)
[2025-09-21T16:50:07] tokens used: 410,835
[2025-09-21T16:50:07] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..834758220b810dd5e40a3d452ab1da63023a1cf9
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..ea6ed086652bca44da613eccb4ac29b14d559d95
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +123,19 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +146,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:50:12] thinking

**Updating code line to remove 'all'**
[2025-09-21T16:50:13] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -179,3 +179,3 @@
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
[2025-09-21T16:50:13] apply_patch(auto_approved=true) exited 0 in 43ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T16:50:13] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..d27912ce46eab71fe2e0b9b76b74dc818416b54f
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..ea6ed086652bca44da613eccb4ac29b14d559d95
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +123,19 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +146,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),

[2025-09-21T16:50:13] tokens used: 411,112
[2025-09-21T16:50:13] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..d27912ce46eab71fe2e0b9b76b74dc818416b54f
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..ea6ed086652bca44da613eccb4ac29b14d559d95
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +123,19 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +146,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:50:19] thinking

**Searching for function definition**
[2025-09-21T16:50:20] exec bash -lc 'rg -n "fn run" src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:50:20] bash -lc 'rg -n "fn run" src/main.rs' succeeded in 21ms:
306:fn run(
[2025-09-21T16:50:20] tokens used: 413,033
[2025-09-21T16:50:20] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..d27912ce46eab71fe2e0b9b76b74dc818416b54f
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..ea6ed086652bca44da613eccb4ac29b14d559d95
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +123,19 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +146,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),

[2025-09-21T16:50:26] exec bash -lc "sed -n '306,340p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:50:26] bash -lc "sed -n '306,340p' src/main.rs" succeeded in 20ms:
fn run(
    settings: &Settings,
    svg: bool,
    all: bool,
    max_commits: Option<usize>,
) -> Result<(), String> {
    let path = ".";

    let now = Instant::now();
    let graph = GitGraph::new(path, settings, all, max_commits)?;

    let duration_graph = now.elapsed().as_micros();

    if settings.debug {
        for branch in &graph.branches {
            eprintln!(
                "{} (col {}) ({:?}) {}",
                branch.name,
                branch.visual.column.unwrap_or(99),
                branch.range,
[2025-09-21T16:50:26] tokens used: 413,265
[2025-09-21T16:50:26] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..d27912ce46eab71fe2e0b9b76b74dc818416b54f
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..ea6ed086652bca44da613eccb4ac29b14d559d95
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +123,19 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +146,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:50:35] thinking

**Removing all parameter and adjusting GitGraph initialization**
[2025-09-21T16:50:36] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -308,3 +308,2 @@
     svg: bool,
-    all: bool,
     max_commits: Option<usize>,
@@ -314,3 +313,3 @@
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
[2025-09-21T16:50:36] apply_patch(auto_approved=true) exited 0 in 48ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T16:50:36] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..79b48809532a3586b9880d374136a358faaaf215
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -315,13 +306,12 @@
 fn run(
     settings: &Settings,
     svg: bool,
-    all: bool,
     max_commits: Option<usize>,
 ) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..ea6ed086652bca44da613eccb4ac29b14d559d95
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +123,19 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +146,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),

[2025-09-21T16:50:36] tokens used: 414,028
[2025-09-21T16:50:36] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..79b48809532a3586b9880d374136a358faaaf215
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -315,13 +306,12 @@
 fn run(
     settings: &Settings,
     svg: bool,
-    all: bool,
     max_commits: Option<usize>,
 ) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..ea6ed086652bca44da613eccb4ac29b14d559d95
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +123,19 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +146,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:50:43] thinking

**Cleaning up 'all' parameter references**
[2025-09-21T16:50:43] exec bash -lc "rg -n \"\\ball\\b\" src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T16:50:43] bash -lc "rg -n \"\\ball\\b\" src/main.rs" exited 2 in 23ms:
src/main.rs: No such file or directory (os error 2)
[2025-09-21T16:50:43] tokens used: 415,175
[2025-09-21T16:50:43] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..79b48809532a3586b9880d374136a358faaaf215
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -315,13 +306,12 @@
 fn run(
     settings: &Settings,
     svg: bool,
-    all: bool,
     max_commits: Option<usize>,
 ) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..ea6ed086652bca44da613eccb4ac29b14d559d95
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +123,19 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +146,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:50:53] thinking

**Correcting missing working directory and re-running**
[2025-09-21T16:50:53] exec bash -lc "rg -n \"\\ball\\b\" src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:50:53] bash -lc "rg -n \"\\ball\\b\" src/main.rs" exited 1 in 11ms:

[2025-09-21T16:50:53] tokens used: 415,575
[2025-09-21T16:50:53] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..79b48809532a3586b9880d374136a358faaaf215
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -315,13 +306,12 @@
 fn run(
     settings: &Settings,
     svg: bool,
-    all: bool,
     max_commits: Option<usize>,
 ) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..ea6ed086652bca44da613eccb4ac29b14d559d95
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +123,19 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +146,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:51:06] thinking

**Reviewing usage and imports**
[2025-09-21T16:51:06] exec bash -lc 'rg -n "GitGraph::new" src' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:51:06] bash -lc 'rg -n "GitGraph::new" src' succeeded in 25ms:
src/main.rs:314:    let graph = GitGraph::new(path, settings, max_commits)?;
[2025-09-21T16:51:06] tokens used: 417,605
[2025-09-21T16:51:06] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..79b48809532a3586b9880d374136a358faaaf215
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -315,13 +306,12 @@
 fn run(
     settings: &Settings,
     svg: bool,
-    all: bool,
     max_commits: Option<usize>,
 ) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..929872aaa4568ab5e6861ff0d748f45379e1aa28
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,22 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +534,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..ea6ed086652bca44da613eccb4ac29b14d559d95
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +123,19 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +146,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:51:27] thinking

**Updating branch color logic**
[2025-09-21T16:51:32] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -509,2 +509,8 @@
             .map(|branch| branch.visual.term_color)
+            .or_else(|| {
+                info.tags
+                    .first()
+                    .and_then(|tag_index| graph.branches.get(*tag_index))
+                    .map(|branch| branch.visual.term_color)
+            })
             .unwrap_or(WHITE);
[2025-09-21T16:51:32] apply_patch(auto_approved=true) exited 0 in 46ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T16:51:32] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..79b48809532a3586b9880d374136a358faaaf215
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -315,13 +306,12 @@
 fn run(
     settings: &Settings,
     svg: bool,
-    all: bool,
     max_commits: Option<usize>,
 ) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..c5337e1a02a26ce5dbdbecfbd084bde4a40bbf0e
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,28 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .or_else(|| {
+                info.tags
+                    .first()
+                    .and_then(|tag_index| graph.branches.get(*tag_index))
+                    .map(|branch| branch.visual.term_color)
+            })
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +540,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..ea6ed086652bca44da613eccb4ac29b14d559d95
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +123,19 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +146,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),

[2025-09-21T16:51:32] tokens used: 418,985
[2025-09-21T16:51:32] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..75ad976ce043150db85d133e09e8eb1c777402a5
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,44 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned = match trace_branch(
+                repository,
+                commits,
+                &indices,
+                oid,
+                &mut branch,
+                branch_idx,
+            ) {
+                Ok(value) => value,
+                Err(err) => return Err(err.to_string()),
+            };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +339,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +395,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +404,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +573,9 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +583,9 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +652,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +684,9 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| {
+            !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some())
+        })
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +755,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +793,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..79b48809532a3586b9880d374136a358faaaf215
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -315,13 +306,12 @@
 fn run(
     settings: &Settings,
     svg: bool,
-    all: bool,
     max_commits: Option<usize>,
 ) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..c5337e1a02a26ce5dbdbecfbd084bde4a40bbf0e
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,28 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .or_else(|| {
+                info.tags
+                    .first()
+                    .and_then(|tag_index| graph.branches.get(*tag_index))
+                    .map(|branch| branch.visual.term_color)
+            })
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +540,28 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch
+                        .name
+                        .strip_prefix("tags/")
+                        .unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..ea6ed086652bca44da613eccb4ac29b14d559d95
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,12 +74,14 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
@@ -94,6 +96,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +114,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +123,19 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
+            order: vec![
+                r"^(master|main)$".to_string(),
+                r"^tags/.*$".to_string(),
+            ],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +146,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:51:46] thinking

**Planning formatting and testing steps**
[2025-09-21T16:51:47] exec bash -lc 'cargo fmt' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:51:47] bash -lc 'cargo fmt' succeeded in 68ms:

[2025-09-21T16:51:47] tokens used: 420,969
[2025-09-21T16:51:47] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..14383bef36ec8f0bc5b3642446db5b6b23128e1f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,38 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned =
+                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
+                    Ok(value) => value,
+                    Err(err) => return Err(err.to_string()),
+                };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +333,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +389,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +398,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +567,7 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +575,7 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +642,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +674,7 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +743,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +781,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..255705b927603c8487138ba6231fb52f9c224d68
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -312,16 +303,11 @@
     Ok(())
 }
 
-fn run(
-    settings: &Settings,
-    svg: bool,
-    all: bool,
-    max_commits: Option<usize>,
-) -> Result<(), String> {
+fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..1e4c09931f1b444bc6b00cf9f121dd0fb332c979
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,28 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .or_else(|| {
+                info.tags
+                    .first()
+                    .and_then(|tag_index| graph.branches.get(*tag_index))
+                    .map(|branch| branch.visual.term_color)
+            })
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +540,25 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..fba490eecd3ac2a38d82f00041edfce248298da0
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,26 +74,38 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
-                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
-                    (r"^(develop|dev)$".to_string(), vec!["bright_yellow".to_string()]),
                     (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (
+                        r"^(develop|dev)$".to_string(),
+                        vec!["bright_yellow".to_string()],
+                    ),
+                    (
                         r"^feature/.*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
-                    (r"^release/.*$".to_string(), vec!["bright_green".to_string()]),
                     (
+                        r"^release/.*$".to_string(),
+                        vec!["bright_green".to_string()],
+                    ),
+                    (
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +123,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +132,16 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
+            order: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +152,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:51:54] thinking

**Running cargo tests**
[2025-09-21T16:51:55] exec bash -lc 'cargo test' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:52:05] bash -lc 'cargo test' exited 124 in 10.00s:
    Updating crates.io index
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
[2025-09-21T16:52:05] tokens used: 421,764
[2025-09-21T16:52:05] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..14383bef36ec8f0bc5b3642446db5b6b23128e1f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,38 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned =
+                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
+                    Ok(value) => value,
+                    Err(err) => return Err(err.to_string()),
+                };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +333,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +389,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +398,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +567,7 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +575,7 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +642,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +674,7 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +743,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +781,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..255705b927603c8487138ba6231fb52f9c224d68
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -312,16 +303,11 @@
     Ok(())
 }
 
-fn run(
-    settings: &Settings,
-    svg: bool,
-    all: bool,
-    max_commits: Option<usize>,
-) -> Result<(), String> {
+fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..1e4c09931f1b444bc6b00cf9f121dd0fb332c979
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,28 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .or_else(|| {
+                info.tags
+                    .first()
+                    .and_then(|tag_index| graph.branches.get(*tag_index))
+                    .map(|branch| branch.visual.term_color)
+            })
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +540,25 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..fba490eecd3ac2a38d82f00041edfce248298da0
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,26 +74,38 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
-                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
-                    (r"^(develop|dev)$".to_string(), vec!["bright_yellow".to_string()]),
                     (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (
+                        r"^(develop|dev)$".to_string(),
+                        vec!["bright_yellow".to_string()],
+                    ),
+                    (
                         r"^feature/.*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
-                    (r"^release/.*$".to_string(), vec!["bright_green".to_string()]),
                     (
+                        r"^release/.*$".to_string(),
+                        vec!["bright_green".to_string()],
+                    ),
+                    (
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +123,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +132,16 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
+            order: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +152,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:52:14] thinking

**Dealing with cargo test network timeout**

I'll note that `cargo test` failed due to network restrictions preventing crate updates, and consider retrying with `CARGO_NET_OFFLINE=1` to attempt offline compilation or checking, since dependencies can't be fetched without network access. I'll try running `cargo check --offline` next to see if existing cached dependencies allow compiling.
[2025-09-21T16:52:15] exec bash -lc 'CARGO_NET_OFFLINE=true cargo check' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:52:15] bash -lc 'CARGO_NET_OFFLINE=true cargo check' exited -1 in 0ms:
error: no matching package named `unicode-xid` found
location searched: crates.io index
required by package `proc-macro2 v1.0.24`
    ... which satisfies dependency `proc-macro2 = "^1.0"` (locked to 1.0.24) of package `serde_derive v1.0.118`
    ... which satisfies dependency `serde_derive = "^1.0"` (locked to 1.0.118) of package `git-graph v0.1.0 (/Users/jqwang/104-CommitLens-codex/.workspace/rust-project)`
As a reminder, you're using offline mode (--offline) which can sometimes cause surprising resolution failures, if this error is too confusing you may wish to retry without `--offline`.
[2025-09-21T16:52:15] tokens used: 424,471
[2025-09-21T16:52:15] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..14383bef36ec8f0bc5b3642446db5b6b23128e1f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,38 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned =
+                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
+                    Ok(value) => value,
+                    Err(err) => return Err(err.to_string()),
+                };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +333,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +389,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +398,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +567,7 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +575,7 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +642,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +674,7 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +743,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +781,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..255705b927603c8487138ba6231fb52f9c224d68
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -312,16 +303,11 @@
     Ok(())
 }
 
-fn run(
-    settings: &Settings,
-    svg: bool,
-    all: bool,
-    max_commits: Option<usize>,
-) -> Result<(), String> {
+fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..1e4c09931f1b444bc6b00cf9f121dd0fb332c979
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,28 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .or_else(|| {
+                info.tags
+                    .first()
+                    .and_then(|tag_index| graph.branches.get(*tag_index))
+                    .map(|branch| branch.visual.term_color)
+            })
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +540,25 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..fba490eecd3ac2a38d82f00041edfce248298da0
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,26 +74,38 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
-                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
-                    (r"^(develop|dev)$".to_string(), vec!["bright_yellow".to_string()]),
                     (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (
+                        r"^(develop|dev)$".to_string(),
+                        vec!["bright_yellow".to_string()],
+                    ),
+                    (
                         r"^feature/.*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
-                    (r"^release/.*$".to_string(), vec!["bright_green".to_string()]),
                     (
+                        r"^release/.*$".to_string(),
+                        vec!["bright_green".to_string()],
+                    ),
+                    (
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +123,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +132,16 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
+            order: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +152,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:52:24] thinking

**Handling build failure due to missing dependencies**
[2025-09-21T16:52:25] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:52:25] bash -lc 'git status -sb' succeeded in 37ms:
## main
 M src/graph.rs
 M src/main.rs
 M src/print/unicode.rs
 M src/settings.rs
[2025-09-21T16:52:25] tokens used: 425,492
[2025-09-21T16:52:25] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..14383bef36ec8f0bc5b3642446db5b6b23128e1f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,38 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned =
+                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
+                    Ok(value) => value,
+                    Err(err) => return Err(err.to_string()),
+                };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +333,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +389,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +398,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +567,7 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +575,7 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +642,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +674,7 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +743,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +781,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..255705b927603c8487138ba6231fb52f9c224d68
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -312,16 +303,11 @@
     Ok(())
 }
 
-fn run(
-    settings: &Settings,
-    svg: bool,
-    all: bool,
-    max_commits: Option<usize>,
-) -> Result<(), String> {
+fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..1e4c09931f1b444bc6b00cf9f121dd0fb332c979
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,28 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .or_else(|| {
+                info.tags
+                    .first()
+                    .and_then(|tag_index| graph.branches.get(*tag_index))
+                    .map(|branch| branch.visual.term_color)
+            })
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +540,25 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..fba490eecd3ac2a38d82f00041edfce248298da0
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,26 +74,38 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
-                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
-                    (r"^(develop|dev)$".to_string(), vec!["bright_yellow".to_string()]),
                     (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (
+                        r"^(develop|dev)$".to_string(),
+                        vec!["bright_yellow".to_string()],
+                    ),
+                    (
                         r"^feature/.*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
-                    (r"^release/.*$".to_string(), vec!["bright_green".to_string()]),
                     (
+                        r"^release/.*$".to_string(),
+                        vec!["bright_green".to_string()],
+                    ),
+                    (
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +123,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +132,16 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
+            order: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +152,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:52:43] thinking

**Verifying all expected changes**
[2025-09-21T16:52:44] exec bash -lc 'git diff src/graph.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:52:44] bash -lc 'git diff src/graph.rs' succeeded in 37ms:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de58..14383be 100644
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
[2025-09-21T16:52:44] tokens used: 426,316
[2025-09-21T16:52:44] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..14383bef36ec8f0bc5b3642446db5b6b23128e1f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,38 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned =
+                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
+                    Ok(value) => value,
+                    Err(err) => return Err(err.to_string()),
+                };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +333,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +389,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +398,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +567,7 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +575,7 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +642,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +674,7 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +743,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +781,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..255705b927603c8487138ba6231fb52f9c224d68
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -312,16 +303,11 @@
     Ok(())
 }
 
-fn run(
-    settings: &Settings,
-    svg: bool,
-    all: bool,
-    max_commits: Option<usize>,
-) -> Result<(), String> {
+fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..1e4c09931f1b444bc6b00cf9f121dd0fb332c979
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,28 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .or_else(|| {
+                info.tags
+                    .first()
+                    .and_then(|tag_index| graph.branches.get(*tag_index))
+                    .map(|branch| branch.visual.term_color)
+            })
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +540,25 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..fba490eecd3ac2a38d82f00041edfce248298da0
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,26 +74,38 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
-                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
-                    (r"^(develop|dev)$".to_string(), vec!["bright_yellow".to_string()]),
                     (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (
+                        r"^(develop|dev)$".to_string(),
+                        vec!["bright_yellow".to_string()],
+                    ),
+                    (
                         r"^feature/.*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
-                    (r"^release/.*$".to_string(), vec!["bright_green".to_string()]),
                     (
+                        r"^release/.*$".to_string(),
+                        vec!["bright_green".to_string()],
+                    ),
+                    (
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +123,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +132,16 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
+            order: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +152,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:52:53] thinking

**Reviewing assign_branches changes**

I want to double-check the truncated diff part around `assign_branches` to make sure the tag handling logic is complete and there's no leftover `trace_branch` calls or missing control flow like `else continue`. I'll also look at nearby code to catch potential compile issues and confirm everything integrates smoothly.
[2025-09-21T16:52:53] exec bash -lc "sed -n '240,340p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:52:53] bash -lc "sed -n '240,340p' src/graph.rs" succeeded in 12ms:
fn assign_branches(
    repository: &Repository,
    commits: &mut [CommitInfo],
    indices: &HashMap<Oid, usize>,
    settings: &Settings,
) -> Result<Vec<BranchInfo>, String> {
    let mut branch_idx = 0;
    let mut branches_ordered = Vec::new();

    for mut branch in extract_branches(repository, commits, &indices, settings)? {
        if branch.is_tag {
            if let Some(start_idx) = branch.range.0 {
                if let Some(info) = commits.get_mut(start_idx) {
                    info.tags.push(branch_idx);
                }
            }
            branch_idx += 1;
            branches_ordered.push(branch);
            continue;
        }
[2025-09-21T16:52:53] tokens used: 430,858
[2025-09-21T16:52:53] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..14383bef36ec8f0bc5b3642446db5b6b23128e1f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,38 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned =
+                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
+                    Ok(value) => value,
+                    Err(err) => return Err(err.to_string()),
+                };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +333,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +389,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +398,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +567,7 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +575,7 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +642,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +674,7 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +743,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +781,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..255705b927603c8487138ba6231fb52f9c224d68
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -312,16 +303,11 @@
     Ok(())
 }
 
-fn run(
-    settings: &Settings,
-    svg: bool,
-    all: bool,
-    max_commits: Option<usize>,
-) -> Result<(), String> {
+fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..1e4c09931f1b444bc6b00cf9f121dd0fb332c979
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,28 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .or_else(|| {
+                info.tags
+                    .first()
+                    .and_then(|tag_index| graph.branches.get(*tag_index))
+                    .map(|branch| branch.visual.term_color)
+            })
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +540,25 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..fba490eecd3ac2a38d82f00041edfce248298da0
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,26 +74,38 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
-                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
-                    (r"^(develop|dev)$".to_string(), vec!["bright_yellow".to_string()]),
                     (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (
+                        r"^(develop|dev)$".to_string(),
+                        vec!["bright_yellow".to_string()],
+                    ),
+                    (
                         r"^feature/.*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
-                    (r"^release/.*$".to_string(), vec!["bright_green".to_string()]),
                     (
+                        r"^release/.*$".to_string(),
+                        vec!["bright_green".to_string()],
+                    ),
+                    (
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +123,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +132,16 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
+            order: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +152,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:53:07] thinking

**Reviewing commit indexing and branch/tag handling**
[2025-09-21T16:53:08] exec bash -lc 'git diff src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:53:08] bash -lc 'git diff src/print/unicode.rs' succeeded in 34ms:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c214967..1e4c099 100644
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@ pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, St
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@ fn get_inserts(graph: &GitGraph, compact: bool) -> HashMap<usize, Vec<Vec<Occ>>>
 fn write_graph(
[2025-09-21T16:53:08] tokens used: 434,849
[2025-09-21T16:53:08] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..14383bef36ec8f0bc5b3642446db5b6b23128e1f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,38 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned =
+                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
+                    Ok(value) => value,
+                    Err(err) => return Err(err.to_string()),
+                };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +333,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +389,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +398,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +567,7 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +575,7 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +642,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +674,7 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +743,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +781,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..255705b927603c8487138ba6231fb52f9c224d68
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -312,16 +303,11 @@
     Ok(())
 }
 
-fn run(
-    settings: &Settings,
-    svg: bool,
-    all: bool,
-    max_commits: Option<usize>,
-) -> Result<(), String> {
+fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..1e4c09931f1b444bc6b00cf9f121dd0fb332c979
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,28 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .or_else(|| {
+                info.tags
+                    .first()
+                    .and_then(|tag_index| graph.branches.get(*tag_index))
+                    .map(|branch| branch.visual.term_color)
+            })
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +540,25 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..fba490eecd3ac2a38d82f00041edfce248298da0
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,26 +74,38 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
-                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
-                    (r"^(develop|dev)$".to_string(), vec!["bright_yellow".to_string()]),
                     (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (
+                        r"^(develop|dev)$".to_string(),
+                        vec!["bright_yellow".to_string()],
+                    ),
+                    (
                         r"^feature/.*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
-                    (r"^release/.*$".to_string(), vec!["bright_green".to_string()]),
                     (
+                        r"^release/.*$".to_string(),
+                        vec!["bright_green".to_string()],
+                    ),
+                    (
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +123,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +132,16 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
+            order: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +152,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:53:16] thinking

**Reviewing variable insertion and usage**
[2025-09-21T16:53:18] exec bash -lc 'git diff src/settings.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:53:18] bash -lc 'git diff src/settings.rs' succeeded in 34ms:
diff --git a/src/settings.rs b/src/settings.rs
index 139d147..fba490e 100644
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,26 +74,38 @@ impl BranchSettingsDef {
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
-                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
[2025-09-21T16:53:18] tokens used: 441,284
[2025-09-21T16:53:18] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..14383bef36ec8f0bc5b3642446db5b6b23128e1f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,38 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned =
+                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
+                    Ok(value) => value,
+                    Err(err) => return Err(err.to_string()),
+                };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +333,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +389,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +398,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +567,7 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +575,7 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +642,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +674,7 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +743,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +781,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..255705b927603c8487138ba6231fb52f9c224d68
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -312,16 +303,11 @@
     Ok(())
 }
 
-fn run(
-    settings: &Settings,
-    svg: bool,
-    all: bool,
-    max_commits: Option<usize>,
-) -> Result<(), String> {
+fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..1e4c09931f1b444bc6b00cf9f121dd0fb332c979
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,28 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .or_else(|| {
+                info.tags
+                    .first()
+                    .and_then(|tag_index| graph.branches.get(*tag_index))
+                    .map(|branch| branch.visual.term_color)
+            })
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +540,25 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..fba490eecd3ac2a38d82f00041edfce248298da0
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,26 +74,38 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
-                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
-                    (r"^(develop|dev)$".to_string(), vec!["bright_yellow".to_string()]),
                     (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (
+                        r"^(develop|dev)$".to_string(),
+                        vec!["bright_yellow".to_string()],
+                    ),
+                    (
                         r"^feature/.*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
-                    (r"^release/.*$".to_string(), vec!["bright_green".to_string()]),
                     (
+                        r"^release/.*$".to_string(),
+                        vec!["bright_green".to_string()],
+                    ),
+                    (
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +123,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +132,16 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
+            order: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +152,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:53:25] thinking

**Adjusting code spacing**
[2025-09-21T16:53:25] exec bash -lc 'git diff src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:53:25] bash -lc 'git diff src/main.rs' succeeded in 27ms:
diff --git a/src/main.rs b/src/main.rs
index d13dce3..255705b 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -31,14 +31,6 @@ fn from_args() -> Result<(), String> {
             "Structured Git graphs for your branching model.\n  \
                   https://github.com/mlange-42/git-graph",
         )
-        .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
         .arg(
             Arg::with_name("max-count")
                 .long("max-count")
@@ -152,7 +144,6 @@ fn from_args() -> Result<(), String> {
[2025-09-21T16:53:25] tokens used: 443,918
[2025-09-21T16:53:25] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..14383bef36ec8f0bc5b3642446db5b6b23128e1f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,38 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned =
+                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
+                    Ok(value) => value,
+                    Err(err) => return Err(err.to_string()),
+                };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +333,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +389,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +398,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +567,7 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +575,7 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +642,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +674,7 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +743,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +781,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..255705b927603c8487138ba6231fb52f9c224d68
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -312,16 +303,11 @@
     Ok(())
 }
 
-fn run(
-    settings: &Settings,
-    svg: bool,
-    all: bool,
-    max_commits: Option<usize>,
-) -> Result<(), String> {
+fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..1e4c09931f1b444bc6b00cf9f121dd0fb332c979
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,28 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .or_else(|| {
+                info.tags
+                    .first()
+                    .and_then(|tag_index| graph.branches.get(*tag_index))
+                    .map(|branch| branch.visual.term_color)
+            })
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +540,25 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..fba490eecd3ac2a38d82f00041edfce248298da0
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,26 +74,38 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
-                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
-                    (r"^(develop|dev)$".to_string(), vec!["bright_yellow".to_string()]),
                     (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (
+                        r"^(develop|dev)$".to_string(),
+                        vec!["bright_yellow".to_string()],
+                    ),
+                    (
                         r"^feature/.*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
-                    (r"^release/.*$".to_string(), vec!["bright_green".to_string()]),
                     (
+                        r"^release/.*$".to_string(),
+                        vec!["bright_green".to_string()],
+                    ),
+                    (
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +123,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +132,16 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
+            order: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +152,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:53:33] thinking

**Preparing to commit changes**
[2025-09-21T16:53:37] exec bash -lc 'git add -A' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:53:37] bash -lc 'git add -A' succeeded in 43ms:

[2025-09-21T16:53:37] tokens used: 444,638
[2025-09-21T16:53:37] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..14383bef36ec8f0bc5b3642446db5b6b23128e1f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,38 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned =
+                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
+                    Ok(value) => value,
+                    Err(err) => return Err(err.to_string()),
+                };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +333,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +389,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +398,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +567,7 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +575,7 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +642,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +674,7 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +743,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +781,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..255705b927603c8487138ba6231fb52f9c224d68
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -312,16 +303,11 @@
     Ok(())
 }
 
-fn run(
-    settings: &Settings,
-    svg: bool,
-    all: bool,
-    max_commits: Option<usize>,
-) -> Result<(), String> {
+fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..1e4c09931f1b444bc6b00cf9f121dd0fb332c979
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,28 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .or_else(|| {
+                info.tags
+                    .first()
+                    .and_then(|tag_index| graph.branches.get(*tag_index))
+                    .map(|branch| branch.visual.term_color)
+            })
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +540,25 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..fba490eecd3ac2a38d82f00041edfce248298da0
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,26 +74,38 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
-                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
-                    (r"^(develop|dev)$".to_string(), vec!["bright_yellow".to_string()]),
                     (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (
+                        r"^(develop|dev)$".to_string(),
+                        vec!["bright_yellow".to_string()],
+                    ),
+                    (
                         r"^feature/.*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
-                    (r"^release/.*$".to_string(), vec!["bright_green".to_string()]),
                     (
+                        r"^release/.*$".to_string(),
+                        vec!["bright_green".to_string()],
+                    ),
+                    (
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +123,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +132,16 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
+            order: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +152,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),

[2025-09-21T16:53:45] exec bash -lc 'git commit -m "042-5e631c2：复现提交代码内容。"' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:53:45] bash -lc 'git commit -m "042-5e631c2：复现提交代码内容。"' succeeded in 52ms:
[main ee782ee] 042-5e631c2：复现提交代码内容。
 4 files changed, 242 insertions(+), 63 deletions(-)
[2025-09-21T16:53:45] tokens used: 444,840
[2025-09-21T16:53:45] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..14383bef36ec8f0bc5b3642446db5b6b23128e1f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,38 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned =
+                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
+                    Ok(value) => value,
+                    Err(err) => return Err(err.to_string()),
+                };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +333,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +389,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +398,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +567,7 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +575,7 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +642,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +674,7 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +743,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +781,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..255705b927603c8487138ba6231fb52f9c224d68
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -312,16 +303,11 @@
     Ok(())
 }
 
-fn run(
-    settings: &Settings,
-    svg: bool,
-    all: bool,
-    max_commits: Option<usize>,
-) -> Result<(), String> {
+fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..1e4c09931f1b444bc6b00cf9f121dd0fb332c979
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,28 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .or_else(|| {
+                info.tags
+                    .first()
+                    .and_then(|tag_index| graph.branches.get(*tag_index))
+                    .map(|branch| branch.visual.term_color)
+            })
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +540,25 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..fba490eecd3ac2a38d82f00041edfce248298da0
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,26 +74,38 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
-                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
-                    (r"^(develop|dev)$".to_string(), vec!["bright_yellow".to_string()]),
                     (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (
+                        r"^(develop|dev)$".to_string(),
+                        vec!["bright_yellow".to_string()],
+                    ),
+                    (
                         r"^feature/.*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
-                    (r"^release/.*$".to_string(), vec!["bright_green".to_string()]),
                     (
+                        r"^release/.*$".to_string(),
+                        vec!["bright_green".to_string()],
+                    ),
+                    (
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +123,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +132,16 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
+            order: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +152,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:53:52] thinking

**Verifying clean git status**
[2025-09-21T16:53:53] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:53:53] bash -lc 'git status -sb' succeeded in 27ms:
## main
[2025-09-21T16:53:53] tokens used: 449,661
[2025-09-21T16:53:53] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..14383bef36ec8f0bc5b3642446db5b6b23128e1f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,38 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned =
+                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
+                    Ok(value) => value,
+                    Err(err) => return Err(err.to_string()),
+                };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +333,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +389,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +398,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +567,7 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +575,7 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +642,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +674,7 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +743,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +781,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..255705b927603c8487138ba6231fb52f9c224d68
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -312,16 +303,11 @@
     Ok(())
 }
 
-fn run(
-    settings: &Settings,
-    svg: bool,
-    all: bool,
-    max_commits: Option<usize>,
-) -> Result<(), String> {
+fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..1e4c09931f1b444bc6b00cf9f121dd0fb332c979
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,28 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .or_else(|| {
+                info.tags
+                    .first()
+                    .and_then(|tag_index| graph.branches.get(*tag_index))
+                    .map(|branch| branch.visual.term_color)
+            })
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +540,25 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..fba490eecd3ac2a38d82f00041edfce248298da0
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,26 +74,38 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
-                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
-                    (r"^(develop|dev)$".to_string(), vec!["bright_yellow".to_string()]),
                     (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (
+                        r"^(develop|dev)$".to_string(),
+                        vec!["bright_yellow".to_string()],
+                    ),
+                    (
                         r"^feature/.*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
-                    (r"^release/.*$".to_string(), vec!["bright_green".to_string()]),
                     (
+                        r"^release/.*$".to_string(),
+                        vec!["bright_green".to_string()],
+                    ),
+                    (
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +123,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +132,16 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
+            order: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +152,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:54:09] thinking

**Summarizing next steps for final message preparation**
[2025-09-21T16:54:10] exec bash -lc "nl -ba src/graph.rs | sed -n '1,200p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:54:10] bash -lc "nl -ba src/graph.rs | sed -n '1,200p'" succeeded in 31ms:
     1	use crate::print::colors::to_terminal_color;
     2	use crate::settings::{BranchOrder, BranchSettings, Settings};
     3	use crate::text;
     4	use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
     5	use itertools::Itertools;
     6	use regex::Regex;
     7	use std::collections::{HashMap, VecDeque};
     8	use std::str;
     9	
    10	/// Represents a git history graph.
    11	pub struct GitGraph {
    12	    pub repository: Repository,
    13	    pub head: Oid,
    14	    pub commits: Vec<CommitInfo>,
    15	    pub indices: HashMap<Oid, usize>,
    16	    pub branches: Vec<BranchInfo>,
    17	}
    18	
    19	impl GitGraph {
    20	    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
[2025-09-21T16:54:10] tokens used: 452,477
[2025-09-21T16:54:10] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..14383bef36ec8f0bc5b3642446db5b6b23128e1f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,38 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned =
+                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
+                    Ok(value) => value,
+                    Err(err) => return Err(err.to_string()),
+                };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +333,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +389,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +398,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +567,7 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +575,7 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +642,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +674,7 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +743,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +781,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..255705b927603c8487138ba6231fb52f9c224d68
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -312,16 +303,11 @@
     Ok(())
 }
 
-fn run(
-    settings: &Settings,
-    svg: bool,
-    all: bool,
-    max_commits: Option<usize>,
-) -> Result<(), String> {
+fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..1e4c09931f1b444bc6b00cf9f121dd0fb332c979
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,28 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .or_else(|| {
+                info.tags
+                    .first()
+                    .and_then(|tag_index| graph.branches.get(*tag_index))
+                    .map(|branch| branch.visual.term_color)
+            })
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +540,25 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..fba490eecd3ac2a38d82f00041edfce248298da0
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,26 +74,38 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
-                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
-                    (r"^(develop|dev)$".to_string(), vec!["bright_yellow".to_string()]),
                     (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (
+                        r"^(develop|dev)$".to_string(),
+                        vec!["bright_yellow".to_string()],
+                    ),
+                    (
                         r"^feature/.*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
-                    (r"^release/.*$".to_string(), vec!["bright_green".to_string()]),
                     (
+                        r"^release/.*$".to_string(),
+                        vec!["bright_green".to_string()],
+                    ),
+                    (
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +123,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +132,16 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
+            order: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +152,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:54:18] thinking

**Preparing to locate line numbers for changes**
[2025-09-21T16:54:18] exec bash -lc "nl -ba src/graph.rs | sed -n '220,360p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:54:19] bash -lc "nl -ba src/graph.rs | sed -n '220,360p'" succeeded in 21ms:
   220	        let (oid, parents) = {
   221	            let info = &commits[idx];
   222	            (info.oid, info.parents)
   223	        };
   224	        for par_oid in &parents {
   225	            if let Some(par_oid) = par_oid {
   226	                if let Some(par_idx) = indices.get(par_oid) {
   227	                    commits[*par_idx].children.push(oid);
   228	                }
   229	            }
   230	        }
   231	    }
   232	}
   233	
   234	/// Extracts branches from repository and merge summaries, assigns branches and branch traces to commits.
   235	///
   236	/// Algorithm:
   237	/// * Find all actual branches (incl. target oid) and all extract branches from merge summaries (incl. parent oid)
   238	/// * Sort all branches by persistence
   239	/// * Iterating over all branches in persistence order, trace back over commit parents until a trace is already assigned
[2025-09-21T16:54:19] tokens used: 455,088
[2025-09-21T16:54:19] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..14383bef36ec8f0bc5b3642446db5b6b23128e1f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,38 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned =
+                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
+                    Ok(value) => value,
+                    Err(err) => return Err(err.to_string()),
+                };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +333,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +389,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +398,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +567,7 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +575,7 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +642,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +674,7 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +743,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +781,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..255705b927603c8487138ba6231fb52f9c224d68
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -312,16 +303,11 @@
     Ok(())
 }
 
-fn run(
-    settings: &Settings,
-    svg: bool,
-    all: bool,
-    max_commits: Option<usize>,
-) -> Result<(), String> {
+fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..1e4c09931f1b444bc6b00cf9f121dd0fb332c979
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,28 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .or_else(|| {
+                info.tags
+                    .first()
+                    .and_then(|tag_index| graph.branches.get(*tag_index))
+                    .map(|branch| branch.visual.term_color)
+            })
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +540,25 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..fba490eecd3ac2a38d82f00041edfce248298da0
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,26 +74,38 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
-                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
-                    (r"^(develop|dev)$".to_string(), vec!["bright_yellow".to_string()]),
                     (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (
+                        r"^(develop|dev)$".to_string(),
+                        vec!["bright_yellow".to_string()],
+                    ),
+                    (
                         r"^feature/.*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
-                    (r"^release/.*$".to_string(), vec!["bright_green".to_string()]),
                     (
+                        r"^release/.*$".to_string(),
+                        vec!["bright_green".to_string()],
+                    ),
+                    (
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +123,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +132,16 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
+            order: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +152,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:54:27] thinking

**Continuing to locate tags block**
[2025-09-21T16:54:27] exec bash -lc "nl -ba src/graph.rs | sed -n '360,520p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:54:27] bash -lc "nl -ba src/graph.rs | sed -n '360,520p'" succeeded in 30ms:
   360	                counter += 1;
   361	
   362	                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
   363	
   364	                let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
   365	                    .unwrap_or_else(|| "unknown".to_string());
   366	                let persistence = branch_order(&branch_name, &settings.branches.persistence) as u8;
   367	
   368	                let pos = branch_order(&branch_name, &settings.branches.order);
   369	
   370	                let term_col = to_terminal_color(
   371	                    &branch_color(
   372	                        &branch_name,
   373	                        &settings.branches.terminal_colors[..],
   374	                        &settings.branches.terminal_colors_unknown,
   375	                        counter,
   376	                    )[..],
   377	                )?;
   378	                let svg_col = branch_color(
   379	                    &branch_name,
[2025-09-21T16:54:27] tokens used: 460,147
[2025-09-21T16:54:27] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..14383bef36ec8f0bc5b3642446db5b6b23128e1f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,38 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned =
+                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
+                    Ok(value) => value,
+                    Err(err) => return Err(err.to_string()),
+                };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +333,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +389,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +398,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +567,7 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +575,7 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +642,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +674,7 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +743,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +781,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..255705b927603c8487138ba6231fb52f9c224d68
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -312,16 +303,11 @@
     Ok(())
 }
 
-fn run(
-    settings: &Settings,
-    svg: bool,
-    all: bool,
-    max_commits: Option<usize>,
-) -> Result<(), String> {
+fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..1e4c09931f1b444bc6b00cf9f121dd0fb332c979
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,28 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .or_else(|| {
+                info.tags
+                    .first()
+                    .and_then(|tag_index| graph.branches.get(*tag_index))
+                    .map(|branch| branch.visual.term_color)
+            })
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +540,25 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..fba490eecd3ac2a38d82f00041edfce248298da0
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,26 +74,38 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
-                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
-                    (r"^(develop|dev)$".to_string(), vec!["bright_yellow".to_string()]),
                     (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (
+                        r"^(develop|dev)$".to_string(),
+                        vec!["bright_yellow".to_string()],
+                    ),
+                    (
                         r"^feature/.*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
-                    (r"^release/.*$".to_string(), vec!["bright_green".to_string()]),
                     (
+                        r"^release/.*$".to_string(),
+                        vec!["bright_green".to_string()],
+                    ),
+                    (
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +123,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +132,16 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
+            order: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +152,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:54:35] thinking

**Preparing line number references**
[2025-09-21T16:54:36] exec bash -lc "nl -ba src/print/unicode.rs | sed -n '400,560p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:54:36] bash -lc "nl -ba src/print/unicode.rs | sed -n '400,560p'" succeeded in 26ms:
   400	                                    }
   401	                                }
   402	                                Vacant(entry) => {
   403	                                    entry.insert(vec![vec![Occ::Range(
   404	                                        idx,
   405	                                        *par_idx,
   406	                                        column_range.0,
   407	                                        column_range.1,
   408	                                    )]]);
   409	                                }
   410	                            }
   411	                        }
   412	                    }
   413	                }
   414	            }
   415	        }
   416	    }
   417	
   418	    inserts
   419	}
[2025-09-21T16:54:36] tokens used: 467,100
[2025-09-21T16:54:36] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..14383bef36ec8f0bc5b3642446db5b6b23128e1f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,38 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned =
+                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
+                    Ok(value) => value,
+                    Err(err) => return Err(err.to_string()),
+                };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +333,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +389,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +398,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +567,7 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +575,7 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +642,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +674,7 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +743,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +781,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..255705b927603c8487138ba6231fb52f9c224d68
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -312,16 +303,11 @@
     Ok(())
 }
 
-fn run(
-    settings: &Settings,
-    svg: bool,
-    all: bool,
-    max_commits: Option<usize>,
-) -> Result<(), String> {
+fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..1e4c09931f1b444bc6b00cf9f121dd0fb332c979
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,28 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .or_else(|| {
+                info.tags
+                    .first()
+                    .and_then(|tag_index| graph.branches.get(*tag_index))
+                    .map(|branch| branch.visual.term_color)
+            })
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +540,25 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..fba490eecd3ac2a38d82f00041edfce248298da0
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,26 +74,38 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
-                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
-                    (r"^(develop|dev)$".to_string(), vec!["bright_yellow".to_string()]),
                     (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (
+                        r"^(develop|dev)$".to_string(),
+                        vec!["bright_yellow".to_string()],
+                    ),
+                    (
                         r"^feature/.*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
-                    (r"^release/.*$".to_string(), vec!["bright_green".to_string()]),
                     (
+                        r"^release/.*$".to_string(),
+                        vec!["bright_green".to_string()],
+                    ),
+                    (
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +123,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +132,16 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
+            order: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +152,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:54:46] thinking

**Identifying key lines for modifications**
[2025-09-21T16:54:47] exec bash -lc "nl -ba src/settings.rs | sed -n '60,180p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:54:47] bash -lc "nl -ba src/settings.rs | sed -n '60,180p'" succeeded in 16ms:
    60	
    61	#[derive(Serialize, Deserialize)]
    62	pub struct ColorsDef {
    63	    matches: Vec<(String, Vec<String>)>,
    64	    unknown: Vec<String>,
    65	}
    66	
    67	impl BranchSettingsDef {
    68	    pub fn git_flow() -> Self {
    69	        BranchSettingsDef {
    70	            persistence: vec![
    71	                r"^(master|main)$".to_string(),
    72	                r"^(develop|dev)$".to_string(),
    73	                r"^feature/.*$".to_string(),
    74	                r"^release/.*$".to_string(),
    75	                r"^hotfix/.*$".to_string(),
    76	                r"^bugfix/.*$".to_string(),
    77	                r"^tags/.*$".to_string(),
    78	            ],
    79	            order: vec![
[2025-09-21T16:54:47] tokens used: 473,041
[2025-09-21T16:54:47] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..14383bef36ec8f0bc5b3642446db5b6b23128e1f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,38 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned =
+                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
+                    Ok(value) => value,
+                    Err(err) => return Err(err.to_string()),
+                };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +333,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +389,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +398,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +567,7 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +575,7 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +642,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +674,7 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +743,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +781,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..255705b927603c8487138ba6231fb52f9c224d68
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -312,16 +303,11 @@
     Ok(())
 }
 
-fn run(
-    settings: &Settings,
-    svg: bool,
-    all: bool,
-    max_commits: Option<usize>,
-) -> Result<(), String> {
+fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..1e4c09931f1b444bc6b00cf9f121dd0fb332c979
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,28 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .or_else(|| {
+                info.tags
+                    .first()
+                    .and_then(|tag_index| graph.branches.get(*tag_index))
+                    .map(|branch| branch.visual.term_color)
+            })
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +540,25 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..fba490eecd3ac2a38d82f00041edfce248298da0
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,26 +74,38 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
-                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
-                    (r"^(develop|dev)$".to_string(), vec!["bright_yellow".to_string()]),
                     (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (
+                        r"^(develop|dev)$".to_string(),
+                        vec!["bright_yellow".to_string()],
+                    ),
+                    (
                         r"^feature/.*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
-                    (r"^release/.*$".to_string(), vec!["bright_green".to_string()]),
                     (
+                        r"^release/.*$".to_string(),
+                        vec!["bright_green".to_string()],
+                    ),
+                    (
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +123,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +132,16 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
+            order: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +152,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:54:55] thinking

**Recording line numbers**
[2025-09-21T16:54:55] exec bash -lc "nl -ba src/main.rs | sed -n '20,80p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:54:55] bash -lc "nl -ba src/main.rs | sed -n '20,80p'" succeeded in 18ms:
    20	            1
    21	        }
    22	    });
    23	}
    24	
    25	fn from_args() -> Result<(), String> {
    26	    create_config()?;
    27	
    28	    let app = App::new("git-graph")
    29	        .version(crate_version!())
    30	        .about(
    31	            "Structured Git graphs for your branching model.\n  \
    32	                  https://github.com/mlange-42/git-graph",
    33	        )
    34	        .arg(
    35	            Arg::with_name("max-count")
    36	                .long("max-count")
    37	                .short("n")
    38	                .help("Maximum number of commits")
    39	                .required(false)
[2025-09-21T16:54:55] tokens used: 476,996
[2025-09-21T16:54:55] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..14383bef36ec8f0bc5b3642446db5b6b23128e1f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,38 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned =
+                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
+                    Ok(value) => value,
+                    Err(err) => return Err(err.to_string()),
+                };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +333,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +389,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +398,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +567,7 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +575,7 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +642,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +674,7 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +743,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +781,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..255705b927603c8487138ba6231fb52f9c224d68
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -312,16 +303,11 @@
     Ok(())
 }
 
-fn run(
-    settings: &Settings,
-    svg: bool,
-    all: bool,
-    max_commits: Option<usize>,
-) -> Result<(), String> {
+fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..1e4c09931f1b444bc6b00cf9f121dd0fb332c979
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,28 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .or_else(|| {
+                info.tags
+                    .first()
+                    .and_then(|tag_index| graph.branches.get(*tag_index))
+                    .map(|branch| branch.visual.term_color)
+            })
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +540,25 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..fba490eecd3ac2a38d82f00041edfce248298da0
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,26 +74,38 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
-                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
-                    (r"^(develop|dev)$".to_string(), vec!["bright_yellow".to_string()]),
                     (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (
+                        r"^(develop|dev)$".to_string(),
+                        vec!["bright_yellow".to_string()],
+                    ),
+                    (
                         r"^feature/.*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
-                    (r"^release/.*$".to_string(), vec!["bright_green".to_string()]),
                     (
+                        r"^release/.*$".to_string(),
+                        vec!["bright_green".to_string()],
+                    ),
+                    (
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +123,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +132,16 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
+            order: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +152,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:55:10] thinking

**Identifying snippet location**
[2025-09-21T16:55:11] exec bash -lc "nl -ba src/main.rs | sed -n '170,340p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T16:55:11] bash -lc "nl -ba src/main.rs | sed -n '170,340p'" succeeded in 17ms:
   170	        debug,
   171	        colored,
   172	        compact,
   173	        include_remote,
   174	        characters: style,
   175	        branch_order: BranchOrder::ShortestFirst(true),
   176	        branches: BranchSettings::from(model).map_err(|err| err.to_string())?,
   177	        merge_patterns: MergePatterns::default(),
   178	    };
   179	
   180	    run(&settings, svg, commit_limit)
   181	}
   182	
   183	fn get_model_name() -> Result<Option<String>, String> {
   184	    let path = ".";
   185	    let repository = Repository::open(path).map_err(|err| err.to_string())?;
   186	
   187	    let mut config_path = PathBuf::from(repository.path());
   188	    config_path.push("git-graph.toml");
   189	
[2025-09-21T16:55:11] tokens used: 477,952
[2025-09-21T16:55:11] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..14383bef36ec8f0bc5b3642446db5b6b23128e1f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,38 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned =
+                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
+                    Ok(value) => value,
+                    Err(err) => return Err(err.to_string()),
+                };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +333,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +389,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +398,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +567,7 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +575,7 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +642,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +674,7 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +743,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +781,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..255705b927603c8487138ba6231fb52f9c224d68
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -312,16 +303,11 @@
     Ok(())
 }
 
-fn run(
-    settings: &Settings,
-    svg: bool,
-    all: bool,
-    max_commits: Option<usize>,
-) -> Result<(), String> {
+fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..1e4c09931f1b444bc6b00cf9f121dd0fb332c979
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,28 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .or_else(|| {
+                info.tags
+                    .first()
+                    .and_then(|tag_index| graph.branches.get(*tag_index))
+                    .map(|branch| branch.visual.term_color)
+            })
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +540,25 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..fba490eecd3ac2a38d82f00041edfce248298da0
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,26 +74,38 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
-                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
-                    (r"^(develop|dev)$".to_string(), vec!["bright_yellow".to_string()]),
                     (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (
+                        r"^(develop|dev)$".to_string(),
+                        vec!["bright_yellow".to_string()],
+                    ),
+                    (
                         r"^feature/.*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
-                    (r"^release/.*$".to_string(), vec!["bright_green".to_string()]),
                     (
+                        r"^release/.*$".to_string(),
+                        vec!["bright_green".to_string()],
+                    ),
+                    (
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +123,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +132,16 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
+            order: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +152,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


[2025-09-21T16:55:32] thinking

**Summarizing key updates and test outcomes**

I'll outline the main code modifications with precise file and line references, highlight the attempted formatting and testing steps, note the test failure due to offline dependencies, and mention assumptions made about tag coloring and heuristics used for tag-to-branch mapping. This will organize the final message clearly for the user.
[2025-09-21T16:55:33] codex

**Key Updates**
- Built explicit HEAD/tag tracking in `src/graph.rs:11` and `src/graph.rs:241`, recording the repo’s HEAD OID, capturing tag targets via `tag_foreach`, and skipping tags during branch column layout.
- Highlighted HEAD rows and rendered tag labels in the Unicode printer through `src/print/unicode.rs:421` and `src/print/unicode.rs:491`, reusing branch colors (falling back to the first tag color) so text output shows `HEAD ->` plus `[tag1, …]`.
- Added `^tags/.*$` ordering and color slots to every builtin model in `src/settings.rs:70`, `src/settings.rs:86`, `src/settings.rs:135`, and `src/settings.rs:154`, giving tags deterministic placement and palette entries.
- Removed the `--all` CLI option and simplified graph construction to always `push_glob("*")`, reflected in `src/main.rs:25`, `src/main.rs:180`, and `src/main.rs:306`.

**Validation**
- `cargo fmt`
- `cargo test` *(fails: crates.io unreachable under restricted network; build could not resolve `unicode-xid`)*
[2025-09-21T16:55:35] tokens used: 481,114
[2025-09-21T16:55:35] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 1e8de5884b037a40a00d9e8a6aa33267f427140c..14383bef36ec8f0bc5b3642446db5b6b23128e1f
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -1,36 +1,34 @@
 use crate::print::colors::to_terminal_color;
 use crate::settings::{BranchOrder, BranchSettings, Settings};
 use crate::text;
-use git2::{BranchType, Commit, Error, Oid, Repository};
+use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
 use itertools::Itertools;
 use regex::Regex;
 use std::collections::{HashMap, VecDeque};
+use std::str;
 
 /// Represents a git history graph.
 pub struct GitGraph {
     pub repository: Repository,
+    pub head: Oid,
     pub commits: Vec<CommitInfo>,
     pub indices: HashMap<Oid, usize>,
     pub branches: Vec<BranchInfo>,
 }
 
 impl GitGraph {
-    pub fn new(
-        path: &str,
-        settings: &Settings,
-        all: bool,
-        max_count: Option<usize>,
-    ) -> Result<Self, String> {
+    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
         let repository = Repository::open(path).map_err(|err| err.to_string())?;
+        let head = repository
+            .head()
+            .map_err(|err| err.to_string())?
+            .target()
+            .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
         let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
             .map_err(|err| err.to_string())?;
-        if all {
-            walk.push_glob("*").map_err(|err| err.to_string())?;
-        } else {
-            walk.push_head().map_err(|err| err.to_string())?;
-        }
+        walk.push_glob("*").map_err(|err| err.to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -75,6 +73,7 @@
         let graph = if settings.include_remote {
             GitGraph {
                 repository,
+                head,
                 commits,
                 indices,
                 branches,
@@ -117,6 +116,7 @@
 
             GitGraph {
                 repository,
+                head,
                 commits: filtered_commits,
                 indices: filtered_indices,
                 branches,
@@ -138,6 +138,7 @@
     pub parents: [Option<Oid>; 2],
     pub children: Vec<Oid>,
     pub branches: Vec<usize>,
+    pub tags: Vec<usize>,
     pub branch_trace: Option<usize>,
 }
 
@@ -149,6 +150,7 @@
             parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
             children: Vec::new(),
             branches: Vec::new(),
+            tags: Vec::new(),
             branch_trace: None,
         }
     }
@@ -162,6 +164,7 @@
     pub persistence: u8,
     pub is_remote: bool,
     pub is_merged: bool,
+    pub is_tag: bool,
     pub visual: BranchVis,
     pub range: (Option<usize>, Option<usize>),
 }
@@ -174,6 +177,7 @@
         persistence: u8,
         is_remote: bool,
         is_merged: bool,
+        is_tag: bool,
         visual: BranchVis,
         end_index: Option<usize>,
     ) -> Self {
@@ -184,6 +188,7 @@
             persistence,
             is_remote,
             is_merged,
+            is_tag,
             visual,
             range: (end_index, None),
         }
@@ -239,30 +244,38 @@
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
     let mut branch_idx = 0;
-    let branches_ordered = extract_branches(repository, commits, &indices, settings)?
-        .into_iter()
-        .filter_map(|mut branch| {
-            if let Some(&idx) = &indices.get(&branch.target) {
-                let info = &mut commits[idx];
-                if !branch.is_merged {
-                    info.branches.push(branch_idx);
+    let mut branches_ordered = Vec::new();
+
+    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+        if branch.is_tag {
+            if let Some(start_idx) = branch.range.0 {
+                if let Some(info) = commits.get_mut(start_idx) {
+                    info.tags.push(branch_idx);
                 }
-                let oid = info.oid;
-                let any_assigned =
-                    trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx)
-                        .ok()?;
+            }
+            branch_idx += 1;
+            branches_ordered.push(branch);
+            continue;
+        }
+
+        if let Some(&idx) = &indices.get(&branch.target) {
+            let info = &mut commits[idx];
+            if !branch.is_merged {
+                info.branches.push(branch_idx);
+            }
+            let oid = info.oid;
+            let any_assigned =
+                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
+                    Ok(value) => value,
+                    Err(err) => return Err(err.to_string()),
+                };
 
-                if any_assigned || !branch.is_merged {
-                    branch_idx += 1;
-                    Some(branch)
-                } else {
-                    None
-                }
-            } else {
-                None
+            if any_assigned || !branch.is_merged {
+                branch_idx += 1;
+                branches_ordered.push(branch);
             }
-        })
-        .collect();
+        }
+    }
 
     Ok(branches_ordered)
 }
@@ -320,6 +333,7 @@
                         branch_order(name, &settings.branches.persistence) as u8,
                         &BranchType::Remote == tp,
                         false,
+                        false,
                         BranchVis::new(
                             branch_order(name, &settings.branches.order),
                             term_color,
@@ -375,6 +389,7 @@
                     persistence,
                     false,
                     true,
+                    false,
                     BranchVis::new(pos, term_col, svg_col),
                     Some(idx + 1),
                 );
@@ -383,6 +398,81 @@
         }
     }
 
+    let mut tag_error: Option<String> = None;
+    let mut tag_branches: Vec<BranchInfo> = Vec::new();
+    repository
+        .tag_foreach(|oid, name| {
+            if tag_error.is_some() {
+                return false;
+            }
+            let name = match str::from_utf8(name) {
+                Ok(val) => val.trim_end_matches('\0'),
+                Err(err) => {
+                    tag_error = Some(err.to_string());
+                    return false;
+                }
+            };
+
+            let target_oid = match find_tag_target(repository, *oid, name) {
+                Some(target) => target,
+                None => return true,
+            };
+
+            if let Some(&target_idx) = indices.get(&target_oid) {
+                counter += 1;
+                let tag_name = name.strip_prefix("refs/tags/").unwrap_or(name);
+                let full_name = format!("tags/{}", tag_name);
+
+                let term_color = match to_terminal_color(
+                    &branch_color(
+                        &full_name,
+                        &settings.branches.terminal_colors[..],
+                        &settings.branches.terminal_colors_unknown,
+                        counter,
+                    )[..],
+                ) {
+                    Ok(color) => color,
+                    Err(err) => {
+                        tag_error = Some(err.to_string());
+                        return false;
+                    }
+                };
+
+                let svg_color = branch_color(
+                    &full_name,
+                    &settings.branches.svg_colors,
+                    &settings.branches.svg_colors_unknown,
+                    counter,
+                );
+
+                let mut branch_info = BranchInfo::new(
+                    target_oid,
+                    None,
+                    full_name,
+                    branch_order(&full_name, &settings.branches.persistence) as u8,
+                    false,
+                    false,
+                    true,
+                    BranchVis::new(
+                        branch_order(&full_name, &settings.branches.order),
+                        term_color,
+                        svg_color,
+                    ),
+                    Some(target_idx),
+                );
+                branch_info.range = (Some(target_idx), Some(target_idx));
+                tag_branches.push(branch_info);
+            }
+            true
+        })
+        .map_err(|err| err.to_string())?;
+
+    if let Some(err) = tag_error {
+        return Err(err);
+    }
+
+    valid_branches.extend(tag_branches);
+
     valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
 
     Ok(valid_branches)
@@ -477,7 +567,7 @@
     let mut start_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -485,7 +575,7 @@
     let mut end_queue: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
         .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
         .collect();
@@ -552,6 +642,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -581,7 +674,7 @@
     let branches_sort: VecDeque<_> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
+        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
         .map(|(idx, br)| {
             (
                 idx,
@@ -650,6 +743,9 @@
         .collect();
 
     for branch in branches {
+        if branch.is_tag {
+            continue;
+        }
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
@@ -685,3 +781,26 @@
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);
     color.clone()
 }
+
+fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
+    if let Ok(reference) = repository.find_reference(name) {
+        if let Some(target) = reference.target() {
+            if let Ok(commit) = repository.find_commit(target) {
+                return Some(commit.id());
+            }
+        }
+        if let Ok(object) = reference.peel(ObjectType::Commit) {
+            if let Ok(commit) = object.into_commit() {
+                return Some(commit.id());
+            }
+        }
+    }
+
+    if let Ok(object) = repository.find_object(oid, None) {
+        if let Ok(commit) = object.peel_to_commit() {
+            return Some(commit.id());
+        }
+    }
+
+    None
+}
diff --git a/src/main.rs b/src/main.rs
index d13dce33654810ec7aca0f6408597619decf9d81..255705b927603c8487138ba6231fb52f9c224d68
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,14 +32,6 @@
                   https://github.com/mlange-42/git-graph",
         )
         .arg(
-            Arg::with_name("all")
-                .long("all")
-                .short("a")
-                .help("Show the entire graph, not only from HEAD.")
-                .required(false)
-                .takes_value(false),
-        )
-        .arg(
             Arg::with_name("max-count")
                 .long("max-count")
                 .short("n")
@@ -152,7 +144,6 @@
 
     let model = get_model(matches.value_of("model"))?;
 
-    let all = matches.is_present("all");
     let commit_limit = match matches.value_of("max-count") {
         None => None,
         Some(str) => match str.parse::<usize>() {
@@ -186,7 +177,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, all, commit_limit)
+    run(&settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {
@@ -312,16 +303,11 @@
     Ok(())
 }
 
-fn run(
-    settings: &Settings,
-    svg: bool,
-    all: bool,
-    max_commits: Option<usize>,
-) -> Result<(), String> {
+fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
     let path = ".";
 
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, all, max_commits)?;
+    let graph = GitGraph::new(path, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index c2149679420566b4bdb6c84e4c63126eb4b4495c..1e4c09931f1b444bc6b00cf9f121dd0fb332c979
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -151,10 +151,13 @@
         .map(|(idx, line)| (*line, idx))
         .collect();
 
+    let head_commit_index = graph.indices.get(&graph.head).copied();
+
     let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
+        head_commit_index,
         &settings.characters,
         &grid,
         settings.colored,
@@ -418,6 +421,7 @@
 fn write_graph(
     graph: &GitGraph,
     line_to_index: &HashMap<usize, usize>,
+    head_index: Option<usize>,
     characters: &Characters,
     grid: &Grid,
     color: bool,
@@ -427,6 +431,9 @@
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             for arr in row {
                 if arr[0] == SPACE {
@@ -435,19 +442,22 @@
                     write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
+            let is_head = head_index.map_or(false, |head_idx| {
+                index.map_or(false, |idx| *idx == head_idx)
+            });
             write_pre(&graph, index, out);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
             out.push_str(&line);
-            write_post(&graph, index, color_enabled, out)?;
+            write_post(&graph, index, color_enabled, is_head, out)?;
             out.push('\n');
         }
     }
@@ -482,6 +492,7 @@
     graph: &GitGraph,
     index: Option<&usize>,
     color: bool,
+    is_head: bool,
     out: &mut String,
 ) -> Result<(), String> {
     if let Some(index) = index {
@@ -491,6 +502,28 @@
             Err(err) => return Err(err.to_string()),
         };
         out.push_str("  ");
+
+        let branch_color = info
+            .branch_trace
+            .and_then(|branch_index| graph.branches.get(branch_index))
+            .map(|branch| branch.visual.term_color)
+            .or_else(|| {
+                info.tags
+                    .first()
+                    .and_then(|tag_index| graph.branches.get(*tag_index))
+                    .map(|branch| branch.visual.term_color)
+            })
+            .unwrap_or(WHITE);
+
+        if is_head {
+            if color {
+                write_colored_str(out, "HEAD ->", branch_color);
+            } else {
+                out.push_str("HEAD ->");
+            }
+            out.push(' ');
+        }
+
         if !info.branches.is_empty() {
             out.push('(');
             for (idx, branch_index) in info.branches.iter().enumerate() {
@@ -507,6 +540,25 @@
             }
             out.push_str(") ");
         }
+
+        if !info.tags.is_empty() {
+            out.push('[');
+            for (idx, tag_index) in info.tags.iter().enumerate() {
+                if let Some(branch) = graph.branches.get(*tag_index) {
+                    let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                    if color {
+                        write_colored_str(out, label, branch.visual.term_color);
+                    } else {
+                        out.push_str(label);
+                    }
+                    if idx < info.tags.len() - 1 {
+                        out.push_str(", ");
+                    }
+                }
+            }
+            out.push_str("] ");
+        }
+
         out.push_str(commit.summary().unwrap_or(""));
     }
     Ok(())
diff --git a/src/settings.rs b/src/settings.rs
index 139d1470f5244398b764c1ac62f44f617d045674..fba490eecd3ac2a38d82f00041edfce248298da0
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -74,26 +74,38 @@
                 r"^release/.*$".to_string(),
                 r"^hotfix/.*$".to_string(),
                 r"^bugfix/.*$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             order: vec![
                 r"^(master|main)$".to_string(),
                 r"^(hotfix)|(release)/.*$".to_string(),
                 r"^(develop|dev)$".to_string(),
                 r"^(develop|dev)$".to_string(),
+                r"^tags/.*$".to_string(),
             ],
             terminal_colors: ColorsDef {
                 matches: vec![
-                    (r"^(master|main)$".to_string(), vec!["bright_blue".to_string()]),
-                    (r"^(develop|dev)$".to_string(), vec!["bright_yellow".to_string()]),
                     (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (
+                        r"^(develop|dev)$".to_string(),
+                        vec!["bright_yellow".to_string()],
+                    ),
+                    (
                         r"^feature/.*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
-                    (r"^release/.*$".to_string(), vec!["bright_green".to_string()]),
                     (
+                        r"^release/.*$".to_string(),
+                        vec!["bright_green".to_string()],
+                    ),
+                    (
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["bright_red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
                 ],
                 unknown: vec!["bright_white".to_string()],
             },
@@ -111,6 +123,7 @@
                         r"^(bugfix)|(hotfix)/.*$".to_string(),
                         vec!["red".to_string()],
                     ),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
                 ],
                 unknown: vec!["gray".to_string()],
             },
@@ -119,10 +132,16 @@
 
     pub fn simple() -> Self {
         BranchSettingsDef {
-            persistence: vec![r"^(master|main)$".to_string()],
-            order: vec![r"^(master|main)$".to_string()],
+            persistence: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
+            order: vec![r"^(master|main)$".to_string(), r"^tags/.*$".to_string()],
             terminal_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["bright_blue".to_string()])],
+                matches: vec![
+                    (
+                        r"^(master|main)$".to_string(),
+                        vec!["bright_blue".to_string()],
+                    ),
+                    (r"^tags/.*$".to_string(), vec!["bright_white".to_string()]),
+                ],
                 unknown: vec![
                     "bright_yellow".to_string(),
                     "bright_green".to_string(),
@@ -133,7 +152,10 @@
             },
 
             svg_colors: ColorsDef {
-                matches: vec![(r"^(master|main)$".to_string(), vec!["blue".to_string()])],
+                matches: vec![
+                    (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
+                    (r"^tags/.*$".to_string(), vec!["white".to_string()]),
+                ],
                 unknown: vec![
                     "orange".to_string(),
                     "green".to_string(),


=== 错误 ===
2025-09-21T16:30:49.520531Z ERROR codex_core::exec: exec error: No such file or directory (os error 2)

=== 最终状态 ===
返回码: 0
状态: ✅ 执行成功
