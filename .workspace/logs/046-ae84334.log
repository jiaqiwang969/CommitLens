=== 任务 046-ae84334 执行日志 ===
时间: 2025-09-22 01:17:51.587277
Prompt:
请在 .workspace 内，依据 .workspace/todolist/todolist-046-ae84334.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/046-ae84334/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："046-ae84334：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 046-ae84334

=== 输出 ===
[2025-09-21T17:08:05] OpenAI Codex v0.39.0 (research preview)
--------
workdir: /Users/jqwang/104-CommitLens-codex/.workspace
model: gpt-5-codex-high
provider: codex
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
--------
[2025-09-21T17:08:05] User instructions:
请在 .workspace 内，依据 .workspace/todolist/todolist-046-ae84334.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/046-ae84334/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："046-ae84334：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 046-ae84334

[2025-09-21T17:08:10] thinking

**Preparing environment inspection command**
[2025-09-21T17:08:10] exec bash -lc 'ls -la' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:08:10] bash -lc 'ls -la' succeeded in 14ms:
total 26648
drwxr-xr-x@  9 jqwang  staff       288 Sep 21 15:57 .
drwxr-xr-x@ 29 jqwang  staff       928 Sep 21 07:49 ..
-rw-r--r--@  1 jqwang  staff         0 Sep 22 01:08 codex_error.txt
-rw-r--r--@  1 jqwang  staff  12977472 Sep 22 01:08 codex_output.txt
-rw-r--r--@  1 jqwang  staff         7 Sep 22 01:08 codex_status.txt
drwxr-xr-x@ 47 jqwang  staff      1504 Sep 22 01:07 logs
drwxr-xr-x@ 12 jqwang  staff       384 Sep 21 20:54 rust-project
-rw-r--r--@  1 jqwang  staff       997 Sep 22 01:08 task_status.json
drwxr-xr-x@  5 jqwang  staff       160 Sep 22 01:08 todolist
[2025-09-21T17:08:10] tokens used: 920

[2025-09-21T17:08:13] thinking

**Preparing to view large TeX file**
[2025-09-21T17:08:13] exec bash -lc 'cat todolist/todolist-046-ae84334.tex' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:08:13] bash -lc 'cat todolist/todolist-046-ae84334.tex' succeeded in 10ms:
\section{提交考古：046-ae84334}

\subsection*{Commit 元信息}
\begin{itemize}
  \item 标题：improved error messages, added agrument --path
  % Escape underscores in email to avoid math-mode errors
  \item 作者：Martin Lange <martin\_lange\_@gmx.net>
  \item 日期：2020-12-27T23:48:03+01:00
\end{itemize}

\subsection*{变更摘要（阅读提示）}
\begin{verbatim}
HEAD:   README/docs + CLI 参数；src/{graph,main,print} 统一错误处理；5 files changed, 65 insertions(+), 45 deletions(-)
HEAD-1: CLI 输出与模型列出/查找改造；1 file changed, 36 insertions(+), 12 deletions(-)
HEAD-2: 版本号提升至 0.1.1；2 files changed, 2 insertions(+), 2 deletions(-)
\end{verbatim}

\subsection*{差异解读（证据）}
\begin{itemize}
  \item 改了什么：在 \texttt{src/main.rs} 中新增参数 \texttt{--path/-p} 并改用 \texttt{Repository::discover}（@@ -31,6 +31,14；@@ -118,+），支持从任意路径定位仓库，错误消息指引用户使用该参数。
[2025-09-21T17:08:13] tokens used: 1,384

[2025-09-21T17:08:22] thinking

**Evaluating planning approach**
[2025-09-21T17:08:22] exec bash -lc 'ls -la rust-project' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:08:22] bash -lc 'ls -la rust-project' succeeded in 15ms:
total 72
drwxr-xr-x@ 12 jqwang  staff    384 Sep 21 20:54 .
drwxr-xr-x@  9 jqwang  staff    288 Sep 21 15:57 ..
drwxr-xr-x@ 12 jqwang  staff    384 Sep 22 01:08 .git
-rw-r--r--@  1 jqwang  staff     14 Sep 21 23:47 .gitignore
-rw-r--r--@  1 jqwang  staff   1038 Sep 22 00:25 .travis.yml
-rw-r--r--@  1 jqwang  staff  15829 Sep 22 01:02 Cargo.lock
-rw-r--r--@  1 jqwang  staff    379 Sep 22 01:02 Cargo.toml
-rw-r--r--@  1 jqwang  staff   1069 Sep 21 23:48 LICENSE
-rw-r--r--@  1 jqwang  staff   2868 Sep 22 00:18 README.md
drwxr-xr-x@  3 jqwang  staff     96 Sep 21 16:01 scripts
drwxr-xr-x@  8 jqwang  staff    256 Sep 22 00:28 src
drwxr-xr-x@  5 jqwang  staff    160 Sep 21 16:01 target
[2025-09-21T17:08:22] tokens used: 4,631

[2025-09-21T17:08:25] thinking

**Checking commit history and source files**
[2025-09-21T17:08:25] exec bash -lc "sed -n '1,200p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:08:25] bash -lc "sed -n '1,200p' src/main.rs" succeeded in 20ms:
use clap::{crate_version, App, Arg, SubCommand};
use git2::{Error, Repository};
use git_graph::graph::{CommitInfo, GitGraph};
use git_graph::print::svg::print_svg;
use git_graph::print::unicode::print_unicode;
use git_graph::settings::{
    BranchOrder, BranchSettings, BranchSettingsDef, Characters, MergePatterns, RepoSettings,
    Settings,
};
use platform_dirs::AppDirs;
use std::path::PathBuf;
use std::str::FromStr;
use std::time::Instant;

fn main() {
    std::process::exit(match from_args() {
        Ok(_) => 0,
        Err(err) => {
            eprintln!("{}", err);
            1
[2025-09-21T17:08:25] tokens used: 8,373

[2025-09-21T17:08:27] thinking

**Requesting remaining file content**
[2025-09-21T17:08:27] exec bash -lc "sed -n '200,400p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:08:27] bash -lc "sed -n '200,400p' src/main.rs" succeeded in 9ms:
    let mut models_dir = AppDirs::new(Some("git-graph"), false).unwrap().config_dir;
    models_dir.push("models");
    models_dir
}

fn get_available_models() -> Result<Vec<String>, String> {
    let models_dir = get_models_dir();

    if !models_dir.exists() {
        return Ok(Vec::new());
    }

    let mut models = Vec::new();
    for entry in std::fs::read_dir(&models_dir).map_err(|err| err.to_string())? {
        let path = entry.map_err(|err| err.to_string())?.path();
        if path.is_file() {
            if let Some("toml") = path.extension().and_then(|ext| ext.to_str()) {
                if let Some(stem) = path.file_stem().and_then(|stem| stem.to_str()) {
                    models.push(stem.to_string());
                }
[2025-09-21T17:08:27] tokens used: 10,703
[2025-09-21T17:08:29] exec bash -lc "sed -n '400,800p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:08:29] bash -lc "sed -n '400,800p' src/main.rs" succeeded in 20ms:
                trace,
            ),
            std::iter::repeat(" ")
                .take(branch.visual.column.unwrap())
                .collect::<String>(),
        )
    } else {
        ("".to_string(), "".to_string())
    };

    eprintln!(
        "{}{} {}{}{} {}",
        indent,
        symbol,
        &commit.id().to_string()[0..7],
        trace_str,
        branch_str,
        &commit.summary().unwrap_or("---")
    );

[2025-09-21T17:08:29] tokens used: 12,713

[2025-09-21T17:08:32] thinking

**Preparing to review source files**
[2025-09-21T17:08:32] exec bash -lc "sed -n '1,200p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:08:32] bash -lc "sed -n '1,200p' src/graph.rs" succeeded in 8ms:
use crate::print::colors::to_terminal_color;
use crate::settings::{BranchOrder, BranchSettings, Settings};
use crate::text;
use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
use itertools::Itertools;
use regex::Regex;
use std::collections::{HashMap, VecDeque};
use std::str;

/// Represents a git history graph.
pub struct HeadInfo {
    pub oid: Oid,
    pub name: Option<String>,
    pub is_branch: bool,
}

pub struct GitGraph {
    pub repository: Repository,
    pub head: HeadInfo,
    pub commits: Vec<CommitInfo>,
[2025-09-21T17:08:32] tokens used: 13,027

[2025-09-21T17:08:36] thinking

**Planning repository argument refactor**
[2025-09-21T17:08:36] exec bash -lc "sed -n '1,200p' src/print/svg.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:08:36] bash -lc "sed -n '1,200p' src/print/svg.rs" succeeded in 7ms:
use crate::graph::GitGraph;
use crate::settings::Settings;
use svg::node::element::path::Data;
use svg::node::element::{Circle, Line, Path};
use svg::Document;

pub fn print_svg(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
    let mut document = Document::new();

    let max_idx = graph.commits.len();
    let mut max_column = 0;

    if settings.debug {
        for branch in &graph.branches {
            if let (Some(start), Some(end)) = branch.range {
                document = document.add(bold_line(
                    start,
                    branch.visual.column.unwrap(),
                    end,
                    branch.visual.column.unwrap(),
[2025-09-21T17:08:36] tokens used: 14,982

[2025-09-21T17:08:38] thinking

**Updating error handling in unicode.rs**
[2025-09-21T17:08:39] exec bash -lc "sed -n '450,520p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:08:39] bash -lc "sed -n '450,520p' src/print/unicode.rs" succeeded in 13ms:
        for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
            let index = line_to_index.get(&line_idx);
            let head_info = match (head_index, index) {
                (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                _ => None,
            };
            write_pre(&graph, index, out);
            let line = row
                .iter()
                .map(|arr| characters.chars[arr[0] as usize])
                .collect::<String>();
            out.push_str(&line);
            write_post(&graph, index, color_enabled, head_info, out)?;
            out.push('\n');
        }
    }
    Ok(())
}

fn enable_color_output(requested: bool) -> bool {
[2025-09-21T17:08:39] tokens used: 16,716

[2025-09-21T17:08:41] thinking

**Searching for error string conversions**
[2025-09-21T17:08:42] exec bash -lc "rg \"err\\.to_string\" src" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:08:42] bash -lc "rg \"err\\.to_string\" src" succeeded in 15ms:
src/main.rs:        branches: BranchSettings::from(model).map_err(|err| err.to_string())?,
src/main.rs:    let repository = Repository::open(path).map_err(|err| err.to_string())?;
src/main.rs:            toml::from_str(&std::fs::read_to_string(config_path).map_err(|err| err.to_string())?)
src/main.rs:                .map_err(|err| err.to_string())?;
src/main.rs:    for entry in std::fs::read_dir(&models_dir).map_err(|err| err.to_string())? {
src/main.rs:        let path = entry.map_err(|err| err.to_string())?.path();
src/main.rs:            let repository = Repository::open(path).map_err(|err| err.to_string())?;
src/main.rs:                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
src/main.rs:                .map_err(|err| err.to_string())?;
src/main.rs:            &std::fs::read_to_string(models_file).map_err(|err| err.to_string())?,
src/main.rs:        .map_err(|err| err.to_string())
src/main.rs:    let repository = Repository::open(path).map_err(|err| err.to_string())?;
src/main.rs:    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
src/main.rs:    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
src/main.rs:        std::fs::create_dir_all(&models_dir).map_err(|err| err.to_string())?;
src/main.rs:            let str = toml::to_string_pretty(&model).map_err(|err| err.to_string())?;
src/main.rs:            std::fs::write(&path, str).map_err(|err| err.to_string())?;
src/main.rs:                    Err(err) => return Err(err.to_string()),
src/print/svg.rs:            return Err(err.to_string());
src/print/svg.rs:    String::from_utf8(out).map_err(|err| err.to_string())
[2025-09-21T17:08:42] tokens used: 17,477

[2025-09-21T17:09:11] thinking

**Detailing repository and error handling refactor**

I'm piecing together how the code switches to opening the repository once with `Repository::discover` and passing that `Repository` instance around, especially changing `GitGraph::new` and `run` to accept `&Repository`. This involves careful cloning since `git2::Repository` supports it, updating error message handling to consistently use `err.message()` for git errors, and adjusting CLI argument parsing to support a new `--path` option that influences repository discovery and usage across commands like `model`. I'm deducing these changes from the report details since I can't see the full diffs, making careful guesses about method signatures and error text to replicate the intended improvements smoothly.
[2025-09-21T17:09:12] exec bash -lc 'ls todolist/figs/046-ae84334' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:09:12] bash -lc 'ls todolist/figs/046-ae84334' exited 1 in 20ms:
ls: todolist/figs/046-ae84334: No such file or directory
[2025-09-21T17:09:12] tokens used: 20,230

[2025-09-21T17:09:15] thinking

**Checking directory contents**
[2025-09-21T17:09:15] exec bash -lc 'ls todolist' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:09:15] bash -lc 'ls todolist' succeeded in 19ms:
figs
task_meta.json
todolist-046-ae84334.tex
[2025-09-21T17:09:15] tokens used: 21,288
[2025-09-21T17:09:17] exec bash -lc 'ls todolist/figs' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:09:17] bash -lc 'ls todolist/figs' succeeded in 8ms:
algorithm_flow.puml
architecture.puml
[2025-09-21T17:09:17] tokens used: 21,449

[2025-09-21T17:10:02] thinking

**Designing CLI path option and repository handling**

I'm mapping out how to add a global `--path/-p` argument to specify the Git repository location, restructuring code to discover the repository once per run. I plan to adjust subcommands to access the repository via this new argument, gracefully handle errors with helpful messages, and refactor related functions to accept repository references instead of reopening repositories repeatedly. This should unify repository access across commands while supporting cases where a repo is optional, like listing models.
[2025-09-21T17:10:03] exec bash -lc 'rg "GitGraph::new" -n' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:10:03] bash -lc 'rg "GitGraph::new" -n' succeeded in 47ms:
src/main.rs:329:    let graph = GitGraph::new(path, settings, max_commits)?;
[2025-09-21T17:10:03] tokens used: 23,875

[2025-09-21T17:10:13] thinking

**Adjusting error handling for git2 errors**
[2025-09-21T17:10:14] exec bash -lc "sed -n '200,400p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:10:14] bash -lc "sed -n '200,400p' src/graph.rs" succeeded in 11ms:
            is_remote,
            is_merged,
            is_tag,
            visual,
            range: (end_index, None),
        }
    }
}

/// Branch properties for visualization.
pub struct BranchVis {
    pub order_group: usize,
    pub term_color: u8,
    pub svg_color: String,
    pub column: Option<usize>,
}

impl BranchVis {
    fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
        BranchVis {
[2025-09-21T17:10:14] tokens used: 24,715

[2025-09-21T17:10:17] thinking

**Pausing to review errors**
[2025-09-21T17:10:18] exec bash -lc "sed -n '400,600p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:10:18] bash -lc "sed -n '400,600p' src/graph.rs" succeeded in 9ms:
                    persistence,
                    false,
                    true,
                    false,
                    BranchVis::new(pos, term_col, svg_col),
                    Some(idx + 1),
                );
                valid_branches.push(branch_info);
            }
        }
    }

    let mut tag_error: Option<String> = None;
    let mut tag_branches: Vec<BranchInfo> = Vec::new();
    repository
        .tag_foreach(|oid, name| {
            if tag_error.is_some() {
                return false;
            }
            let name = match str::from_utf8(name) {
[2025-09-21T17:10:18] tokens used: 40,436

[2025-09-21T17:10:31] thinking

**Planning error handling and CLI updates**

I’m sorting out which error conversions need `.message()` calls for `git2::Error` versus `.to_string()` for other error types like `Utf8Error`. Then, I’ll focus on updating the CLI in `main.rs`, adding a `--path` argument, restructuring commands to use a `Repository` helper, and deciding how to handle README updates—likely adding a placeholder if exact docs aren’t available.
[2025-09-21T17:10:33] exec bash -lc "sed -n '1,200p' README.md" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:10:33] bash -lc "sed -n '1,200p' README.md" succeeded in 18ms:
# git-graph

![git-graph screenshot](docs/git-graph.png)

`git-graph` draws readable Git history graphs that follow well-known branching models. It helps teams reason about their release process by grouping branches, merges, and releases into a structured layout.

## Features
- Draws Git graphs that follow `git-flow`, `simple`, or `none` branching models
- Highlights active branches, merges, and tags in a compact Unicode or SVG rendering
- Configurable branch colors via named ANSI colors or 0-255 palette indices in model files
- Supports dense (`--sparse` off) and sparse (`--sparse`) graph styles
- Limits commits via `--max-count` and shows the complete history with `--all`
- Focuses on local development with `--local` to hide remote tracking branches
- Outputs SVG via `--svg` and includes a debug rendering with `--debug`

## Installation
- **Crates.io**: `cargo install git-graph`
- **From source**: clone the repository and run `cargo install --path .`
- **Pre-built binaries**: download the artifact attached to the latest GitHub release

[2025-09-21T17:10:33] tokens used: 42,987

[2025-09-21T17:10:36] thinking

**Planning README and docs update**
[2025-09-21T17:10:36] exec bash -lc 'ls docs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:10:36] bash -lc 'ls docs' exited 1 in 8ms:
ls: docs: No such file or directory
[2025-09-21T17:10:36] tokens used: 47,977

[2025-09-21T17:11:04] thinking

**Planning repository handling and error refinements**

I'm mapping out how to pass `Repository` references throughout the code to unify repository access and adjusting error conversions to use `err.message().to_string()` for git2 errors across modules, plus cleaning up error handling in SVG output paths for consistency. This will require updating function signatures and cloning repositories where necessary.
[2025-09-21T17:11:04] exec bash -lc "rg \"err\\.to_string\" src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:11:04] bash -lc "rg \"err\\.to_string\" src/print/unicode.rs" succeeded in 14ms:
            Err(err) => return Err(err.to_string()),
[2025-09-21T17:11:04] tokens used: 50,110

[2025-09-21T17:11:23] thinking

**Preparing error handling improvements and patch plan**
[2025-09-21T17:11:23] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -1,3 +1,3 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
[2025-09-21T17:11:23] apply_patch(auto_approved=true) exited 0 in 30ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T17:11:23] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..499ba978094b6c5126ad16517c63efdd2465c406
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;

[2025-09-21T17:11:23] tokens used: 51,449
[2025-09-21T17:11:23] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..499ba978094b6c5126ad16517c63efdd2465c406
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;


[2025-09-21T17:11:28] thinking

**Adding new path argument**
[2025-09-21T17:11:30] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -100,2 +100,10 @@
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
[2025-09-21T17:11:30] apply_patch(auto_approved=true) exited 0 in 18ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T17:11:30] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..94b1387c40a10891cbb334027a6fc84a59b25876
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")

[2025-09-21T17:11:30] tokens used: 51,974
[2025-09-21T17:11:30] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..94b1387c40a10891cbb334027a6fc84a59b25876
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")


[2025-09-21T17:11:49] thinking

**Restructuring repository discovery and command flow**
[2025-09-21T17:11:57] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -130,2 +130,3 @@
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
@@ -137,5 +138,6 @@
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
@@ -145,3 +147,3 @@
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
@@ -150,3 +152,4 @@
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
@@ -185,3 +188,3 @@
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
[2025-09-21T17:11:57] apply_patch(auto_approved=true) exited 0 in 31ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T17:11:57] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..f9cb3d68d2e5891a3bfb42d387136eb9bf5e0313
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,7 +186,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {

[2025-09-21T17:11:57] tokens used: 57,887
[2025-09-21T17:11:57] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..f9cb3d68d2e5891a3bfb42d387136eb9bf5e0313
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,7 +186,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {


[2025-09-21T17:12:03] thinking

**Refactoring function signatures to accept repository**
[2025-09-21T17:12:04] tokens used: 59,928
[2025-09-21T17:12:04] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..f9cb3d68d2e5891a3bfb42d387136eb9bf5e0313
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,7 +186,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
 fn get_model_name() -> Result<Option<String>, String> {


[2025-09-21T17:12:06] thinking

**Correcting working directory path**
[2025-09-21T17:12:08] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -191,6 +191,3 @@
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
[2025-09-21T17:12:08] apply_patch(auto_approved=true) exited 0 in 21ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T17:12:08] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..8177b9e3e9976c2e0ebc8edc1af4af38b504c920
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 

[2025-09-21T17:12:08] tokens used: 61,191
[2025-09-21T17:12:08] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..8177b9e3e9976c2e0ebc8edc1af4af38b504c920
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 


[2025-09-21T17:12:11] thinking

**Checking code cleanliness and references**
[2025-09-21T17:12:11] exec bash -lc "sed -n '130,220p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:12:11] bash -lc "sed -n '130,220p' src/main.rs" succeeded in 19ms:
    let matches = app.clone().get_matches();
    let repo_path = matches.value_of("path");

    if let Some(matches) = matches.subcommand_matches("model") {
        if matches.is_present("list") {
            println!("{}", get_available_models()?.join("\n"));
            return Ok(());
        }

        let repository = discover_repository(repo_path)?;
        match matches.value_of("model") {
            None => {
                let curr_model = get_model_name(&repository)?;
                match curr_model {
                    None => println!("No branching model set"),
                    Some(model) => println!("{}", model),
                }
            }
            Some(model) => set_model(&repository, model)?,
        };
[2025-09-21T17:12:11] tokens used: 61,675
[2025-09-21T17:12:11] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..8177b9e3e9976c2e0ebc8edc1af4af38b504c920
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 


[2025-09-21T17:12:14] thinking

**Updating get_model signature**
[2025-09-21T17:12:16] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -235,3 +235,3 @@
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
@@ -239,5 +239,2 @@
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
[2025-09-21T17:12:16] apply_patch(auto_approved=true) exited 0 in 31ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T17:12:16] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..730ea03ac38ac64dd12d168b9f9e50ddac416ae8
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 

[2025-09-21T17:12:16] tokens used: 62,917
[2025-09-21T17:12:16] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..730ea03ac38ac64dd12d168b9f9e50ddac416ae8
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 


[2025-09-21T17:12:19] thinking

**Refactoring set_model signature**
[2025-09-21T17:12:20] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -280,7 +280,4 @@
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
[2025-09-21T17:12:20] apply_patch(auto_approved=true) exited 0 in 32ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T17:12:20] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..0d8e723783bd4d3fc6eb9a9a0a8c6763fcfd6abe
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");

[2025-09-21T17:12:20] tokens used: 63,442
[2025-09-21T17:12:20] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..0d8e723783bd4d3fc6eb9a9a0a8c6763fcfd6abe
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");


[2025-09-21T17:12:25] thinking

**Updating run function signature and implementation**
[2025-09-21T17:12:27] tokens used: 65,578
[2025-09-21T17:12:27] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..0d8e723783bd4d3fc6eb9a9a0a8c6763fcfd6abe
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");


[2025-09-21T17:12:29] thinking

**Remembering to set working directory**
[2025-09-21T17:12:31] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -326,7 +326,10 @@
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
-
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
[2025-09-21T17:12:31] apply_patch(auto_approved=true) exited 0 in 28ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T17:12:31] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..667a121cd3d22d9c7bbad2166fe66a2d103a2a4f
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
@@ -322,11 +324,14 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
-
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 

[2025-09-21T17:12:31] tokens used: 66,483
[2025-09-21T17:12:31] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..667a121cd3d22d9c7bbad2166fe66a2d103a2a4f
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
@@ -322,11 +324,14 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
-
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 


[2025-09-21T17:12:41] thinking

**Adding a repository discovery helper**
[2025-09-21T17:12:44] tokens used: 67,835
[2025-09-21T17:12:44] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..667a121cd3d22d9c7bbad2166fe66a2d103a2a4f
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
@@ -322,11 +324,14 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
-
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 


[2025-09-21T17:12:47] thinking

**Preparing working directory**
[2025-09-21T17:12:50] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -326,2 +326,20 @@
 
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
+
 fn run(
[2025-09-21T17:12:50] apply_patch(auto_approved=true) exited 0 in 29ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T17:12:50] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..e85d339f3678c975ab223def9ad582c59b29f2d9
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 

[2025-09-21T17:12:50] tokens used: 69,854
[2025-09-21T17:12:50] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..e85d339f3678c975ab223def9ad582c59b29f2d9
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 


[2025-09-21T17:12:53] thinking

**Updating error conversions for git**
[2025-09-21T17:12:53] exec bash -lc 'rg "Repository::open" -n src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:12:53] bash -lc 'rg "Repository::open" -n src/main.rs' exited 1 in 16ms:

[2025-09-21T17:12:53] tokens used: 70,697
[2025-09-21T17:12:53] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..e85d339f3678c975ab223def9ad582c59b29f2d9
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 


[2025-09-21T17:13:02] thinking

**Refactoring GitGraph::new signature and error handling**
[2025-09-21T17:13:06] tokens used: 71,910
[2025-09-21T17:13:06] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..e85d339f3678c975ab223def9ad582c59b29f2d9
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 


[2025-09-21T17:13:09] thinking

**Setting working directory**
[2025-09-21T17:13:12] tokens used: 73,187
[2025-09-21T17:13:12] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..e85d339f3678c975ab223def9ad582c59b29f2d9
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 


[2025-09-21T17:13:15] thinking

**Setting working directory**
[2025-09-21T17:13:19] tokens used: 74,475
[2025-09-21T17:13:19] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..e85d339f3678c975ab223def9ad582c59b29f2d9
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 


[2025-09-21T17:13:22] thinking

**Correcting working directory setting**
[2025-09-21T17:13:22] exec bash -lc pwd in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:13:22] bash -lc pwd succeeded in 17ms:
/Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:13:22] tokens used: 75,228
[2025-09-21T17:13:22] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..e85d339f3678c975ab223def9ad582c59b29f2d9
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 


[2025-09-21T17:13:25] thinking

**Resetting patch with specific workdir**
[2025-09-21T17:13:29] tokens used: 76,037
[2025-09-21T17:13:29] turn diff:
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..e85d339f3678c975ab223def9ad582c59b29f2d9
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 


[2025-09-21T17:13:32] thinking

**Adding missing workdir parameter**
[2025-09-21T17:13:36] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -25,6 +25,14 @@
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository
+            .head()
+            .map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
@@ -37,7 +45,10 @@
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
@@ -52,3 +63,3 @@
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
[2025-09-21T17:13:36] apply_patch(auto_approved=true) exited 0 in 33ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T17:13:36] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..324c64e24d9462ce5465407761740b0fb6933e9d
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,18 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository
+            .head()
+            .map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +43,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +61,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..e85d339f3678c975ab223def9ad582c59b29f2d9
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 

[2025-09-21T17:13:36] tokens used: 77,479
[2025-09-21T17:13:36] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..324c64e24d9462ce5465407761740b0fb6933e9d
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,18 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository
+            .head()
+            .map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +43,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +61,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..e85d339f3678c975ab223def9ad582c59b29f2d9
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 


[2025-09-21T17:13:40] thinking

**Replacing .to_string() calls for errors**
[2025-09-21T17:13:40] exec bash -lc "rg \"err\\.to_string\" -n src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:13:40] bash -lc "rg \"err\\.to_string\" -n src/graph.rs" succeeded in 9ms:
292:                    Err(err) => return Err(err.to_string()),
319:        .map_err(|err| err.to_string())?
321:        .map_err(|err| err.to_string())?;
379:            .map_err(|err| err.to_string())?;
384:                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
433:                    tag_error = Some(err.to_string());
458:                        tag_error = Some(err.to_string());
490:        .map_err(|err| err.to_string())?;
[2025-09-21T17:13:40] tokens used: 78,263
[2025-09-21T17:13:40] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..324c64e24d9462ce5465407761740b0fb6933e9d
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,18 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository
+            .head()
+            .map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +43,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +61,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..e85d339f3678c975ab223def9ad582c59b29f2d9
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 


[2025-09-21T17:13:45] thinking

**Examining error handling changes near line 292**
[2025-09-21T17:13:46] exec bash -lc "sed -n '260,320p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:13:46] bash -lc "sed -n '260,320p' src/graph.rs" succeeded in 19ms:
/// * Sort all branches by persistence
/// * Iterating over all branches in persistence order, trace back over commit parents until a trace is already assigned
fn assign_branches(
    repository: &Repository,
    commits: &mut [CommitInfo],
    indices: &HashMap<Oid, usize>,
    settings: &Settings,
) -> Result<Vec<BranchInfo>, String> {
    let mut branch_idx = 0;
    let mut branches_ordered = Vec::new();

    for mut branch in extract_branches(repository, commits, &indices, settings)? {
        if branch.is_tag {
            if let Some(start_idx) = branch.range.0 {
                if let Some(info) = commits.get_mut(start_idx) {
                    info.tags.push(branch_idx);
                }
            }
            branch_idx += 1;
            branches_ordered.push(branch);
[2025-09-21T17:13:46] tokens used: 83,144
[2025-09-21T17:13:46] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..324c64e24d9462ce5465407761740b0fb6933e9d
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,18 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository
+            .head()
+            .map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +43,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +61,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..e85d339f3678c975ab223def9ad582c59b29f2d9
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 


[2025-09-21T17:13:53] thinking

**Updating error conversion for git2::Error**
[2025-09-21T17:13:53] exec bash -lc "sed -n '420,500p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:13:53] bash -lc "sed -n '420,500p' src/graph.rs" succeeded in 9ms:
        }
    }

    let mut tag_error: Option<String> = None;
    let mut tag_branches: Vec<BranchInfo> = Vec::new();
    repository
        .tag_foreach(|oid, name| {
            if tag_error.is_some() {
                return false;
            }
            let name = match str::from_utf8(name) {
                Ok(val) => val.trim_end_matches('\0'),
                Err(err) => {
                    tag_error = Some(err.to_string());
                    return false;
                }
            };

            let target_oid = match find_tag_target(repository, *oid, name) {
                Some(target) => target,
[2025-09-21T17:13:53] tokens used: 84,514
[2025-09-21T17:13:53] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..324c64e24d9462ce5465407761740b0fb6933e9d
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,18 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository
+            .head()
+            .map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +43,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +61,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..e85d339f3678c975ab223def9ad582c59b29f2d9
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 


[2025-09-21T17:14:03] thinking

**Refining error string conversions for git2 errors**
[2025-09-21T17:14:06] tokens used: 86,166
[2025-09-21T17:14:06] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..324c64e24d9462ce5465407761740b0fb6933e9d
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,18 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository
+            .head()
+            .map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +43,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +61,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..e85d339f3678c975ab223def9ad582c59b29f2d9
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 


[2025-09-21T17:14:09] thinking

**Setting the working directory**
[2025-09-21T17:14:12] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -291,3 +291,3 @@
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
@@ -318,5 +318,5 @@
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
@@ -378,3 +378,3 @@
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
@@ -383,3 +383,5 @@
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
@@ -489,3 +491,3 @@
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
[2025-09-21T17:14:12] apply_patch(auto_approved=true) exited 0 in 24ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T17:14:12] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..4557fd49c632c519affe8211ccf8f060cd4c92b2
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,18 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository
+            .head()
+            .map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +43,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +61,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +289,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +316,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +376,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +489,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..e85d339f3678c975ab223def9ad582c59b29f2d9
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 

[2025-09-21T17:14:12] tokens used: 87,154
[2025-09-21T17:14:12] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..4557fd49c632c519affe8211ccf8f060cd4c92b2
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,18 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository
+            .head()
+            .map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +43,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +61,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +289,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +316,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +376,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +489,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..e85d339f3678c975ab223def9ad582c59b29f2d9
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 


[2025-09-21T17:14:16] thinking

**Searching for remaining err.to_string() calls**
[2025-09-21T17:14:16] exec bash -lc "rg \"err\\.to_string\" -n src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:14:16] bash -lc "rg \"err\\.to_string\" -n src/graph.rs" succeeded in 24ms:
435:                    tag_error = Some(err.to_string());
460:                        tag_error = Some(err.to_string());
[2025-09-21T17:14:16] tokens used: 87,741
[2025-09-21T17:14:16] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..4557fd49c632c519affe8211ccf8f060cd4c92b2
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,18 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository
+            .head()
+            .map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +43,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +61,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +289,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +316,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +376,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +489,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..e85d339f3678c975ab223def9ad582c59b29f2d9
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 


[2025-09-21T17:14:25] thinking

**Reviewing error handling in main.rs**
[2025-09-21T17:14:26] exec bash -lc 'rg "err.to_string" -n src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:14:26] bash -lc 'rg "err.to_string" -n src/main.rs' succeeded in 10ms:
185:        branches: BranchSettings::from(model).map_err(|err| err.to_string())?,
198:            toml::from_str(&std::fs::read_to_string(config_path).map_err(|err| err.to_string())?)
199:                .map_err(|err| err.to_string())?;
221:    for entry in std::fs::read_dir(&models_dir).map_err(|err| err.to_string())? {
222:        let path = entry.map_err(|err| err.to_string())?.path();
245:                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
247:                .map_err(|err| err.to_string())?;
263:            &std::fs::read_to_string(models_file).map_err(|err| err.to_string())?,
265:        .map_err(|err| err.to_string())
291:    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
292:    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
309:        std::fs::create_dir_all(&models_dir).map_err(|err| err.to_string())?;
319:            let str = toml::to_string_pretty(&model).map_err(|err| err.to_string())?;
320:            std::fs::write(&path, str).map_err(|err| err.to_string())?;
371:                    Err(err) => return Err(err.to_string()),
[2025-09-21T17:14:26] tokens used: 127,843
[2025-09-21T17:14:26] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..4557fd49c632c519affe8211ccf8f060cd4c92b2
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,18 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository
+            .head()
+            .map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +43,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +61,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +289,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +316,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +376,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +489,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..e85d339f3678c975ab223def9ad582c59b29f2d9
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,11 +278,8 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
-
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
 
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 


[2025-09-21T17:14:30] thinking

**Reviewing error handling conversions**
[2025-09-21T17:14:31] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -370,3 +370,3 @@
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
[2025-09-21T17:14:31] apply_patch(auto_approved=true) exited 0 in 37ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T17:14:31] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..4557fd49c632c519affe8211ccf8f060cd4c92b2
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,18 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository
+            .head()
+            .map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +43,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +61,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +289,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +316,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +376,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +489,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..0ac930a45f715a943bbe2e5d434ef85cbb616532
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +278,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +368,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }

[2025-09-21T17:14:31] tokens used: 128,875
[2025-09-21T17:14:31] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..4557fd49c632c519affe8211ccf8f060cd4c92b2
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,18 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository
+            .head()
+            .map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +43,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +61,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +289,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +316,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +376,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +489,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..0ac930a45f715a943bbe2e5d434ef85cbb616532
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +278,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +368,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }


[2025-09-21T17:14:36] thinking

**Updating error handling messages**
[2025-09-21T17:14:37] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -503,3 +503,3 @@
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
[2025-09-21T17:14:37] apply_patch(auto_approved=true) exited 0 in 44ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T17:14:37] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..4557fd49c632c519affe8211ccf8f060cd4c92b2
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,18 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository
+            .head()
+            .map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +43,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +61,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +289,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +316,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +376,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +489,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..0ac930a45f715a943bbe2e5d434ef85cbb616532
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +278,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +368,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 

[2025-09-21T17:14:37] tokens used: 129,255
[2025-09-21T17:14:37] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..4557fd49c632c519affe8211ccf8f060cd4c92b2
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,18 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository
+            .head()
+            .map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +43,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +61,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +289,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +316,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +376,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +489,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..0ac930a45f715a943bbe2e5d434ef85cbb616532
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +278,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +368,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:14:40] thinking

**Updating error handling in print/svg.rs**
[2025-09-21T17:14:41] exec bash -lc "sed -n '60,120p' src/print/svg.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:14:41] bash -lc "sed -n '60,120p' src/print/svg.rs" succeeded in 20ms:
                                branch.visual.column.unwrap(),
                                *par_idx,
                                par_branch.visual.column.unwrap(),
                                split_index,
                                color,
                            ));
                        }
                    }
                }
            }

            document = document.add(commit_dot(
                idx,
                branch.visual.column.unwrap(),
                branch_color,
                !info.is_merge,
            ));
        }
    }
    let (x_max, y_max) = commit_coord(max_idx + 1, max_column + 1);
[2025-09-21T17:14:41] tokens used: 129,492
[2025-09-21T17:14:41] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..4557fd49c632c519affe8211ccf8f060cd4c92b2
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,18 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository
+            .head()
+            .map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +43,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +61,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +289,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +316,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +376,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +489,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..0ac930a45f715a943bbe2e5d434ef85cbb616532
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +278,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +368,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:14:49] thinking

**Updating SVG write error handling**
[2025-09-21T17:14:52] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/svg.rs
@@ -85,8 +85,3 @@
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
[2025-09-21T17:14:52] apply_patch(auto_approved=true) exited 0 in 38ms:
Success. Updated the following files:
M src/print/svg.rs
[2025-09-21T17:14:52] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..4557fd49c632c519affe8211ccf8f060cd4c92b2
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,18 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository
+            .head()
+            .map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +43,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +61,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +289,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +316,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +376,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +489,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..0ac930a45f715a943bbe2e5d434ef85cbb616532
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +278,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +368,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 

[2025-09-21T17:14:52] tokens used: 131,331
[2025-09-21T17:14:52] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..4557fd49c632c519affe8211ccf8f060cd4c92b2
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,18 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository
+            .head()
+            .map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +43,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +61,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +289,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +316,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +376,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +489,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..0ac930a45f715a943bbe2e5d434ef85cbb616532
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +278,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +368,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:15:01] thinking

**Verifying git error handling and updating README**
[2025-09-21T17:15:03] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/README.md
@@ -30,2 +30,3 @@
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
[2025-09-21T17:15:03] apply_patch(auto_approved=true) exited 0 in 43ms:
Success. Updated the following files:
M README.md
[2025-09-21T17:15:03] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..4557fd49c632c519affe8211ccf8f060cd4c92b2
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,18 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository
+            .head()
+            .map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +43,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +61,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +289,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +316,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +376,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +489,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..0ac930a45f715a943bbe2e5d434ef85cbb616532
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +278,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +368,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 

[2025-09-21T17:15:03] tokens used: 132,743
[2025-09-21T17:15:03] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..4557fd49c632c519affe8211ccf8f060cd4c92b2
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,18 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository
+            .head()
+            .map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +43,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +61,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +289,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +316,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +376,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +489,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..0ac930a45f715a943bbe2e5d434ef85cbb616532
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +278,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +368,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:15:08] thinking

**Preparing to format Rust code**
[2025-09-21T17:15:08] exec bash -lc 'cargo fmt' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:15:08] bash -lc 'cargo fmt' succeeded in 62ms:

[2025-09-21T17:15:08] tokens used: 133,784
[2025-09-21T17:15:08] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..0ac930a45f715a943bbe2e5d434ef85cbb616532
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +278,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +368,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:15:12] thinking

**Preparing to build project**
[2025-09-21T17:15:13] exec bash -lc 'cargo build' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:15:23] bash -lc 'cargo build' exited 124 in 10.00s:
    Updating crates.io index
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
[2025-09-21T17:15:23] tokens used: 134,348
[2025-09-21T17:15:23] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..0ac930a45f715a943bbe2e5d434ef85cbb616532
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +278,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +368,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:15:29] thinking

**Handling offline build failure**

I see the build failed due to network restrictions preventing index updates. Since the repo likely has a Cargo.lock, I’ll try running `cargo build --offline` to avoid further network issues and see if it succeeds without needing to update crates.
[2025-09-21T17:15:30] exec bash -lc 'cargo build --offline' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:15:30] bash -lc 'cargo build --offline' exited -1 in 0ms:
error: no matching package named `unicode-xid` found
location searched: crates.io index
required by package `proc-macro2 v1.0.24`
    ... which satisfies dependency `proc-macro2 = "^1.0"` (locked to 1.0.24) of package `serde_derive v1.0.118`
    ... which satisfies dependency `serde_derive = "^1.0"` (locked to 1.0.118) of package `git-graph v0.1.1 (/Users/jqwang/104-CommitLens-codex/.workspace/rust-project)`
As a reminder, you're using offline mode (--offline) which can sometimes cause surprising resolution failures, if this error is too confusing you may wish to retry without `--offline`.
[2025-09-21T17:15:30] tokens used: 135,172
[2025-09-21T17:15:30] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..0ac930a45f715a943bbe2e5d434ef85cbb616532
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +278,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +368,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:15:35] thinking

**Preparing to commit changes**
[2025-09-21T17:15:35] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:15:35] bash -lc 'git status -sb' succeeded in 37ms:
## main
 M README.md
 M src/graph.rs
 M src/main.rs
 M src/print/svg.rs
 M src/print/unicode.rs
[2025-09-21T17:15:35] tokens used: 135,569
[2025-09-21T17:15:35] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..0ac930a45f715a943bbe2e5d434ef85cbb616532
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +278,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +368,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:15:39] thinking

**Checking src/main.rs diff**
[2025-09-21T17:15:39] exec bash -lc 'git diff --stat' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:15:39] bash -lc 'git diff --stat' succeeded in 25ms:
 README.md            |  1 +
 src/graph.rs         | 39 ++++++++++++++++++++-----------
 src/main.rs          | 65 +++++++++++++++++++++++++++++++++++-----------------
 src/print/svg.rs     |  7 +-----
 src/print/unicode.rs |  2 +-
 5 files changed, 72 insertions(+), 42 deletions(-)
[2025-09-21T17:15:39] tokens used: 136,606
[2025-09-21T17:15:39] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..0ac930a45f715a943bbe2e5d434ef85cbb616532
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +278,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +368,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:15:43] thinking

**Inspecting main.rs diffs**
[2025-09-21T17:15:43] exec bash -lc 'git diff src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:15:43] bash -lc 'git diff src/main.rs' succeeded in 20ms:
diff --git a/src/main.rs b/src/main.rs
index 595b85b..0ac930a 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@ fn from_args() -> Result<(), String> {
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
[2025-09-21T17:15:43] tokens used: 136,930
[2025-09-21T17:15:43] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..0ac930a45f715a943bbe2e5d434ef85cbb616532
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +278,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +368,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:15:48] thinking

**Verifying semicolon usage in diff**
[2025-09-21T17:15:49] exec bash -lc 'git diff src/graph.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:15:49] bash -lc 'git diff src/graph.rs' succeeded in 24ms:
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84..98a5e85 100644
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@ pub struct GitGraph {
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
[2025-09-21T17:15:49] tokens used: 139,087
[2025-09-21T17:15:49] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..0ac930a45f715a943bbe2e5d434ef85cbb616532
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +278,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +368,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:15:54] thinking

**Reviewing error handling formatting**
[2025-09-21T17:15:54] exec bash -lc 'git diff src/print/svg.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:15:54] bash -lc 'git diff src/print/svg.rs' succeeded in 19ms:
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f..81fad26 100644
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@ pub fn print_svg(graph: &GitGraph, settings: &Settings) -> Result<String, String
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
[2025-09-21T17:15:54] tokens used: 142,163
[2025-09-21T17:15:54] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..0ac930a45f715a943bbe2e5d434ef85cbb616532
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +278,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +368,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:15:58] thinking

**Reviewing print/unicode.rs changes**
[2025-09-21T17:15:59] exec bash -lc 'git diff src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:15:59] bash -lc 'git diff src/print/unicode.rs' succeeded in 19ms:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a4..b969413 100644
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@ fn write_post(
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 
[2025-09-21T17:15:59] tokens used: 142,608
[2025-09-21T17:15:59] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..0ac930a45f715a943bbe2e5d434ef85cbb616532
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +278,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +368,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:16:03] thinking

**Checking README changes**
[2025-09-21T17:16:03] exec bash -lc 'git diff README.md' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:16:03] bash -lc 'git diff README.md' succeeded in 20ms:
diff --git a/README.md b/README.md
index 541fbe9..243e6e0 100644
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@ Common flags:
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
[2025-09-21T17:16:03] tokens used: 142,904
[2025-09-21T17:16:03] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..0ac930a45f715a943bbe2e5d434ef85cbb616532
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,14 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +128,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +136,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +186,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +233,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +278,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +324,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +368,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:16:17] thinking

**Ensuring global argument availability for subcommands**

I’m verifying that the `--path` argument in Clap is set as global so it works with subcommands like `model`. Since Clap 2 requires `.global(true)` to access arguments after the subcommand, adding this flag to the `Arg` should make `git-graph model --path ...` valid and smooth out usage. I’ll update the argument builder accordingly to improve command-line consistency.
[2025-09-21T17:16:20] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -106,3 +106,4 @@
                 .required(false)
-                .takes_value(true),
+                .takes_value(true)
+                .global(true),
         )
[2025-09-21T17:16:20] apply_patch(auto_approved=true) exited 0 in 59ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T17:16:20] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..26b80efc7c0402b39d8303443127851e5bd05bc7
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,15 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true)
+                .global(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +129,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +137,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +187,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +234,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +279,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +325,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +369,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 

[2025-09-21T17:16:20] tokens used: 145,821
[2025-09-21T17:16:20] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..26b80efc7c0402b39d8303443127851e5bd05bc7
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,15 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true)
+                .global(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +129,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +137,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +187,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +234,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +279,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +325,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +369,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:16:24] thinking

**Running cargo fmt for formatting**
[2025-09-21T17:16:24] exec bash -lc 'cargo fmt' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:16:24] bash -lc 'cargo fmt' succeeded in 70ms:

[2025-09-21T17:16:24] tokens used: 157,826
[2025-09-21T17:16:24] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..26b80efc7c0402b39d8303443127851e5bd05bc7
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,15 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true)
+                .global(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +129,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +137,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +187,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +234,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +279,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +325,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +369,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:16:27] thinking

**Verifying format stability**
[2025-09-21T17:16:27] exec bash -lc 'git diff src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:16:27] bash -lc 'git diff src/main.rs' succeeded in 20ms:
diff --git a/src/main.rs b/src/main.rs
index 595b85b..26b80ef 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,15 @@ fn from_args() -> Result<(), String> {
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
[2025-09-21T17:16:27] tokens used: 159,042
[2025-09-21T17:16:27] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..26b80efc7c0402b39d8303443127851e5bd05bc7
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,15 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true)
+                .global(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +129,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +137,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +187,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +234,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +279,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +325,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +369,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:16:33] thinking

**Verifying code formatting effects**
[2025-09-21T17:16:33] exec bash -lc 'git diff --stat' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:16:33] bash -lc 'git diff --stat' succeeded in 31ms:
 README.md            |  1 +
 src/graph.rs         | 39 ++++++++++++++++++++-----------
 src/main.rs          | 66 +++++++++++++++++++++++++++++++++++-----------------
 src/print/svg.rs     |  7 +-----
 src/print/unicode.rs |  2 +-
 5 files changed, 73 insertions(+), 42 deletions(-)
[2025-09-21T17:16:33] tokens used: 160,869
[2025-09-21T17:16:33] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..26b80efc7c0402b39d8303443127851e5bd05bc7
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,15 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true)
+                .global(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +129,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +137,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +187,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +234,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +279,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +325,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +369,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:16:39] thinking

**Preparing commit after build attempt**
[2025-09-21T17:16:39] exec bash -lc 'git add -A' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:16:39] bash -lc 'git add -A' succeeded in 38ms:

[2025-09-21T17:16:39] tokens used: 162,848
[2025-09-21T17:16:39] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..26b80efc7c0402b39d8303443127851e5bd05bc7
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,15 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true)
+                .global(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +129,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +137,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +187,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +234,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +279,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +325,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +369,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:16:44] thinking

**Committing changes with message**
[2025-09-21T17:16:45] exec bash -lc 'git commit -m "046-ae84334：复现提交代码内容。"' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:16:45] bash -lc 'git commit -m "046-ae84334：复现提交代码内容。"' succeeded in 38ms:
[main b382093] 046-ae84334：复现提交代码内容。
 5 files changed, 73 insertions(+), 42 deletions(-)
[2025-09-21T17:16:45] tokens used: 163,054
[2025-09-21T17:16:45] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..26b80efc7c0402b39d8303443127851e5bd05bc7
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,15 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true)
+                .global(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +129,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +137,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +187,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +234,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +279,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +325,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +369,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:16:53] thinking

**Gathering line numbers for summary**
[2025-09-21T17:16:54] exec bash -lc "nl -ba src/main.rs | sed -n '90,200p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:16:54] bash -lc "nl -ba src/main.rs | sed -n '90,200p'" succeeded in 30ms:
    90	                .required(false)
    91	                .takes_value(true),
    92	        )
    93	        .arg(
    94	            Arg::with_name("local")
    95	                .long("local")
    96	                .short("l")
    97	                .help("Show only local branches, no remotes.")
    98	                .required(false)
    99	                .takes_value(false),
   100	        )
   101	        .arg(
   102	            Arg::with_name("path")
   103	                .long("path")
   104	                .short("p")
   105	                .help("Start repository discovery at <path>.")
   106	                .required(false)
   107	                .takes_value(true)
   108	                .global(true),
   109	        )
[2025-09-21T17:16:54] tokens used: 163,499
[2025-09-21T17:16:54] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..26b80efc7c0402b39d8303443127851e5bd05bc7
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,15 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true)
+                .global(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +129,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +137,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +187,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +234,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +279,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +325,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +369,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:16:59] thinking

**Locating key function lines**
[2025-09-21T17:16:59] exec bash -lc "nl -ba src/main.rs | sed -n '250,380p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:16:59] bash -lc "nl -ba src/main.rs | sed -n '250,380p'" succeeded in 29ms:
   250	                read_model(&repo_config.model)
   251	            } else {
   252	                read_model("git-flow").or_else(|_| Ok(BranchSettingsDef::git_flow()))
   253	            }
   254	        }
   255	    }
   256	}
   257	
   258	fn read_model(model: &str) -> Result<BranchSettingsDef, String> {
   259	    let mut models_file = get_models_dir();
   260	    models_file.push(format!("{}.toml", model));
   261	
   262	    if models_file.exists() {
   263	        toml::from_str::<BranchSettingsDef>(
   264	            &std::fs::read_to_string(models_file).map_err(|err| err.to_string())?,
   265	        )
   266	        .map_err(|err| err.to_string())
   267	    } else {
   268	        let available_models = get_available_models()?;
   269	        let models_dir = models_file.parent().unwrap().display().to_string();
[2025-09-21T17:16:59] tokens used: 165,871
[2025-09-21T17:17:00] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..26b80efc7c0402b39d8303443127851e5bd05bc7
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,15 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true)
+                .global(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +129,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +137,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +187,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +234,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +279,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +325,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +369,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:17:04] thinking

**Preparing to add line numbers for graph.rs changes**
[2025-09-21T17:17:05] exec bash -lc "nl -ba src/graph.rs | sed -n '1,160p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:17:05] bash -lc "nl -ba src/graph.rs | sed -n '1,160p'" succeeded in 30ms:
     1	use crate::print::colors::to_terminal_color;
     2	use crate::settings::{BranchOrder, BranchSettings, Settings};
     3	use crate::text;
     4	use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
     5	use itertools::Itertools;
     6	use regex::Regex;
     7	use std::collections::{HashMap, VecDeque};
     8	use std::str;
     9	
    10	/// Represents a git history graph.
    11	pub struct HeadInfo {
    12	    pub oid: Oid,
    13	    pub name: Option<String>,
    14	    pub is_branch: bool,
    15	}
    16	
    17	pub struct GitGraph {
    18	    pub repository: Repository,
    19	    pub head: HeadInfo,
    20	    pub commits: Vec<CommitInfo>,
[2025-09-21T17:17:05] tokens used: 169,220
[2025-09-21T17:17:05] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..26b80efc7c0402b39d8303443127851e5bd05bc7
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,15 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true)
+                .global(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +129,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +137,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +187,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +234,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +279,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +325,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +369,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:17:12] thinking

**Listing code changes with line references**
[2025-09-21T17:17:13] exec bash -lc "nl -ba src/print/unicode.rs | sed -n '490,520p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:17:13] bash -lc "nl -ba src/print/unicode.rs | sed -n '490,520p'" succeeded in 24ms:
   490	    }
   491	}
   492	
   493	fn write_post(
   494	    graph: &GitGraph,
   495	    index: Option<&usize>,
   496	    color: bool,
   497	    head: Option<&HeadInfo>,
   498	    out: &mut String,
   499	) -> Result<(), String> {
   500	    if let Some(index) = index {
   501	        let info = &graph.commits[*index];
   502	        let commit = match graph.repository.find_commit(info.oid) {
   503	            Ok(c) => c,
   504	            Err(err) => return Err(err.message().to_string()),
   505	        };
   506	        out.push_str("  ");
   507	
   508	        let branch_color = info
   509	            .branch_trace
[2025-09-21T17:17:13] tokens used: 171,547
[2025-09-21T17:17:13] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..26b80efc7c0402b39d8303443127851e5bd05bc7
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,15 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true)
+                .global(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +129,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +137,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +187,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +234,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +279,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +325,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +369,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:17:19] thinking

**Checking line numbers in print/svg**
[2025-09-21T17:17:19] exec bash -lc "nl -ba src/print/svg.rs | sed -n '70,110p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:17:19] bash -lc "nl -ba src/print/svg.rs | sed -n '70,110p'" succeeded in 16ms:
    70	
    71	            document = document.add(commit_dot(
    72	                idx,
    73	                branch.visual.column.unwrap(),
    74	                branch_color,
    75	                !info.is_merge,
    76	            ));
    77	        }
    78	    }
    79	    let (x_max, y_max) = commit_coord(max_idx + 1, max_column + 1);
    80	    document = document
    81	        .set("viewBox", (0, 0, x_max, y_max))
    82	        .set("width", x_max)
    83	        .set("height", y_max);
    84	
    85	    let mut out: Vec<u8> = vec![];
    86	    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
    87	
    88	    String::from_utf8(out).map_err(|err| err.to_string())
    89	}
[2025-09-21T17:17:19] tokens used: 180,371
[2025-09-21T17:17:19] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..26b80efc7c0402b39d8303443127851e5bd05bc7
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,15 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true)
+                .global(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +129,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +137,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +187,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +234,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +279,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +325,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +369,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:17:24] thinking

**Adjusting README lines**
[2025-09-21T17:17:25] exec bash -lc "nl -ba README.md | sed -n '20,40p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:17:25] bash -lc "nl -ba README.md | sed -n '20,40p'" succeeded in 21ms:
    20	
    21	## Usage
    22	```
    23	git-graph [OPTIONS]
    24	```
    25	
    26	Common flags:
    27	- `--model <preset>` selects `git-flow` (default), `simple`, or `none`.
    28	- `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
    29	- `--sparse` switches to the sparse rendering style (compact is default).
    30	- `--svg` prints the graph as SVG; redirect to a file for further processing.
    31	- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
    32	- `git-graph model <preset>` persists the branching model for the current repository.
    33	- `git-graph model --list` prints the available presets stored in the configuration directory.
    34	
    35	Example:
    36	```
    37	git-graph --max-count 40 --svg > graph.svg
    38	```
    39	Open the generated file in your browser or vector graphics tool of choice.
[2025-09-21T17:17:25] tokens used: 181,686
[2025-09-21T17:17:25] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..26b80efc7c0402b39d8303443127851e5bd05bc7
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,15 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true)
+                .global(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +129,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +137,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +187,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +234,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +279,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +325,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +369,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:17:32] thinking

**Summarizing key code changes and build attempts**

I’m gathering details on signature changes in `GitGraph::new`, unified error handling in `graph.rs`, and new helpers like `discover_repository`. I’ll also note build attempts were blocked by missing offline dependencies due to network restrictions, and confirm the working tree is clean before finalizing. This will help give a clear overview of the updates and build context.
[2025-09-21T17:17:33] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:17:33] bash -lc 'git status -sb' succeeded in 21ms:
## main
[2025-09-21T17:17:33] tokens used: 183,071
[2025-09-21T17:17:33] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..26b80efc7c0402b39d8303443127851e5bd05bc7
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,15 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true)
+                .global(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +129,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +137,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +187,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +234,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +279,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +325,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +369,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


[2025-09-21T17:17:46] thinking

**Crafting final response message**
[2025-09-21T17:17:46] codex

**复现结果**
- Global `--path`/`-p` 参数现可控制仓库发现流程，并在缺失仓库时给出明确提示；同时 `model` 子命令与主路径共用该仓库句柄（src/main.rs:102-155, src/main.rs:328-372）。
- `GitGraph::new`/`run` 改为接收已有的 `Repository`，并在构图过程中统一使用 `err.message()` 透传 git2 错误，保持 CLI 与打印层错误文本一致（src/graph.rs:26-147, src/graph.rs:287-374）。
- SVG/Unicode 渲染器直接通过 `map_err` 返回错误信息，避免局部 `match` 分支（src/print/svg.rs:85-88, src/print/unicode.rs:500-505）。
- README 追加 `--path` 用法说明，反映新的 CLI 能力（README.md:31）。

**验证**
- `cargo fmt`
- `cargo build`（受限：沙箱无法访问 crates.io，离线模式因依赖未缓存同样失败；需联网或预先 `cargo fetch` 后再构建）

**后续建议**
1. 在允许联网的环境执行 `cargo build` 以确认依赖拉取与编译流程正常。
[2025-09-21T17:17:51] tokens used: 184,674
[2025-09-21T17:17:51] turn diff:
diff --git a/README.md b/README.md
index 541fbe9fda2458591f5a0cbddb1d36bc519e5edc..243e6e07d6c280e18fd1a3b5132cbd95f095dcb6
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@
 - `--local` / `-l` shows only local branches; remote branches such as `origin/*` are hidden.
 - `--sparse` switches to the sparse rendering style (compact is default).
 - `--svg` prints the graph as SVG; redirect to a file for further processing.
+- `--path <dir>` / `-p` starts repository discovery from `<dir>` so you can run the tool outside of the repo root.
 - `git-graph model <preset>` persists the branching model for the current repository.
 - `git-graph model --list` prints the available presets stored in the configuration directory.
 
diff --git a/src/graph.rs b/src/graph.rs
index 67a6d84579fbe426e4931bde504cff1cd85b5fdd..98a5e85e2cbbb86eaf7c29305cbc60140389743e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -23,10 +23,16 @@
 }
 
 impl GitGraph {
-    pub fn new(path: &str, settings: &Settings, max_count: Option<usize>) -> Result<Self, String> {
-        let repository = Repository::open(path).map_err(|err| err.to_string())?;
-        let head_reference = repository.head().map_err(|err| err.to_string())?;
-        let resolved_head = head_reference.resolve().map_err(|err| err.to_string())?;
+    pub fn new(
+        repo: &Repository,
+        settings: &Settings,
+        max_count: Option<usize>,
+    ) -> Result<Self, String> {
+        let repository = repo.clone();
+        let head_reference = repository.head().map_err(|err| err.message().to_string())?;
+        let resolved_head = head_reference
+            .resolve()
+            .map_err(|err| err.message().to_string())?;
         let head_oid = resolved_head
             .target()
             .ok_or_else(|| "Failed to resolve repository HEAD".to_string())?;
@@ -35,11 +41,14 @@
             name: head_reference.shorthand().map(|name| name.to_string()),
             is_branch: head_reference.is_branch(),
         };
-        let mut walk = repository.revwalk().map_err(|err| err.to_string())?;
+        let mut walk = repository
+            .revwalk()
+            .map_err(|err| err.message().to_string())?;
 
         walk.set_sorting(git2::Sort::TOPOLOGICAL | git2::Sort::TIME)
-            .map_err(|err| err.to_string())?;
-        walk.push_glob("*").map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
+        walk.push_glob("*")
+            .map_err(|err| err.message().to_string())?;
 
         let mut commits = Vec::new();
         let mut indices = HashMap::new();
@@ -50,7 +59,7 @@
                 }
             }
 
-            let oid = oid.map_err(|err| err.to_string())?;
+            let oid = oid.map_err(|err| err.message().to_string())?;
             let commit = repository.find_commit(oid).unwrap();
             commits.push(CommitInfo::new(&commit));
             indices.insert(oid, idx);
@@ -278,7 +287,7 @@
             let any_assigned =
                 match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
                     Ok(value) => value,
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 };
 
             if any_assigned || !branch.is_merged {
@@ -305,9 +314,9 @@
     };
     let actual_branches = repository
         .branches(filter)
-        .map_err(|err| err.to_string())?
+        .map_err(|err| err.message().to_string())?
         .collect::<Result<Vec<_>, Error>>()
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     let mut counter = 0;
 
@@ -365,12 +374,14 @@
     for (idx, info) in commits.iter().enumerate() {
         let commit = repository
             .find_commit(info.oid)
-            .map_err(|err| err.to_string())?;
+            .map_err(|err| err.message().to_string())?;
         if info.is_merge {
             if let Some(summary) = commit.summary() {
                 counter += 1;
 
-                let parent_oid = commit.parent_id(1).map_err(|err| err.to_string())?;
+                let parent_oid = commit
+                    .parent_id(1)
+                    .map_err(|err| err.message().to_string())?;
 
                 let branch_name = text::parse_merge_summary(summary, &settings.merge_patterns)
                     .unwrap_or_else(|| "unknown".to_string());
@@ -476,7 +487,7 @@
             }
             true
         })
-        .map_err(|err| err.to_string())?;
+        .map_err(|err| err.message().to_string())?;
 
     if let Some(err) = tag_error {
         return Err(err);
diff --git a/src/main.rs b/src/main.rs
index 595b85b1fc3e02bd004cfc1aa7351d863d8a8ceb..26b80efc7c0402b39d8303443127851e5bd05bc7
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 use clap::{crate_version, App, Arg, SubCommand};
-use git2::{Error, Repository};
+use git2::{Error, ErrorCode, Repository};
 use git_graph::graph::{CommitInfo, GitGraph};
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
@@ -98,6 +98,15 @@
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("path")
+                .long("path")
+                .short("p")
+                .help("Start repository discovery at <path>.")
+                .required(false)
+                .takes_value(true)
+                .global(true),
+        )
         .subcommand(
             SubCommand::with_name("model")
                 .about("Prints or permanently sets the branching model for a repository.")
@@ -120,6 +129,7 @@
         );
 
     let matches = app.clone().get_matches();
+    let repo_path = matches.value_of("path");
 
     if let Some(matches) = matches.subcommand_matches("model") {
         if matches.is_present("list") {
@@ -127,20 +137,22 @@
             return Ok(());
         }
 
+        let repository = discover_repository(repo_path)?;
         match matches.value_of("model") {
             None => {
-                let curr_model = get_model_name()?;
+                let curr_model = get_model_name(&repository)?;
                 match curr_model {
                     None => println!("No branching model set"),
                     Some(model) => println!("{}", model),
                 }
             }
-            Some(model) => set_model(model)?,
+            Some(model) => set_model(&repository, model)?,
         };
         return Ok(());
     }
 
-    let model = get_model(matches.value_of("model"))?;
+    let repository = discover_repository(repo_path)?;
+    let model = get_model(&repository, matches.value_of("model"))?;
 
     let commit_limit = match matches.value_of("max-count") {
         None => None,
@@ -175,13 +187,10 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit)
 }
 
-fn get_model_name() -> Result<Option<String>, String> {
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
+fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -225,13 +234,10 @@
     Ok(models)
 }
 
-fn get_model(model: Option<&str>) -> Result<BranchSettingsDef, String> {
+fn get_model(repository: &Repository, model: Option<&str>) -> Result<BranchSettingsDef, String> {
     match model {
         Some(model) => read_model(model),
         None => {
-            let path = ".";
-            let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
             let mut config_path = PathBuf::from(repository.path());
             config_path.push("git-graph.toml");
 
@@ -273,12 +279,9 @@
     }
 }
 
-fn set_model(model: &str) -> Result<(), String> {
+fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
     read_model(model)?;
 
-    let path = ".";
-    let repository = Repository::open(path).map_err(|err| err.to_string())?;
-
     let mut config_path = PathBuf::from(repository.path());
     config_path.push("git-graph.toml");
 
@@ -322,11 +325,32 @@
     Ok(())
 }
 
-fn run(settings: &Settings, svg: bool, max_commits: Option<usize>) -> Result<(), String> {
-    let path = ".";
+fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
+    let search_root = path.unwrap_or(".");
+    Repository::discover(search_root).map_err(|err| {
+        if err.code() == ErrorCode::NotFound {
+            if let Some(path) = path {
+                format!(
+                    "Could not find a Git repository starting from '{}'. Navigate into a repository or use option --path <path>.",
+                    path
+                )
+            } else {
+                String::from("Navigate into a repository or use option --path <path>.")
+            }
+        } else {
+            err.message().to_string()
+        }
+    })
+}
 
+fn run(
+    repository: &Repository,
+    settings: &Settings,
+    svg: bool,
+    max_commits: Option<usize>,
+) -> Result<(), String> {
     let now = Instant::now();
-    let graph = GitGraph::new(path, settings, max_commits)?;
+    let graph = GitGraph::new(repository, settings, max_commits)?;
 
     let duration_graph = now.elapsed().as_micros();
 
@@ -345,7 +369,7 @@
             if info.branch_trace.is_some() {
                 match print_commit_short(&graph, &info) {
                     Ok(_) => {}
-                    Err(err) => return Err(err.to_string()),
+                    Err(err) => return Err(err.message().to_string()),
                 }
             }
         }
diff --git a/src/print/svg.rs b/src/print/svg.rs
index ff4113f7ed455e136f5464794043559076a7614d..81fad26b2b5db249e5e846d8470f263d15079629
--- a/src/print/svg.rs
+++ b/src/print/svg.rs
@@ -83,12 +83,7 @@
         .set("height", y_max);
 
     let mut out: Vec<u8> = vec![];
-    match svg::write(&mut out, &document) {
-        Ok(_) => {}
-        Err(err) => {
-            return Err(err.to_string());
-        }
-    }
+    svg::write(&mut out, &document).map_err(|err| err.to_string())?;
 
     String::from_utf8(out).map_err(|err| err.to_string())
 }
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index f4a63a45fa124a171a27a76fbebd0cfc53fcc93b..b969413c6d1395537eb63abe1a9f90061b262710
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -501,7 +501,7 @@
         let info = &graph.commits[*index];
         let commit = match graph.repository.find_commit(info.oid) {
             Ok(c) => c,
-            Err(err) => return Err(err.to_string()),
+            Err(err) => return Err(err.message().to_string()),
         };
         out.push_str("  ");
 


=== 最终状态 ===
返回码: 0
状态: ✅ 执行成功
