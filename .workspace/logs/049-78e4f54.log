=== 任务 049-78e4f54 执行日志 ===
时间: 2025-09-22 01:33:26.086135
Prompt:
请在 .workspace 内，依据 .workspace/todolist/todolist-049-78e4f54.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/049-78e4f54/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："049-78e4f54：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 049-78e4f54

=== 输出 ===
[2025-09-21T17:24:02] OpenAI Codex v0.39.0 (research preview)
--------
workdir: /Users/jqwang/104-CommitLens-codex/.workspace
model: gpt-5-codex-high
provider: codex
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
--------
[2025-09-21T17:24:02] User instructions:
请在 .workspace 内，依据 .workspace/todolist/todolist-049-78e4f54.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/049-78e4f54/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："049-78e4f54：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 049-78e4f54

[2025-09-21T17:24:06] thinking

**Examining workspace directories**
[2025-09-21T17:24:06] exec bash -lc 'ls -la' in /Users/jqwang/104-CommitLens-codex/.workspace/.workspace
[2025-09-21T17:24:06] bash -lc 'ls -la' exited -1 in 0ms:
No such file or directory (os error 2)
[2025-09-21T17:24:06] tokens used: 915

[2025-09-21T17:24:11] thinking

**Clarifying workspace directory usage**
[2025-09-21T17:24:11] exec bash -lc 'ls -la' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:24:11] bash -lc 'ls -la' succeeded in 19ms:
total 28704
drwxr-xr-x@  9 jqwang  staff       288 Sep 21 15:57 .
drwxr-xr-x@ 29 jqwang  staff       928 Sep 21 07:49 ..
-rw-r--r--@  1 jqwang  staff       103 Sep 22 01:24 codex_error.txt
-rw-r--r--@  1 jqwang  staff  13740860 Sep 22 01:24 codex_output.txt
-rw-r--r--@  1 jqwang  staff         7 Sep 22 01:24 codex_status.txt
drwxr-xr-x@ 50 jqwang  staff      1600 Sep 22 01:23 logs
drwxr-xr-x@ 12 jqwang  staff       384 Sep 21 20:54 rust-project
-rw-r--r--@  1 jqwang  staff      1054 Sep 22 01:24 task_status.json
drwxr-xr-x@  5 jqwang  staff       160 Sep 22 01:24 todolist
[2025-09-21T17:24:11] tokens used: 2,044

[2025-09-21T17:24:20] thinking

**Preparing to extract instructions**
[2025-09-21T17:24:20] exec bash -lc "sed -n '1,160p' todolist/todolist-049-78e4f54.tex" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:24:20] bash -lc "sed -n '1,160p' todolist/todolist-049-78e4f54.tex" succeeded in 9ms:
\section{提交考古：049-78e4f54}

\subsection*{Commit 元信息}
\begin{itemize}
  \item 标题：equal colors for related local and remote branches
  \item 作者：Martin Lange <martin\_lange\_@gmx.net>
  \item 日期：2020-12-28T18:42:14+01:00
\end{itemize}

\subsection*{变更摘要（阅读提示）}
src/graph.rs | 70 ++（1 file, 55 insertions, 15 deletions）。聚焦“本地与远程同名分支的颜色一致性”：
（1）统一前缀常量 \texttt{ORIGIN = "origin/"}；（2）重构 \texttt{assign\_branches}/\texttt{trace\_branch} 的调用/参数，允许在追踪时访问“全部分支”；（3）当追踪到已有 \texttt{branch\_trace} 时，若当前分支为 \texttt{origin/<name>} 且与已有本地分支 \texttt{<name>} 匹配，则复用其 \texttt{term\_color/svg\_color}。

\subsection*{差异解读（证据）}
\begin{itemize}
  \item 改了什么：
    \begin{itemize}
      \item src/graph.rs:6 附近：新增常量 \texttt{ORIGIN}（HEAD.diff@@\verb|+6|）。
      \item src/graph.rs:270–305：\texttt{assign\_branches} 改为先构建 \texttt{index\_map: Vec<Option<usize>>}，延后生成最终分支数组，并同步修正 \texttt{CommitInfo.branch\_trace} 的索引（HEAD.diff@@\verb|-270,24 +272,30| 与后续 for 循环）。
      \item src/graph.rs:502–566：\texttt{trace\_branch} 签名从“传入单一 \texttt{\&mut BranchInfo}”改为“传入 \texttt{branches: \&mut [BranchInfo]} + 当前索引”，并在命中已有 \texttt{branch\_trace} 时，若当前名称以 \texttt{ORIGIN} 开头且去前缀等于旧名称，则复制旧分支的 \texttt{term\_color/svg\_color}（HEAD.diff@@\verb|-476,8 +502,8| 和 @@\verb|-486,7 +512,20|）。
[2025-09-21T17:24:20] tokens used: 4,079

[2025-09-21T17:24:22] thinking

**Checking for more content**
[2025-09-21T17:24:22] exec bash -lc "sed -n '160,320p' todolist/todolist-049-78e4f54.tex" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:24:22] bash -lc "sed -n '160,320p' todolist/todolist-049-78e4f54.tex" succeeded in 9ms:

[2025-09-21T17:24:22] tokens used: 5,640

[2025-09-21T17:24:25] thinking

**Examining Rust project workspace**
[2025-09-21T17:24:25] exec bash -lc ls in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:24:25] bash -lc ls succeeded in 9ms:
Cargo.lock
Cargo.toml
LICENSE
README.md
scripts
src
target
[2025-09-21T17:24:25] tokens used: 5,881

[2025-09-21T17:24:28] thinking

**Inspecting source directory**
[2025-09-21T17:24:28] exec bash -lc 'ls src' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:24:28] bash -lc 'ls src' succeeded in 9ms:
graph.rs
lib.rs
main.rs
print
settings.rs
text.rs
[2025-09-21T17:24:28] tokens used: 9,579

[2025-09-21T17:24:32] thinking

**Preparing to update src/graph.rs**
[2025-09-21T17:24:32] exec bash -lc "sed -n '1,200p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:24:32] bash -lc "sed -n '1,200p' src/graph.rs" succeeded in 9ms:
use crate::print::colors::to_terminal_color;
use crate::settings::{BranchOrder, BranchSettings, Settings};
use crate::text;
use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
use itertools::Itertools;
use regex::Regex;
use std::collections::{HashMap, VecDeque};
use std::str;

/// Represents a git history graph.
pub struct HeadInfo {
    pub oid: Oid,
    pub name: Option<String>,
    pub is_branch: bool,
}

pub struct GitGraph {
    pub repository: Repository,
    pub head: HeadInfo,
    pub commits: Vec<CommitInfo>,
[2025-09-21T17:24:32] tokens used: 10,058

[2025-09-21T17:24:35] thinking

**Continuing search for relevant code sections**
[2025-09-21T17:24:35] exec bash -lc "sed -n '200,400p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:24:35] bash -lc "sed -n '200,400p' src/graph.rs" succeeded in 19ms:
        is_tag: bool,
        visual: BranchVis,
        end_index: Option<usize>,
    ) -> Self {
        BranchInfo {
            target,
            merge_target,
            name,
            persistence,
            is_remote,
            is_merged,
            is_tag,
            visual,
            range: (end_index, None),
        }
    }
}

/// Branch properties for visualization.
pub struct BranchVis {
[2025-09-21T17:24:35] tokens used: 15,698

[2025-09-21T17:24:37] thinking

**Identifying key sections to review**
[2025-09-21T17:24:37] exec bash -lc "sed -n '400,600p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:24:37] bash -lc "sed -n '400,600p' src/graph.rs" succeeded in 11ms:
                let svg_col = branch_color(
                    &branch_name,
                    &settings.branches.svg_colors,
                    &settings.branches.svg_colors_unknown,
                    counter,
                );

                let branch_info = BranchInfo::new(
                    parent_oid,
                    Some(info.oid),
                    branch_name,
                    persistence,
                    false,
                    true,
                    false,
                    BranchVis::new(pos, term_col, svg_col),
                    Some(idx + 1),
                );
                valid_branches.push(branch_info);
            }
[2025-09-21T17:24:37] tokens used: 17,506

[2025-09-21T17:24:40] thinking

**Continuing to review branch_order/branch_color**
[2025-09-21T17:24:40] exec bash -lc "sed -n '600,800p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:24:40] bash -lc "sed -n '600,800p' src/graph.rs" succeeded in 9ms:
        .filter(|br| !br.1.is_tag && (br.1.range.0.is_some() || br.1.range.1.is_some()))
        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
        .collect();

    if !forward {
        std::mem::swap(&mut start_queue, &mut end_queue);
    }

    for i in 0..commits.len() {
        let idx = if forward { i } else { commits.len() - 1 - i };

        loop {
            let start = start_queue.pop_front();

            if let Some(start) = start {
                if start.1 == idx {
                    let branch = &mut branches[start.0];
                    let group = &mut occupied[branch.visual.order_group];
                    let column = group
[2025-09-21T17:24:40] tokens used: 23,004

[2025-09-21T17:24:44] thinking

**Scrolling to confirm branch_color**
[2025-09-21T17:24:44] exec bash -lc "sed -n '800,1000p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:24:44] bash -lc "sed -n '800,1000p' src/graph.rs" succeeded in 8ms:
            b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..]))
        })
        .map(|(_pos, col)| &col.1[counter % col.1.len()])
        .unwrap_or_else(|| &unknown[counter % unknown.len()]);
    color.clone()
}

fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
    if let Ok(reference) = repository.find_reference(name) {
        if let Some(target) = reference.target() {
            if let Ok(commit) = repository.find_commit(target) {
                return Some(commit.id());
            }
        }
        if let Ok(object) = reference.peel(ObjectType::Commit) {
            if let Ok(commit) = object.into_commit() {
                return Some(commit.id());
            }
        }
    }
[2025-09-21T17:24:44] tokens used: 26,673

[2025-09-21T17:24:54] thinking

**Analyzing update requirements for graph.rs**
[2025-09-21T17:24:55] exec bash -lc 'rg "ORIGIN" -n' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:24:55] bash -lc 'rg "ORIGIN" -n' exited 1 in 24ms:

[2025-09-21T17:24:55] tokens used: 27,620

[2025-09-21T17:25:57] thinking

**Redesigning branch assignment and tracing**

I'm parsing detailed notes on restructuring `assign_branches` to create an `ORIGIN` constant and to shift from assigning branches immediately to building an `index_map` that tracks original to final positions. This lets `trace_branch` access all branches during color-copying updates. The main challenge is to keep commit branch indices consistent after filtering out unneeded branches by using `index_map` for remapping. It’s a careful dance ensuring the new logic faithfully matches the summary while handling remote branches sharing colors with local ones. I'll reconstruct code reflecting these changes and the updated function signatures.
**Implementing branch placeholders and index remapping**

The strategy involves pushing branches (including placeholders as `None`) into a vector to preserve branch indices during processing. I assign each branch an index before calling `trace_branch`, which now receives all branches as a slice plus the current index for cross-branch info access (like color copying). If a branch is found unnecessary (merged and unassigned), it’s nulled out (set to `None`) rather than removed immediately, preserving indexing for commits referencing those branches. Afterwards, I build an `index_map` to compress out the removed branches and then update all commit branch and tag indices to their new positions accordingly. This careful placeholder approach ensures stable indices while enabling richer tracing logic.
**Speculating on branch vector reordering**
[2025-09-21T17:26:54] codex
**Implementing branch placeholders and index remapping**

The strategy involves pushing branches (including placeholders as `None`) into a vector to preserve branch indices during processing. I assign each branch an index before calling `trace_branch`, which now receives all branches as a slice plus the current index for cross-branch info access (like color copying). If a branch is found unnecessary (merged and unassigned), it’s nulled out (set to `None`) rather than removed immediately, preserving indexing for commits referencing those branches. Afterwards, I build an `index_map` to compress out the removed branches and then update all commit branch and tag indices to their new positions accordingly. This careful placeholder approach ensures stable indices while enabling richer tracing logic.
[2025-09-21T17:26:54] codex
**Speculating on branch vector reordering**
[2025-09-21T17:26:54] exec bash -lc 'rg "index_map" -n src/graph.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:26:54] bash -lc 'rg "index_map" -n src/graph.rs' succeeded in 15ms:
112:            let index_map: HashMap<usize, Option<&usize>> = indices
120:                    let mut idx0 = index_map[&start_idx];
123:                        idx0 = index_map[&start_idx];
128:                    let mut idx0 = index_map[&end_idx];
131:                        idx0 = index_map[&end_idx];
[2025-09-21T17:26:54] tokens used: 36,115

[2025-09-21T17:28:50] thinking

**Planning branch assignment refactor**
**Rewriting assign_branches with filtering and remapping**

I'll carefully implement assign_branches to build branches and keep vectors, call trace_branch with updated signature, track which branches to keep, then build an index_map to remap branch indices in commits, updating branches, tags, and branch_trace accordingly. I’m also sorting out the necessary ownership and borrowing details to avoid conflicts, planning to add the ORIGIN constant and align trace_branch’s logic with these changes.
[2025-09-21T17:28:52] codex
**Rewriting assign_branches with filtering and remapping**

I'll carefully implement assign_branches to build branches and keep vectors, call trace_branch with updated signature, track which branches to keep, then build an index_map to remap branch indices in commits, updating branches, tags, and branch_trace accordingly. I’m also sorting out the necessary ownership and borrowing details to avoid conflicts, planning to add the ORIGIN constant and align trace_branch’s logic with these changes.
[2025-09-21T17:28:53] exec bash -lc 'rg "trace_branch" -n src/graph.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:28:53] bash -lc 'rg "trace_branch" -n src/graph.rs' succeeded in 25ms:
288:                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
505:fn trace_branch<'repo>(
[2025-09-21T17:28:53] tokens used: 54,394

[2025-09-21T17:28:57] thinking

**Adding ORIGIN constant and planning patch**
[2025-09-21T17:28:58] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -9,2 +9,4 @@
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
[2025-09-21T17:28:58] apply_patch(auto_approved=true) exited 0 in 32ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T17:28:58] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..d5d6894fb7b72c9e7673fa330054c192f284065e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,

[2025-09-21T17:28:58] tokens used: 54,756
[2025-09-21T17:28:58] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..d5d6894fb7b72c9e7673fa330054c192f284065e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,


[2025-09-21T17:29:31] thinking

**Preparing to rewrite assign_branches function**
[2025-09-21T17:29:31] exec bash -lc "sed -n '260,360p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:29:31] bash -lc "sed -n '260,360p' src/graph.rs" succeeded in 12ms:
/// * Sort all branches by persistence
/// * Iterating over all branches in persistence order, trace back over commit parents until a trace is already assigned
fn assign_branches(
    repository: &Repository,
    commits: &mut [CommitInfo],
    indices: &HashMap<Oid, usize>,
    settings: &Settings,
) -> Result<Vec<BranchInfo>, String> {
    let mut branch_idx = 0;
    let mut branches_ordered = Vec::new();

    for mut branch in extract_branches(repository, commits, &indices, settings)? {
        if branch.is_tag {
            if let Some(start_idx) = branch.range.0 {
                if let Some(info) = commits.get_mut(start_idx) {
                    info.tags.push(branch_idx);
                }
            }
            branch_idx += 1;
            branches_ordered.push(branch);
[2025-09-21T17:29:31] tokens used: 63,692
[2025-09-21T17:29:31] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..d5d6894fb7b72c9e7673fa330054c192f284065e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,


[2025-09-21T17:29:34] thinking

**Replacing code section with patch**
[2025-09-21T17:29:41] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -267,4 +267,4 @@
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
@@ -272,2 +272,3 @@
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
@@ -277,4 +278,4 @@
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
@@ -282,18 +283,39 @@
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
+
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
+        }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            &indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
+    }
+
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
         }
@@ -301,2 +323,22 @@
 
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
[2025-09-21T17:29:41] apply_patch(auto_approved=true) exited 0 in 23ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T17:29:41] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..9e3cbf94a7b91329b1cc9ab8abe3efbac0a3d62e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
     for mut branch in extract_branches(repository, commits, &indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
+
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
+        }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            &indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
+    }
+
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
         }
     }
 
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 

[2025-09-21T17:29:41] tokens used: 67,236
[2025-09-21T17:29:41] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..9e3cbf94a7b91329b1cc9ab8abe3efbac0a3d62e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
     for mut branch in extract_branches(repository, commits, &indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
+
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
+        }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            &indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
+    }
+
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
         }
     }
 
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 


[2025-09-21T17:30:39] thinking

**Refactoring trace_branch function**
**Planning code extraction**
[2025-09-21T17:30:40] codex
**Planning code extraction**
[2025-09-21T17:30:40] exec bash -lc "sed -n '500,620p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:30:40] bash -lc "sed -n '500,620p' src/graph.rs" succeeded in 13ms:
                    Ok(color) => color,
                    Err(err) => {
                        tag_error = Some(err.to_string());
                        return false;
                    }
                };

                let svg_color = branch_color(
                    &full_name,
                    &settings.branches.svg_colors,
                    &settings.branches.svg_colors_unknown,
                    counter,
                );

                let mut branch_info = BranchInfo::new(
                    target_oid,
                    None,
                    full_name,
                    branch_order(&full_name, &settings.branches.persistence) as u8,
                    false,
[2025-09-21T17:30:40] tokens used: 73,662
[2025-09-21T17:30:40] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..9e3cbf94a7b91329b1cc9ab8abe3efbac0a3d62e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
     for mut branch in extract_branches(repository, commits, &indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
+
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
+        }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            &indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
+    }
+
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
         }
     }
 
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 


[2025-09-21T17:30:49] thinking

**Implementing updated trace_branch function**

I'll rewrite the `trace_branch` function to include the planned logic while preserving existing handling for merges and branch ranges. I'll also incorporate remote branch color copying only when appropriate and handle cases where the remote name is missing. This keeps the function consistent with the current workflow before branch filtering.
[2025-09-21T17:30:52] tokens used: 75,987
[2025-09-21T17:30:52] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..9e3cbf94a7b91329b1cc9ab8abe3efbac0a3d62e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
     for mut branch in extract_branches(repository, commits, &indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
+
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
+        }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            &indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
+    }
+
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
         }
     }
 
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 


[2025-09-21T17:30:56] thinking

**Correcting patch application path**
[2025-09-21T17:30:59] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -553,3 +553,3 @@
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
@@ -560,5 +560,21 @@
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
@@ -603,2 +619,3 @@
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
[2025-09-21T17:30:59] apply_patch(auto_approved=true) exited 0 in 35ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T17:30:59] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..4ed4f8e5730e6a5dbdcdc89f28fcecbafc70d511
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
     for mut branch in extract_branches(repository, commits, &indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            &indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {

[2025-09-21T17:30:59] tokens used: 77,369
[2025-09-21T17:30:59] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..4ed4f8e5730e6a5dbdcdc89f28fcecbafc70d511
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
     for mut branch in extract_branches(repository, commits, &indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            &indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {


[2025-09-21T17:31:03] thinking

**Verifying parameter replacement consistency**
[2025-09-21T17:31:03] exec bash -lc "sed -n '540,620p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:31:03] bash -lc "sed -n '540,620p' src/graph.rs" succeeded in 12ms:
    valid_branches.extend(tag_branches);

    valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));

    Ok(valid_branches)
}

/// Traces brack branches by following 1st commit parent,
/// until a commit is reached that already has a trace.
fn trace_branch<'repo>(
    repository: &'repo Repository,
    commits: &mut [CommitInfo],
    indices: &HashMap<Oid, usize>,
    oid: Oid,
    branches: &mut [BranchInfo],
    branch_index: usize,
) -> Result<bool, Error> {
    let mut curr_oid = oid;
    let mut prev_index: Option<usize> = None;
    let mut start_index: Option<i32> = None;
[2025-09-21T17:31:03] tokens used: 78,124
[2025-09-21T17:31:03] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..4ed4f8e5730e6a5dbdcdc89f28fcecbafc70d511
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
     for mut branch in extract_branches(repository, commits, &indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            &indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {


[2025-09-21T17:31:06] thinking

**Continuing review**
[2025-09-21T17:31:07] exec bash -lc "sed -n '620,700p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:31:07] bash -lc "sed -n '620,700p' src/graph.rs" succeeded in 10ms:
    let branch = &mut branches[branch_index];
    if let Some(end) = branch.range.0 {
        if let Some(start_index) = start_index {
            if start_index < end as i32 {
                // TODO: find a better solution (bool field?) to identify non-merged branches that were not assigned to any commits, and thus should not occupy a column.
                branch.range = (None, None);
            } else {
                branch.range = (branch.range.0, Some(start_index as usize));
            }
        } else {
            branch.range = (branch.range.0, None);
        }
    } else {
        branch.range = (branch.range.0, start_index.map(|si| si as usize));
    }
    Ok(any_assigned)
}

/// Sorts branches into columns for visualization, that all branches can be
/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
[2025-09-21T17:31:07] tokens used: 79,079
[2025-09-21T17:31:07] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..4ed4f8e5730e6a5dbdcdc89f28fcecbafc70d511
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
     for mut branch in extract_branches(repository, commits, &indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            &indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {


[2025-09-21T17:31:19] thinking

**Refactoring branch helpers with ORIGIN constant**
[2025-09-21T17:31:24] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -846,3 +846,8 @@
         .iter()
-        .position(|b| b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..])))
+        .position(|b| {
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
+        })
         .unwrap_or(order.len())
@@ -860,3 +865,6 @@
         .find_position(|(b, _)| {
-            b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..]))
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
         })
[2025-09-21T17:31:24] apply_patch(auto_approved=true) exited 0 in 28ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T17:31:24] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..2c9f5fbe1929fcdd54c5644c68402d66e1668c12
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
     for mut branch in extract_branches(repository, commits, &indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            &indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {
@@ -783,7 +844,12 @@
 fn branch_order(name: &str, order: &[Regex]) -> usize {
     order
         .iter()
-        .position(|b| b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..])))
+        .position(|b| {
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
+        })
         .unwrap_or(order.len())
 }
 
@@ -797,7 +863,10 @@
     let color = order
         .iter()
         .find_position(|(b, _)| {
-            b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..]))
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
         })
         .map(|(_pos, col)| &col.1[counter % col.1.len()])
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);

[2025-09-21T17:31:24] tokens used: 90,257
[2025-09-21T17:31:24] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..2c9f5fbe1929fcdd54c5644c68402d66e1668c12
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
     for mut branch in extract_branches(repository, commits, &indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            &indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {
@@ -783,7 +844,12 @@
 fn branch_order(name: &str, order: &[Regex]) -> usize {
     order
         .iter()
-        .position(|b| b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..])))
+        .position(|b| {
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
+        })
         .unwrap_or(order.len())
 }
 
@@ -797,7 +863,10 @@
     let color = order
         .iter()
         .find_position(|(b, _)| {
-            b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..]))
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
         })
         .map(|(_pos, col)| &col.1[counter % col.1.len()])
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);


[2025-09-21T17:31:39] thinking

**Refining branch tracing and parameter passing**

I’m carefully adjusting how branches are mutated during tracing to minimize repeated mutable borrows, and also correcting a call where a double reference to `indices` was passed instead of a single reference, aiming for clearer and safer parameter usage consistent with Rust’s borrowing rules.
[2025-09-21T17:31:39] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -301,3 +301,3 @@
             commits,
-            &indices,
+            indices,
             oid,
[2025-09-21T17:31:39] apply_patch(auto_approved=true) exited 0 in 21ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T17:31:39] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..b4908f59b075e473303b06d22d23400fa512bd66
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
     for mut branch in extract_branches(repository, commits, &indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {
@@ -783,7 +844,12 @@
 fn branch_order(name: &str, order: &[Regex]) -> usize {
     order
         .iter()
-        .position(|b| b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..])))
+        .position(|b| {
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
+        })
         .unwrap_or(order.len())
 }
 
@@ -797,7 +863,10 @@
     let color = order
         .iter()
         .find_position(|(b, _)| {
-            b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..]))
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
         })
         .map(|(_pos, col)| &col.1[counter % col.1.len()])
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);

[2025-09-21T17:31:39] tokens used: 93,094
[2025-09-21T17:31:39] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..b4908f59b075e473303b06d22d23400fa512bd66
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
     for mut branch in extract_branches(repository, commits, &indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {
@@ -783,7 +844,12 @@
 fn branch_order(name: &str, order: &[Regex]) -> usize {
     order
         .iter()
-        .position(|b| b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..])))
+        .position(|b| {
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
+        })
         .unwrap_or(order.len())
 }
 
@@ -797,7 +863,10 @@
     let color = order
         .iter()
         .find_position(|(b, _)| {
-            b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..]))
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
         })
         .map(|(_pos, col)| &col.1[counter % col.1.len()])
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);


[2025-09-21T17:31:43] thinking

**Aligning extract_branches call parameters**
[2025-09-21T17:31:44] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -270,3 +270,3 @@
 
-    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+    for mut branch in extract_branches(repository, commits, indices, settings)? {
         if branch.is_tag {
[2025-09-21T17:31:44] apply_patch(auto_approved=true) exited 0 in 29ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T17:31:44] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..7eb6cf6a14bda6a54781745af48b70a775cd5ec0
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
-    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+    for mut branch in extract_branches(repository, commits, indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {
@@ -783,7 +844,12 @@
 fn branch_order(name: &str, order: &[Regex]) -> usize {
     order
         .iter()
-        .position(|b| b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..])))
+        .position(|b| {
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
+        })
         .unwrap_or(order.len())
 }
 
@@ -797,7 +863,10 @@
     let color = order
         .iter()
         .find_position(|(b, _)| {
-            b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..]))
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
         })
         .map(|(_pos, col)| &col.1[counter % col.1.len()])
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);

[2025-09-21T17:31:44] tokens used: 93,595
[2025-09-21T17:31:44] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..7eb6cf6a14bda6a54781745af48b70a775cd5ec0
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
-    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+    for mut branch in extract_branches(repository, commits, indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {
@@ -783,7 +844,12 @@
 fn branch_order(name: &str, order: &[Regex]) -> usize {
     order
         .iter()
-        .position(|b| b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..])))
+        .position(|b| {
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
+        })
         .unwrap_or(order.len())
 }
 
@@ -797,7 +863,10 @@
     let color = order
         .iter()
         .find_position(|(b, _)| {
-            b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..]))
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
         })
         .map(|(_pos, col)| &col.1[counter % col.1.len()])
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);


[2025-09-21T17:31:53] thinking

**Preparing code formatting and validation**

I'm making sure the `trace_branch` function handles mutable branch access properly and considering how to treat branch ranges for removed branches. Before running tests or builds, I'll run `cargo fmt` to keep the code style consistent and verify `rustfmt` is available for formatting.
[2025-09-21T17:31:53] exec bash -lc 'cargo fmt' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:31:53] bash -lc 'cargo fmt' succeeded in 79ms:

[2025-09-21T17:31:53] tokens used: 94,131
[2025-09-21T17:31:53] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..7eb6cf6a14bda6a54781745af48b70a775cd5ec0
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
-    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+    for mut branch in extract_branches(repository, commits, indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {
@@ -783,7 +844,12 @@
 fn branch_order(name: &str, order: &[Regex]) -> usize {
     order
         .iter()
-        .position(|b| b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..])))
+        .position(|b| {
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
+        })
         .unwrap_or(order.len())
 }
 
@@ -797,7 +863,10 @@
     let color = order
         .iter()
         .find_position(|(b, _)| {
-            b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..]))
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
         })
         .map(|(_pos, col)| &col.1[counter % col.1.len()])
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);


[2025-09-21T17:32:00] thinking

**Preparing to run tests**
[2025-09-21T17:32:00] exec bash -lc 'cargo test' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:32:10] bash -lc 'cargo test' exited 124 in 10.01s:
    Updating crates.io index
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
[2025-09-21T17:32:10] tokens used: 94,272
[2025-09-21T17:32:10] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..7eb6cf6a14bda6a54781745af48b70a775cd5ec0
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
-    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+    for mut branch in extract_branches(repository, commits, indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {
@@ -783,7 +844,12 @@
 fn branch_order(name: &str, order: &[Regex]) -> usize {
     order
         .iter()
-        .position(|b| b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..])))
+        .position(|b| {
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
+        })
         .unwrap_or(order.len())
 }
 
@@ -797,7 +863,10 @@
     let color = order
         .iter()
         .find_position(|(b, _)| {
-            b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..]))
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
         })
         .map(|(_pos, col)| &col.1[counter % col.1.len()])
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);


[2025-09-21T17:32:16] thinking

**Handling network timeout by switching to offline mode**
[2025-09-21T17:32:16] exec bash -lc 'CARGO_NET_OFFLINE=true cargo test' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:32:16] bash -lc 'CARGO_NET_OFFLINE=true cargo test' exited -1 in 0ms:
error: no matching package named `unicode-xid` found
location searched: crates.io index
required by package `proc-macro2 v1.0.24`
    ... which satisfies dependency `proc-macro2 = "^1.0"` (locked to 1.0.24) of package `serde_derive v1.0.118`
    ... which satisfies dependency `serde_derive = "^1.0"` (locked to 1.0.118) of package `git-graph v0.1.2 (/Users/jqwang/104-CommitLens-codex/.workspace/rust-project)`
As a reminder, you're using offline mode (--offline) which can sometimes cause surprising resolution failures, if this error is too confusing you may wish to retry without `--offline`.
[2025-09-21T17:32:16] tokens used: 97,156
[2025-09-21T17:32:16] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..7eb6cf6a14bda6a54781745af48b70a775cd5ec0
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
-    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+    for mut branch in extract_branches(repository, commits, indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {
@@ -783,7 +844,12 @@
 fn branch_order(name: &str, order: &[Regex]) -> usize {
     order
         .iter()
-        .position(|b| b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..])))
+        .position(|b| {
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
+        })
         .unwrap_or(order.len())
 }
 
@@ -797,7 +863,10 @@
     let color = order
         .iter()
         .find_position(|(b, _)| {
-            b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..]))
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
         })
         .map(|(_pos, col)| &col.1[counter % col.1.len()])
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);


[2025-09-21T17:32:22] thinking

**Handling offline dependency issues**
[2025-09-21T17:32:22] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:32:22] bash -lc 'git status -sb' succeeded in 22ms:
## main
 M src/graph.rs
[2025-09-21T17:32:22] tokens used: 97,595
[2025-09-21T17:32:22] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..7eb6cf6a14bda6a54781745af48b70a775cd5ec0
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
-    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+    for mut branch in extract_branches(repository, commits, indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {
@@ -783,7 +844,12 @@
 fn branch_order(name: &str, order: &[Regex]) -> usize {
     order
         .iter()
-        .position(|b| b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..])))
+        .position(|b| {
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
+        })
         .unwrap_or(order.len())
 }
 
@@ -797,7 +863,10 @@
     let color = order
         .iter()
         .find_position(|(b, _)| {
-            b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..]))
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
         })
         .map(|(_pos, col)| &col.1[counter % col.1.len()])
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);


[2025-09-21T17:32:26] thinking

**Verifying code changes against commit summary**
[2025-09-21T17:32:27] exec bash -lc 'git diff src/graph.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:32:27] bash -lc 'git diff src/graph.rs' succeeded in 22ms:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85..7eb6cf6 100644
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@ use regex::Regex;
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,38 +265,80 @@ fn assign_branches(
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
[2025-09-21T17:32:27] tokens used: 98,682
[2025-09-21T17:32:27] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..7eb6cf6a14bda6a54781745af48b70a775cd5ec0
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
-    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+    for mut branch in extract_branches(repository, commits, indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {
@@ -783,7 +844,12 @@
 fn branch_order(name: &str, order: &[Regex]) -> usize {
     order
         .iter()
-        .position(|b| b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..])))
+        .position(|b| {
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
+        })
         .unwrap_or(order.len())
 }
 
@@ -797,7 +863,10 @@
     let color = order
         .iter()
         .find_position(|(b, _)| {
-            b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..]))
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
         })
         .map(|(_pos, col)| &col.1[counter % col.1.len()])
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);


[2025-09-21T17:32:37] thinking

**Ensuring branch trace consistency and preparing commit**

I'm confirming that branch traces handle removed branches correctly and maintaining alignment between branch data structures. I've verified Rust type inference will work for the branch mapping vector and plan to stage all changes with `git add -A` before committing with the specified message.
[2025-09-21T17:32:37] exec bash -lc 'git add -A' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:32:37] bash -lc 'git add -A' succeeded in 23ms:

[2025-09-21T17:32:37] tokens used: 101,144
[2025-09-21T17:32:37] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..7eb6cf6a14bda6a54781745af48b70a775cd5ec0
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
-    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+    for mut branch in extract_branches(repository, commits, indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {
@@ -783,7 +844,12 @@
 fn branch_order(name: &str, order: &[Regex]) -> usize {
     order
         .iter()
-        .position(|b| b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..])))
+        .position(|b| {
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
+        })
         .unwrap_or(order.len())
 }
 
@@ -797,7 +863,10 @@
     let color = order
         .iter()
         .find_position(|(b, _)| {
-            b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..]))
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
         })
         .map(|(_pos, col)| &col.1[counter % col.1.len()])
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);


[2025-09-21T17:32:41] thinking

**Committing changes**
[2025-09-21T17:32:41] exec bash -lc 'git commit -m "049-78e4f54：复现提交代码内容。"' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:32:41] bash -lc 'git commit -m "049-78e4f54：复现提交代码内容。"' succeeded in 49ms:
[main 9f4c791] 049-78e4f54：复现提交代码内容。
 1 file changed, 93 insertions(+), 24 deletions(-)
[2025-09-21T17:32:41] tokens used: 101,292
[2025-09-21T17:32:41] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..7eb6cf6a14bda6a54781745af48b70a775cd5ec0
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
-    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+    for mut branch in extract_branches(repository, commits, indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {
@@ -783,7 +844,12 @@
 fn branch_order(name: &str, order: &[Regex]) -> usize {
     order
         .iter()
-        .position(|b| b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..])))
+        .position(|b| {
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
+        })
         .unwrap_or(order.len())
 }
 
@@ -797,7 +863,10 @@
     let color = order
         .iter()
         .find_position(|(b, _)| {
-            b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..]))
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
         })
         .map(|(_pos, col)| &col.1[counter % col.1.len()])
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);


[2025-09-21T17:32:45] thinking

**Preparing final summary and verifying commit**
[2025-09-21T17:32:45] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:32:45] bash -lc 'git status -sb' succeeded in 21ms:
## main
[2025-09-21T17:32:45] tokens used: 101,629
[2025-09-21T17:32:45] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..7eb6cf6a14bda6a54781745af48b70a775cd5ec0
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
-    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+    for mut branch in extract_branches(repository, commits, indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {
@@ -783,7 +844,12 @@
 fn branch_order(name: &str, order: &[Regex]) -> usize {
     order
         .iter()
-        .position(|b| b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..])))
+        .position(|b| {
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
+        })
         .unwrap_or(order.len())
 }
 
@@ -797,7 +863,10 @@
     let color = order
         .iter()
         .find_position(|(b, _)| {
-            b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..]))
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
         })
         .map(|(_pos, col)| &col.1[counter % col.1.len()])
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);


[2025-09-21T17:32:50] thinking

**Preparing detailed summary with line references**
[2025-09-21T17:32:50] exec bash -lc "nl -ba src/graph.rs | sed -n '1,40p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:32:50] bash -lc "nl -ba src/graph.rs | sed -n '1,40p'" succeeded in 17ms:
     1	use crate::print::colors::to_terminal_color;
     2	use crate::settings::{BranchOrder, BranchSettings, Settings};
     3	use crate::text;
     4	use git2::{BranchType, Commit, Error, ObjectType, Oid, Repository};
     5	use itertools::Itertools;
     6	use regex::Regex;
     7	use std::collections::{HashMap, VecDeque};
     8	use std::str;
     9	
    10	const ORIGIN: &str = "origin/";
    11	
    12	/// Represents a git history graph.
    13	pub struct HeadInfo {
    14	    pub oid: Oid,
    15	    pub name: Option<String>,
    16	    pub is_branch: bool,
    17	}
    18	
    19	pub struct GitGraph {
    20	    pub repository: Repository,
[2025-09-21T17:32:50] tokens used: 101,931
[2025-09-21T17:32:50] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..7eb6cf6a14bda6a54781745af48b70a775cd5ec0
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
-    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+    for mut branch in extract_branches(repository, commits, indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {
@@ -783,7 +844,12 @@
 fn branch_order(name: &str, order: &[Regex]) -> usize {
     order
         .iter()
-        .position(|b| b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..])))
+        .position(|b| {
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
+        })
         .unwrap_or(order.len())
 }
 
@@ -797,7 +863,10 @@
     let color = order
         .iter()
         .find_position(|(b, _)| {
-            b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..]))
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
         })
         .map(|(_pos, col)| &col.1[counter % col.1.len()])
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);


[2025-09-21T17:32:56] thinking

**Preparing to review assign_branches changes**
[2025-09-21T17:32:57] exec bash -lc "nl -ba src/graph.rs | sed -n '250,360p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:32:57] bash -lc "nl -ba src/graph.rs | sed -n '250,360p'" succeeded in 29ms:
   250	                }
   251	            }
   252	        }
   253	    }
   254	}
   255	
   256	/// Extracts branches from repository and merge summaries, assigns branches and branch traces to commits.
   257	///
   258	/// Algorithm:
   259	/// * Find all actual branches (incl. target oid) and all extract branches from merge summaries (incl. parent oid)
   260	/// * Sort all branches by persistence
   261	/// * Iterating over all branches in persistence order, trace back over commit parents until a trace is already assigned
   262	fn assign_branches(
   263	    repository: &Repository,
   264	    commits: &mut [CommitInfo],
   265	    indices: &HashMap<Oid, usize>,
   266	    settings: &Settings,
   267	) -> Result<Vec<BranchInfo>, String> {
   268	    let mut branches = Vec::new();
   269	    let mut keep = Vec::new();
[2025-09-21T17:32:57] tokens used: 102,621
[2025-09-21T17:32:57] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..7eb6cf6a14bda6a54781745af48b70a775cd5ec0
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
-    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+    for mut branch in extract_branches(repository, commits, indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {
@@ -783,7 +844,12 @@
 fn branch_order(name: &str, order: &[Regex]) -> usize {
     order
         .iter()
-        .position(|b| b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..])))
+        .position(|b| {
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
+        })
         .unwrap_or(order.len())
 }
 
@@ -797,7 +863,10 @@
     let color = order
         .iter()
         .find_position(|(b, _)| {
-            b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..]))
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
         })
         .map(|(_pos, col)| &col.1[counter % col.1.len()])
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);


[2025-09-21T17:33:00] thinking

**Gathering lines for trace_branch changes**
[2025-09-21T17:33:01] exec bash -lc "nl -ba src/graph.rs | sed -n '540,660p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:33:01] bash -lc "nl -ba src/graph.rs | sed -n '540,660p'" succeeded in 28ms:
   540	    valid_branches.extend(tag_branches);
   541	
   542	    valid_branches.sort_by_cached_key(|branch| (branch.persistence, !branch.is_merged));
   543	
   544	    Ok(valid_branches)
   545	}
   546	
   547	/// Traces brack branches by following 1st commit parent,
   548	/// until a commit is reached that already has a trace.
   549	fn trace_branch<'repo>(
   550	    repository: &'repo Repository,
   551	    commits: &mut [CommitInfo],
   552	    indices: &HashMap<Oid, usize>,
   553	    oid: Oid,
   554	    branches: &mut [BranchInfo],
   555	    branch_index: usize,
   556	) -> Result<bool, Error> {
   557	    let mut curr_oid = oid;
   558	    let mut prev_index: Option<usize> = None;
   559	    let mut start_index: Option<i32> = None;
[2025-09-21T17:33:01] tokens used: 104,064
[2025-09-21T17:33:01] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..7eb6cf6a14bda6a54781745af48b70a775cd5ec0
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
-    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+    for mut branch in extract_branches(repository, commits, indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {
@@ -783,7 +844,12 @@
 fn branch_order(name: &str, order: &[Regex]) -> usize {
     order
         .iter()
-        .position(|b| b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..])))
+        .position(|b| {
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
+        })
         .unwrap_or(order.len())
 }
 
@@ -797,7 +863,10 @@
     let color = order
         .iter()
         .find_position(|(b, _)| {
-            b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..]))
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
         })
         .map(|(_pos, col)| &col.1[counter % col.1.len()])
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);


[2025-09-21T17:33:05] thinking

**Checking branch_order references**
[2025-09-21T17:33:05] exec bash -lc "nl -ba src/graph.rs | sed -n '780,860p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:33:05] bash -lc "nl -ba src/graph.rs | sed -n '780,860p'" succeeded in 31ms:
   780	
   781	        let mut found = group_occ.len();
   782	        for (i, column_occ) in group_occ.iter().enumerate() {
   783	            let mut occ = false;
   784	            for (s, e) in column_occ {
   785	                if start <= *e && end >= *s {
   786	                    occ = true;
   787	                    break;
   788	                }
   789	            }
   790	            if !occ {
   791	                if let Some(merge_trace) = branch
   792	                    .merge_target
   793	                    .and_then(|t| indices.get(&t))
   794	                    .and_then(|t_idx| commits[*t_idx].branch_trace)
   795	                {
   796	                    let merge_branch = &branches[merge_trace];
   797	                    if merge_branch.visual.order_group == branch.visual.order_group {
   798	                        if let Some(merge_column) = merge_branch.visual.column {
   799	                            if merge_column == i {
[2025-09-21T17:33:05] tokens used: 105,957
[2025-09-21T17:33:05] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..7eb6cf6a14bda6a54781745af48b70a775cd5ec0
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
-    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+    for mut branch in extract_branches(repository, commits, indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {
@@ -783,7 +844,12 @@
 fn branch_order(name: &str, order: &[Regex]) -> usize {
     order
         .iter()
-        .position(|b| b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..])))
+        .position(|b| {
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
+        })
         .unwrap_or(order.len())
 }
 
@@ -797,7 +863,10 @@
     let color = order
         .iter()
         .find_position(|(b, _)| {
-            b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..]))
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
         })
         .map(|(_pos, col)| &col.1[counter % col.1.len()])
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);


[2025-09-21T17:33:09] thinking

**Continuing to fetch branch_color**
[2025-09-21T17:33:10] exec bash -lc "nl -ba src/graph.rs | sed -n '860,920p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:33:10] bash -lc "nl -ba src/graph.rs | sed -n '860,920p'" succeeded in 18ms:
   860	    unknown: &[T],
   861	    counter: usize,
   862	) -> T {
   863	    let color = order
   864	        .iter()
   865	        .find_position(|(b, _)| {
   866	            b.is_match(name)
   867	                || name
   868	                    .strip_prefix(ORIGIN)
   869	                    .map_or(false, |remote| b.is_match(remote))
   870	        })
   871	        .map(|(_pos, col)| &col.1[counter % col.1.len()])
   872	        .unwrap_or_else(|| &unknown[counter % unknown.len()]);
   873	    color.clone()
   874	}
   875	
   876	fn find_tag_target(repository: &Repository, oid: Oid, name: &str) -> Option<Oid> {
   877	    if let Ok(reference) = repository.find_reference(name) {
   878	        if let Some(target) = reference.target() {
   879	            if let Ok(commit) = repository.find_commit(target) {
[2025-09-21T17:33:10] tokens used: 107,078
[2025-09-21T17:33:10] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..7eb6cf6a14bda6a54781745af48b70a775cd5ec0
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
-    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+    for mut branch in extract_branches(repository, commits, indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {
@@ -783,7 +844,12 @@
 fn branch_order(name: &str, order: &[Regex]) -> usize {
     order
         .iter()
-        .position(|b| b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..])))
+        .position(|b| {
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
+        })
         .unwrap_or(order.len())
 }
 
@@ -797,7 +863,10 @@
     let color = order
         .iter()
         .find_position(|(b, _)| {
-            b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..]))
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
         })
         .map(|(_pos, col)| &col.1[counter % col.1.len()])
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);


[2025-09-21T17:33:23] thinking

**Summarizing final commit and test results**

I'll explain the `src/graph.rs` changes clearly in bullets covering branch assignment, index mapping, `trace_branch` updates with color reuse and `ORIGIN` constant, note test failures due to offline missing crates, and include assumptions from partial report info, finishing with commit confirmation and next steps to run tests once dependencies are available.
[2025-09-21T17:33:24] codex

- Reworked branch assignment to stage branches, build an `index_map`, and remap `CommitInfo` references per报告描述，使保留分支与被丢弃分支索引对应 (`src/graph.rs:268-344`).
- Updated `trace_branch` to operate on the full branch slice, copy colors from同名本地分支，当命中已有 `branch_trace` 且远程前缀为 `origin/` 时复用颜色 (`src/graph.rs:549-636`)；对应 todolist 图示的颜色对齐逻辑。
- 抽取 `ORIGIN` 常量并在分支排序/配色匹配中统一使用，避免魔法字符串 (`src/graph.rs:10`, `src/graph.rs:843-874`).
- 测试：`cargo test` 在离线环境下因缺少 crates.io 依赖（如 `unicode-xid`）失败；需联网或预热缓存后再行验证。
- 假设/妥协：报告未提供完整索引重映射实现细节，按差异说明推导了最小可行的 `index_map` 与颜色复用方案；提交已按要求以 “049-78e4f54：复现提交代码内容。” 完成。建议：1) 待网络可用时重跑 `cargo test`。
[2025-09-21T17:33:25] tokens used: 108,807
[2025-09-21T17:33:25] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 98a5e85e2cbbb86eaf7c29305cbc60140389743e..7eb6cf6a14bda6a54781745af48b70a775cd5ec0
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -7,6 +7,8 @@
 use std::collections::{HashMap, VecDeque};
 use std::str;
 
+const ORIGIN: &str = "origin/";
+
 /// Represents a git history graph.
 pub struct HeadInfo {
     pub oid: Oid,
@@ -263,40 +265,82 @@
     indices: &HashMap<Oid, usize>,
     settings: &Settings,
 ) -> Result<Vec<BranchInfo>, String> {
-    let mut branch_idx = 0;
-    let mut branches_ordered = Vec::new();
+    let mut branches = Vec::new();
+    let mut keep = Vec::new();
 
-    for mut branch in extract_branches(repository, commits, &indices, settings)? {
+    for mut branch in extract_branches(repository, commits, indices, settings)? {
         if branch.is_tag {
+            let branch_idx = branches.len();
             if let Some(start_idx) = branch.range.0 {
                 if let Some(info) = commits.get_mut(start_idx) {
                     info.tags.push(branch_idx);
                 }
             }
-            branch_idx += 1;
-            branches_ordered.push(branch);
+            branches.push(branch);
+            keep.push(true);
             continue;
         }
 
-        if let Some(&idx) = &indices.get(&branch.target) {
-            let info = &mut commits[idx];
-            if !branch.is_merged {
-                info.branches.push(branch_idx);
-            }
-            let oid = info.oid;
-            let any_assigned =
-                match trace_branch(repository, commits, &indices, oid, &mut branch, branch_idx) {
-                    Ok(value) => value,
-                    Err(err) => return Err(err.message().to_string()),
-                };
+        let idx = match indices.get(&branch.target) {
+            Some(idx) => *idx,
+            None => continue,
+        };
 
-            if any_assigned || !branch.is_merged {
-                branch_idx += 1;
-                branches_ordered.push(branch);
-            }
+        let branch_idx = branches.len();
+        let info = &mut commits[idx];
+        if !branch.is_merged {
+            info.branches.push(branch_idx);
         }
+        let oid = info.oid;
+
+        branches.push(branch);
+        keep.push(false);
+
+        let any_assigned = match trace_branch(
+            repository,
+            commits,
+            indices,
+            oid,
+            &mut branches[..],
+            branch_idx,
+        ) {
+            Ok(value) => value,
+            Err(err) => return Err(err.message().to_string()),
+        };
+
+        keep[branch_idx] = any_assigned || !branches[branch_idx].is_merged;
     }
 
+    let mut index_map: Vec<Option<usize>> = vec![None; branches.len()];
+    let mut branches_ordered = Vec::new();
+
+    for (idx, branch) in branches.into_iter().enumerate() {
+        if keep[idx] {
+            index_map[idx] = Some(branches_ordered.len());
+            branches_ordered.push(branch);
+        }
+    }
+
+    for commit in commits.iter_mut() {
+        let mapped_branches = commit
+            .branches
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.branches = mapped_branches;
+
+        let mapped_tags = commit
+            .tags
+            .iter()
+            .filter_map(|idx| index_map.get(*idx).copied().flatten())
+            .collect();
+        commit.tags = mapped_tags;
+
+        commit.branch_trace = commit
+            .branch_trace
+            .and_then(|idx| index_map.get(idx).copied().flatten());
+    }
+
     Ok(branches_ordered)
 }
 
@@ -507,16 +551,32 @@
     commits: &mut [CommitInfo],
     indices: &HashMap<Oid, usize>,
     oid: Oid,
-    branch: &mut BranchInfo,
+    branches: &mut [BranchInfo],
     branch_index: usize,
 ) -> Result<bool, Error> {
     let mut curr_oid = oid;
     let mut prev_index: Option<usize> = None;
     let mut start_index: Option<i32> = None;
     let mut any_assigned = false;
+    let remote_name = branches
+        .get(branch_index)
+        .and_then(|branch| branch.name.strip_prefix(ORIGIN))
+        .map(|name| name.to_string());
     while let Some(index) = indices.get(&curr_oid) {
         let info = &mut commits[*index];
-        if info.branch_trace.is_some() {
+        if let Some(existing_trace) = info.branch_trace {
+            if let Some(remote_name) = remote_name.as_deref() {
+                if let Some(existing_branch) = branches.get(existing_trace) {
+                    if existing_branch.name == remote_name {
+                        let term_color = existing_branch.visual.term_color;
+                        let svg_color = existing_branch.visual.svg_color.clone();
+                        if let Some(branch) = branches.get_mut(branch_index) {
+                            branch.visual.term_color = term_color;
+                            branch.visual.svg_color = svg_color;
+                        }
+                    }
+                }
+            }
             match prev_index {
                 None => start_index = Some(*index as i32 - 1),
                 Some(prev_index) => {
@@ -557,6 +617,7 @@
         }
     }
 
+    let branch = &mut branches[branch_index];
     if let Some(end) = branch.range.0 {
         if let Some(start_index) = start_index {
             if start_index < end as i32 {
@@ -783,7 +844,12 @@
 fn branch_order(name: &str, order: &[Regex]) -> usize {
     order
         .iter()
-        .position(|b| b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..])))
+        .position(|b| {
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
+        })
         .unwrap_or(order.len())
 }
 
@@ -797,7 +863,10 @@
     let color = order
         .iter()
         .find_position(|(b, _)| {
-            b.is_match(name) || (name.starts_with("origin/") && b.is_match(&name[7..]))
+            b.is_match(name)
+                || name
+                    .strip_prefix(ORIGIN)
+                    .map_or(false, |remote| b.is_match(remote))
         })
         .map(|(_pos, col)| &col.1[counter % col.1.len()])
         .unwrap_or_else(|| &unknown[counter % unknown.len()]);


=== 错误 ===
2025-09-21T17:24:06.721077Z ERROR codex_core::exec: exec error: No such file or directory (os error 2)

=== 最终状态 ===
返回码: 0
状态: ✅ 执行成功
