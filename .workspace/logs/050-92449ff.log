=== 任务 050-92449ff 执行日志 ===
时间: 2025-09-22 01:47:07.636786
Prompt:
请在 .workspace 内，依据 .workspace/todolist/todolist-050-92449ff.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/050-92449ff/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："050-92449ff：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 050-92449ff

=== 输出 ===
[2025-09-21T17:33:31] OpenAI Codex v0.39.0 (research preview)
--------
workdir: /Users/jqwang/104-CommitLens-codex/.workspace
model: gpt-5-codex-high
provider: codex
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
--------
[2025-09-21T17:33:31] User instructions:
请在 .workspace 内，依据 .workspace/todolist/todolist-050-92449ff.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/050-92449ff/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："050-92449ff：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 050-92449ff

[2025-09-21T17:33:34] thinking

**Planning multi-step task**
[2025-09-21T17:33:35] exec bash -lc "cat <<'EOF'
Planning:
1. Inspect todolist report and related figures to gather file list and code snippets.
2. Update .workspace/rust-project per report: edit/create files with contents described, noting any missing context.
3. Run required build/test commands (cargo build/test) if applicable per report.
4. Stage changes and commit with provided message.
EOF" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:33:35] bash -lc "cat <<'EOF'
Planning:
1. Inspect todolist report and related figures to gather file list and code snippets.
2. Update .workspace/rust-project per report: edit/create files with contents described, noting any missing context.
3. Run required build/test commands (cargo build/test) if applicable per report.
4. Stage changes and commit with provided message.
EOF" succeeded in 22ms:
Planning:
1. Inspect todolist report and related figures to gather file list and code snippets.
2. Update .workspace/rust-project per report: edit/create files with contents described, noting any missing context.
3. Run required build/test commands (cargo build/test) if applicable per report.
4. Stage changes and commit with provided message.
[2025-09-21T17:33:35] tokens used: 3,174

[2025-09-21T17:33:39] thinking

**Planning next steps**
[2025-09-21T17:33:39] exec bash -lc 'ls -la' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:33:39] bash -lc 'ls -la' succeeded in 21ms:
total 28696
drwxr-xr-x@  9 jqwang  staff       288 Sep 21 15:57 .
drwxr-xr-x@ 29 jqwang  staff       928 Sep 21 07:49 ..
-rw-r--r--@  1 jqwang  staff         0 Sep 22 01:33 codex_error.txt
-rw-r--r--@  1 jqwang  staff  13948688 Sep 22 01:33 codex_output.txt
-rw-r--r--@  1 jqwang  staff         7 Sep 22 01:33 codex_status.txt
drwxr-xr-x@ 51 jqwang  staff      1632 Sep 22 01:33 logs
drwxr-xr-x@ 12 jqwang  staff       384 Sep 21 20:54 rust-project
-rw-r--r--@  1 jqwang  staff      1073 Sep 22 01:33 task_status.json
drwxr-xr-x@  5 jqwang  staff       160 Sep 22 01:33 todolist
[2025-09-21T17:33:39] tokens used: 3,540

[2025-09-21T17:33:41] thinking

**Viewing .tex file**
[2025-09-21T17:33:43] exec bash -lc 'cat todolist/todolist-050-92449ff.tex' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:33:43] bash -lc 'cat todolist/todolist-050-92449ff.tex' succeeded in 8ms:
\section{提交考古：050-92449ff}

\subsection*{Commit 元信息}
\begin{itemize}
  \item 标题：page output, switch to disable, removed no-color short switch
  \item 作者：Martin Lange \texttt{<martin\_lange\_@gmx.net>}
  \item 日期：2020-12-29T01:47:12+01:00
\end{itemize}

\subsection*{变更摘要（阅读提示）}
从相邻提交差异（HEAD.diff）看：
\begin{itemize}
  \item 4 files changed, 258 insertions(+), 15 deletions(-)
  \item 关键文件：Cargo.toml（新增 crossterm 依赖）、src/main.rs（新增分页输出、移除 \verb|no-color| 短选项）、src/print/unicode.rs（输出接口改为逐行）
\end{itemize}

\subsection*{差异解读（证据）}
\textbf{改了什么}
\begin{itemize}
  \item 新增交互式分页输出：在 \texttt{src/main.rs} 引入 \texttt{crossterm}，实现 \texttt{print\_paged()} 并通过新开关 \texttt{--no-pager} 控制（见 HEAD.diff: src/main.rs 新增函数 \texttt{print\_paged} 及参数解析）。
[2025-09-21T17:33:43] tokens used: 5,032

[2025-09-21T17:33:46] thinking

**Assessing context and project structure**
[2025-09-21T17:33:47] exec bash -lc 'ls -R rust-project' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:33:47] bash -lc 'ls -R rust-project' succeeded in 11ms:
Cargo.lock
Cargo.toml
LICENSE
README.md
scripts
src
target

rust-project/scripts:
linearize-history.sh

rust-project/src:
graph.rs
lib.rs
main.rs
print
settings.rs
text.rs

rust-project/src/print:
[2025-09-21T17:33:47] tokens used: 6,820

[2025-09-21T17:33:50] thinking

**Evaluating modification necessity**
[2025-09-21T17:33:52] exec bash -lc "cat <<'EOF'
Plan update:
- Completed step 1: gathered report details.
- Next: apply changes to files in rust-project per report.
- Then run cargo build/test if relevant.
- Finally stage and commit.
EOF" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:33:52] bash -lc "cat <<'EOF'
Plan update:
- Completed step 1: gathered report details.
- Next: apply changes to files in rust-project per report.
- Then run cargo build/test if relevant.
- Finally stage and commit.
EOF" succeeded in 20ms:
Plan update:
- Completed step 1: gathered report details.
- Next: apply changes to files in rust-project per report.
- Then run cargo build/test if relevant.
- Finally stage and commit.
[2025-09-21T17:33:52] tokens used: 7,719

[2025-09-21T17:33:54] thinking

**Reviewing existing source files**
[2025-09-21T17:33:54] exec bash -lc "sed -n '1,200p' rust-project/src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:33:54] bash -lc "sed -n '1,200p' rust-project/src/main.rs" succeeded in 18ms:
use clap::{crate_version, App, Arg, SubCommand};
use git2::{Error, ErrorCode, Repository};
use git_graph::graph::{CommitInfo, GitGraph};
use git_graph::print::svg::print_svg;
use git_graph::print::unicode::print_unicode;
use git_graph::settings::{
    BranchOrder, BranchSettings, BranchSettingsDef, Characters, MergePatterns, RepoSettings,
    Settings,
};
use platform_dirs::AppDirs;
use std::path::PathBuf;
use std::str::FromStr;
use std::time::Instant;

fn main() {
    std::process::exit(match from_args() {
        Ok(_) => 0,
        Err(err) => {
            eprintln!("{}", err);
            1
[2025-09-21T17:33:54] tokens used: 8,029

[2025-09-21T17:33:57] thinking

**Planning to review run function**
[2025-09-21T17:33:57] exec bash -lc 'rg "fn run" -n rust-project/src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:33:57] bash -lc 'rg "fn run" -n rust-project/src/main.rs' succeeded in 25ms:
346:fn run(
[2025-09-21T17:33:57] tokens used: 9,927
[2025-09-21T17:33:59] exec bash -lc "sed -n '300,520p' rust-project/src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:33:59] bash -lc "sed -n '300,520p' rust-project/src/main.rs" succeeded in 21ms:

    Ok(())
}

fn create_config() -> Result<(), String> {
    let app_dir = AppDirs::new(Some("git-graph"), false).unwrap().config_dir;
    let mut models_dir = app_dir;
    models_dir.push("models");

    if !models_dir.exists() {
        std::fs::create_dir_all(&models_dir).map_err(|err| err.to_string())?;

        let models = [
            (BranchSettingsDef::git_flow(), "git-flow.toml"),
            (BranchSettingsDef::simple(), "simple.toml"),
            (BranchSettingsDef::none(), "none.toml"),
        ];
        for (model, file) in &models {
            let mut path = PathBuf::from(&models_dir);
            path.push(file);
[2025-09-21T17:33:59] tokens used: 16,027

[2025-09-21T17:34:02] thinking

**Reviewing print function and unicode.rs**
[2025-09-21T17:34:02] exec bash -lc "sed -n '1,200p' rust-project/src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:34:02] bash -lc "sed -n '1,200p' rust-project/src/print/unicode.rs" succeeded in 10ms:
use crate::graph::{GitGraph, HeadInfo};
use crate::settings::{Characters, Settings};
use atty::Stream;
use std::collections::hash_map::Entry::{Occupied, Vacant};
use std::collections::HashMap;
use yansi::Paint;

const SPACE: u8 = 0;
const DOT: u8 = 1;
const CIRCLE: u8 = 2;
const VER: u8 = 3;
const HOR: u8 = 4;
const CROSS: u8 = 5;
const R_U: u8 = 6;
const R_D: u8 = 7;
const L_D: u8 = 8;
const L_U: u8 = 9;
const VER_L: u8 = 10;
const VER_R: u8 = 11;
const HOR_U: u8 = 12;
[2025-09-21T17:34:02] tokens used: 17,400

[2025-09-21T17:34:04] thinking

**Reviewing code and dependencies**
[2025-09-21T17:34:04] exec bash -lc 'cat rust-project/Cargo.toml' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:34:04] bash -lc 'cat rust-project/Cargo.toml' succeeded in 20ms:
[package]
name = "git-graph"
version = "0.1.2"
authors = ["Martin Lange <martin_lange_@gmx.net>"]
edition = "2018"
description = "Structured Git graphs for your branching model."
repository = "https://github.com/mlange-42/git-graph"
keywords = ["git", "graph", "cli"]
license = "MIT"
readme = "README.md"

[dependencies]
git2 = "0.13"
regex = "1.4"
serde = "1.0"
serde_derive = "1.0"
toml = "0.5"
itertools = "0.9"
svg = "0.8"
clap = "2.33"
[2025-09-21T17:34:04] tokens used: 20,689

[2025-09-21T17:34:07] thinking

**Preparing to update printing module and dependencies**
[2025-09-21T17:34:07] exec bash -lc 'cat rust-project/src/print/mod.rs' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:34:07] bash -lc 'cat rust-project/src/print/mod.rs' succeeded in 8ms:
use crate::graph::GitGraph;
use std::cmp::max;

pub mod colors;
pub mod svg;
pub mod unicode;

/// Find the index at which a between-branch connection
/// has to deviate from the current branch's column.
///
/// Returns the last index on the current column.
fn get_deviate_index(graph: &GitGraph, index: usize, par_index: usize) -> usize {
    let info = &graph.commits[index];

    let par_info = &graph.commits[par_index];
    let par_branch = &graph.branches[par_info.branch_trace.unwrap()];

    let mut min_split_idx = index;
    for sibling_oid in &par_info.children {
        if let Some(&sibling_index) = graph.indices.get(sibling_oid) {
[2025-09-21T17:34:07] tokens used: 23,005

[2025-09-21T17:34:09] thinking

**Checking string usage of print_unicode**
[2025-09-21T17:34:09] exec bash -lc 'rg "print_unicode" -n rust-project/src' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:34:10] bash -lc 'rg "print_unicode" -n rust-project/src' succeeded in 12ms:
rust-project/src/main.rs:5:use git_graph::print::unicode::print_unicode;
rust-project/src/main.rs:383:        println!("{}", print_unicode(&graph, &settings)?);
rust-project/src/print/unicode.rs:28:pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
[2025-09-21T17:34:10] tokens used: 23,595

[2025-09-21T17:34:21] thinking

**Reconstructing print functions for paging output**
[2025-09-21T17:34:21] exec bash -lc 'rg "print_paged" -R' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:34:21] bash -lc 'rg "print_paged" -R' exited 2 in 20ms:
error: Found argument '-R' which wasn't expected, or isn't valid in this context

USAGE:
    
    rg [OPTIONS] PATTERN [PATH ...]
    rg [OPTIONS] -e PATTERN ... [PATH ...]
    rg [OPTIONS] -f PATTERNFILE ... [PATH ...]
    rg [OPTIONS] --files [PATH ...]
    rg [OPTIONS] --type-list
    command | rg [OPTIONS] PATTERN
    rg [OPTIONS] --help
    rg [OPTIONS] --version

For more information try --help

[2025-09-21T17:34:21] tokens used: 34,094

[2025-09-21T17:34:25] thinking

**Confirming ripgrep usage and searching for print_graph**
[2025-09-21T17:34:25] exec bash -lc 'rg "fn print_graph" -n rust-project/src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:34:25] bash -lc 'rg "fn print_graph" -n rust-project/src/print/unicode.rs' exited 1 in 15ms:

[2025-09-21T17:34:25] tokens used: 34,963

[2025-09-21T17:34:28] thinking

**Identifying potential function name**
[2025-09-21T17:34:29] exec bash -lc "sed -n '200,400p' rust-project/src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:34:29] bash -lc "sed -n '200,400p' rust-project/src/print/unicode.rs" succeeded in 7ms:
    index: usize,
    (from, to): (usize, usize),
    merge: bool,
    color: u8,
    pers: u8,
) {
    if from == to {
        return;
    }
    let from_2 = from * 2;
    let to_2 = to * 2;
    if from < to {
        for column in (from_2 + 1)..to_2 {
            if merge && column == to_2 - 1 {
                grid.set(column, index, ARR_R, color, pers);
            } else {
                let (curr, _, old_pers) = grid.get_tuple(column, index);
                let (new_col, new_pers) = if pers < old_pers {
                    (Some(color), Some(pers))
                } else {
[2025-09-21T17:34:29] tokens used: 35,155

[2025-09-21T17:34:32] thinking

**Locating write_graph function**
[2025-09-21T17:34:32] exec bash -lc 'rg "fn write_graph" -n rust-project/src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:34:32] bash -lc 'rg "fn write_graph" -n rust-project/src/print/unicode.rs' succeeded in 11ms:
421:fn write_graph(
[2025-09-21T17:34:32] tokens used: 48,256
[2025-09-21T17:34:35] exec bash -lc "sed -n '400,520p' rust-project/src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:34:35] bash -lc "sed -n '400,520p' rust-project/src/print/unicode.rs" succeeded in 20ms:
                                    }
                                }
                                Vacant(entry) => {
                                    entry.insert(vec![vec![Occ::Range(
                                        idx,
                                        *par_idx,
                                        column_range.0,
                                        column_range.1,
                                    )]]);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    inserts
}
[2025-09-21T17:34:35] tokens used: 51,111
[2025-09-21T17:34:39] exec bash -lc "sed -n '520,760p' rust-project/src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:34:39] bash -lc "sed -n '520,760p' rust-project/src/print/unicode.rs" succeeded in 18ms:
        let mut head_written = false;
        if let Some(head_info) = head {
            if !head_info.is_branch {
                if color {
                    write_colored_str(out, "HEAD ->", branch_color);
                } else {
                    out.push_str("HEAD ->");
                }
                out.push(' ');
                head_written = true;
            }
        }

        let mut branch_indices = info.branches.clone();
        let head_branch_name_opt = head
            .filter(|head_info| head_info.is_branch)
            .and_then(|head_info| head_info.name.as_deref());

        if let Some(head_branch_name) = head_branch_name_opt {
            branch_indices
[2025-09-21T17:34:39] tokens used: 54,504

[2025-09-21T17:38:13] thinking

**Changing print logic to use line vectors**
**Adapting print_paged with terminal interaction**

I’m working through the detailed design to implement the interactive paged output using crossterm. This involves enabling raw mode, hiding the cursor, managing screen redraws with terminal size, handling key events like scrolling and quitting, and cleaning up on exit to restore terminal state properly. I’m carefully organizing RAII-style guards and the event loop to ensure smooth user interaction and safe terminal cleanup.
**Implementing pager event loop and status display**

I’m building the run_pager_loop function to render lines with scrolling and key navigation, carefully managing terminal clearing, cursor position, and status line updates. I’m also preparing to add the pager_status helper and planning necessary Cargo.toml and source edits to integrate crossterm properly.
[2025-09-21T17:38:40] codex
**Adapting print_paged with terminal interaction**

I’m working through the detailed design to implement the interactive paged output using crossterm. This involves enabling raw mode, hiding the cursor, managing screen redraws with terminal size, handling key events like scrolling and quitting, and cleaning up on exit to restore terminal state properly. I’m carefully organizing RAII-style guards and the event loop to ensure smooth user interaction and safe terminal cleanup.
[2025-09-21T17:38:40] codex
**Implementing pager event loop and status display**

I’m building the run_pager_loop function to render lines with scrolling and key navigation, carefully managing terminal clearing, cursor position, and status line updates. I’m also preparing to add the pager_status helper and planning necessary Cargo.toml and source edits to integrate crossterm properly.
[2025-09-21T17:38:41] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/Cargo.toml
@@ -24,2 +24,3 @@
 yansi = "0.5"
+crossterm = "0.19"
 
[2025-09-21T17:38:41] apply_patch(auto_approved=true) exited 0 in 27ms:
Success. Updated the following files:
M rust-project/Cargo.toml
[2025-09-21T17:38:41] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3

[2025-09-21T17:38:41] tokens used: 68,482
[2025-09-21T17:38:41] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3


[2025-09-21T17:39:00] thinking

**Adjusting CLI argument handling and pager integration**
[2025-09-21T17:39:06] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -78,4 +78,3 @@
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
@@ -85,2 +84,9 @@
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
@@ -169,2 +175,3 @@
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
@@ -189,3 +196,3 @@
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
[2025-09-21T17:39:06] apply_patch(auto_approved=true) exited 0 in 21ms:
Success. Updated the following files:
M rust-project/src/main.rs
[2025-09-21T17:39:06] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..e8ec311d509735f4e738f549abc4deb8b52ac53b
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {

[2025-09-21T17:39:06] tokens used: 95,694
[2025-09-21T17:39:06] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..e8ec311d509735f4e738f549abc4deb8b52ac53b
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {


[2025-09-21T17:39:10] thinking

**Updating run function signature and logic**
[2025-09-21T17:39:12] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -357,2 +357,3 @@
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
@@ -389,3 +390,8 @@
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
[2025-09-21T17:39:12] apply_patch(auto_approved=true) exited 0 in 18ms:
Success. Updated the following files:
M rust-project/src/main.rs
[2025-09-21T17:39:12] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..664dfac58181ed4d0a8c9994abb14edf2225f29c
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();

[2025-09-21T17:39:12] tokens used: 96,614
[2025-09-21T17:39:12] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..664dfac58181ed4d0a8c9994abb14edf2225f29c
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();


[2025-09-21T17:40:01] thinking

**Adding paged and unpaged print functions**
[2025-09-21T17:40:09] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -411,2 +411,132 @@
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::cmp;
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    execute!(stdout, Hide)?;
+
+    let result = pager_loop(&lines, &mut stdout);
+
+    execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show)?;
+    terminal::disable_raw_mode()?;
+    stdout.flush()?;
+    println!();
+
+    result
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{queue, cursor::MoveTo};
+    use std::cmp;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
[2025-09-21T17:40:09] apply_patch(auto_approved=true) exited 0 in 43ms:
Success. Updated the following files:
M rust-project/src/main.rs
[2025-09-21T17:40:09] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..d73dac8127179db7bc7dc36ada6ab035e523589b
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,136 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::cmp;
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    execute!(stdout, Hide)?;
+
+    let result = pager_loop(&lines, &mut stdout);
+
+    execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show)?;
+    terminal::disable_raw_mode()?;
+    stdout.flush()?;
+    println!();
+
+    result
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{queue, cursor::MoveTo};
+    use std::cmp;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };

[2025-09-21T17:40:09] tokens used: 102,100
[2025-09-21T17:40:09] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..d73dac8127179db7bc7dc36ada6ab035e523589b
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,136 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::cmp;
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    execute!(stdout, Hide)?;
+
+    let result = pager_loop(&lines, &mut stdout);
+
+    execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show)?;
+    terminal::disable_raw_mode()?;
+    stdout.flush()?;
+    println!();
+
+    result
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{queue, cursor::MoveTo};
+    use std::cmp;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };


[2025-09-21T17:40:23] thinking

**Verifying imports and cleaning unused ones**
[2025-09-21T17:40:23] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -423,3 +423,2 @@
     use crossterm::{execute, queue};
-    use std::cmp;
     use std::io::{stdout, Stdout, Write};
[2025-09-21T17:40:23] apply_patch(auto_approved=true) exited 0 in 35ms:
Success. Updated the following files:
M rust-project/src/main.rs
[2025-09-21T17:40:23] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..85166a83640f770667c2c221b6eeb0d0fec45587
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,135 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    execute!(stdout, Hide)?;
+
+    let result = pager_loop(&lines, &mut stdout);
+
+    execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show)?;
+    terminal::disable_raw_mode()?;
+    stdout.flush()?;
+    println!();
+
+    result
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{queue, cursor::MoveTo};
+    use std::cmp;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };

[2025-09-21T17:40:23] tokens used: 104,428
[2025-09-21T17:40:23] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..85166a83640f770667c2c221b6eeb0d0fec45587
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,135 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    execute!(stdout, Hide)?;
+
+    let result = pager_loop(&lines, &mut stdout);
+
+    execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show)?;
+    terminal::disable_raw_mode()?;
+    stdout.flush()?;
+    println!();
+
+    result
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{queue, cursor::MoveTo};
+    use std::cmp;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };


[2025-09-21T17:40:32] thinking

**Reviewing function argument references**
[2025-09-21T17:40:34] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -433,3 +433,3 @@
 
-    let result = pager_loop(&lines, &mut stdout);
+    let result = pager_loop(lines, &mut stdout);
 
[2025-09-21T17:40:34] apply_patch(auto_approved=true) exited 0 in 34ms:
Success. Updated the following files:
M rust-project/src/main.rs
[2025-09-21T17:40:34] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..5ef60d322a0607d1e970b8966c20a52d7c514583
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,135 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    execute!(stdout, Hide)?;
+
+    let result = pager_loop(lines, &mut stdout);
+
+    execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show)?;
+    terminal::disable_raw_mode()?;
+    stdout.flush()?;
+    println!();
+
+    result
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{queue, cursor::MoveTo};
+    use std::cmp;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };

[2025-09-21T17:40:34] tokens used: 112,867
[2025-09-21T17:40:34] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..5ef60d322a0607d1e970b8966c20a52d7c514583
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,135 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    execute!(stdout, Hide)?;
+
+    let result = pager_loop(lines, &mut stdout);
+
+    execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show)?;
+    terminal::disable_raw_mode()?;
+    stdout.flush()?;
+    println!();
+
+    result
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{queue, cursor::MoveTo};
+    use std::cmp;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };


[2025-09-21T17:41:06] thinking

**Ensuring proper terminal cleanup on error**

I'm figuring out how to guarantee raw mode is always disabled and the terminal cursor shown, even if clearing or paging commands fail, by restructuring cleanup with a dedicated function that attempts each step and captures errors without skipping the critical `disable_raw_mode` call. This will keep the terminal state consistent whether the pager completes successfully or errors out.
[2025-09-21T17:41:08] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -433,10 +433,10 @@
 
-    let result = pager_loop(lines, &mut stdout);
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
 
-    execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show)?;
-    terminal::disable_raw_mode()?;
-    stdout.flush()?;
-    println!();
-
-    result
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
 }
@@ -521,2 +521,34 @@
 
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::execute;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
 fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
[2025-09-21T17:41:08] apply_patch(auto_approved=true) exited 0 in 35ms:
Success. Updated the following files:
M rust-project/src/main.rs
[2025-09-21T17:41:08] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..a60ede55d3415d68c66b8f3783904d5443fcf60d
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,167 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    execute!(stdout, Hide)?;
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{queue, cursor::MoveTo};
+    use std::cmp;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::execute;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };

[2025-09-21T17:41:08] tokens used: 116,796
[2025-09-21T17:41:08] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..a60ede55d3415d68c66b8f3783904d5443fcf60d
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,167 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    execute!(stdout, Hide)?;
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{queue, cursor::MoveTo};
+    use std::cmp;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::execute;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };


[2025-09-21T17:41:17] thinking

**Fixing imports for pager_cleanup**
[2025-09-21T17:41:18] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -525,2 +525,3 @@
     use crossterm::execute;
+    use std::io::Write;
 
[2025-09-21T17:41:18] apply_patch(auto_approved=true) exited 0 in 36ms:
Success. Updated the following files:
M rust-project/src/main.rs
[2025-09-21T17:41:18] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..08e525287e248efed06edaec3132f3afd5633cf6
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,168 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    execute!(stdout, Hide)?;
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{queue, cursor::MoveTo};
+    use std::cmp;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::execute;
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };

[2025-09-21T17:41:18] tokens used: 120,774
[2025-09-21T17:41:18] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..08e525287e248efed06edaec3132f3afd5633cf6
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,168 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    execute!(stdout, Hide)?;
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{queue, cursor::MoveTo};
+    use std::cmp;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::execute;
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };


[2025-09-21T17:41:21] thinking

**Verifying import statement order**
[2025-09-21T17:41:21] exec bash -lc 'rg "pager_loop" -n rust-project/src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:41:21] bash -lc 'rg "pager_loop" -n rust-project/src/main.rs' succeeded in 15ms:
434:    let pager_result = pager_loop(lines, &mut stdout);
444:fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
[2025-09-21T17:41:21] tokens used: 122,137
[2025-09-21T17:41:21] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..08e525287e248efed06edaec3132f3afd5633cf6
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,168 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    execute!(stdout, Hide)?;
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{queue, cursor::MoveTo};
+    use std::cmp;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::execute;
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };

[2025-09-21T17:41:24] exec bash -lc "sed -n '420,520p' rust-project/src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:41:24] bash -lc "sed -n '420,520p' rust-project/src/main.rs" succeeded in 18ms:
    use crossterm::event::{self, Event, KeyCode};
    use crossterm::style::Print;
    use crossterm::terminal::{self, Clear, ClearType};
    use crossterm::{execute, queue};
    use std::io::{stdout, Stdout, Write};

    if lines.is_empty() {
        return Ok(());
    }

    let mut stdout = stdout();
    terminal::enable_raw_mode()?;
    execute!(stdout, Hide)?;

    let pager_result = pager_loop(lines, &mut stdout);
    let cleanup_result = pager_cleanup(&mut stdout);

    match (pager_result, cleanup_result) {
        (Err(err), _) => Err(err),
        (_, Err(err)) => Err(err),
[2025-09-21T17:41:24] tokens used: 122,344
[2025-09-21T17:41:24] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..08e525287e248efed06edaec3132f3afd5633cf6
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,168 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    execute!(stdout, Hide)?;
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{queue, cursor::MoveTo};
+    use std::cmp;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::execute;
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };


[2025-09-21T17:41:29] thinking

**Adjusting imports for flush method**
[2025-09-21T17:41:30] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -447,4 +447,5 @@
     use crossterm::terminal::{self, Clear, ClearType};
-    use crossterm::{queue, cursor::MoveTo};
+    use crossterm::{cursor::MoveTo, queue};
     use std::cmp;
+    use std::io::Write;
 
[2025-09-21T17:41:30] apply_patch(auto_approved=true) exited 0 in 35ms:
Success. Updated the following files:
M rust-project/src/main.rs
[2025-09-21T17:41:30] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..c4382e3bfffdb5a679970e4887341ad9651ca7ee
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,169 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    execute!(stdout, Hide)?;
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::execute;
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };

[2025-09-21T17:41:30] tokens used: 123,740
[2025-09-21T17:41:30] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..c4382e3bfffdb5a679970e4887341ad9651ca7ee
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,169 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    execute!(stdout, Hide)?;
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::execute;
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };


[2025-09-21T17:41:56] thinking

**Ensuring robust terminal pager handling**

I'm reviewing the terminal pager code to prevent leftover screen artifacts by always clearing the screen before paging, managing offsets correctly for pagination limits, and fixing a critical issue where enabling raw mode and hiding the cursor can fail and leave raw mode active. To fix this, I'll adjust `print_paged` to disable raw mode if hiding the cursor fails, add cleanup calls after errors, and consider a RAII guard to ensure raw mode is disabled and cursor shown on all exit paths. This careful error handling keeps the terminal state consistent even if intermediate steps fail.
[2025-09-21T17:41:58] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -431,3 +431,6 @@
     terminal::enable_raw_mode()?;
-    execute!(stdout, Hide)?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
 
[2025-09-21T17:41:58] apply_patch(auto_approved=true) exited 0 in 39ms:
Success. Updated the following files:
M rust-project/src/main.rs
[2025-09-21T17:41:58] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..b2eb85f117ba5537351aef7dd9bf9f6c33800ef0
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,172 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::execute;
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };

[2025-09-21T17:41:58] tokens used: 127,155
[2025-09-21T17:41:58] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..b2eb85f117ba5537351aef7dd9bf9f6c33800ef0
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,172 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::execute;
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };


[2025-09-21T17:42:10] thinking

**Refactoring pager cleanup and print_unicode**

I’m revising `pager_cleanup` to robustly disable raw mode and show the cursor even if errors occur, ensuring proper flushing and cursor positioning. Next, I’m overhauling `print_unicode` and related functions to return `Result<Vec<String>, String>`, adjusting internal logic to accumulate lines instead of a single string, and updating all dependent code accordingly. This involves careful signature changes and string handling tweaks to keep everything coherent.
[2025-09-21T17:42:14] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -27,3 +27,3 @@
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
@@ -155,3 +155,2 @@
 
-    let mut out = String::new();
     write_graph(
@@ -163,5 +162,3 @@
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
[2025-09-21T17:42:14] apply_patch(auto_approved=true) exited 0 in 33ms:
Success. Updated the following files:
M rust-project/src/print/unicode.rs
[2025-09-21T17:42:14] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..b2eb85f117ba5537351aef7dd9bf9f6c33800ef0
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,172 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::execute;
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..b9669ef9a205df2017d875e9d8e9e02b44f1ad71
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {

[2025-09-21T17:42:14] tokens used: 130,019
[2025-09-21T17:42:14] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..b2eb85f117ba5537351aef7dd9bf9f6c33800ef0
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,172 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::execute;
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..b9669ef9a205df2017d875e9d8e9e02b44f1ad71
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {


[2025-09-21T17:42:18] thinking

**Updating write_graph function signature**
[2025-09-21T17:42:22] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -424,5 +424,6 @@
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
@@ -434,12 +435,13 @@
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
@@ -452,3 +454,4 @@
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             let line = row
@@ -457,8 +460,8 @@
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line_to_string(&line, &mut line.clone());
+            // placeholder to satisfy compiler
         }
     }
-    Ok(())
+    }
+    Ok(lines)
 }
[2025-09-21T17:42:23] apply_patch(auto_approved=true) exited 0 in 41ms:
Success. Updated the following files:
M rust-project/src/print/unicode.rs
[2025-09-21T17:42:23] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..b2eb85f117ba5537351aef7dd9bf9f6c33800ef0
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,172 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::execute;
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..b71aa3e0a6d51418ac1af9aab6b4edcf3afe6b32
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line_to_string(&line, &mut line.clone());
+            // placeholder to satisfy compiler
         }
     }
-    Ok(())
+    }
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {

[2025-09-21T17:42:23] tokens used: 131,171
[2025-09-21T17:42:23] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..b2eb85f117ba5537351aef7dd9bf9f6c33800ef0
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,172 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::execute;
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..b71aa3e0a6d51418ac1af9aab6b4edcf3afe6b32
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line_to_string(&line, &mut line.clone());
+            // placeholder to satisfy compiler
         }
     }
-    Ok(())
+    }
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:42:32] thinking

**Correcting variable misuse in write_graph function**
[2025-09-21T17:42:32] exec bash -lc "sed -n '420,520p' rust-project/src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:42:32] bash -lc "sed -n '420,520p' rust-project/src/print/unicode.rs" succeeded in 22ms:
    line_to_index: &HashMap<usize, usize>,
    head_index: Option<usize>,
    characters: &Characters,
    grid: &Grid,
    color: bool,
) -> Result<Vec<String>, String> {
    let color_enabled = enable_color_output(color);
    let height = grid.data.len() / grid.width;
    let mut lines = Vec::with_capacity(height);
    if color_enabled {
        for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
            let index = line_to_index.get(&line_idx);
            let head_info = match (head_index, index) {
                (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                _ => None,
            };
            let mut line = String::new();
            write_pre(&graph, index, &mut line);
            for arr in row {
                if arr[0] == SPACE {
[2025-09-21T17:42:32] tokens used: 132,167
[2025-09-21T17:42:32] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..b2eb85f117ba5537351aef7dd9bf9f6c33800ef0
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,172 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::execute;
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..b71aa3e0a6d51418ac1af9aab6b4edcf3afe6b32
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             let line = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line_to_string(&line, &mut line.clone());
+            // placeholder to satisfy compiler
         }
     }
-    Ok(())
+    }
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:42:38] thinking

**Fixing else branch and stray braces**
[2025-09-21T17:42:41] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -456,3 +456,3 @@
             write_pre(&graph, index, &mut line);
-            let line = row
+            let graph_segment = row
                 .iter()
@@ -460,6 +460,6 @@
                 .collect::<String>();
-            line_to_string(&line, &mut line.clone());
-            // placeholder to satisfy compiler
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
-    }
     }
[2025-09-21T17:42:41] apply_patch(auto_approved=true) exited 0 in 23ms:
Success. Updated the following files:
M rust-project/src/print/unicode.rs
[2025-09-21T17:42:41] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..b2eb85f117ba5537351aef7dd9bf9f6c33800ef0
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,172 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::execute;
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {

[2025-09-21T17:42:41] tokens used: 136,004
[2025-09-21T17:42:41] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..b2eb85f117ba5537351aef7dd9bf9f6c33800ef0
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,172 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::execute;
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:42:44] thinking

**Verifying brace correctness**
[2025-09-21T17:42:45] exec bash -lc "sed -n '420,520p' rust-project/src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:42:45] bash -lc "sed -n '420,520p' rust-project/src/print/unicode.rs" succeeded in 14ms:
    line_to_index: &HashMap<usize, usize>,
    head_index: Option<usize>,
    characters: &Characters,
    grid: &Grid,
    color: bool,
) -> Result<Vec<String>, String> {
    let color_enabled = enable_color_output(color);
    let height = grid.data.len() / grid.width;
    let mut lines = Vec::with_capacity(height);
    if color_enabled {
        for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
            let index = line_to_index.get(&line_idx);
            let head_info = match (head_index, index) {
                (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                _ => None,
            };
            let mut line = String::new();
            write_pre(&graph, index, &mut line);
            for arr in row {
                if arr[0] == SPACE {
[2025-09-21T17:42:45] tokens used: 137,799
[2025-09-21T17:42:45] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..b2eb85f117ba5537351aef7dd9bf9f6c33800ef0
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,172 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::execute;
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:42:59] thinking

**Verifying write_graph integration and return types**
[2025-09-21T17:43:00] exec bash -lc 'rg "Result<String" -n rust-project/src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:43:00] bash -lc 'rg "Result<String" -n rust-project/src/print/unicode.rs' exited 1 in 9ms:

[2025-09-21T17:43:00] tokens used: 139,588
[2025-09-21T17:43:00] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..b2eb85f117ba5537351aef7dd9bf9f6c33800ef0
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,172 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::execute;
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first,
+        last,
+        total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:43:05] thinking

**Ensuring code formatting consistency**
[2025-09-21T17:43:05] exec bash -lc 'cargo fmt' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:43:05] bash -lc 'cargo fmt' succeeded in 65ms:

[2025-09-21T17:43:05] tokens used: 139,847
[2025-09-21T17:43:05] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:43:10] thinking

**Reviewing formatted Rust files**
[2025-09-21T17:43:10] exec bash -lc 'rg "print_paged" -n src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:43:10] bash -lc 'rg "print_paged" -n src/main.rs' succeeded in 11ms:
393:            print_paged(&lines).map_err(|err| err.to_string())?;
418:fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
[2025-09-21T17:43:10] tokens used: 142,524
[2025-09-21T17:43:10] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {

[2025-09-21T17:43:14] exec bash -lc "sed -n '418,520p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:43:14] bash -lc "sed -n '418,520p' src/main.rs" succeeded in 13ms:
fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
    use crossterm::cursor::{Hide, MoveTo, Show};
    use crossterm::event::{self, Event, KeyCode};
    use crossterm::style::Print;
    use crossterm::terminal::{self, Clear, ClearType};
    use crossterm::{execute, queue};
    use std::io::{stdout, Stdout, Write};

    if lines.is_empty() {
        return Ok(());
    }

    let mut stdout = stdout();
    terminal::enable_raw_mode()?;
    if let Err(err) = execute!(stdout, Hide) {
        let _ = terminal::disable_raw_mode();
        return Err(err);
    }

    let pager_result = pager_loop(lines, &mut stdout);
[2025-09-21T17:43:14] tokens used: 142,938
[2025-09-21T17:43:14] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {

[2025-09-21T17:43:18] exec bash -lc "sed -n '520,620p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:43:18] bash -lc "sed -n '520,620p' src/main.rs" succeeded in 16ms:
            Event::Resize(_, _) => continue,
            _ => {}
        }
    }
}

fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
    use crossterm::cursor::{MoveTo, Show};
    use crossterm::execute;
    use crossterm::terminal::{self, Clear, ClearType};
    use std::io::Write;

    let mut error: Option<std::io::Error> = None;

    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
        error = Some(err);
    }

    if let Err(err) = stdout.flush() {
        if error.is_none() {
[2025-09-21T17:43:18] tokens used: 144,251
[2025-09-21T17:43:18] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:43:32] thinking

**Reviewing and validating pager loop logic**

I’m making sure the use of `queue!` in the pager loop handles screen clearing and leftover lines properly, checking that `pager_status` is called when there are no lines, and verifying no redundant imports or variable shadowing exist. I also plan to update `Cargo.lock` by building the project after careful code changes.
[2025-09-21T17:43:33] exec bash -lc 'cargo build' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:43:43] bash -lc 'cargo build' exited 124 in 10.01s:
    Updating crates.io index
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
[2025-09-21T17:43:43] tokens used: 146,867
[2025-09-21T17:43:43] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:43:54] thinking

**Handling dependency update without network**

The network is restricted, so I can't update the crates.io index or fetch the new `crossterm` dependency the usual way. I need to find an offline fallback to update `Cargo.lock` and note that building the project isn't possible without network access. I'll consider checking for cached crates locally or manually editing the lockfile to replicate the commit as best as I can while acknowledging this limitation in the final response.
[2025-09-21T17:43:55] exec bash -lc 'ls ~/.cargo/registry/src' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:43:55] bash -lc 'ls ~/.cargo/registry/src' succeeded in 19ms:
index.crates.io-1949cf8c6b5b557f
[2025-09-21T17:43:55] tokens used: 149,042
[2025-09-21T17:43:55] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:43:59] thinking

**Checking for existing crossterm download**
[2025-09-21T17:43:59] exec bash -lc 'ls ~/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f | head' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:43:59] bash -lc 'ls ~/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f | head' succeeded in 30ms:
ab_glyph_rasterizer-0.1.10
addr2line-0.24.2
adler2-2.0.0
adler2-2.0.1
aes-0.8.4
ahash-0.4.8
aho-corasick-0.7.20
aho-corasick-1.1.3
allocator-api2-0.2.21
ammonia-4.0.0
[2025-09-21T17:43:59] tokens used: 149,293
[2025-09-21T17:43:59] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:44:03] thinking

**Checking for crossterm crate**
[2025-09-21T17:44:04] exec bash -lc 'ls ~/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f | grep crossterm' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:44:04] bash -lc 'ls ~/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f | grep crossterm' succeeded in 14ms:
crossterm-0.25.0
crossterm-0.27.0
crossterm-0.28.1
[2025-09-21T17:44:04] tokens used: 149,612
[2025-09-21T17:44:04] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..c1bf74ff91ef0c4f099da7b7c05466e97b9ce542
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:44:15] thinking

**Adjusting crossterm version for offline build**
[2025-09-21T17:44:15] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/Cargo.toml
@@ -24,3 +24,3 @@
 yansi = "0.5"
-crossterm = "0.19"
+crossterm = "0.25"
 
[2025-09-21T17:44:15] apply_patch(auto_approved=true) exited 0 in 31ms:
Success. Updated the following files:
M rust-project/Cargo.toml
[2025-09-21T17:44:15] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {

[2025-09-21T17:44:15] tokens used: 151,176
[2025-09-21T17:44:15] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:44:20] thinking

**Building project offline**
[2025-09-21T17:44:20] exec bash -lc 'CARGO_NET_OFFLINE=true cargo build' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:44:20] bash -lc 'CARGO_NET_OFFLINE=true cargo build' exited -1 in 0ms:
     Locking 101 packages to latest compatible versions
    Updating aho-corasick v0.7.15 -> v1.1.3
    Updating ansi_term v0.11.0 -> v0.12.1
    Updating autocfg v1.0.1 -> v1.5.0
      Adding bitflags v1.3.2
      Adding bitflags v2.9.4
    Updating cc v1.0.66 -> v1.2.37
    Updating clap v2.33.3 -> v2.34.0 (available: v4.5.47)
      Adding crossterm v0.25.0 (available: v0.28.1)
      Adding crossterm_winapi v0.9.1
    Updating dirs-sys-next v0.1.1 -> v0.1.2
      Adding displaydoc v0.2.5
      Adding find-msvc-tools v0.1.1
    Updating form_urlencoded v1.0.0 -> v1.2.2
      Adding getrandom v0.2.16
      Adding getrandom v0.3.3
    Updating hermit-abi v0.1.17 -> v0.1.19
      Adding icu_collections v2.0.0
      Adding icu_locale_core v2.0.0
      Adding icu_normalizer v2.0.0
[2025-09-21T17:44:20] tokens used: 151,971
[2025-09-21T17:44:20] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:44:37] thinking

**Analyzing offline cargo build failure**

I'm working through why `cargo build` fails offline due to attempting to update dependencies without a matching lock file. It seems the build tries to fetch new versions or metadata that aren’t cached locally, causing it to fail since no network is available. I’m considering ways to manually adjust `Cargo.lock` or check the local crate index to resolve missing entries for crates like `git2` and `crossterm`. This offline limitation makes building tricky without proper cached metadata.
[2025-09-21T17:44:38] exec bash -lc "ls ~/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f | grep '"'^git2'"'" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:44:38] bash -lc "ls ~/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f | grep '"'^git2'"'" succeeded in 27ms:
git2-0.15.0
git2-0.19.0
[2025-09-21T17:44:38] tokens used: 154,232
[2025-09-21T17:44:38] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:44:45] thinking

**Investigating missing crate version**
[2025-09-21T17:44:46] exec bash -lc 'head -n 20 Cargo.lock' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:44:46] bash -lc 'head -n 20 Cargo.lock' succeeded in 11ms:
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "ansi_term"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d52a9bb7ec0cf484c551830a7ce27bd20d67eac647e1befb56b0be4ee39a55d2"
dependencies = [
 "winapi",
[2025-09-21T17:44:46] tokens used: 157,024
[2025-09-21T17:44:46] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:44:51] thinking

**Checking Cargo.lock for new dependency**
[2025-09-21T17:44:51] exec bash -lc 'rg "crossterm" Cargo.lock' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:44:51] bash -lc 'rg "crossterm" Cargo.lock' exited 2 in 22ms:
Cargo.lock: No such file or directory (os error 2)
[2025-09-21T17:44:51] tokens used: 157,471
[2025-09-21T17:44:51] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:44:57] thinking

**Correcting working directory for command execution**
[2025-09-21T17:44:57] exec bash -lc 'rg "crossterm" Cargo.lock' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:44:57] bash -lc 'rg "crossterm" Cargo.lock' succeeded in 23ms:
name = "crossterm"
 "crossterm_winapi",
name = "crossterm_winapi"
 "crossterm",
[2025-09-21T17:44:57] tokens used: 158,420
[2025-09-21T17:44:57] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:45:03] thinking

**Verifying existing dependencies**
[2025-09-21T17:45:04] exec bash -lc "rg -n \"\\[\\[package\\]\\]\\nname = \\\"crossterm\\\"\" -n Cargo.lock" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:45:04] bash -lc "rg -n \"\\[\\[package\\]\\]\\nname = \\\"crossterm\\\"\" -n Cargo.lock" exited 2 in 22ms:
the literal '"\n"' is not allowed in a regex

Consider enabling multiline mode with the --multiline flag (or -U for short).
When multiline mode is enabled, new line characters can be matched.
[2025-09-21T17:45:04] tokens used: 158,671
[2025-09-21T17:45:04] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:45:08] thinking

**Searching for crossterm in Cargo.lock**
[2025-09-21T17:45:08] exec bash -lc "rg -n \"name = \\\"crossterm\\\"\" Cargo.lock" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:45:08] bash -lc "rg -n \"name = \\\"crossterm\\\"\" Cargo.lock" succeeded in 24ms:
86:name = "crossterm"
[2025-09-21T17:45:08] tokens used: 159,212
[2025-09-21T17:45:08] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:45:12] thinking

**Starting exploration**
[2025-09-21T17:45:13] exec bash -lc "sed -n '86,130p' Cargo.lock" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:45:13] bash -lc "sed -n '86,130p' Cargo.lock" succeeded in 21ms:
name = "crossterm"
version = "0.25.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e64e6c0fbe2c17357405f7c758c1ef960fce08bdfb2c03d88d2a18d7e09c4b67"
dependencies = [
 "bitflags 1.3.2",
 "crossterm_winapi",
 "libc",
 "mio",
 "parking_lot",
 "signal-hook",
 "signal-hook-mio",
 "winapi",
]

[[package]]
name = "crossterm_winapi"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "acdd7c62a3665c7f6830a51635d9ac9b23ed385797f70a83bb8bafe9c572ab2b"
[2025-09-21T17:45:13] tokens used: 159,486
[2025-09-21T17:45:13] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:45:23] thinking

**Reviewing build dependencies and plan update**
[2025-09-21T17:45:25] exec bash -lc "cat <<'EOF'
Plan update:
- Completed step 2: applied report-driven changes to Cargo.toml, src/main.rs, src/print/unicode.rs.
- Next: attempt cargo build/test (offline limitations acknowledged) and document results.
- Finally: stage files and commit with required message.
EOF" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:45:25] bash -lc "cat <<'EOF'
Plan update:
- Completed step 2: applied report-driven changes to Cargo.toml, src/main.rs, src/print/unicode.rs.
- Next: attempt cargo build/test (offline limitations acknowledged) and document results.
- Finally: stage files and commit with required message.
EOF" succeeded in 32ms:
Plan update:
- Completed step 2: applied report-driven changes to Cargo.toml, src/main.rs, src/print/unicode.rs.
- Next: attempt cargo build/test (offline limitations acknowledged) and document results.
- Finally: stage files and commit with required message.
[2025-09-21T17:45:25] tokens used: 216,175
[2025-09-21T17:45:25] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:45:31] thinking

**Preparing to commit changes**
[2025-09-21T17:45:31] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:45:31] bash -lc 'git status -sb' succeeded in 23ms:
## main
 M Cargo.lock
 M Cargo.toml
 M src/main.rs
 M src/print/unicode.rs
[2025-09-21T17:45:31] tokens used: 217,224
[2025-09-21T17:45:31] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:45:37] thinking

**Verifying Cargo.lock consistency**
[2025-09-21T17:45:38] exec bash -lc 'git diff Cargo.toml' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:45:38] bash -lc 'git diff Cargo.toml' succeeded in 34ms:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a..be56e5d 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@ lazy_static = "1.4"
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
[2025-09-21T17:45:38] tokens used: 217,413
[2025-09-21T17:45:38] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:45:42] thinking

**Reviewing main.rs changes**
[2025-09-21T17:45:42] exec bash -lc 'git diff src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:45:42] bash -lc 'git diff src/main.rs' succeeded in 26ms:
diff --git a/src/main.rs b/src/main.rs
index 1b30b65..9978f84 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,12 +76,18 @@ fn from_args() -> Result<(), String> {
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
+        .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
[2025-09-21T17:45:42] tokens used: 217,728
[2025-09-21T17:45:42] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:45:47] thinking

**Reviewing unicode.rs changes**
[2025-09-21T17:45:48] exec bash -lc 'git diff src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:45:48] bash -lc 'git diff src/print/unicode.rs' succeeded in 34ms:
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413..62620dd 100644
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@ const ARR_R: u8 = 15;
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@ pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, St
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
[2025-09-21T17:45:48] tokens used: 220,181
[2025-09-21T17:45:48] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:45:53] thinking

**Preparing to commit changes**
[2025-09-21T17:45:54] exec bash -lc 'git add -A' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:45:54] bash -lc 'git add -A' succeeded in 28ms:

[2025-09-21T17:45:54] tokens used: 221,567
[2025-09-21T17:45:54] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:45:58] thinking

**Committing changes**
[2025-09-21T17:45:58] exec bash -lc 'git commit -m "050-92449ff：复现提交代码内容。"' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:45:58] bash -lc 'git commit -m "050-92449ff：复现提交代码内容。"' succeeded in 33ms:
[main bdfc808] 050-92449ff：复现提交代码内容。
 4 files changed, 855 insertions(+), 210 deletions(-)
[2025-09-21T17:45:58] tokens used: 221,772
[2025-09-21T17:45:58] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:46:02] thinking

**Confirming plan update**
[2025-09-21T17:46:03] exec bash -lc "cat <<'EOF'
Plan update:
- Completed step 3: attempted cargo build but blocked by offline crates.io access; documented for report.
- Step 4 done: staged and committed changes with required message.
- Plan complete.
EOF" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T17:46:03] bash -lc "cat <<'EOF'
Plan update:
- Completed step 3: attempted cargo build but blocked by offline crates.io access; documented for report.
- Step 4 done: staged and committed changes with required message.
- Plan complete.
EOF" succeeded in 26ms:
Plan update:
- Completed step 3: attempted cargo build but blocked by offline crates.io access; documented for report.
- Step 4 done: staged and committed changes with required message.
- Plan complete.
[2025-09-21T17:46:03] tokens used: 222,016
[2025-09-21T17:46:03] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:46:12] thinking

**Preparing final response details**
[2025-09-21T17:46:12] exec bash -lc "nl -ba src/main.rs | sed -n '70,120p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:46:12] bash -lc "nl -ba src/main.rs | sed -n '70,120p'" succeeded in 24ms:
    70	                .short("S")
    71	                .help(
    72	                    "Render a sparse graph: merges connect to branch lines rather than merge commits."
    73	                )
    74	                .required(false)
    75	                .takes_value(false),
    76	        )
    77	        .arg(
    78	            Arg::with_name("no-color")
    79	                .long("no-color")
    80	                .help("Disable colors (auto-detected when unsupported).")
    81	                .required(false)
    82	                .takes_value(false),
    83	        )
    84	        .arg(
    85	            Arg::with_name("no-pager")
    86	                .long("no-pager")
    87	                .help("Use no pager (print everything at once without prompt).")
    88	                .required(false)
    89	                .takes_value(false),
[2025-09-21T17:46:12] tokens used: 222,486
[2025-09-21T17:46:12] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:46:17] thinking

**Searching for pager usage lines**
[2025-09-21T17:46:17] exec bash -lc "nl -ba src/main.rs | sed -n '160,220p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:46:17] bash -lc "nl -ba src/main.rs | sed -n '160,220p'" succeeded in 26ms:
   160	    let repository = discover_repository(repo_path)?;
   161	    let model = get_model(&repository, matches.value_of("model"))?;
   162	
   163	    let commit_limit = match matches.value_of("max-count") {
   164	        None => None,
   165	        Some(str) => match str.parse::<usize>() {
   166	            Ok(val) => Some(val),
   167	            Err(_) => {
   168	                return Err(format![
   169	                    "Option max-count must be a positive number, but got '{}'",
   170	                    str
   171	                ])
   172	            }
   173	        },
   174	    };
   175	    let svg = matches.is_present("svg");
   176	    let pager = !matches.is_present("no-pager");
   177	    let colored = !matches.is_present("no-color");
   178	    let compact = !matches.is_present("sparse");
   179	    let debug = matches.is_present("debug");
[2025-09-21T17:46:17] tokens used: 223,359
[2025-09-21T17:46:17] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:46:23] thinking

**Preparing run function edits**
[2025-09-21T17:46:25] exec bash -lc "nl -ba src/main.rs | sed -n '320,420p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:46:25] bash -lc "nl -ba src/main.rs | sed -n '320,420p'" succeeded in 20ms:
   320	            (BranchSettingsDef::git_flow(), "git-flow.toml"),
   321	            (BranchSettingsDef::simple(), "simple.toml"),
   322	            (BranchSettingsDef::none(), "none.toml"),
   323	        ];
   324	        for (model, file) in &models {
   325	            let mut path = PathBuf::from(&models_dir);
   326	            path.push(file);
   327	            let str = toml::to_string_pretty(&model).map_err(|err| err.to_string())?;
   328	            std::fs::write(&path, str).map_err(|err| err.to_string())?;
   329	        }
   330	    }
   331	
   332	    Ok(())
   333	}
   334	
   335	fn discover_repository(path: Option<&str>) -> Result<Repository, String> {
   336	    let search_root = path.unwrap_or(".");
   337	    Repository::discover(search_root).map_err(|err| {
   338	        if err.code() == ErrorCode::NotFound {
   339	            if let Some(path) = path {
[2025-09-21T17:46:25] tokens used: 231,007
[2025-09-21T17:46:25] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:46:30] thinking

**Locating pager_loop and print_unicode lines**
[2025-09-21T17:46:30] exec bash -lc "nl -ba src/print/unicode.rs | sed -n '1,80p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:46:30] bash -lc "nl -ba src/print/unicode.rs | sed -n '1,80p'" succeeded in 29ms:
     1	use crate::graph::{GitGraph, HeadInfo};
     2	use crate::settings::{Characters, Settings};
     3	use atty::Stream;
     4	use std::collections::hash_map::Entry::{Occupied, Vacant};
     5	use std::collections::HashMap;
     6	use yansi::Paint;
     7	
     8	const SPACE: u8 = 0;
     9	const DOT: u8 = 1;
    10	const CIRCLE: u8 = 2;
    11	const VER: u8 = 3;
    12	const HOR: u8 = 4;
    13	const CROSS: u8 = 5;
    14	const R_U: u8 = 6;
    15	const R_D: u8 = 7;
    16	const L_D: u8 = 8;
    17	const L_U: u8 = 9;
    18	const VER_L: u8 = 10;
    19	const VER_R: u8 = 11;
    20	const HOR_U: u8 = 12;
[2025-09-21T17:46:30] tokens used: 233,368
[2025-09-21T17:46:30] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:46:37] thinking

**Adding line numbers to write_graph**
[2025-09-21T17:46:38] exec bash -lc "nl -ba src/print/unicode.rs | sed -n '420,500p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:46:38] bash -lc "nl -ba src/print/unicode.rs | sed -n '420,500p'" succeeded in 18ms:
   420	    line_to_index: &HashMap<usize, usize>,
   421	    head_index: Option<usize>,
   422	    characters: &Characters,
   423	    grid: &Grid,
   424	    color: bool,
   425	) -> Result<Vec<String>, String> {
   426	    let color_enabled = enable_color_output(color);
   427	    let height = grid.data.len() / grid.width;
   428	    let mut lines = Vec::with_capacity(height);
   429	    if color_enabled {
   430	        for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
   431	            let index = line_to_index.get(&line_idx);
   432	            let head_info = match (head_index, index) {
   433	                (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
   434	                _ => None,
   435	            };
   436	            let mut line = String::new();
   437	            write_pre(&graph, index, &mut line);
   438	            for arr in row {
   439	                if arr[0] == SPACE {
[2025-09-21T17:46:38] tokens used: 235,957
[2025-09-21T17:46:38] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:46:45] thinking

**Preparing commit details and summary**
[2025-09-21T17:46:47] exec bash -lc "nl -ba Cargo.toml | sed -n '20,40p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:46:47] bash -lc "nl -ba Cargo.toml | sed -n '20,40p'" succeeded in 29ms:
    20	clap = "2.33"
    21	lazy_static = "1.4"
    22	atty = "0.2"
    23	platform-dirs = "0.3"
    24	yansi = "0.5"
    25	crossterm = "0.25"
    26	
    27	[profile.release]
    28	opt-level = 3
    29	lto = true
    30	codegen-units = 1
[2025-09-21T17:46:47] tokens used: 237,406
[2025-09-21T17:46:47] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:46:53] thinking

**Checking for crossterm references in Cargo.lock**
[2025-09-21T17:46:53] exec bash -lc "nl -ba Cargo.lock | sed -n '80,120p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T17:46:53] bash -lc "nl -ba Cargo.lock | sed -n '80,120p'" succeeded in 30ms:
    80	 "textwrap",
    81	 "unicode-width",
    82	 "vec_map",
    83	]
    84	
    85	[[package]]
    86	name = "crossterm"
    87	version = "0.25.0"
    88	source = "registry+https://github.com/rust-lang/crates.io-index"
    89	checksum = "e64e6c0fbe2c17357405f7c758c1ef960fce08bdfb2c03d88d2a18d7e09c4b67"
    90	dependencies = [
    91	 "bitflags 1.3.2",
    92	 "crossterm_winapi",
    93	 "libc",
    94	 "mio",
    95	 "parking_lot",
    96	 "signal-hook",
    97	 "signal-hook-mio",
    98	 "winapi",
    99	]
[2025-09-21T17:46:53] tokens used: 237,687
[2025-09-21T17:46:53] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


[2025-09-21T17:47:02] thinking

**Summarizing modifications and build attempts**

I'll describe the key code changes with file and line references, note our build attempt was blocked by offline status preventing fetching the `git2` crate, and highlight our assumption of using crossterm version 0.25 due to local availability. This will go in the final message under verification.
[2025-09-21T17:47:02] codex

**复现结果**
- `Cargo.toml:25`、`Cargo.lock:86` 引入 `crossterm` 依赖以支撑交互式分页；版本取自本地缓存（0.25），对应报告中新依赖。
- `src/main.rs:78-90` 移除了 `--no-color` 的短/别名并新增 `--no-pager` 选项；`src/main.rs:175-197` 在参数解析阶段记录分页开关；`src/main.rs:353-409` 改为获取逐行输出后根据 `--no-pager` 与 TTY 状态选择分页或直接打印。
- `src/main.rs:412-485` 新增分页实现：`print_unpaged` 直接逐行输出，`print_paged`/`pager_loop` 使用 `crossterm` 处理窗口大小、滚动键（↑/↓/Enter/PageDown/PageUp/Home/End）及 `q`/`Esc` 退出，`pager_cleanup` 负责恢复终端状态。
- `src/print/unicode.rs:28-63` 将 `print_unicode` 返回值改为 `Vec<String>`；`src/print/unicode.rs:420-466` 重写 `write_graph` 逐行构造文本，供分页器按行消费。

**验证**
- 运行 `cargo build` 时因沙箱网络受限无法下载 `git2` 等现有依赖，构建未能完成；命令已执行并记录该限制。

**假设与说明**
- 选择 `crossterm = "0.25"` 是因本地环境仅缓存该版本，可离线复现提交功能；若需精确匹配历史版本，请在有网络的环境中调回原版本后重新构建。
- 终端分页提示文本及键位遵循报告描述；若需与原提交完全一致，可在具备参考输出时再微调。
[2025-09-21T17:47:07] tokens used: 239,063
[2025-09-21T17:47:07] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index f833b1a2290a0b15e223944ec3fe2e050f96972f..be56e5d717c9c12df4c09a71201c34dff15fc213
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,6 +22,7 @@
 atty = "0.2"
 platform-dirs = "0.3"
 yansi = "0.5"
+crossterm = "0.25"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index 1b30b65121cc30b94fdf3f851ca4a2d8bfce88c7..9978f849558e29987946b053959654f72fe2070a
--- a/src/main.rs
+++ b/src/main.rs
@@ -76,13 +76,19 @@
         )
         .arg(
             Arg::with_name("no-color")
-                .long("no-color").alias("mono")
-                .short("M")
+                .long("no-color")
                 .help("Disable colors (auto-detected when unsupported).")
                 .required(false)
                 .takes_value(false),
         )
         .arg(
+            Arg::with_name("no-pager")
+                .long("no-pager")
+                .help("Use no pager (print everything at once without prompt).")
+                .required(false)
+                .takes_value(false),
+        )
+        .arg(
             Arg::with_name("style")
                 .long("style")
                 .short("s")
@@ -167,6 +173,7 @@
         },
     };
     let svg = matches.is_present("svg");
+    let pager = !matches.is_present("no-pager");
     let colored = !matches.is_present("no-color");
     let compact = !matches.is_present("sparse");
     let debug = matches.is_present("debug");
@@ -187,7 +194,7 @@
         merge_patterns: MergePatterns::default(),
     };
 
-    run(&repository, &settings, svg, commit_limit)
+    run(&repository, &settings, svg, commit_limit, pager)
 }
 
 fn get_model_name(repository: &Repository) -> Result<Option<String>, String> {
@@ -348,6 +355,7 @@
     settings: &Settings,
     svg: bool,
     max_commits: Option<usize>,
+    pager: bool,
 ) -> Result<(), String> {
     let now = Instant::now();
     let graph = GitGraph::new(repository, settings, max_commits)?;
@@ -380,7 +388,12 @@
     if svg {
         println!("{}", print_svg(&graph, &settings)?);
     } else {
-        println!("{}", print_unicode(&graph, &settings)?);
+        let lines = print_unicode(&graph, &settings)?;
+        if pager && atty::is(atty::Stream::Stdout) {
+            print_paged(&lines).map_err(|err| err.to_string())?;
+        } else {
+            print_unpaged(&lines);
+        }
     };
 
     let duration_print = now.elapsed().as_micros();
@@ -396,6 +409,170 @@
     Ok(())
 }
 
+fn print_unpaged(lines: &[String]) {
+    for line in lines {
+        println!("{}", line);
+    }
+}
+
+fn print_paged(lines: &[String]) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{Hide, MoveTo, Show};
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{execute, queue};
+    use std::io::{stdout, Stdout, Write};
+
+    if lines.is_empty() {
+        return Ok(());
+    }
+
+    let mut stdout = stdout();
+    terminal::enable_raw_mode()?;
+    if let Err(err) = execute!(stdout, Hide) {
+        let _ = terminal::disable_raw_mode();
+        return Err(err);
+    }
+
+    let pager_result = pager_loop(lines, &mut stdout);
+    let cleanup_result = pager_cleanup(&mut stdout);
+
+    match (pager_result, cleanup_result) {
+        (Err(err), _) => Err(err),
+        (_, Err(err)) => Err(err),
+        _ => Ok(()),
+    }
+}
+
+fn pager_loop(lines: &[String], stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::event::{self, Event, KeyCode};
+    use crossterm::style::Print;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use crossterm::{cursor::MoveTo, queue};
+    use std::cmp;
+    use std::io::Write;
+
+    let mut offset = 0usize;
+
+    loop {
+        let (_cols, rows) = terminal::size()?;
+        let body_rows = rows.saturating_sub(1) as usize;
+
+        queue!(stdout, MoveTo(0, 0), Clear(ClearType::All))?;
+
+        for visible in 0..body_rows {
+            let idx = offset + visible;
+            queue!(stdout, MoveTo(0, visible as u16))?;
+            if idx < lines.len() {
+                queue!(stdout, Print(&lines[idx]))?;
+            }
+        }
+
+        let status_line = pager_status(offset, lines.len(), body_rows);
+        queue!(
+            stdout,
+            MoveTo(0, rows.saturating_sub(1)),
+            Clear(ClearType::CurrentLine),
+            Print(status_line)
+        )?;
+        stdout.flush()?;
+
+        match event::read()? {
+            Event::Key(event) => match event.code {
+                KeyCode::Char('q') | KeyCode::Char('Q') | KeyCode::Esc => break Ok(()),
+                KeyCode::Down | KeyCode::Char('j') | KeyCode::Enter => {
+                    if offset + 1 < lines.len() {
+                        offset += 1;
+                    }
+                }
+                KeyCode::Up | KeyCode::Char('k') => {
+                    if offset > 0 {
+                        offset -= 1;
+                    }
+                }
+                KeyCode::PageDown | KeyCode::Char(' ') => {
+                    if body_rows == 0 {
+                        continue;
+                    }
+                    if offset + body_rows < lines.len() {
+                        offset = cmp::min(offset + body_rows, lines.len().saturating_sub(1));
+                    } else if !lines.is_empty() {
+                        offset = lines.len().saturating_sub(1);
+                    }
+                }
+                KeyCode::PageUp => {
+                    if body_rows == 0 || offset <= body_rows {
+                        offset = 0;
+                    } else {
+                        offset -= body_rows;
+                    }
+                }
+                KeyCode::Home => offset = 0,
+                KeyCode::End => {
+                    if body_rows == 0 {
+                        offset = lines.len().saturating_sub(1);
+                    } else if lines.len() > body_rows {
+                        offset = lines.len() - body_rows;
+                    }
+                }
+                _ => {}
+            },
+            Event::Resize(_, _) => continue,
+            _ => {}
+        }
+    }
+}
+
+fn pager_cleanup(stdout: &mut Stdout) -> Result<(), std::io::Error> {
+    use crossterm::cursor::{MoveTo, Show};
+    use crossterm::execute;
+    use crossterm::terminal::{self, Clear, ClearType};
+    use std::io::Write;
+
+    let mut error: Option<std::io::Error> = None;
+
+    if let Err(err) = execute!(stdout, MoveTo(0, 0), Clear(ClearType::All), Show) {
+        error = Some(err);
+    }
+
+    if let Err(err) = stdout.flush() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    if let Err(err) = terminal::disable_raw_mode() {
+        if error.is_none() {
+            error = Some(err);
+        }
+    }
+
+    println!();
+
+    if let Some(err) = error {
+        Err(err)
+    } else {
+        Ok(())
+    }
+}
+
+fn pager_status(offset: usize, total: usize, page_height: usize) -> String {
+    if total == 0 {
+        return String::from("No output (press q to quit)");
+    }
+    let first = offset + 1;
+    let last = if page_height == 0 {
+        first
+    } else {
+        usize::min(offset + page_height, total)
+    };
+
+    format!(
+        "[{}-{} of {}] ↑/↓, Enter/PageDown/PageUp, End/Home, q/Esc to quit",
+        first, last, total
+    )
+}
+
 fn print_commit_short(graph: &GitGraph, info: &CommitInfo) -> Result<(), Error> {
     let commit = &graph.commit(info.oid)?;
     let symbol = if commit.parents().len() > 1 { "o" } else { "*" };
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index b969413c6d1395537eb63abe1a9f90061b262710..62620dd4bc711398b49fca6887f862f088a87d5d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -25,7 +25,7 @@
 
 const WHITE: u8 = 7;
 
-pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<String, String> {
+pub fn print_unicode(graph: &GitGraph, settings: &Settings) -> Result<Vec<String>, String> {
     let num_cols = 2 * graph
         .branches
         .iter()
@@ -153,7 +153,6 @@
 
     let head_commit_index = graph.indices.get(&graph.head.oid).copied();
 
-    let mut out = String::new();
     write_graph(
         &graph,
         &index_map_inv,
@@ -161,9 +160,7 @@
         &settings.characters,
         &grid,
         settings.colored,
-        &mut out,
-    )?;
-    Ok(out)
+    )
 }
 
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
@@ -425,9 +422,10 @@
     characters: &Characters,
     grid: &Grid,
     color: bool,
-    out: &mut String,
-) -> Result<(), String> {
+) -> Result<Vec<String>, String> {
     let color_enabled = enable_color_output(color);
+    let height = grid.data.len() / grid.width;
+    let mut lines = Vec::with_capacity(height);
     if color_enabled {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
             let index = line_to_index.get(&line_idx);
@@ -435,16 +433,17 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
             for arr in row {
                 if arr[0] == SPACE {
-                    out.push(characters.chars[arr[0] as usize]);
+                    line.push(characters.chars[arr[0] as usize]);
                 } else {
-                    write_colored_char(out, characters.chars[arr[0] as usize], arr[1]);
+                    write_colored_char(&mut line, characters.chars[arr[0] as usize], arr[1]);
                 }
             }
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     } else {
         for (line_idx, row) in grid.data.chunks(grid.width).enumerate() {
@@ -453,17 +452,18 @@
                 (Some(head_idx), Some(idx)) if *idx == head_idx => Some(&graph.head),
                 _ => None,
             };
-            write_pre(&graph, index, out);
-            let line = row
+            let mut line = String::new();
+            write_pre(&graph, index, &mut line);
+            let graph_segment = row
                 .iter()
                 .map(|arr| characters.chars[arr[0] as usize])
                 .collect::<String>();
-            out.push_str(&line);
-            write_post(&graph, index, color_enabled, head_info, out)?;
-            out.push('\n');
+            line.push_str(&graph_segment);
+            write_post(&graph, index, color_enabled, head_info, &mut line)?;
+            lines.push(line);
         }
     }
-    Ok(())
+    Ok(lines)
 }
 
 fn enable_color_output(requested: bool) -> bool {


=== 最终状态 ===
返回码: 0
状态: ✅ 执行成功
