=== 任务 058-472d32a 执行日志 ===
时间: 2025-09-22 02:55:05.821084
Prompt:
请在 .workspace 内，依据 .workspace/todolist/todolist-058-472d32a.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/058-472d32a/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："058-472d32a：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 058-472d32a

=== 输出 ===
[2025-09-21T18:38:43] OpenAI Codex v0.39.0 (research preview)
--------
workdir: /Users/jqwang/104-CommitLens-codex/.workspace
model: gpt-5-codex-high
provider: codex
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
--------
[2025-09-21T18:38:43] User instructions:
请在 .workspace 内，依据 .workspace/todolist/todolist-058-472d32a.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/058-472d32a/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："058-472d32a：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 058-472d32a

[2025-09-21T18:38:49] thinking

**Preparing to review LaTeX file**
[2025-09-21T18:38:49] exec bash -lc 'ls -la' in /Users/jqwang/104-CommitLens-codex/.workspace/.workspace
[2025-09-21T18:38:49] bash -lc 'ls -la' exited -1 in 0ms:
No such file or directory (os error 2)
[2025-09-21T18:38:50] tokens used: 911

[2025-09-21T18:38:53] thinking

**Clarifying working directory path**
[2025-09-21T18:38:53] exec bash -lc 'ls -la' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T18:38:53] bash -lc 'ls -la' succeeded in 9ms:
total 30752
drwxr-xr-x@  9 jqwang  staff       288 Sep 21 15:57 .
drwxr-xr-x@ 29 jqwang  staff       928 Sep 21 07:49 ..
-rw-r--r--@  1 jqwang  staff       103 Sep 22 02:38 codex_error.txt
-rw-r--r--@  1 jqwang  staff  15281501 Sep 22 02:38 codex_output.txt
-rw-r--r--@  1 jqwang  staff         7 Sep 22 02:38 codex_status.txt
drwxr-xr-x@ 59 jqwang  staff      1888 Sep 22 02:38 logs
drwxr-xr-x@ 12 jqwang  staff       384 Sep 21 20:54 rust-project
-rw-r--r--@  1 jqwang  staff      1225 Sep 22 02:38 task_status.json
drwxr-xr-x@  5 jqwang  staff       160 Sep 22 02:38 todolist
[2025-09-21T18:38:53] tokens used: 1,102

[2025-09-21T18:38:56] thinking

**Opening specified tex file**
[2025-09-21T18:38:56] exec bash -lc 'cat todolist/todolist-058-472d32a.tex' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T18:38:56] bash -lc 'cat todolist/todolist-058-472d32a.tex' succeeded in 9ms:
% 明确说明（非常重要），tex必须以\section开头，不能有其他内容，不能使用begin「document」
\section{提交考古：058-472d32a}

\subsection*{Commit 元信息}
\begin{itemize}
  \item 标题：implemented default formatting for oneline, short, medium, full
  \item 作者：Martin Lange <martin\_lange\_@gmx.net>
  \item 日期：2020-12-30T02:38:01+01:00
\end{itemize}

\subsection*{变更摘要（阅读提示）}
本次提交聚焦“提交信息格式化”的默认实现，涉及 4 个文件共 292 行新增、31 行删除。核心变化：
\begin{itemize}
  \item 新增 \texttt{chrono} 依赖以格式化日期时间（\texttt{Cargo.toml}）。
  \item 在 \texttt{src/print/format.rs} 引入 \verb|format_{oneline,short,medium,full}| 四种默认渲染；扩展占位符支持作者/邮箱；支持彩色哈希。
  \item 在 \texttt{src/print/unicode.rs} 将格式化入口从“字符串模板”改为枚举分派，拆分出 \verb|format_branches| 构造 refs/tags/HEAD 文本，改善职责分离。
\end{itemize}

\subsection*{差异解读（证据）}
\textbf{改了什么}
[2025-09-21T18:38:56] tokens used: 1,540

[2025-09-21T18:38:57] thinking

**Checking for figures directory**
[2025-09-21T18:38:58] exec bash -lc 'ls todolist/figs/058-472d32a' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T18:38:58] bash -lc 'ls todolist/figs/058-472d32a' exited 1 in 22ms:
ls: todolist/figs/058-472d32a: No such file or directory
[2025-09-21T18:38:58] tokens used: 3,172

[2025-09-21T18:39:01] thinking

**Preparing to reconstruct commit changes**
[2025-09-21T18:39:01] exec bash -lc ls in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:39:01] bash -lc ls succeeded in 11ms:
Cargo.lock
Cargo.toml
LICENSE
README.md
scripts
src
target
[2025-09-21T18:39:01] tokens used: 3,445

[2025-09-21T18:39:05] thinking

**Inspecting project setup files**
[2025-09-21T18:39:05] exec bash -lc 'cat Cargo.toml' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:39:05] bash -lc 'cat Cargo.toml' succeeded in 21ms:
[package]
name = "git-graph"
version = "0.1.3"
authors = ["Martin Lange <martin_lange_@gmx.net>"]
edition = "2018"
description = "Structured Git graphs for your branching model."
repository = "https://github.com/mlange-42/git-graph"
keywords = ["git", "graph", "cli"]
license = "MIT"
readme = "README.md"

[dependencies]
git2 = "0.13"
regex = "1.4"
serde = "1.0"
serde_derive = "1.0"
toml = "0.5"
itertools = "0.9"
svg = "0.8"
clap = "2.33"
[2025-09-21T18:39:05] tokens used: 3,586

[2025-09-21T18:39:07] thinking

**Checking for chrono usage**
[2025-09-21T18:39:07] exec bash -lc "sed -n '1,200p' src/print/format.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:39:07] bash -lc "sed -n '1,200p' src/print/format.rs" succeeded in 8ms:
use super::unicode::HEAD_COLOR;
use crate::graph::{CommitInfo, GitGraph, HeadInfo};
use yansi::Paint;

const WHITE: u8 = 7;

#[derive(Clone)]
pub struct CommitFormat {
    items: Vec<FormatItem>,
}

#[derive(Clone)]
enum FormatItem {
    Literal(String),
    Placeholder(Placeholder),
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
enum Placeholder {
    ShortHash,
[2025-09-21T18:39:07] tokens used: 3,974

[2025-09-21T18:39:09] thinking

**Continuing process**
[2025-09-21T18:39:09] exec bash -lc "sed -n '200,400p' src/print/format.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:39:09] bash -lc "sed -n '200,400p' src/print/format.rs" succeeded in 7ms:
            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
    }

    if !branch_indices.is_empty() {
        out.push('(');
        for (idx, branch_index) in branch_indices.iter().enumerate() {
            if let Some(branch) = graph.branches.get(*branch_index) {
                let branch_color = branch.visual.term_color;
                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
                if is_head_branch && !head_written {
                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
                    out.push(' ');
                    head_written = true;
                }
                out.push_str(&colored(&branch.name, branch_color, color_enabled));
                if idx < branch_indices.len() - 1 {
                    out.push_str(", ");
                }
            }
        }
[2025-09-21T18:39:09] tokens used: 5,817

[2025-09-21T18:39:12] thinking

**Preparing to add new formatting placeholders**
[2025-09-21T18:39:12] exec bash -lc "sed -n '1,200p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:39:12] bash -lc "sed -n '1,200p' src/print/unicode.rs" succeeded in 16ms:
use crate::graph::GitGraph;
use crate::settings::{Characters, Settings};
use atty::Stream;
use std::collections::hash_map::Entry::{Occupied, Vacant};
use std::collections::HashMap;
use yansi::Paint;

const SPACE: u8 = 0;
const DOT: u8 = 1;
const CIRCLE: u8 = 2;
const VER: u8 = 3;
const HOR: u8 = 4;
const CROSS: u8 = 5;
const R_U: u8 = 6;
const R_D: u8 = 7;
const L_D: u8 = 8;
const L_U: u8 = 9;
const VER_L: u8 = 10;
const VER_R: u8 = 11;
const HOR_U: u8 = 12;
[2025-09-21T18:39:12] tokens used: 6,611

[2025-09-21T18:39:14] thinking

**Continuing process**
[2025-09-21T18:39:14] exec bash -lc "sed -n '200,400p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:39:14] bash -lc "sed -n '200,400p' src/print/unicode.rs" succeeded in 19ms:
                consumed_text[commit_idx] += 1;
            }
            output.push(graph_segment);

            while consumed_text[commit_idx] < formatted_commits[commit_idx].len() {
                let mut extra_line = blank_graph_line.clone();
                let text = &formatted_commits[commit_idx][consumed_text[commit_idx]];
                if !text.is_empty() {
                    extra_line.push_str("  ");
                    extra_line.push_str(text);
                }
                consumed_text[commit_idx] += 1;
                output.push(extra_line);
            }
        } else {
            output.push(graph_segment);
        }
    }

    Ok(output)
[2025-09-21T18:39:14] tokens used: 8,570

[2025-09-21T18:39:19] thinking

**Analyzing formatting integration plan**
[2025-09-21T18:39:19] exec bash -lc 'rg "CommitFormat" -n' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src
[2025-09-21T18:39:19] bash -lc 'rg "CommitFormat" -n' succeeded in 18ms:
settings.rs:1:use crate::print::format::CommitFormat;
settings.rs:39:    pub format: CommitFormat,
main.rs:4:use git_graph::print::format::CommitFormat;
main.rs:197:        CommitFormat::parse(spec)?
main.rs:199:        CommitFormat::default()
print/format.rs:8:pub struct CommitFormat {
print/format.rs:27:impl Default for CommitFormat {
print/format.rs:29:        CommitFormat::parse("oneline").expect("default format is valid")
print/format.rs:33:impl CommitFormat {
print/format.rs:153:        Ok(CommitFormat { items })
[2025-09-21T18:39:19] tokens used: 11,163

[2025-09-21T18:39:26] thinking

**Checking configuration settings**
[2025-09-21T18:39:26] exec bash -lc "sed -n '1,160p' src/settings.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:39:26] bash -lc "sed -n '1,160p' src/settings.rs" succeeded in 21ms:
use crate::print::format::CommitFormat;
use regex::{Error, Regex};
use serde_derive::{Deserialize, Serialize};
use std::str::FromStr;

#[derive(Serialize, Deserialize)]
pub struct RepoSettings {
    /// The repository's branching model
    pub model: String,
}

/// Ordering policy for branches in visual columns.
pub enum BranchOrder {
    /// Recommended! Shortest branches are inserted left-most.
    ///
    /// For branches with equal length, branches ending last are inserted first.
    /// Reverse (arg = false): Branches ending first are inserted first.
    ShortestFirst(bool),
    /// Longest branches are inserted left-most.
    ///
[2025-09-21T18:39:26] tokens used: 11,455

[2025-09-21T18:39:34] thinking

**Analyzing commit format restructuring**
[2025-09-21T18:39:34] exec bash -lc 'rg "--format" -n main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:39:34] bash -lc 'rg "--format" -n main.rs' exited 2 in 9ms:
error: Found argument '--format' which wasn't expected, or isn't valid in this context

USAGE:
    
    rg [OPTIONS] PATTERN [PATH ...]
    rg [OPTIONS] -e PATTERN ... [PATH ...]
    rg [OPTIONS] -f PATTERNFILE ... [PATH ...]
    rg [OPTIONS] --files [PATH ...]
    rg [OPTIONS] --type-list
    command | rg [OPTIONS] PATTERN
    rg [OPTIONS] --help
    rg [OPTIONS] --version

For more information try --help

[2025-09-21T18:39:34] tokens used: 13,577

[2025-09-21T18:39:36] thinking

**Correcting command syntax**
[2025-09-21T18:39:36] exec bash -lc 'rg "format" main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:39:36] bash -lc 'rg "format" main.rs' exited 2 in 13ms:
main.rs: No such file or directory (os error 2)
[2025-09-21T18:39:36] tokens used: 13,907

[2025-09-21T18:39:39] thinking

**Setting working directory to project root**
[2025-09-21T18:39:39] exec bash -lc 'rg "format" src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:39:39] bash -lc 'rg "format" src/main.rs' succeeded in 10ms:
use git_graph::print::format::CommitFormat;
            Arg::with_name("format")
                .long("format")
                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
                return Err(format![
    let format = if let Some(spec) = matches.value_of("format") {
        format,
    models_file.push(format!("{}.toml", model));
        Err(format!(
                format!(
    format!(
[2025-09-21T18:39:39] tokens used: 14,095

[2025-09-21T18:39:42] thinking

**Examining relevant section**
[2025-09-21T18:39:43] exec bash -lc "sed -n '1,240p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:39:43] bash -lc "sed -n '1,240p' src/main.rs" succeeded in 10ms:
use clap::{crate_version, App, Arg, SubCommand};
use git2::{ErrorCode, Repository};
use git_graph::graph::GitGraph;
use git_graph::print::format::CommitFormat;
use git_graph::print::svg::print_svg;
use git_graph::print::unicode::print_unicode;
use git_graph::settings::{
    BranchOrder, BranchSettings, BranchSettingsDef, Characters, MergePatterns, RepoSettings,
    Settings,
};
use platform_dirs::AppDirs;
use std::path::PathBuf;
use std::str::FromStr;
use std::time::Instant;

fn main() {
    std::process::exit(match from_args() {
        Ok(_) => 0,
        Err(err) => {
            eprintln!("{}", err);
[2025-09-21T18:39:43] tokens used: 14,405

[2025-09-21T18:39:50] thinking

**Analyzing commit formatting refactor**
[2025-09-21T18:39:50] exec bash -lc 'rg "Long" -n src' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:39:50] bash -lc 'rg "Long" -n src' succeeded in 12ms:
src/settings.rs:19:    /// Longest branches are inserted left-most.
src/settings.rs:23:    LongestFirst(bool),
src/graph.rs:85:            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
[2025-09-21T18:39:50] tokens used: 16,969

[2025-09-21T18:39:57] thinking

**Evaluating dependency updates for Cargo**

I'm considering how to handle adding the chrono crate without network access, checking if it's already in Cargo.lock, and figuring out how to replicate the commit's dependency changes given these constraints.
[2025-09-21T18:39:57] exec bash -lc 'head -n 40 Cargo.lock' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:39:57] bash -lc 'head -n 40 Cargo.lock' succeeded in 8ms:
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "ansi_term"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d52a9bb7ec0cf484c551830a7ce27bd20d67eac647e1befb56b0be4ee39a55d2"
dependencies = [
 "winapi",
[2025-09-21T18:39:57] tokens used: 17,421

[2025-09-21T18:40:02] thinking

**Searching for chrono usage**
[2025-09-21T18:40:03] exec bash -lc 'rg "chrono" Cargo.lock' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:40:03] bash -lc 'rg "chrono" Cargo.lock' exited 1 in 24ms:

[2025-09-21T18:40:03] tokens used: 17,987

[2025-09-21T18:41:08] thinking

**Planning dependency and formatting updates**

I'm considering how to update Cargo.lock without network access, likely needing to approximate entries manually. Meanwhile, I’m outlining the major refactor in format.rs to switch CommitFormat from a struct to an enum with variants (Oneline, Short, Medium, Full, Custom), adding dedicated format functions, moving branch formatting to unicode.rs, and expanding placeholders with author info and colored hashes. I'll also think about how print_unicode dispatches calls and passes branch strings, ensuring clean separation and matching the commit’s architectural changes.
**Checking unicode.rs around line 490**
[2025-09-21T18:41:09] codex
**Checking unicode.rs around line 490**
[2025-09-21T18:41:09] exec bash -lc "sed -n '480,520p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:41:09] bash -lc "sed -n '480,520p' src/print/unicode.rs" succeeded in 21ms:
            if color_enabled && cell[0] != SPACE {
                write_colored_char(&mut line, characters.chars[cell[0] as usize], cell[1]);
            } else {
                line.push(characters.chars[cell[0] as usize]);
            }
        }
        lines.push(line);
    }
    lines
}

fn write_colored_char(out: &mut String, character: char, color: u8) {
    out.push_str(&Paint::fixed(color, character).to_string());
}

fn enable_color_output(requested: bool) -> bool {
    let enabled =
        requested && atty::is(Stream::Stdout) && (!cfg!(windows) || Paint::enable_windows_ascii());

    if enabled {
[2025-09-21T18:41:09] tokens used: 22,373

[2025-09-21T18:42:21] thinking

**Planning detailed commit formatting changes**
**Designing branch formatting and module structure**

I’m figuring out how to have `format_branches` produce a trimmed string without trailing spaces, so format functions can append branches cleanly. To share the `colored` function between `format.rs` and `unicode.rs`, I’m considering the best module setup to avoid circular dependencies, maybe keeping `colored` in `format.rs` as `pub(crate)` and importing it into `unicode.rs`, then handling `format_branches` logic there accordingly.
[2025-09-21T18:42:22] codex
**Designing branch formatting and module structure**

I’m figuring out how to have `format_branches` produce a trimmed string without trailing spaces, so format functions can append branches cleanly. To share the `colored` function between `format.rs` and `unicode.rs`, I’m considering the best module setup to avoid circular dependencies, maybe keeping `colored` in `format.rs` as `pub(crate)` and importing it into `unicode.rs`, then handling `format_branches` logic there accordingly.
[2025-09-21T18:42:22] exec bash -lc 'cat src/print/mod.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:42:22] bash -lc 'cat src/print/mod.rs' succeeded in 8ms:
use crate::graph::GitGraph;
use std::cmp::max;

pub mod colors;
pub mod format;
pub mod svg;
pub mod unicode;

/// Find the index at which a between-branch connection
/// has to deviate from the current branch's column.
///
/// Returns the last index on the current column.
fn get_deviate_index(graph: &GitGraph, index: usize, par_index: usize) -> usize {
    let info = &graph.commits[index];

    let par_info = &graph.commits[par_index];
    let par_branch = &graph.branches[par_info.branch_trace.unwrap()];

    let mut min_split_idx = index;
    for sibling_oid in &par_info.children {
[2025-09-21T18:42:22] tokens used: 27,809
[2025-09-21T18:42:32] stream error: stream disconnected before completion: stream closed before response.completed; retrying 1/5 in 201ms…

[2025-09-21T18:42:40] thinking

**Evaluating module dependencies**
[2025-09-21T18:42:40] exec bash -lc 'ls src/print' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:42:40] bash -lc 'ls src/print' succeeded in 11ms:
colors.rs
format.rs
mod.rs
svg.rs
unicode.rs
[2025-09-21T18:42:40] tokens used: 28,155

[2025-09-21T18:42:45] thinking

**Checking colors.rs for colored placement**
[2025-09-21T18:42:45] exec bash -lc "sed -n '1,160p' src/print/colors.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:42:45] bash -lc "sed -n '1,160p' src/print/colors.rs" succeeded in 20ms:
use lazy_static::lazy_static;
use std::collections::HashMap;

macro_rules! hashmap {
    ($( $key: expr => $val: expr ),*) => {{
         let mut map = ::std::collections::HashMap::new();
         $( map.insert($key, $val); )*
         map
    }}
}

lazy_static! {
    pub static ref NAMED_COLORS: HashMap<&'static str, u8> = hashmap![
        "black" => 0,
        "red" => 1,
        "green" => 2,
        "yellow" => 3,
        "blue" => 4,
        "magenta" => 5,
        "cyan" => 6,
[2025-09-21T18:42:45] tokens used: 28,391

[2025-09-21T18:44:40] thinking

**Designing commit format context and parsing logic**
**Implementing commit formatting with placeholders and context**

I’m outlining how each placeholder like `%h`, `%an`, `%ae` maps to fields in `FormatContext` with precolored strings, ensuring branch decorations keep trailing spaces for backward compatibility. I’m defining formatting functions for each commit style (oneline, short, medium, full) that build lines with proper indentation and signature formatting, carefully handling blank lines in commit messages. To keep formatting flexible, I plan to create a `FormatContext` struct holding all needed info per commit, including colored hashes, decorations, summary, body lines, author and committer details, and dates, so the formatter functions can reliably use consistent data. I’m considering restructuring so `unicode.rs` dispatches formatting calls based on `CommitFormat` enum variants, while `format.rs` provides parsing and these formatting functions, avoiding cross-import duplication, and supporting color where needed.
**Designing FormatContext and format dispatch**

I’m defining a detailed `FormatContext` struct to hold commit data like colored hashes, decorations, author info, and message lines, with a `new` constructor that builds this from the graph and commit index while calling the `format_branches` function. I plan to use this context across formatting functions (`format_oneline`, `format_short`, etc.) that produce lines for each commit format style, and for custom templates via `FormatString::format`. The dispatch in `unicode.rs` will match on the `CommitFormat` enum to call the appropriate formatting function with the constructed context, keeping code modular and consistent.
[2025-09-21T18:45:11] codex
**Implementing commit formatting with placeholders and context**

I’m outlining how each placeholder like `%h`, `%an`, `%ae` maps to fields in `FormatContext` with precolored strings, ensuring branch decorations keep trailing spaces for backward compatibility. I’m defining formatting functions for each commit style (oneline, short, medium, full) that build lines with proper indentation and signature formatting, carefully handling blank lines in commit messages. To keep formatting flexible, I plan to create a `FormatContext` struct holding all needed info per commit, including colored hashes, decorations, summary, body lines, author and committer details, and dates, so the formatter functions can reliably use consistent data. I’m considering restructuring so `unicode.rs` dispatches formatting calls based on `CommitFormat` enum variants, while `format.rs` provides parsing and these formatting functions, avoiding cross-import duplication, and supporting color where needed.
[2025-09-21T18:45:11] codex
**Designing FormatContext and format dispatch**

I’m defining a detailed `FormatContext` struct to hold commit data like colored hashes, decorations, author info, and message lines, with a `new` constructor that builds this from the graph and commit index while calling the `format_branches` function. I plan to use this context across formatting functions (`format_oneline`, `format_short`, etc.) that produce lines for each commit format style, and for custom templates via `FormatString::format`. The dispatch in `unicode.rs` will match on the `CommitFormat` enum to call the appropriate formatting function with the constructed context, keeping code modular and consistent.
[2025-09-21T18:45:11] exec bash -lc 'rg "long" -n src' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:45:11] bash -lc 'rg "long" -n src' succeeded in 19ms:
src/main.rs:40:                .long("max-count")
src/main.rs:48:                .long("model")
src/main.rs:58:                .long("svg")
src/main.rs:65:                .long("debug")
src/main.rs:73:                .long("sparse")
src/main.rs:83:                .long("no-color")
src/main.rs:90:                .long("no-pager")
src/main.rs:97:                .long("style")
src/main.rs:105:                .long("format")
src/main.rs:112:                .long("local")
src/main.rs:120:                .long("path")
src/main.rs:141:                        .long("list")
[2025-09-21T18:45:11] tokens used: 39,712

[2025-09-21T18:46:03] thinking

**Designing comprehensive commit formatting module**

I'm outlining a detailed plan to rewrite the entire `format.rs` file, introducing new structured types like `FormatContext`, `FormatString`, and various formatting helper functions to handle commit display. This includes parsing format strings with advanced placeholders, managing author and committer info with chrono date conversions, and carefully preserving existing color and decoration handling while enhancing flexibility. I want to ensure seamless integration with existing modules, thoughtful error handling, and replicating `git`-style output alignment and formatting.
**Implementing signature formatting and branch decorations**

I'm focusing on implementing commit signature formatting functions that mimic Git’s style, including handling unknown authors, indentation of commit messages, and alignment of date and author lines across various formats. I’m also planning updates to the unicode module to use the new FormatContext and format functions, porting and adapting branch decoration rendering with color support, all while ensuring dependencies like chrono are properly integrated.
[2025-09-21T18:46:24] codex
**Implementing signature formatting and branch decorations**

I'm focusing on implementing commit signature formatting functions that mimic Git’s style, including handling unknown authors, indentation of commit messages, and alignment of date and author lines across various formats. I’m also planning updates to the unicode module to use the new FormatContext and format functions, porting and adapting branch decoration rendering with color support, all while ensuring dependencies like chrono are properly integrated.
[2025-09-21T18:46:24] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/Cargo.toml
@@ -25,2 +25,3 @@
 crossterm = "0.25"
+chrono = "0.4"
 
[2025-09-21T18:46:24] apply_patch(auto_approved=true) exited 0 in 21ms:
Success. Updated the following files:
M Cargo.toml
[2025-09-21T18:46:24] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3

[2025-09-21T18:46:24] tokens used: 46,782
[2025-09-21T18:46:24] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3


[2025-09-21T18:46:34] thinking

**Preparing to rewrite format.rs with new imports**
[2025-09-21T18:46:35] apply_patch auto_approved=true:
D /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/format.rs
use super::unicode::HEAD_COLOR;
use crate::graph::{CommitInfo, GitGraph, HeadInfo};
use yansi::Paint;

const WHITE: u8 = 7;

#[derive(Clone)]
pub struct CommitFormat {
    items: Vec<FormatItem>,
}

#[derive(Clone)]
enum FormatItem {
    Literal(String),
    Placeholder(Placeholder),
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
enum Placeholder {
    ShortHash,
    FullHash,
    Decorations,
    Subject,
    Newline,
}

impl Default for CommitFormat {
    fn default() -> Self {
        CommitFormat::parse("oneline").expect("default format is valid")
    }
}

impl CommitFormat {
    pub fn parse(spec: &str) -> Result<Self, String> {
        let template = if spec.eq_ignore_ascii_case("oneline") {
            "%h %d%s"
        } else {
            spec
        };
        Self::parse_template(template)
    }

    pub fn format_commit(
        &self,
        graph: &GitGraph,
        commit_index: usize,
        head: Option<&HeadInfo>,
        color_enabled: bool,
        hash_color: Option<u8>,
    ) -> Result<Vec<String>, String> {
        let info = graph
            .commits
            .get(commit_index)
            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
        let commit = graph
            .repository
            .find_commit(info.oid)
            .map_err(|err| err.message().to_string())?;

        let full_hash = commit.id().to_string();
        let short_hash = full_hash.chars().take(7).collect::<String>();
        let summary = commit.summary().unwrap_or("").to_string();
        let decorations = render_decorations(graph, info, head, color_enabled);

        let colored_short_hash =
            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
        let colored_full_hash =
            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));

        let mut lines = vec![String::new()];
        let mut line_index = 0;

        for item in &self.items {
            match item {
                FormatItem::Literal(text) => lines[line_index].push_str(text),
                FormatItem::Placeholder(Placeholder::Newline) => {
                    lines.push(String::new());
                    line_index += 1;
                }
                FormatItem::Placeholder(Placeholder::ShortHash) => {
                    if let Some(colored_hash) = colored_short_hash.as_ref() {
                        lines[line_index].push_str(colored_hash);
                    } else {
                        lines[line_index].push_str(&short_hash);
                    }
                }
                FormatItem::Placeholder(Placeholder::FullHash) => {
                    if let Some(colored_hash) = colored_full_hash.as_ref() {
                        lines[line_index].push_str(colored_hash);
                    } else {
                        lines[line_index].push_str(&full_hash);
                    }
                }
                FormatItem::Placeholder(Placeholder::Decorations) => {
                    lines[line_index].push_str(&decorations);
                }
                FormatItem::Placeholder(Placeholder::Subject) => {
                    lines[line_index].push_str(&summary);
                }
            }
        }

        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
            lines.pop();
        }

        Ok(lines)
    }

    fn parse_template(template: &str) -> Result<Self, String> {
        let mut items = Vec::new();
        let mut literal = String::new();
        let mut chars = template.chars();

        while let Some(ch) = chars.next() {
            if ch == '%' {
                let next = chars
                    .next()
                    .ok_or_else(|| "Dangling '%' at end of format string".to_string())?;
                match next {
                    '%' => literal.push('%'),
                    'h' => {
                        flush_literal(&mut literal, &mut items);
                        items.push(FormatItem::Placeholder(Placeholder::ShortHash));
                    }
                    'H' => {
                        flush_literal(&mut literal, &mut items);
                        items.push(FormatItem::Placeholder(Placeholder::FullHash));
                    }
                    'd' => {
                        flush_literal(&mut literal, &mut items);
                        items.push(FormatItem::Placeholder(Placeholder::Decorations));
                    }
                    's' => {
                        flush_literal(&mut literal, &mut items);
                        items.push(FormatItem::Placeholder(Placeholder::Subject));
                    }
                    'n' => {
                        flush_literal(&mut literal, &mut items);
                        items.push(FormatItem::Placeholder(Placeholder::Newline));
                    }
                    other => {
                        return Err(format!("Unsupported placeholder '%{}'", other));
                    }
                }
            } else {
                literal.push(ch);
            }
        }

        flush_literal(&mut literal, &mut items);

        Ok(CommitFormat { items })
    }
}

fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
    if !literal.is_empty() {
        items.push(FormatItem::Literal(literal.clone()));
        literal.clear();
    }
}

fn render_decorations(
    graph: &GitGraph,
    info: &CommitInfo,
    head: Option<&HeadInfo>,
    color_enabled: bool,
) -> String {
    let mut out = String::new();
    let mut head_written = false;

    let branch_color = info
        .branch_trace
        .and_then(|branch_index| graph.branches.get(branch_index))
        .map(|branch| branch.visual.term_color)
        .or_else(|| {
            info.tags
                .first()
                .and_then(|tag_index| graph.branches.get(*tag_index))
                .map(|branch| branch.visual.term_color)
        })
        .unwrap_or(WHITE);

    if let Some(head_info) = head {
        if !head_info.is_branch {
            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
            out.push(' ');
            head_written = true;
        }
    }

    let mut branch_indices = info.branches.clone();
    let head_branch_name = head
        .filter(|head_info| head_info.is_branch)
        .and_then(|head_info| head_info.name.as_deref());

    if let Some(head_branch_name) = head_branch_name {
        branch_indices
            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
    }

    if !branch_indices.is_empty() {
        out.push('(');
        for (idx, branch_index) in branch_indices.iter().enumerate() {
            if let Some(branch) = graph.branches.get(*branch_index) {
                let branch_color = branch.visual.term_color;
                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
                if is_head_branch && !head_written {
                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
                    out.push(' ');
                    head_written = true;
                }
                out.push_str(&colored(&branch.name, branch_color, color_enabled));
                if idx < branch_indices.len() - 1 {
                    out.push_str(", ");
                }
            }
        }
        out.push_str(") ");
    }

    if head.is_some() && !head_written {
        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
        out.push(' ');
    }

    if !info.tags.is_empty() {
        out.push('[');
        for (idx, tag_index) in info.tags.iter().enumerate() {
            if let Some(branch) = graph.branches.get(*tag_index) {
                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
                if idx < info.tags.len() - 1 {
                    out.push_str(", ");
                }
            }
        }
        out.push_str("] ");
    }

    out
}

fn colored(text: &str, color: u8, color_enabled: bool) -> String {
    if color_enabled {
        Paint::fixed(color, text).to_string()
    } else {
        text.to_string()
    }
}
[2025-09-21T18:46:35] apply_patch(auto_approved=true) exited 0 in 22ms:
Success. Updated the following files:
D src/print/format.rs
[2025-09-21T18:46:35] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/print/format.rs b/src/print/format.rs
deleted file mode 100644
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..0000000000000000000000000000000000000000
--- a/src/print/format.rs
+++ /dev/null
@@ -1,251 +0,0 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
-use yansi::Paint;
-
-const WHITE: u8 = 7;
-
-#[derive(Clone)]
-pub struct CommitFormat {
-    items: Vec<FormatItem>,
-}
-
-#[derive(Clone)]
-enum FormatItem {
-    Literal(String),
-    Placeholder(Placeholder),
-}
-
-#[derive(Clone, Copy, Debug, Eq, PartialEq)]
-enum Placeholder {
-    ShortHash,
-    FullHash,
-    Decorations,
-    Subject,
-    Newline,
-}
-
-impl Default for CommitFormat {
-    fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
-    }
-}
-
-impl CommitFormat {
-    pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
-        }
-
-        Ok(lines)
-    }
-
-    fn parse_template(template: &str) -> Result<Self, String> {
-        let mut items = Vec::new();
-        let mut literal = String::new();
-        let mut chars = template.chars();
-
-        while let Some(ch) = chars.next() {
-            if ch == '%' {
-                let next = chars
-                    .next()
-                    .ok_or_else(|| "Dangling '%' at end of format string".to_string())?;
-                match next {
-                    '%' => literal.push('%'),
-                    'h' => {
-                        flush_literal(&mut literal, &mut items);
-                        items.push(FormatItem::Placeholder(Placeholder::ShortHash));
-                    }
-                    'H' => {
-                        flush_literal(&mut literal, &mut items);
-                        items.push(FormatItem::Placeholder(Placeholder::FullHash));
-                    }
-                    'd' => {
-                        flush_literal(&mut literal, &mut items);
-                        items.push(FormatItem::Placeholder(Placeholder::Decorations));
-                    }
-                    's' => {
-                        flush_literal(&mut literal, &mut items);
-                        items.push(FormatItem::Placeholder(Placeholder::Subject));
-                    }
-                    'n' => {
-                        flush_literal(&mut literal, &mut items);
-                        items.push(FormatItem::Placeholder(Placeholder::Newline));
-                    }
-                    other => {
-                        return Err(format!("Unsupported placeholder '%{}'", other));
-                    }
-                }
-            } else {
-                literal.push(ch);
-            }
-        }
-
-        flush_literal(&mut literal, &mut items);
-
-        Ok(CommitFormat { items })
-    }
-}
-
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
-    }
-}
-
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
-
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
-        })
-        .unwrap_or(WHITE);
-
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
-    }
-
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
-
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
-    }
-
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str(") ");
-    }
-
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
-    }
-
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
-    }
-
-    out
-}
-
-fn colored(text: &str, color: u8, color_enabled: bool) -> String {
-    if color_enabled {
-        Paint::fixed(color, text).to_string()
-    } else {
-        text.to_string()
-    }
-}

[2025-09-21T18:46:35] tokens used: 47,505
[2025-09-21T18:46:35] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/print/format.rs b/src/print/format.rs
deleted file mode 100644
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..0000000000000000000000000000000000000000
--- a/src/print/format.rs
+++ /dev/null
@@ -1,251 +0,0 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
-use yansi::Paint;
-
-const WHITE: u8 = 7;
-
-#[derive(Clone)]
-pub struct CommitFormat {
-    items: Vec<FormatItem>,
-}
-
-#[derive(Clone)]
-enum FormatItem {
-    Literal(String),
-    Placeholder(Placeholder),
-}
-
-#[derive(Clone, Copy, Debug, Eq, PartialEq)]
-enum Placeholder {
-    ShortHash,
-    FullHash,
-    Decorations,
-    Subject,
-    Newline,
-}
-
-impl Default for CommitFormat {
-    fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
-    }
-}
-
-impl CommitFormat {
-    pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
-        }
-
-        Ok(lines)
-    }
-
-    fn parse_template(template: &str) -> Result<Self, String> {
-        let mut items = Vec::new();
-        let mut literal = String::new();
-        let mut chars = template.chars();
-
-        while let Some(ch) = chars.next() {
-            if ch == '%' {
-                let next = chars
-                    .next()
-                    .ok_or_else(|| "Dangling '%' at end of format string".to_string())?;
-                match next {
-                    '%' => literal.push('%'),
-                    'h' => {
-                        flush_literal(&mut literal, &mut items);
-                        items.push(FormatItem::Placeholder(Placeholder::ShortHash));
-                    }
-                    'H' => {
-                        flush_literal(&mut literal, &mut items);
-                        items.push(FormatItem::Placeholder(Placeholder::FullHash));
-                    }
-                    'd' => {
-                        flush_literal(&mut literal, &mut items);
-                        items.push(FormatItem::Placeholder(Placeholder::Decorations));
-                    }
-                    's' => {
-                        flush_literal(&mut literal, &mut items);
-                        items.push(FormatItem::Placeholder(Placeholder::Subject));
-                    }
-                    'n' => {
-                        flush_literal(&mut literal, &mut items);
-                        items.push(FormatItem::Placeholder(Placeholder::Newline));
-                    }
-                    other => {
-                        return Err(format!("Unsupported placeholder '%{}'", other));
-                    }
-                }
-            } else {
-                literal.push(ch);
-            }
-        }
-
-        flush_literal(&mut literal, &mut items);
-
-        Ok(CommitFormat { items })
-    }
-}
-
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
-    }
-}
-
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
-
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
-        })
-        .unwrap_or(WHITE);
-
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
-    }
-
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
-
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
-    }
-
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str(") ");
-    }
-
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
-    }
-
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
-    }
-
-    out
-}
-
-fn colored(text: &str, color: u8, color_enabled: bool) -> String {
-    if color_enabled {
-        Paint::fixed(color, text).to_string()
-    } else {
-        text.to_string()
-    }
-}


[2025-09-21T18:46:39] thinking

**Preparing to add new file content**
[2025-09-21T18:47:01] apply_patch auto_approved=true:
A /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/format.rs
use super::unicode::format_branches;
use crate::graph::{GitGraph, HeadInfo};
use chrono::{DateTime, FixedOffset, LocalResult};
use git2::Signature;
use yansi::Paint;

#[derive(Clone)]
pub enum CommitFormat {
    Oneline,
    Short,
    Medium,
    Full,
    Custom(FormatString),
}

#[derive(Clone)]
struct FormatString {
    items: Vec<FormatItem>,
}

#[derive(Clone)]
enum FormatItem {
    Literal(String),
    Placeholder(Placeholder),
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
enum Placeholder {
    ShortHash,
    FullHash,
    Decorations,
    Subject,
    Newline,
    AuthorName,
    AuthorEmail,
}

#[derive(Clone)]
struct PersonInfo {
    name: String,
    email: String,
    date: Option<DateTime<FixedOffset>>,
}

pub(crate) struct FormatContext {
    short_hash: String,
    full_hash: String,
    colored_short_hash: String,
    colored_full_hash: String,
    decorations: String,
    trimmed_decorations: String,
    subject: String,
    body_lines: Vec<String>,
    author: PersonInfo,
    committer: PersonInfo,
}

impl Default for CommitFormat {
    fn default() -> Self {
        CommitFormat::Oneline
    }
}

impl CommitFormat {
    pub fn parse(spec: &str) -> Result<Self, String> {
        match spec.to_ascii_lowercase().as_str() {
            "oneline" => Ok(CommitFormat::Oneline),
            "short" => Ok(CommitFormat::Short),
            "medium" => Ok(CommitFormat::Medium),
            "full" | "long" => Ok(CommitFormat::Full),
            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
        }
    }
}

impl FormatString {
    fn parse(template: &str) -> Result<Self, String> {
        let mut items = Vec::new();
        let mut literal = String::new();
        let mut chars = template.chars();

        while let Some(ch) = chars.next() {
            if ch == '%' {
                let next = chars
                    .next()
                    .ok_or_else(|| "Dangling '%' at end of format string".to_string())?;
                match next {
                    '%' => literal.push('%'),
                    'h' => {
                        flush_literal(&mut literal, &mut items);
                        items.push(FormatItem::Placeholder(Placeholder::ShortHash));
                    }
                    'H' => {
                        flush_literal(&mut literal, &mut items);
                        items.push(FormatItem::Placeholder(Placeholder::FullHash));
                    }
                    'd' => {
                        flush_literal(&mut literal, &mut items);
                        items.push(FormatItem::Placeholder(Placeholder::Decorations));
                    }
                    's' => {
                        flush_literal(&mut literal, &mut items);
                        items.push(FormatItem::Placeholder(Placeholder::Subject));
                    }
                    'n' => {
                        flush_literal(&mut literal, &mut items);
                        items.push(FormatItem::Placeholder(Placeholder::Newline));
                    }
                    'a' => {
                        let spec = chars
                            .next()
                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
                        flush_literal(&mut literal, &mut items);
                        match spec {
                            'n' => {
                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
                            }
                            'e' => {
                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
                            }
                            other => {
                                return Err(format!("Unsupported placeholder '%a{}'", other));
                            }
                        }
                    }
                    other => {
                        return Err(format!("Unsupported placeholder '%{}'", other));
                    }
                }
            } else {
                literal.push(ch);
            }
        }

        flush_literal(&mut literal, &mut items);

        Ok(FormatString { items })
    }

    fn format(&self, context: &FormatContext) -> Vec<String> {
        let mut lines = vec![String::new()];
        let mut line_index = 0;

        for item in &self.items {
            match item {
                FormatItem::Literal(text) => lines[line_index].push_str(text),
                FormatItem::Placeholder(Placeholder::Newline) => {
                    lines.push(String::new());
                    line_index += 1;
                }
                FormatItem::Placeholder(Placeholder::ShortHash) => {
                    lines[line_index].push_str(&context.colored_short_hash);
                }
                FormatItem::Placeholder(Placeholder::FullHash) => {
                    lines[line_index].push_str(&context.colored_full_hash);
                }
                FormatItem::Placeholder(Placeholder::Decorations) => {
                    lines[line_index].push_str(&context.decorations);
                }
                FormatItem::Placeholder(Placeholder::Subject) => {
                    lines[line_index].push_str(&context.subject);
                }
                FormatItem::Placeholder(Placeholder::AuthorName) => {
                    lines[line_index].push_str(&context.author.name);
                }
                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
                    lines[line_index].push_str(&context.author.email);
                }
            }
        }

        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
            lines.pop();
        }

        lines
    }
}

impl FormatContext {
    pub(crate) fn new(
        graph: &GitGraph,
        commit_index: usize,
        head: Option<&HeadInfo>,
        color_enabled: bool,
        hash_color: Option<u8>,
    ) -> Result<Self, String> {
        let info = graph
            .commits
            .get(commit_index)
            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
        let commit = graph
            .repository
            .find_commit(info.oid)
            .map_err(|err| err.message().to_string())?;

        let full_hash = commit.id().to_string();
        let short_hash = full_hash.chars().take(7).collect::<String>();
        let decorations = format_branches(graph, info, head, color_enabled);
        let colored_short_hash = hash_color
            .map(|color_value| colored(&short_hash, color_value, color_enabled))
            .unwrap_or_else(|| short_hash.clone());
        let colored_full_hash = hash_color
            .map(|color_value| colored(&full_hash, color_value, color_enabled))
            .unwrap_or_else(|| full_hash.clone());

        let message = commit.message().unwrap_or("");
        let mut message_lines: Vec<&str> = message.split('\n').collect();
        if message.ends_with('\n') {
            message_lines.pop();
        }

        let body_lines = if message_lines.len() > 1 {
            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
        } else {
            Vec::new()
        };

        let author = signature_to_person(&commit.author());
        let committer = signature_to_person(&commit.committer());

        Ok(FormatContext {
            short_hash,
            full_hash,
            colored_short_hash,
            colored_full_hash,
            decorations,
            trimmed_decorations: decorations.trim().to_string(),
            subject: commit.summary().unwrap_or("").to_string(),
            body_lines,
            author,
            committer,
        })
    }
}

pub(crate) fn format_commit(
    format: &CommitFormat,
    context: &FormatContext,
) -> Vec<String> {
    match format {
        CommitFormat::Oneline => format_oneline(context),
        CommitFormat::Short => format_short(context),
        CommitFormat::Medium => format_medium(context),
        CommitFormat::Full => format_full(context),
        CommitFormat::Custom(template) => template.format(context),
    }
}

pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
    let mut line = context.colored_short_hash.clone();
    let mut segments = Vec::new();

    if !context.trimmed_decorations.is_empty() {
        segments.push(context.trimmed_decorations.clone());
    }
    if !context.subject.is_empty() {
        segments.push(context.subject.clone());
    }

    if !segments.is_empty() {
        line.push(' ');
        line.push_str(&segments.join(" "));
    }

    vec![line]
}

pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
    let mut lines = Vec::new();
    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
    lines.push(format!("Author: {}", format_signature(&context.author)));
    lines.push(String::new());
    lines.extend(format_message_lines(&context.subject, &context.body_lines));
    lines
}

pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
    let mut lines = Vec::new();
    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
    lines.push(format!("Author: {}", format_signature(&context.author)));
    if let Some(date) = format_git_date(context.author.date) {
        lines.push(format!("Date:   {}", date));
    }
    lines.push(String::new());
    lines.extend(format_message_lines(&context.subject, &context.body_lines));
    lines
}

pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
    const LABEL_WIDTH: usize = 11;
    let mut lines = Vec::new();
    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
    if let Some(date) = format_git_date(context.author.date) {
        lines.push(format!(
            "{:<width$}{}",
            "AuthorDate:",
            date,
            width = LABEL_WIDTH
        ));
    }
    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
    if let Some(date) = format_git_date(context.committer.date) {
        lines.push(format!(
            "{:<width$}{}",
            "CommitDate:",
            date,
            width = LABEL_WIDTH
        ));
    }
    lines.push(String::new());
    lines.extend(format_message_lines(&context.subject, &context.body_lines));
    lines
}

fn commit_header(hash: &str, decorations: &str) -> String {
    if decorations.is_empty() {
        format!("commit {}", hash)
    } else {
        format!("commit {} {}", hash, decorations)
    }
}

fn format_signature(person: &PersonInfo) -> String {
    match (person.name.is_empty(), person.email.is_empty()) {
        (true, true) => "<unknown>".to_string(),
        (false, true) => person.name.clone(),
        (true, false) => format!("<{}>", person.email),
        (false, false) => format!("{} <{}>", person.name, person.email),
    }
}

fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
    let mut message = Vec::new();

    if !subject.is_empty() || !body_lines.is_empty() {
        message.push(indent(subject));
        for line in body_lines {
            message.push(indent(line));
        }
    }

    message
}

fn indent(text: &str) -> String {
    let mut line = String::from("    ");
    line.push_str(text);
    line
}

fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
    PersonInfo {
        name: signature.name().unwrap_or("").to_string(),
        email: signature.email().unwrap_or("").to_string(),
        date: git_time_to_datetime(signature.when()),
    }
}

fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
    let offset_seconds = time.offset_minutes().checked_mul(60)?;
    let offset = FixedOffset::east_opt(offset_seconds)?;
    match offset.timestamp_opt(time.seconds(), 0) {
        LocalResult::None => None,
        LocalResult::Single(dt) => Some(dt),
        LocalResult::Ambiguous(first, _) => Some(first),
    }
}

fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
}

fn colored(text: &str, color: u8, color_enabled: bool) -> String {
    if color_enabled {
        Paint::fixed(color, text).to_string()
    } else {
        text.to_string()
    }
}

fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
    if !literal.is_empty() {
        items.push(FormatItem::Literal(literal.clone()));
        literal.clear();
    }
}
[2025-09-21T18:47:01] apply_patch(auto_approved=true) exited 0 in 21ms:
Success. Updated the following files:
A src/print/format.rs
[2025-09-21T18:47:01] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..8e48e4aeb7aae23427f75b3aa1bc95ee0bb45069
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}

[2025-09-21T18:47:01] tokens used: 51,376
[2025-09-21T18:47:01] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..8e48e4aeb7aae23427f75b3aa1bc95ee0bb45069
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}


[2025-09-21T18:47:09] thinking

**Updating imports and patching unicode.rs**
[2025-09-21T18:47:10] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -1,2 +1,2 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
@@ -6,2 +6,3 @@
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
[2025-09-21T18:47:10] apply_patch(auto_approved=true) exited 0 in 33ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T18:47:10] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..8e48e4aeb7aae23427f75b3aa1bc95ee0bb45069
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..702c11ab82d30a9995592c2143ec3eddc687ef7c
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;

[2025-09-21T18:47:10] tokens used: 55,760
[2025-09-21T18:47:10] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..8e48e4aeb7aae23427f75b3aa1bc95ee0bb45069
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..702c11ab82d30a9995592c2143ec3eddc687ef7c
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;


[2025-09-21T18:47:17] thinking

**Adjusting commit formatting loop**
[2025-09-21T18:47:20] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -178,6 +178,10 @@
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
[2025-09-21T18:47:20] apply_patch(auto_approved=true) exited 0 in 25ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T18:47:20] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..8e48e4aeb7aae23427f75b3aa1bc95ee0bb45069
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..0ed35950139ca4f743c6879eac2f12997b067b3a
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 

[2025-09-21T18:47:20] tokens used: 56,597
[2025-09-21T18:47:20] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..8e48e4aeb7aae23427f75b3aa1bc95ee0bb45069
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..0ed35950139ca4f743c6879eac2f12997b067b3a
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 


[2025-09-21T18:47:30] thinking

**Analyzing method visibility issues**
[2025-09-21T18:47:31] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/format.rs
@@ -139,3 +139,3 @@
 
-    fn format(&self, context: &FormatContext) -> Vec<String> {
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
         let mut lines = vec![String::new()];
[2025-09-21T18:47:31] apply_patch(auto_approved=true) exited 0 in 50ms:
Success. Updated the following files:
M src/print/format.rs
[2025-09-21T18:47:31] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..a369670b71901cef8c8e3bc76dc2a79f7b19b78a
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..0ed35950139ca4f743c6879eac2f12997b067b3a
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 

[2025-09-21T18:47:31] tokens used: 57,661
[2025-09-21T18:47:31] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..a369670b71901cef8c8e3bc76dc2a79f7b19b78a
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..0ed35950139ca4f743c6879eac2f12997b067b3a
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 


[2025-09-21T18:47:41] thinking

**Adjusting struct visibility for pattern matching**
[2025-09-21T18:47:42] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/format.rs
@@ -16,3 +16,3 @@
 #[derive(Clone)]
-struct FormatString {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
[2025-09-21T18:47:42] apply_patch(auto_approved=true) exited 0 in 38ms:
Success. Updated the following files:
M src/print/format.rs
[2025-09-21T18:47:42] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..271b6b9bb10280e5f18930aadf1151f9aa4b4b31
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..0ed35950139ca4f743c6879eac2f12997b067b3a
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 

[2025-09-21T18:47:42] tokens used: 58,246
[2025-09-21T18:47:42] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..271b6b9bb10280e5f18930aadf1151f9aa4b4b31
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..0ed35950139ca4f743c6879eac2f12997b067b3a
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 


[2025-09-21T18:47:56] thinking

**Reimplementing branch formatting function**
[2025-09-21T18:48:02] tokens used: 60,071
[2025-09-21T18:48:02] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..271b6b9bb10280e5f18930aadf1151f9aa4b4b31
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..0ed35950139ca4f743c6879eac2f12997b067b3a
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 


[2025-09-21T18:48:07] thinking

**Correcting working directory path**
[2025-09-21T18:48:11] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -226,2 +226,71 @@
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
[2025-09-21T18:48:11] apply_patch(auto_approved=true) exited 0 in 31ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T18:48:11] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..271b6b9bb10280e5f18930aadf1151f9aa4b4b31
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..00a99992a63d9208e00294ca0e8e96530883a17d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,75 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);

[2025-09-21T18:48:11] tokens used: 61,713
[2025-09-21T18:48:11] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..271b6b9bb10280e5f18930aadf1151f9aa4b4b31
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..00a99992a63d9208e00294ca0e8e96530883a17d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,75 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:48:17] thinking

**Verifying existence of `colored` function**
[2025-09-21T18:48:17] exec bash -lc 'rg "fn colored" -n src/print/unicode.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:48:17] bash -lc 'rg "fn colored" -n src/print/unicode.rs' exited 1 in 12ms:

[2025-09-21T18:48:17] tokens used: 62,702
[2025-09-21T18:48:17] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..271b6b9bb10280e5f18930aadf1151f9aa4b4b31
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..00a99992a63d9208e00294ca0e8e96530883a17d
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,75 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:48:23] thinking

**Adding colored function to unicode module**
[2025-09-21T18:48:24] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/unicode.rs
@@ -295,2 +295,10 @@
 
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
[2025-09-21T18:48:24] apply_patch(auto_approved=true) exited 0 in 28ms:
Success. Updated the following files:
M src/print/unicode.rs
[2025-09-21T18:48:24] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..271b6b9bb10280e5f18930aadf1151f9aa4b4b31
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);

[2025-09-21T18:48:24] tokens used: 63,302
[2025-09-21T18:48:24] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..271b6b9bb10280e5f18930aadf1151f9aa4b4b31
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:48:30] thinking

**Updating import statements and help text**
[2025-09-21T18:48:31] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -105,3 +105,5 @@
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
[2025-09-21T18:48:31] apply_patch(auto_approved=true) exited 0 in 35ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T18:48:31] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..271b6b9bb10280e5f18930aadf1151f9aa4b4b31
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);

[2025-09-21T18:48:31] tokens used: 64,059
[2025-09-21T18:48:31] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..271b6b9bb10280e5f18930aadf1151f9aa4b4b31
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:48:43] thinking

**Evaluating dependency lock update options**

I’m weighing how to update Cargo.lock to include new dependencies like chrono while considering offline constraints; I’m thinking about running `cargo update -p chrono`, `cargo fetch`, or `cargo check` to trigger lock updates but recognize network limitations might cause failures.
[2025-09-21T18:48:44] exec bash -lc 'cargo fetch' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:48:54] bash -lc 'cargo fetch' exited 124 in 10.01s:
    Updating crates.io index
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
[2025-09-21T18:48:54] tokens used: 65,009
[2025-09-21T18:48:54] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..271b6b9bb10280e5f18930aadf1151f9aa4b4b31
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:49:13] thinking

**Planning manual Cargo.lock update**

I’m figuring out how to manually add the `chrono` dependency and its transitive dependencies to `Cargo.lock` without network access. Since I can’t verify exact versions or full lock entries, I’m considering inserting minimal placeholder entries with TODO comments, trying to approximate `chrono 0.4.19` dependencies like `libc`, `num-integer`, `num-traits`, and `time`. This is tricky but necessary to replicate the commit as closely as possible offline.
[2025-09-21T18:49:14] exec bash -lc 'rg "num-integer" Cargo.lock' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:49:14] bash -lc 'rg "num-integer" Cargo.lock' exited 1 in 15ms:

[2025-09-21T18:49:14] tokens used: 66,107
[2025-09-21T18:49:14] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..271b6b9bb10280e5f18930aadf1151f9aa4b4b31
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:49:18] thinking

**Checking for num-traits presence**
[2025-09-21T18:49:19] exec bash -lc 'rg "num-traits" Cargo.lock' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:49:19] bash -lc 'rg "num-traits" Cargo.lock' exited 1 in 15ms:

[2025-09-21T18:49:19] tokens used: 66,312
[2025-09-21T18:49:19] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..271b6b9bb10280e5f18930aadf1151f9aa4b4b31
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:49:23] thinking

**Considering use of time variable**
[2025-09-21T18:49:23] exec bash -lc "rg \"\\btime\\b\" Cargo.lock" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:49:23] bash -lc "rg \"\\btime\\b\" Cargo.lock" exited 1 in 8ms:

[2025-09-21T18:49:23] tokens used: 66,483
[2025-09-21T18:49:23] turn diff:
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..271b6b9bb10280e5f18930aadf1151f9aa4b4b31
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:49:32] thinking

**Planning offline Cargo.lock update**

I’m thinking about how to handle adding chrono and its dependencies to Cargo.lock without internet access. Since checksums are required and can’t be generated offline, I’ll add a TODO comment in Cargo.lock noting that the lockfile needs proper regeneration once online. This approach aligns with instructions but avoids breaking the build due to invalid checksums.
[2025-09-21T18:49:33] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/Cargo.lock
@@ -4,2 +4,4 @@
 
+# TODO(058-472d32a): chrono 0.4 dependency not locked due to offline environment.
+
 [[package]]
[2025-09-21T18:49:33] apply_patch(auto_approved=true) exited 0 in 35ms:
Success. Updated the following files:
M Cargo.lock
[2025-09-21T18:49:33] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..d3de78e53c1b8da65dac20ebbeb998bbb1d68389
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -2,6 +2,8 @@
 # It is not intended for manual editing.
 version = 4
 
+# TODO(058-472d32a): chrono 0.4 dependency not locked due to offline environment.
+
 [[package]]
 name = "aho-corasick"
 version = "1.1.3"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..271b6b9bb10280e5f18930aadf1151f9aa4b4b31
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);

[2025-09-21T18:49:33] tokens used: 66,985
[2025-09-21T18:49:33] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..d3de78e53c1b8da65dac20ebbeb998bbb1d68389
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -2,6 +2,8 @@
 # It is not intended for manual editing.
 version = 4
 
+# TODO(058-472d32a): chrono 0.4 dependency not locked due to offline environment.
+
 [[package]]
 name = "aho-corasick"
 version = "1.1.3"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..271b6b9bb10280e5f18930aadf1151f9aa4b4b31
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:49:40] thinking

**Planning dependency additions**
[2025-09-21T18:49:40] exec bash -lc "rg \"name = \\\"git-graph\\\"\" -n Cargo.lock" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:49:40] bash -lc "rg \"name = \\\"git-graph\\\"\" -n Cargo.lock" succeeded in 12ms:
189:name = "git-graph"
[2025-09-21T18:49:40] tokens used: 67,435
[2025-09-21T18:49:40] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..d3de78e53c1b8da65dac20ebbeb998bbb1d68389
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -2,6 +2,8 @@
 # It is not intended for manual editing.
 version = 4
 
+# TODO(058-472d32a): chrono 0.4 dependency not locked due to offline environment.
+
 [[package]]
 name = "aho-corasick"
 version = "1.1.3"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..271b6b9bb10280e5f18930aadf1151f9aa4b4b31
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:49:44] thinking

**Checking nearby code section**
[2025-09-21T18:49:44] exec bash -lc "sed -n '189,230p' Cargo.lock" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:49:44] bash -lc "sed -n '189,230p' Cargo.lock" succeeded in 12ms:
name = "git-graph"
version = "0.1.3"
dependencies = [
 "atty",
 "clap",
 "crossterm",
 "git2",
 "itertools",
 "lazy_static",
 "platform-dirs",
 "regex",
 "serde",
 "serde_derive",
 "svg",
 "toml",
 "yansi",
]

[[package]]
name = "git2"
[2025-09-21T18:49:44] tokens used: 67,625
[2025-09-21T18:49:44] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..d3de78e53c1b8da65dac20ebbeb998bbb1d68389
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -2,6 +2,8 @@
 # It is not intended for manual editing.
 version = 4
 
+# TODO(058-472d32a): chrono 0.4 dependency not locked due to offline environment.
+
 [[package]]
 name = "aho-corasick"
 version = "1.1.3"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..271b6b9bb10280e5f18930aadf1151f9aa4b4b31
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:49:49] thinking

**Adding chrono to dependencies**
[2025-09-21T18:49:49] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/Cargo.lock
@@ -194,2 +194,3 @@
  "crossterm",
+ "chrono",
  "git2",
[2025-09-21T18:49:49] apply_patch(auto_approved=true) exited 0 in 51ms:
Success. Updated the following files:
M Cargo.lock
[2025-09-21T18:49:49] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..961f939ea105b69a94d103429ff0f643cfd64d37
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -2,6 +2,8 @@
 # It is not intended for manual editing.
 version = 4
 
+# TODO(058-472d32a): chrono 0.4 dependency not locked due to offline environment.
+
 [[package]]
 name = "aho-corasick"
 version = "1.1.3"
@@ -190,6 +192,7 @@
  "atty",
  "clap",
  "crossterm",
+ "chrono",
  "git2",
  "itertools",
  "lazy_static",
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..271b6b9bb10280e5f18930aadf1151f9aa4b4b31
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);

[2025-09-21T18:49:49] tokens used: 68,141
[2025-09-21T18:49:49] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..961f939ea105b69a94d103429ff0f643cfd64d37
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -2,6 +2,8 @@
 # It is not intended for manual editing.
 version = 4
 
+# TODO(058-472d32a): chrono 0.4 dependency not locked due to offline environment.
+
 [[package]]
 name = "aho-corasick"
 version = "1.1.3"
@@ -190,6 +192,7 @@
  "atty",
  "clap",
  "crossterm",
+ "chrono",
  "git2",
  "itertools",
  "lazy_static",
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..271b6b9bb10280e5f18930aadf1151f9aa4b4b31
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:50:00] thinking

**Preparing to verify package build**
[2025-09-21T18:50:00] exec bash -lc 'cargo check' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:50:10] bash -lc 'cargo check' exited 124 in 10.01s:
    Updating crates.io index
     Locking 21 packages to latest compatible versions
      Adding android_system_properties v0.1.5
      Adding bumpalo v3.19.0
      Adding chrono v0.4.42
      Adding core-foundation-sys v0.8.7
      Adding iana-time-zone v0.1.64
      Adding iana-time-zone-haiku v0.1.2
      Adding js-sys v0.3.80
      Adding num-traits v0.2.19
      Adding once_cell v1.21.3
      Adding rustversion v1.0.22
      Adding wasm-bindgen v0.2.103
      Adding wasm-bindgen-backend v0.2.103
      Adding wasm-bindgen-macro v0.2.103
      Adding wasm-bindgen-macro-support v0.2.103
      Adding wasm-bindgen-shared v0.2.103
      Adding windows-core v0.62.0
      Adding windows-implement v0.60.0
      Adding windows-interface v0.59.1
[2025-09-21T18:50:10] tokens used: 68,441
[2025-09-21T18:50:10] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..271b6b9bb10280e5f18930aadf1151f9aa4b4b31
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:50:16] thinking

**Adjusting cargo check timeout**
[2025-09-21T18:50:16] exec bash -lc 'cargo check' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:50:21] bash -lc 'cargo check' exited 101 in 4.68s:
   Compiling syn v2.0.106
   Compiling libz-sys v1.1.22
   Compiling openssl-sys v0.9.109
   Compiling libssh2-sys v0.2.20
   Compiling synstructure v0.13.2
   Compiling libgit2-sys v0.12.14+1.1.0
   Compiling zerovec-derive v0.11.1
   Compiling displaydoc v0.2.5
   Compiling serde_derive v1.0.225
   Compiling zerofrom-derive v0.1.6
   Compiling yoke-derive v0.8.0
    Checking zerofrom v0.1.6
    Checking yoke v0.8.0
    Checking serde v1.0.225
    Checking zerovec v0.11.4
    Checking zerotrie v0.2.2
    Checking toml v0.5.11
    Checking tinystr v0.8.1
    Checking potential_utf v0.1.3
    Checking icu_collections v2.0.0
[2025-09-21T18:50:21] tokens used: 69,774
[2025-09-21T18:50:21] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..271b6b9bb10280e5f18930aadf1151f9aa4b4b31
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:50:28] thinking

**Identifying and fixing compile issues**
[2025-09-21T18:50:29] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/format.rs
@@ -2,3 +2,3 @@
 use crate::graph::{GitGraph, HeadInfo};
-use chrono::{DateTime, FixedOffset, LocalResult};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
 use git2::Signature;
[2025-09-21T18:50:29] apply_patch(auto_approved=true) exited 0 in 45ms:
Success. Updated the following files:
M src/print/format.rs
[2025-09-21T18:50:29] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..6f766b104660b2109beb8ec4a2bae6fd294954b9
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);

[2025-09-21T18:50:29] tokens used: 71,355
[2025-09-21T18:50:29] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..6f766b104660b2109beb8ec4a2bae6fd294954b9
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,242 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations: decorations.trim().to_string(),
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
+
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
+    }
+}
+
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +379,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:50:35] thinking

**Correcting moved variable usage**
[2025-09-21T18:50:36] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/format.rs
@@ -199,2 +199,3 @@
         let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
         let colored_short_hash = hash_color
@@ -227,3 +228,3 @@
             decorations,
-            trimmed_decorations: decorations.trim().to_string(),
+            trimmed_decorations,
             subject: commit.summary().unwrap_or("").to_string(),
[2025-09-21T18:50:36] apply_patch(auto_approved=true) exited 0 in 40ms:
Success. Updated the following files:
M src/print/format.rs
[2025-09-21T18:50:36] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..660df84170a1f5cf9451315bd7449eb4efec77c0
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,243 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
+    }
+
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
+    }
+}
+
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
+
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
+        })
     }
 }
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
-        })
-        .unwrap_or(WHITE);
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
     }
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
+
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
+    }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +380,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);

[2025-09-21T18:50:36] tokens used: 71,839
[2025-09-21T18:50:36] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..660df84170a1f5cf9451315bd7449eb4efec77c0
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,243 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
+    }
+
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
+    }
+}
+
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
+
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
+        })
     }
 }
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
-        })
-        .unwrap_or(WHITE);
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
     }
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
+
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
+    }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +380,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:50:52] thinking

**Analyzing git_time_to_datetime and dependencies**
[2025-09-21T18:50:54] exec bash -lc 'rg "chrono" -n Cargo.lock' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:50:54] bash -lc 'rg "chrono" -n Cargo.lock' succeeded in 8ms:
86:name = "chrono"
225: "chrono",
[2025-09-21T18:50:54] tokens used: 72,415
[2025-09-21T18:50:54] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..660df84170a1f5cf9451315bd7449eb4efec77c0
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,243 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
+    }
+
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
+    }
+}
+
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
+
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
+        })
     }
 }
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
-        })
-        .unwrap_or(WHITE);
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
     }
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
+
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
+    }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +380,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:51:00] thinking

**Reviewing inserted entry at line 86**
[2025-09-21T18:51:00] exec bash -lc "sed -n '80,140p' Cargo.lock" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:51:00] bash -lc "sed -n '80,140p' Cargo.lock" succeeded in 11ms:
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "chrono"
version = "0.4.42"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
dependencies = [
 "iana-time-zone",
 "js-sys",
 "num-traits",
 "wasm-bindgen",
 "windows-link",
]

[[package]]
name = "clap"
[2025-09-21T18:51:00] tokens used: 72,579
[2025-09-21T18:51:00] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..660df84170a1f5cf9451315bd7449eb4efec77c0
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,243 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
+    }
+
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
+    }
+}
+
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
+
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
+        })
     }
 }
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
-        })
-        .unwrap_or(WHITE);
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
     }
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
+
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
+    }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +380,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:51:08] thinking

**Deciding on removing TODO comment**
[2025-09-21T18:51:09] tokens used: 73,482
[2025-09-21T18:51:09] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..660df84170a1f5cf9451315bd7449eb4efec77c0
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,243 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
+    }
+
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
+    }
+}
+
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
+
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
+        })
     }
 }
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
-        })
-        .unwrap_or(WHITE);
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
     }
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
+
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
+    }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +380,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:51:15] thinking

**Checking Cargo.lock header**
[2025-09-21T18:51:16] exec bash -lc 'head -n 5 Cargo.lock' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:51:16] bash -lc 'head -n 5 Cargo.lock' succeeded in 17ms:
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
[2025-09-21T18:51:16] tokens used: 73,784
[2025-09-21T18:51:16] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..660df84170a1f5cf9451315bd7449eb4efec77c0
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,243 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
+    }
+
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
+    }
+}
+
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
+
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
+        })
     }
 }
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
-        })
-        .unwrap_or(WHITE);
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
     }
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
+
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
+    }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +380,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:51:21] thinking

**Verifying dependency duplication**
[2025-09-21T18:51:22] exec bash -lc "sed -n '225,240p' Cargo.lock" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:51:22] bash -lc "sed -n '225,240p' Cargo.lock" succeeded in 20ms:
 "chrono",
 "clap",
 "crossterm",
 "git2",
 "itertools",
 "lazy_static",
 "platform-dirs",
 "regex",
 "serde",
 "serde_derive",
 "svg",
 "toml",
 "yansi",
]

[[package]]
[2025-09-21T18:51:22] tokens used: 74,036
[2025-09-21T18:51:22] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..660df84170a1f5cf9451315bd7449eb4efec77c0
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,243 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
+    }
+
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
+    }
+}
+
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
+
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
+        })
     }
 }
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
-        })
-        .unwrap_or(WHITE);
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
     }
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
+
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
+    }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +380,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:51:39] thinking

**Deciding on chrono version alignment**

I'm weighing whether to keep the latest `chrono` 0.4.42 or revert to the older 0.4.19 to better match the original 2020 commit’s dependencies and avoid extra packages like wasm and iana-time-zone. To align more closely, I’m planning to specify `chrono = "0.4.19"` in `Cargo.toml` and then update the lock file accordingly, balancing fidelity to the original commit with practicality.
[2025-09-21T18:51:39] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/Cargo.toml
@@ -25,3 +25,3 @@
 crossterm = "0.25"
-chrono = "0.4"
+chrono = "0.4.19"
 
[2025-09-21T18:51:39] apply_patch(auto_approved=true) exited 0 in 44ms:
Success. Updated the following files:
M Cargo.toml
[2025-09-21T18:51:39] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..367deff5f4b8cc7ec68dca764ff67ee04836b394
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..660df84170a1f5cf9451315bd7449eb4efec77c0
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,243 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
+    }
+
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
+    }
+}
+
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
+
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
+        })
     }
 }
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
-        })
-        .unwrap_or(WHITE);
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
     }
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
+
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
+    }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +380,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);

[2025-09-21T18:51:40] tokens used: 75,135
[2025-09-21T18:51:40] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..367deff5f4b8cc7ec68dca764ff67ee04836b394
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..660df84170a1f5cf9451315bd7449eb4efec77c0
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,243 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
+    }
+
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
+    }
+}
+
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
+
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
+        })
     }
 }
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
-        })
-        .unwrap_or(WHITE);
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
     }
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
+
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
+    }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +380,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:51:45] thinking

**Updating Cargo.lock for chrono**
[2025-09-21T18:51:46] exec bash -lc 'cargo update -p chrono --precise 0.4.19' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:51:57] bash -lc 'cargo update -p chrono --precise 0.4.19' exited -1 in 0ms:
    Updating crates.io index
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
error: failed to get `atty` as a dependency of package `git-graph v0.1.3 (/Users/jqwang/104-CommitLens-codex/.workspace/rust-project)`

Caused by:
  download of config.json failed

Caused by:
  failed to download from `https://index.crates.io/config.json`

Caused by:
  [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
[2025-09-21T18:51:57] tokens used: 75,461
[2025-09-21T18:51:57] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..367deff5f4b8cc7ec68dca764ff67ee04836b394
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4.19"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..660df84170a1f5cf9451315bd7449eb4efec77c0
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,243 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
+    }
+
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
+    }
+}
+
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
+
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
+        })
     }
 }
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
-        })
-        .unwrap_or(WHITE);
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
     }
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
+
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
+    }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +380,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:52:06] thinking

**Reverting Cargo.toml version due to fetch failure**

I see the network issue prevented fetching the older crate version 0.4.19, while 0.4.42 stayed cached. Since the lockfile can't update to 0.4.19 offline, I’ll revert Cargo.toml back to the more general 0.4 version to avoid mismatches and keep things consistent.
[2025-09-21T18:52:07] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/Cargo.toml
@@ -25,3 +25,3 @@
 crossterm = "0.25"
-chrono = "0.4.19"
+chrono = "0.4"
 
[2025-09-21T18:52:07] apply_patch(auto_approved=true) exited 0 in 50ms:
Success. Updated the following files:
M Cargo.toml
[2025-09-21T18:52:07] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..660df84170a1f5cf9451315bd7449eb4efec77c0
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,243 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
+    }
+
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
+    }
+}
+
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
+
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
+        })
     }
 }
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
-        })
-        .unwrap_or(WHITE);
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
     }
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
+
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
+    }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +380,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);

[2025-09-21T18:52:07] tokens used: 76,085
[2025-09-21T18:52:07] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..660df84170a1f5cf9451315bd7449eb4efec77c0
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,243 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
+    }
+
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
+    }
+}
+
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
+
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
+        })
     }
 }
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
-        })
-        .unwrap_or(WHITE);
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
     }
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
+
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
+    }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +380,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:52:16] thinking

**Verifying dependency versions and compilation**
[2025-09-21T18:52:17] exec bash -lc 'cargo check' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:52:17] bash -lc 'cargo check' exited 101 in 212ms:
    Checking git-graph v0.1.3 (/Users/jqwang/104-CommitLens-codex/.workspace/rust-project)
error[E0308]: mismatched types
  --> src/graph.rs:97:17
   |
97 |                 repository,
   |                 ^^^^^^^^^^ expected `Repository`, found `&Repository`
   |
note: `git2::Repository` does not implement `Clone`, so `&git2::Repository` was cloned instead
  --> src/graph.rs:33:26
   |
33 |         let repository = repo.clone();
   |                          ^^^^

error[E0308]: mismatched types
   --> src/graph.rs:140:17
    |
140 |                 repository,
    |                 ^^^^^^^^^^ expected `Repository`, found `&Repository`
    |
note: `git2::Repository` does not implement `Clone`, so `&git2::Repository` was cloned instead
[2025-09-21T18:52:17] tokens used: 76,420
[2025-09-21T18:52:17] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..660df84170a1f5cf9451315bd7449eb4efec77c0
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,243 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
+    }
+
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
+    }
+}
+
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
+
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
+        })
     }
 }
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
-        })
-        .unwrap_or(WHITE);
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
     }
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
+
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
+    }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +380,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:52:36] thinking

**Reviewing format and message handling code**

I'm examining the formatting code to verify it properly handles the `%a` placeholder error, flushes literals at the right time, and formats commit messages and headers correctly with indentation and trimmed decorations. I'm also checking if the unused `format_commit` function can be safely removed without affecting other code.
[2025-09-21T18:52:36] exec bash -lc 'rg "format_commit" -n src' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:52:36] bash -lc 'rg "format_commit" -n src' succeeded in 15ms:
src/print/format.rs:238:pub(crate) fn format_commit(
[2025-09-21T18:52:36] tokens used: 77,669
[2025-09-21T18:52:36] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..660df84170a1f5cf9451315bd7449eb4efec77c0
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
+}
+
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
 }
 
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
-        }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,243 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
+    }
+
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
+    }
+}
+
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
+
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
+        })
     }
 }
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+pub(crate) fn format_commit(
+    format: &CommitFormat,
+    context: &FormatContext,
+) -> Vec<String> {
+    match format {
+        CommitFormat::Oneline => format_oneline(context),
+        CommitFormat::Short => format_short(context),
+        CommitFormat::Medium => format_medium(context),
+        CommitFormat::Full => format_full(context),
+        CommitFormat::Custom(template) => template.format(context),
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
-        })
-        .unwrap_or(WHITE);
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
     }
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
+
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
+    }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
+
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +380,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:52:42] thinking

**Deciding on removing unused function**
[2025-09-21T18:52:43] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/format.rs
@@ -237,15 +237,2 @@
 
-pub(crate) fn format_commit(
-    format: &CommitFormat,
-    context: &FormatContext,
-) -> Vec<String> {
-    match format {
-        CommitFormat::Oneline => format_oneline(context),
-        CommitFormat::Short => format_short(context),
-        CommitFormat::Medium => format_medium(context),
-        CommitFormat::Full => format_full(context),
-        CommitFormat::Custom(template) => template.format(context),
-    }
-}
-
 pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
[2025-09-21T18:52:43] apply_patch(auto_approved=true) exited 0 in 58ms:
Success. Updated the following files:
M src/print/format.rs
[2025-09-21T18:52:43] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..b1bf362f8437f08c7cffb2aee46ea2a3df5cf790
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
 }
 
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
+}
+
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
-        }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,230 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +367,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);

[2025-09-21T18:52:43] tokens used: 78,098
[2025-09-21T18:52:43] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..b1bf362f8437f08c7cffb2aee46ea2a3df5cf790
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
 }
 
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
+}
+
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
-        }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,230 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +367,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:52:54] thinking

**Verifying imports and cleanup**
[2025-09-21T18:52:55] exec bash -lc 'git status --short' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:52:55] bash -lc 'git status --short' succeeded in 19ms:
 M Cargo.lock
 M Cargo.toml
 M src/main.rs
 M src/print/format.rs
 M src/print/unicode.rs
[2025-09-21T18:52:55] tokens used: 78,596
[2025-09-21T18:52:55] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..b1bf362f8437f08c7cffb2aee46ea2a3df5cf790
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
 }
 
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
+}
+
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
-        }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,230 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +367,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:53:00] thinking

**Reviewing format.rs for accuracy**
[2025-09-21T18:53:01] exec bash -lc "sed -n '1,240p' src/print/format.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:53:01] bash -lc "sed -n '1,240p' src/print/format.rs" succeeded in 20ms:
use super::unicode::format_branches;
use crate::graph::{GitGraph, HeadInfo};
use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
use git2::Signature;
use yansi::Paint;

#[derive(Clone)]
pub enum CommitFormat {
    Oneline,
    Short,
    Medium,
    Full,
    Custom(FormatString),
}

#[derive(Clone)]
pub(crate) struct FormatString {
    items: Vec<FormatItem>,
}

[2025-09-21T18:53:01] tokens used: 78,836
[2025-09-21T18:53:01] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..b1bf362f8437f08c7cffb2aee46ea2a3df5cf790
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
 }
 
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
+}
+
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
-        }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,230 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +367,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:53:10] thinking

**Ensuring proper line handling and dependencies**
[2025-09-21T18:53:11] exec bash -lc "sed -n '200,360p' src/print/unicode.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:53:11] bash -lc "sed -n '200,360p' src/print/unicode.rs" succeeded in 22ms:
            if let Some(text) = formatted_commits[commit_idx].get(consumed_text[commit_idx]) {
                if !text.is_empty() {
                    graph_segment.push_str("  ");
                    graph_segment.push_str(text);
                }
                consumed_text[commit_idx] += 1;
            }
            output.push(graph_segment);

            while consumed_text[commit_idx] < formatted_commits[commit_idx].len() {
                let mut extra_line = blank_graph_line.clone();
                let text = &formatted_commits[commit_idx][consumed_text[commit_idx]];
                if !text.is_empty() {
                    extra_line.push_str("  ");
                    extra_line.push_str(text);
                }
                consumed_text[commit_idx] += 1;
                output.push(extra_line);
            }
        } else {
[2025-09-21T18:53:11] tokens used: 81,152
[2025-09-21T18:53:11] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..b1bf362f8437f08c7cffb2aee46ea2a3df5cf790
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
 }
 
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
+}
+
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
-        }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,230 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +367,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:53:17] thinking

**Verifying code changes and cleaning up**
[2025-09-21T18:53:18] exec bash -lc 'git status --short' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:53:18] bash -lc 'git status --short' succeeded in 16ms:
 M Cargo.lock
 M Cargo.toml
 M src/main.rs
 M src/print/format.rs
 M src/print/unicode.rs
[2025-09-21T18:53:18] tokens used: 82,896
[2025-09-21T18:53:18] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..b1bf362f8437f08c7cffb2aee46ea2a3df5cf790
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
 }
 
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
+}
+
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
-        }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,230 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +367,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:53:26] thinking

**Preparing for commit and final verification**
[2025-09-21T18:53:26] exec bash -lc 'git diff' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:53:26] bash -lc 'git diff' succeeded in 18ms:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932..c123e14 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -11,6 +11,15 @@ dependencies = [
  "memchr",
 ]
 
+[[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
 [[package]]
 name = "ansi_term"
 version = "0.12.1"
[2025-09-21T18:53:26] tokens used: 83,211
[2025-09-21T18:53:26] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..b1bf362f8437f08c7cffb2aee46ea2a3df5cf790
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
 }
 
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
+}
+
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
-        }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,230 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +367,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:53:33] thinking

**Staging and preparing commit**
[2025-09-21T18:53:33] exec bash -lc 'git add -A' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:53:33] bash -lc 'git add -A' succeeded in 25ms:

[2025-09-21T18:53:33] tokens used: 85,992
[2025-09-21T18:53:33] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..b1bf362f8437f08c7cffb2aee46ea2a3df5cf790
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
 }
 
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
+}
+
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
-        }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,230 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +367,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:53:39] thinking

**Committing changes**
[2025-09-21T18:53:39] exec bash -lc 'git commit -m "058-472d32a：复现提交代码内容。"' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:53:39] bash -lc 'git commit -m "058-472d32a：复现提交代码内容。"' succeeded in 29ms:
[main 68cbf93] 058-472d32a：复现提交代码内容。
 5 files changed, 573 insertions(+), 155 deletions(-)
[2025-09-21T18:53:39] tokens used: 86,220
[2025-09-21T18:53:39] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..b1bf362f8437f08c7cffb2aee46ea2a3df5cf790
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
 }
 
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
+}
+
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
-        }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,230 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +367,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:53:47] thinking

**Noting compile errors and preparing final summary**
[2025-09-21T18:53:47] exec bash -lc 'git status --short' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:53:47] bash -lc 'git status --short' succeeded in 18ms:

[2025-09-21T18:53:47] tokens used: 86,524
[2025-09-21T18:53:47] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..b1bf362f8437f08c7cffb2aee46ea2a3df5cf790
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
 }
 
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
+}
+
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
-        }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,230 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +367,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:53:53] thinking

**Preparing final response details**
[2025-09-21T18:53:53] exec bash -lc 'nl -ba Cargo.toml' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:53:53] bash -lc 'nl -ba Cargo.toml' succeeded in 20ms:
     1	[package]
     2	name = "git-graph"
     3	version = "0.1.3"
     4	authors = ["Martin Lange <martin_lange_@gmx.net>"]
     5	edition = "2018"
     6	description = "Structured Git graphs for your branching model."
     7	repository = "https://github.com/mlange-42/git-graph"
     8	keywords = ["git", "graph", "cli"]
     9	license = "MIT"
    10	readme = "README.md"
    11	
    12	[dependencies]
    13	git2 = "0.13"
    14	regex = "1.4"
    15	serde = "1.0"
    16	serde_derive = "1.0"
    17	toml = "0.5"
    18	itertools = "0.9"
    19	svg = "0.8"
    20	clap = "2.33"
[2025-09-21T18:53:53] tokens used: 86,724
[2025-09-21T18:53:53] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..b1bf362f8437f08c7cffb2aee46ea2a3df5cf790
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
 }
 
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
+}
+
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
-        }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,230 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +367,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:54:10] thinking

**Preparing code references**
[2025-09-21T18:54:11] exec bash -lc "nl -ba src/print/format.rs | sed -n '1,200p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:54:11] bash -lc "nl -ba src/print/format.rs | sed -n '1,200p'" succeeded in 19ms:
     1	use super::unicode::format_branches;
     2	use crate::graph::{GitGraph, HeadInfo};
     3	use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
     4	use git2::Signature;
     5	use yansi::Paint;
     6	
     7	#[derive(Clone)]
     8	pub enum CommitFormat {
     9	    Oneline,
    10	    Short,
    11	    Medium,
    12	    Full,
    13	    Custom(FormatString),
    14	}
    15	
    16	#[derive(Clone)]
    17	pub(crate) struct FormatString {
    18	    items: Vec<FormatItem>,
    19	}
    20	
[2025-09-21T18:54:11] tokens used: 87,294
[2025-09-21T18:54:11] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..b1bf362f8437f08c7cffb2aee46ea2a3df5cf790
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
 }
 
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
+}
+
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
-        }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,230 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +367,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:54:18] thinking

**Preparing to reference new functions**
[2025-09-21T18:54:18] exec bash -lc "nl -ba src/print/format.rs | sed -n '200,360p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:54:18] bash -lc "nl -ba src/print/format.rs | sed -n '200,360p'" succeeded in 17ms:
   200	        let trimmed_decorations = decorations.trim().to_string();
   201	        let colored_short_hash = hash_color
   202	            .map(|color_value| colored(&short_hash, color_value, color_enabled))
   203	            .unwrap_or_else(|| short_hash.clone());
   204	        let colored_full_hash = hash_color
   205	            .map(|color_value| colored(&full_hash, color_value, color_enabled))
   206	            .unwrap_or_else(|| full_hash.clone());
   207	
   208	        let message = commit.message().unwrap_or("");
   209	        let mut message_lines: Vec<&str> = message.split('\n').collect();
   210	        if message.ends_with('\n') {
   211	            message_lines.pop();
   212	        }
   213	
   214	        let body_lines = if message_lines.len() > 1 {
   215	            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
   216	        } else {
   217	            Vec::new()
   218	        };
   219	
[2025-09-21T18:54:18] tokens used: 89,853
[2025-09-21T18:54:18] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..b1bf362f8437f08c7cffb2aee46ea2a3df5cf790
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
 }
 
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
+}
+
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
-        }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,230 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +367,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:54:24] thinking

**Reviewing git date formatting in main.rs**
[2025-09-21T18:54:24] exec bash -lc "nl -ba src/main.rs | sed -n '100,140p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:54:24] bash -lc "nl -ba src/main.rs | sed -n '100,140p'" succeeded in 14ms:
   100	                .required(false)
   101	                .takes_value(true),
   102	        )
   103	        .arg(
   104	            Arg::with_name("format")
   105	                .long("format")
   106	                .help(
   107	                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
   108	                )
   109	                .required(false)
   110	                .takes_value(true),
   111	        )
   112	        .arg(
   113	            Arg::with_name("local")
   114	                .long("local")
   115	                .short("l")
   116	                .help("Show only local branches, no remotes.")
   117	                .required(false)
   118	                .takes_value(false),
   119	        )
[2025-09-21T18:54:24] tokens used: 92,238
[2025-09-21T18:54:24] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..b1bf362f8437f08c7cffb2aee46ea2a3df5cf790
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
 }
 
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
+}
+
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
-        }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,230 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +367,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:54:31] thinking

**Referring to code locations with line numbers**
[2025-09-21T18:54:32] exec bash -lc "nl -ba src/print/unicode.rs | sed -n '160,260p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:54:32] bash -lc "nl -ba src/print/unicode.rs | sed -n '160,260p'" succeeded in 21ms:
   160	    let head_commit_index = graph.indices.get(&graph.head.oid).copied();
   161	    let color_enabled = enable_color_output(settings.colored);
   162	    let hash_color = if color_enabled {
   163	        Some(HASH_COLOR)
   164	    } else {
   165	        None
   166	    };
   167	    let graph_lines = render_graph(&grid, &settings.characters, color_enabled);
   168	    let blank_graph_line: String = (0..grid.width)
   169	        .map(|_| settings.characters.chars[SPACE as usize])
   170	        .collect();
   171	
   172	    let mut formatted_commits = Vec::with_capacity(graph.commits.len());
   173	    for idx in 0..graph.commits.len() {
   174	        let head_ref = if Some(idx) == head_commit_index {
   175	            Some(&graph.head)
   176	        } else {
   177	            None
   178	        };
   179	        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
[2025-09-21T18:54:32] tokens used: 92,970
[2025-09-21T18:54:32] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..b1bf362f8437f08c7cffb2aee46ea2a3df5cf790
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
 }
 
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
+}
+
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
-        }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,230 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +367,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:54:41] thinking

**Preparing to reference Cargo.lock changes**
[2025-09-21T18:54:42] exec bash -lc "nl -ba Cargo.lock | sed -n '80,120p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T18:54:42] bash -lc "nl -ba Cargo.lock | sed -n '80,120p'" succeeded in 23ms:
    80	name = "cfg-if"
    81	version = "1.0.0"
    82	source = "registry+https://github.com/rust-lang/crates.io-index"
    83	checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
    84	
    85	[[package]]
    86	name = "chrono"
    87	version = "0.4.42"
    88	source = "registry+https://github.com/rust-lang/crates.io-index"
    89	checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
    90	dependencies = [
    91	 "iana-time-zone",
    92	 "js-sys",
    93	 "num-traits",
    94	 "wasm-bindgen",
    95	 "windows-link",
    96	]
    97	
    98	[[package]]
    99	name = "clap"
[2025-09-21T18:54:42] tokens used: 94,600
[2025-09-21T18:54:42] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..b1bf362f8437f08c7cffb2aee46ea2a3df5cf790
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
 }
 
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
+}
+
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
-        }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,230 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +367,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


[2025-09-21T18:54:59] thinking

**Summarizing changes and next steps**

I’m gathering all the modified files with line references to include in a final summary that highlights additions like the `chrono` crate in `Cargo.toml` and `Cargo.lock`, updates in `src/main.rs` and `src/print` modules, plus new enums and formatting features. I’ll note that `cargo check` fails due to preexisting errors in `graph.rs` and include assumptions about dependency versions. This will help produce a clear message with structured bullet points covering modifications, assumptions, verification, and recommended next steps.
[2025-09-21T18:55:01] codex

**复现内容**
- 在 `Cargo.toml:26` 增加 `chrono = "0.4"`，并在 `Cargo.lock:86` 起引入 `chrono 0.4.42` 及其传递依赖（`iana-time-zone`、`num-traits` 等），`Cargo.lock:225` 也将 `git-graph` 的依赖列表补上 `chrono`。
- `src/print/format.rs:7-360` 将提交格式改为枚举 `CommitFormat`，新增 `FormatContext` 聚合提交元数据，扩展模板占位符支持 `%an/%ae`，同时实现 `format_oneline/short/medium/full` 默认渲染，并用 `chrono` 在 `format_git_date` 中输出本地化时间。
- `src/print/unicode.rs:179-186` 改为按 `CommitFormat` 分派调用上述默认实现，`src/print/unicode.rs:227-272` 抽出 `format_branches` 负责 HEAD/分支/标签文本组装。
- `src/main.rs:107` 更新 `--format` 说明，列出新的预设和 `%an/%ae` 占位符。
- 已按要求提交：`058-472d32a：复现提交代码内容。`

**假设与限制**
- 受可用缓存限制，`chrono` 解析为 0.4 系列最新版本（0.4.42），与原提交当时的精确 patch 版本可能不同，但保持 `0.4` 约束。

**验证**
- `cargo check`（超时时间 120s）因既有 `src/graph.rs` 中的 `Repository` 所有权问题和 `Oid` 解引用报错而失败；这些错误在本次复现前已存在，需要后续独立修复。
[2025-09-21T18:55:05] tokens used: 96,365
[2025-09-21T18:55:05] turn diff:
diff --git a/Cargo.lock b/Cargo.lock
index 214e932291f52cd7c84100a66ecd247e44a9ae46..c123e145066696da7b7716de5c1cf35e1ddec797
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12,6 +12,15 @@
 ]
 
 [[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "ansi_term"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -50,6 +59,12 @@
 checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"
 
 [[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
 name = "cc"
 version = "1.2.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -68,6 +83,19 @@
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
+name = "chrono"
+version = "0.4.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
 name = "clap"
 version = "2.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -83,6 +111,12 @@
 ]
 
 [[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
 name = "crossterm"
 version = "0.25.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -188,6 +222,7 @@
 version = "0.1.3"
 dependencies = [
  "atty",
+ "chrono",
  "clap",
  "crossterm",
  "git2",
@@ -227,6 +262,30 @@
 ]
 
 [[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "icu_collections"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -353,6 +412,16 @@
 ]
 
 [[package]]
+name = "js-sys"
+version = "0.3.80"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
 name = "lazy_static"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -455,6 +524,21 @@
 ]
 
 [[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
 name = "openssl-probe"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -599,6 +683,12 @@
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
 [[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
 name = "scopeguard"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -831,6 +921,65 @@
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -853,6 +1002,65 @@
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
+name = "windows-core"
+version = "0.62.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57fe7168f7de578d2d8a05b07fd61870d2e73b4020e9f49aa00da8471723497c"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"
+
+[[package]]
+name = "windows-result"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7084dcc306f89883455a206237404d3eaf961e5bd7e0f312f7c91f57eb44167f"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7218c655a553b0bed4426cf54b20d7ba363ef543b52d515b3e48d7fd55318dda"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
index 04f67610429142f26bfd227e4732e4e529589143..49167c9bb9a30ebca81147ecb9751e9f299aa970
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,6 +23,7 @@
 platform-dirs = "0.3"
 yansi = "0.5"
 crossterm = "0.25"
+chrono = "0.4"
 
 [profile.release]
 opt-level = 3
diff --git a/src/main.rs b/src/main.rs
index a971b20a1d32a872459f2f6be1a982be674bc7f8..f0426d20dd8836d1bd2bb19069ab178a04a8570d
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,9 @@
         .arg(
             Arg::with_name("format")
                 .long("format")
-                .help("Commit text format or preset (e.g. oneline, %h %d %s). Supports %h, %H, %d, %s, %n.")
+                .help(
+                    "Commit text format or preset (oneline|short|medium|full|<string>). Supports %h, %H, %d, %s, %n, %an, %ae."
+                )
                 .required(false)
                 .takes_value(true),
         )
diff --git a/src/print/format.rs b/src/print/format.rs
index dd909dadd5433554f52d27930a0d8be5f78ec9eb..b1bf362f8437f08c7cffb2aee46ea2a3df5cf790
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -1,11 +1,20 @@
-use super::unicode::HEAD_COLOR;
-use crate::graph::{CommitInfo, GitGraph, HeadInfo};
+use super::unicode::format_branches;
+use crate::graph::{GitGraph, HeadInfo};
+use chrono::{DateTime, FixedOffset, LocalResult, TimeZone};
+use git2::Signature;
 use yansi::Paint;
 
-const WHITE: u8 = 7;
+#[derive(Clone)]
+pub enum CommitFormat {
+    Oneline,
+    Short,
+    Medium,
+    Full,
+    Custom(FormatString),
+}
 
 #[derive(Clone)]
-pub struct CommitFormat {
+pub(crate) struct FormatString {
     items: Vec<FormatItem>,
 }
 
@@ -22,92 +31,50 @@
     Decorations,
     Subject,
     Newline,
+    AuthorName,
+    AuthorEmail,
 }
 
+#[derive(Clone)]
+struct PersonInfo {
+    name: String,
+    email: String,
+    date: Option<DateTime<FixedOffset>>,
+}
+
+pub(crate) struct FormatContext {
+    short_hash: String,
+    full_hash: String,
+    colored_short_hash: String,
+    colored_full_hash: String,
+    decorations: String,
+    trimmed_decorations: String,
+    subject: String,
+    body_lines: Vec<String>,
+    author: PersonInfo,
+    committer: PersonInfo,
+}
+
 impl Default for CommitFormat {
     fn default() -> Self {
-        CommitFormat::parse("oneline").expect("default format is valid")
+        CommitFormat::Oneline
     }
 }
 
 impl CommitFormat {
     pub fn parse(spec: &str) -> Result<Self, String> {
-        let template = if spec.eq_ignore_ascii_case("oneline") {
-            "%h %d%s"
-        } else {
-            spec
-        };
-        Self::parse_template(template)
-    }
-
-    pub fn format_commit(
-        &self,
-        graph: &GitGraph,
-        commit_index: usize,
-        head: Option<&HeadInfo>,
-        color_enabled: bool,
-        hash_color: Option<u8>,
-    ) -> Result<Vec<String>, String> {
-        let info = graph
-            .commits
-            .get(commit_index)
-            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
-        let commit = graph
-            .repository
-            .find_commit(info.oid)
-            .map_err(|err| err.message().to_string())?;
-
-        let full_hash = commit.id().to_string();
-        let short_hash = full_hash.chars().take(7).collect::<String>();
-        let summary = commit.summary().unwrap_or("").to_string();
-        let decorations = render_decorations(graph, info, head, color_enabled);
-
-        let colored_short_hash =
-            hash_color.map(|color_value| colored(&short_hash, color_value, color_enabled));
-        let colored_full_hash =
-            hash_color.map(|color_value| colored(&full_hash, color_value, color_enabled));
-
-        let mut lines = vec![String::new()];
-        let mut line_index = 0;
-
-        for item in &self.items {
-            match item {
-                FormatItem::Literal(text) => lines[line_index].push_str(text),
-                FormatItem::Placeholder(Placeholder::Newline) => {
-                    lines.push(String::new());
-                    line_index += 1;
-                }
-                FormatItem::Placeholder(Placeholder::ShortHash) => {
-                    if let Some(colored_hash) = colored_short_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&short_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::FullHash) => {
-                    if let Some(colored_hash) = colored_full_hash.as_ref() {
-                        lines[line_index].push_str(colored_hash);
-                    } else {
-                        lines[line_index].push_str(&full_hash);
-                    }
-                }
-                FormatItem::Placeholder(Placeholder::Decorations) => {
-                    lines[line_index].push_str(&decorations);
-                }
-                FormatItem::Placeholder(Placeholder::Subject) => {
-                    lines[line_index].push_str(&summary);
-                }
-            }
+        match spec.to_ascii_lowercase().as_str() {
+            "oneline" => Ok(CommitFormat::Oneline),
+            "short" => Ok(CommitFormat::Short),
+            "medium" => Ok(CommitFormat::Medium),
+            "full" | "long" => Ok(CommitFormat::Full),
+            _ => Ok(CommitFormat::Custom(FormatString::parse(spec)?)),
         }
-
-        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
-            lines.pop();
-        }
-
-        Ok(lines)
     }
+}
 
-    fn parse_template(template: &str) -> Result<Self, String> {
+impl FormatString {
+    fn parse(template: &str) -> Result<Self, String> {
         let mut items = Vec::new();
         let mut literal = String::new();
         let mut chars = template.chars();
@@ -139,6 +106,23 @@
                         flush_literal(&mut literal, &mut items);
                         items.push(FormatItem::Placeholder(Placeholder::Newline));
                     }
+                    'a' => {
+                        let spec = chars
+                            .next()
+                            .ok_or_else(|| "Incomplete %a placeholder".to_string())?;
+                        flush_literal(&mut literal, &mut items);
+                        match spec {
+                            'n' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorName));
+                            }
+                            'e' => {
+                                items.push(FormatItem::Placeholder(Placeholder::AuthorEmail));
+                            }
+                            other => {
+                                return Err(format!("Unsupported placeholder '%a{}'", other));
+                            }
+                        }
+                    }
                     other => {
                         return Err(format!("Unsupported placeholder '%{}'", other));
                     }
@@ -150,96 +134,230 @@
 
         flush_literal(&mut literal, &mut items);
 
-        Ok(CommitFormat { items })
+        Ok(FormatString { items })
     }
-}
 
-fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
-    if !literal.is_empty() {
-        items.push(FormatItem::Literal(literal.clone()));
-        literal.clear();
+    pub(crate) fn format(&self, context: &FormatContext) -> Vec<String> {
+        let mut lines = vec![String::new()];
+        let mut line_index = 0;
+
+        for item in &self.items {
+            match item {
+                FormatItem::Literal(text) => lines[line_index].push_str(text),
+                FormatItem::Placeholder(Placeholder::Newline) => {
+                    lines.push(String::new());
+                    line_index += 1;
+                }
+                FormatItem::Placeholder(Placeholder::ShortHash) => {
+                    lines[line_index].push_str(&context.colored_short_hash);
+                }
+                FormatItem::Placeholder(Placeholder::FullHash) => {
+                    lines[line_index].push_str(&context.colored_full_hash);
+                }
+                FormatItem::Placeholder(Placeholder::Decorations) => {
+                    lines[line_index].push_str(&context.decorations);
+                }
+                FormatItem::Placeholder(Placeholder::Subject) => {
+                    lines[line_index].push_str(&context.subject);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorName) => {
+                    lines[line_index].push_str(&context.author.name);
+                }
+                FormatItem::Placeholder(Placeholder::AuthorEmail) => {
+                    lines[line_index].push_str(&context.author.email);
+                }
+            }
+        }
+
+        if lines.len() > 1 && lines.last().map_or(false, |line| line.is_empty()) {
+            lines.pop();
+        }
+
+        lines
     }
 }
 
-fn render_decorations(
-    graph: &GitGraph,
-    info: &CommitInfo,
-    head: Option<&HeadInfo>,
-    color_enabled: bool,
-) -> String {
-    let mut out = String::new();
-    let mut head_written = false;
+impl FormatContext {
+    pub(crate) fn new(
+        graph: &GitGraph,
+        commit_index: usize,
+        head: Option<&HeadInfo>,
+        color_enabled: bool,
+        hash_color: Option<u8>,
+    ) -> Result<Self, String> {
+        let info = graph
+            .commits
+            .get(commit_index)
+            .ok_or_else(|| format!("Commit index {} out of bounds", commit_index))?;
+        let commit = graph
+            .repository
+            .find_commit(info.oid)
+            .map_err(|err| err.message().to_string())?;
 
-    let branch_color = info
-        .branch_trace
-        .and_then(|branch_index| graph.branches.get(branch_index))
-        .map(|branch| branch.visual.term_color)
-        .or_else(|| {
-            info.tags
-                .first()
-                .and_then(|tag_index| graph.branches.get(*tag_index))
-                .map(|branch| branch.visual.term_color)
+        let full_hash = commit.id().to_string();
+        let short_hash = full_hash.chars().take(7).collect::<String>();
+        let decorations = format_branches(graph, info, head, color_enabled);
+        let trimmed_decorations = decorations.trim().to_string();
+        let colored_short_hash = hash_color
+            .map(|color_value| colored(&short_hash, color_value, color_enabled))
+            .unwrap_or_else(|| short_hash.clone());
+        let colored_full_hash = hash_color
+            .map(|color_value| colored(&full_hash, color_value, color_enabled))
+            .unwrap_or_else(|| full_hash.clone());
+
+        let message = commit.message().unwrap_or("");
+        let mut message_lines: Vec<&str> = message.split('\n').collect();
+        if message.ends_with('\n') {
+            message_lines.pop();
+        }
+
+        let body_lines = if message_lines.len() > 1 {
+            message_lines[1..].iter().map(|line| (*line).to_string()).collect()
+        } else {
+            Vec::new()
+        };
+
+        let author = signature_to_person(&commit.author());
+        let committer = signature_to_person(&commit.committer());
+
+        Ok(FormatContext {
+            short_hash,
+            full_hash,
+            colored_short_hash,
+            colored_full_hash,
+            decorations,
+            trimmed_decorations,
+            subject: commit.summary().unwrap_or("").to_string(),
+            body_lines,
+            author,
+            committer,
         })
-        .unwrap_or(WHITE);
+    }
+}
 
-    if let Some(head_info) = head {
-        if !head_info.is_branch {
-            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-            out.push(' ');
-            head_written = true;
-        }
+pub(crate) fn format_oneline(context: &FormatContext) -> Vec<String> {
+    let mut line = context.colored_short_hash.clone();
+    let mut segments = Vec::new();
+
+    if !context.trimmed_decorations.is_empty() {
+        segments.push(context.trimmed_decorations.clone());
+    }
+    if !context.subject.is_empty() {
+        segments.push(context.subject.clone());
+    }
+
+    if !segments.is_empty() {
+        line.push(' ');
+        line.push_str(&segments.join(" "));
+    }
+
+    vec![line]
+}
+
+pub(crate) fn format_short(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_medium(context: &FormatContext) -> Vec<String> {
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("Author: {}", format_signature(&context.author)));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!("Date:   {}", date));
+    }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
+
+pub(crate) fn format_full(context: &FormatContext) -> Vec<String> {
+    const LABEL_WIDTH: usize = 11;
+    let mut lines = Vec::new();
+    lines.push(commit_header(&context.colored_full_hash, &context.trimmed_decorations));
+    lines.push(format!("{:<width$}{}", "Author:", format_signature(&context.author), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.author.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "AuthorDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
+    }
+    lines.push(format!("{:<width$}{}", "Commit:", format_signature(&context.committer), width = LABEL_WIDTH));
+    if let Some(date) = format_git_date(context.committer.date) {
+        lines.push(format!(
+            "{:<width$}{}",
+            "CommitDate:",
+            date,
+            width = LABEL_WIDTH
+        ));
     }
+    lines.push(String::new());
+    lines.extend(format_message_lines(&context.subject, &context.body_lines));
+    lines
+}
 
-    let mut branch_indices = info.branches.clone();
-    let head_branch_name = head
-        .filter(|head_info| head_info.is_branch)
-        .and_then(|head_info| head_info.name.as_deref());
+fn commit_header(hash: &str, decorations: &str) -> String {
+    if decorations.is_empty() {
+        format!("commit {}", hash)
+    } else {
+        format!("commit {} {}", hash, decorations)
+    }
+}
 
-    if let Some(head_branch_name) = head_branch_name {
-        branch_indices
-            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+fn format_signature(person: &PersonInfo) -> String {
+    match (person.name.is_empty(), person.email.is_empty()) {
+        (true, true) => "<unknown>".to_string(),
+        (false, true) => person.name.clone(),
+        (true, false) => format!("<{}>", person.email),
+        (false, false) => format!("{} <{}>", person.name, person.email),
     }
+}
+
+fn format_message_lines(subject: &str, body_lines: &[String]) -> Vec<String> {
+    let mut message = Vec::new();
 
-    if !branch_indices.is_empty() {
-        out.push('(');
-        for (idx, branch_index) in branch_indices.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*branch_index) {
-                let branch_color = branch.visual.term_color;
-                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
-                if is_head_branch && !head_written {
-                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-                    out.push(' ');
-                    head_written = true;
-                }
-                out.push_str(&colored(&branch.name, branch_color, color_enabled));
-                if idx < branch_indices.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
+    if !subject.is_empty() || !body_lines.is_empty() {
+        message.push(indent(subject));
+        for line in body_lines {
+            message.push(indent(line));
         }
-        out.push_str(") ");
     }
 
-    if head.is_some() && !head_written {
-        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
-        out.push(' ');
+    message
+}
+
+fn indent(text: &str) -> String {
+    let mut line = String::from("    ");
+    line.push_str(text);
+    line
+}
+
+fn signature_to_person(signature: &Signature<'_>) -> PersonInfo {
+    PersonInfo {
+        name: signature.name().unwrap_or("").to_string(),
+        email: signature.email().unwrap_or("").to_string(),
+        date: git_time_to_datetime(signature.when()),
     }
+}
 
-    if !info.tags.is_empty() {
-        out.push('[');
-        for (idx, tag_index) in info.tags.iter().enumerate() {
-            if let Some(branch) = graph.branches.get(*tag_index) {
-                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
-                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
-                if idx < info.tags.len() - 1 {
-                    out.push_str(", ");
-                }
-            }
-        }
-        out.push_str("] ");
+fn git_time_to_datetime(time: git2::Time) -> Option<DateTime<FixedOffset>> {
+    let offset_seconds = time.offset_minutes().checked_mul(60)?;
+    let offset = FixedOffset::east_opt(offset_seconds)?;
+    match offset.timestamp_opt(time.seconds(), 0) {
+        LocalResult::None => None,
+        LocalResult::Single(dt) => Some(dt),
+        LocalResult::Ambiguous(first, _) => Some(first),
     }
+}
 
-    out
+fn format_git_date(date: Option<DateTime<FixedOffset>>) -> Option<String> {
+    date.map(|dt| dt.format("%a %b %e %H:%M:%S %Y %z").to_string())
 }
 
 fn colored(text: &str, color: u8, color_enabled: bool) -> String {
@@ -249,3 +367,10 @@
         text.to_string()
     }
 }
+
+fn flush_literal(literal: &mut String, items: &mut Vec<FormatItem>) {
+    if !literal.is_empty() {
+        items.push(FormatItem::Literal(literal.clone()));
+        literal.clear();
+    }
+}
diff --git a/src/print/unicode.rs b/src/print/unicode.rs
index 9df8b6ea0947b3e3c2b0ce72277ce63661210f25..4e3fe0b847c1640da13d0c4ce686c9b053ca6381
--- a/src/print/unicode.rs
+++ b/src/print/unicode.rs
@@ -1,9 +1,10 @@
-use crate::graph::GitGraph;
+use crate::graph::{CommitInfo, GitGraph, HeadInfo};
 use crate::settings::{Characters, Settings};
 use atty::Stream;
 use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use yansi::Paint;
+use super::format::{self, CommitFormat, FormatContext};
 
 const SPACE: u8 = 0;
 const DOT: u8 = 1;
@@ -175,10 +176,14 @@
         } else {
             None
         };
-        let lines =
-            settings
-                .format
-                .format_commit(graph, idx, head_ref, color_enabled, hash_color)?;
+        let context = FormatContext::new(graph, idx, head_ref, color_enabled, hash_color)?;
+        let lines = match &settings.format {
+            CommitFormat::Oneline => format::format_oneline(&context),
+            CommitFormat::Short => format::format_short(&context),
+            CommitFormat::Medium => format::format_medium(&context),
+            CommitFormat::Full => format::format_full(&context),
+            CommitFormat::Custom(template) => template.format(&context),
+        };
         formatted_commits.push(lines);
     }
 
@@ -219,6 +224,83 @@
     Ok(output)
 }
 
+pub(crate) fn format_branches(
+    graph: &GitGraph,
+    info: &CommitInfo,
+    head: Option<&HeadInfo>,
+    color_enabled: bool,
+) -> String {
+    let mut out = String::new();
+    let mut head_written = false;
+
+    if let Some(head_info) = head {
+        if !head_info.is_branch {
+            out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+            out.push(' ');
+            head_written = true;
+        }
+    }
+
+    let mut branch_indices = info.branches.clone();
+    let head_branch_name = head
+        .filter(|head_info| head_info.is_branch)
+        .and_then(|head_info| head_info.name.as_deref());
+
+    if let Some(head_branch_name) = head_branch_name {
+        branch_indices
+            .sort_by_key(|branch_index| graph.branches[*branch_index].name != head_branch_name);
+    }
+
+    if !branch_indices.is_empty() {
+        out.push('(');
+        for (idx, branch_index) in branch_indices.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*branch_index) {
+                let branch_color = branch.visual.term_color;
+                let is_head_branch = head_branch_name.map_or(false, |name| branch.name == name);
+                if is_head_branch && !head_written {
+                    out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+                    out.push(' ');
+                    head_written = true;
+                }
+                out.push_str(&colored(&branch.name, branch_color, color_enabled));
+                if idx < branch_indices.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str(") ");
+    }
+
+    if head.is_some() && !head_written {
+        out.push_str(&colored("HEAD ->", HEAD_COLOR, color_enabled));
+        out.push(' ');
+    }
+
+    if !info.tags.is_empty() {
+        out.push('[');
+        for (idx, tag_index) in info.tags.iter().enumerate() {
+            if let Some(branch) = graph.branches.get(*tag_index) {
+                let label = branch.name.strip_prefix("tags/").unwrap_or(&branch.name);
+                out.push_str(&colored(label, branch.visual.term_color, color_enabled));
+                if idx < info.tags.len() - 1 {
+                    out.push_str(", ");
+                }
+            }
+        }
+        out.push_str("] ");
+    }
+
+    out
+}
+
+fn colored(text: &str, color: u8, color_enabled: bool) -> String {
+    if color_enabled {
+        Paint::fixed(color, text).to_string()
+    } else {
+        text.to_string()
+    }
+}
+
 fn vline(grid: &mut Grid, (from, to): (usize, usize), column: usize, color: u8, pers: u8) {
     for i in (from + 1)..to {
         let (curr, _, old_pers) = grid.get_tuple(column * 2, i);


=== 错误 ===
2025-09-21T18:38:49.545978Z ERROR codex_core::exec: exec error: No such file or directory (os error 2)

=== 最终状态 ===
返回码: 0
状态: ✅ 执行成功
