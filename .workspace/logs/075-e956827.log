=== 任务 075-e956827 执行日志 ===
时间: 2025-09-22 05:16:10.550333
Prompt:
请在 .workspace 内，依据 .workspace/todolist/todolist-075-e956827.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/075-e956827/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："075-e956827：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 075-e956827

=== 输出 ===
[2025-09-21T21:03:17] OpenAI Codex v0.39.0 (research preview)
--------
workdir: /Users/jqwang/104-CommitLens-codex/.workspace
model: gpt-5-codex-high
provider: codex
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
--------
[2025-09-21T21:03:17] User instructions:
请在 .workspace 内，依据 .workspace/todolist/todolist-075-e956827.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/075-e956827/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："075-e956827：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 075-e956827

[2025-09-21T21:03:24] thinking

**Preparing initial inspection and planning approach**
[2025-09-21T21:03:24] exec bash -lc 'ls -la' in /Users/jqwang/104-CommitLens-codex/.workspace/.workspace
[2025-09-21T21:03:24] bash -lc 'ls -la' exited -1 in 0ms:
No such file or directory (os error 2)
[2025-09-21T21:03:24] tokens used: 967

[2025-09-21T21:03:26] thinking

**Resolving workspace absolute path**
[2025-09-21T21:03:26] exec bash -lc 'ls -la' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T21:03:26] bash -lc 'ls -la' succeeded in 25ms:
total 38944
drwxr-xr-x@  9 jqwang  staff       288 Sep 21 15:57 .
drwxr-xr-x@ 29 jqwang  staff       928 Sep 21 07:49 ..
-rw-r--r--@  1 jqwang  staff       103 Sep 22 05:03 codex_error.txt
-rw-r--r--@  1 jqwang  staff  19771311 Sep 22 05:03 codex_output.txt
-rw-r--r--@  1 jqwang  staff         7 Sep 22 05:03 codex_status.txt
drwxr-xr-x@ 76 jqwang  staff      2432 Sep 22 05:03 logs
drwxr-xr-x@ 12 jqwang  staff       384 Sep 18 13:06 rust-project
-rw-r--r--@  1 jqwang  staff      1548 Sep 22 05:03 task_status.json
drwxr-xr-x@  5 jqwang  staff       160 Sep 22 05:03 todolist
[2025-09-21T21:03:26] tokens used: 1,164

[2025-09-21T21:03:28] thinking

**Preparing to read LaTeX file**
[2025-09-21T21:03:28] exec bash -lc 'cat todolist/todolist-075-e956827.tex' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T21:03:28] bash -lc 'cat todolist/todolist-075-e956827.tex' succeeded in 8ms:
\section{提交考古：075-e956827}

\subsection*{Commit 元信息}
\begin{itemize}
  \item 标题：respect source and target branches when assigning branch columns, removed FCFS ordering
  \item 作者：Martin Lange <martin\_lange\_@gmx.net>
  \item 日期：2021-01-02T16:44:05+01:00
\end{itemize}

\subsection*{变更摘要（阅读提示）}
\begin{verbatim}
HEAD:   src/graph.rs | 198 ++++++++++++++++++++--------------------------------
        src/main.rs  |   6 +-
        src/print/format.rs |   1 -
        src/settings.rs |   4 --
        4 files changed, 78 insertions(+), 131 deletions(-)
HEAD-1: README.md (links/text), docs/manual.md (regex) — 2 files changed, 3 insertions(+), 3 deletions(-)
HEAD-2: Cargo.toml, Cargo.lock — 2 files changed, 2 insertions(+), 2 deletions(-)
\end{verbatim}

[2025-09-21T21:03:28] tokens used: 1,627

[2025-09-21T21:03:31] thinking

**Exploring workspace contents**
[2025-09-21T21:03:31] exec bash -lc 'ls -R' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:03:31] bash -lc 'ls -R' succeeded in 20ms:
Cargo.lock
Cargo.toml
docs
LICENSE
README.md
scripts
src

./docs:
manual.md

./scripts:
linearize-history.sh

./src:
graph.rs
lib.rs
main.rs
print
settings.rs
[2025-09-21T21:03:31] tokens used: 3,560

[2025-09-21T21:03:34] thinking

**Verifying repository status**
[2025-09-21T21:03:34] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:03:34] bash -lc 'git status -sb' succeeded in 17ms:
## main
[2025-09-21T21:03:34] tokens used: 3,780

[2025-09-21T21:03:37] thinking

**Reviewing code for consistency**
[2025-09-21T21:03:37] exec bash -lc "sed -n '1,200p' src/settings.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:03:37] bash -lc "sed -n '1,200p' src/settings.rs" succeeded in 9ms:
//! Graph generation settings.

use crate::print::format::CommitFormat;
use regex::{Error, Regex};
use serde_derive::{Deserialize, Serialize};
use std::str::FromStr;

/// Repository settings for the branching model.
/// Used to read repo's git-graph.toml
#[derive(Serialize, Deserialize)]
pub struct RepoSettings {
    /// The repository's branching model
    pub model: String,
}

/// Ordering policy for branches in visual columns.
pub enum BranchOrder {
    /// Recommended! Shortest branches are inserted left-most.
    ///
    /// For branches with equal length, branches ending last are inserted first.
[2025-09-21T21:03:37] tokens used: 3,985

[2025-09-21T21:03:42] thinking

**Planning code modifications and investigating commits**

I need to remove FCFS-related code and adjust `graph.rs`. To do that properly, I want to reconstruct the exact final code, so I'll check the git history in the repo to find the relevant commit since we might have it locally and no external network access. This way, I can align changes precisely with the final version referenced in the report.
[2025-09-21T21:03:43] exec bash -lc 'git log --oneline | head' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:03:44] bash -lc 'git log --oneline | head' succeeded in 22ms:
7199a4c 073-d93a92b：复现提交代码内容。
655deeb 072-35a0f7c：复现提交代码内容。
f380828 071-6bc7137：复现提交代码内容。
c1e69b0 070-a4edd40：复现提交代码内容。
3e99299 069-855331b：复现提交代码内容。
afc9ea7 068-31f96a6：复现提交代码内容。
e48799e 067-bf70a57：复现提交代码内容。
c1f457f 066-7fc9ac3：复现提交代码内容。
b045300 065-3845114：复现提交代码内容。
d565507 064-49e4dd3：复现提交代码内容。
[2025-09-21T21:03:44] tokens used: 6,242

[2025-09-21T21:03:50] thinking

**Inspecting local patches for commits**
[2025-09-21T21:03:50] exec bash -lc 'ls todolist' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T21:03:50] bash -lc 'ls todolist' succeeded in 19ms:
figs
task_meta.json
todolist-075-e956827.tex
[2025-09-21T21:03:50] tokens used: 6,722

[2025-09-21T21:03:52] thinking

**Checking task_meta.json for details**
[2025-09-21T21:03:52] exec bash -lc 'cat todolist/task_meta.json' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T21:03:52] bash -lc 'cat todolist/task_meta.json' succeeded in 10ms:
{
  "task_id": "075-e956827",
  "start_time": "2025-09-22T05:03:17.547711",
  "source_report": ".artifacts/reports/075-e956827.tex",
  "source_figs": ".artifacts/figs/075-e956827",
  "workspace_dir": ".workspace",
  "todolist_dir": ".workspace/todolist",
  "project_name": "rust-project",
  "project_output_dir": ".workspace/rust-project"
}
[2025-09-21T21:03:52] tokens used: 6,935

[2025-09-21T21:03:58] thinking

**Inspecting potential artifact directories**
[2025-09-21T21:03:58] exec bash -lc 'ls ..' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T21:03:58] bash -lc 'ls ..' succeeded in 10ms:
__pycache__
界面-设置.png
界面.png
docs
Example.pdf
pyproject.toml
README.md
requirements.txt
src
tools
[2025-09-21T21:03:58] tokens used: 7,293

[2025-09-21T21:04:01] thinking

**Inspecting source files for changes**
[2025-09-21T21:04:01] exec bash -lc "sed -n '1,160p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:04:01] bash -lc "sed -n '1,160p' src/graph.rs" succeeded in 9ms:
//! A graph structure representing the history of a Git repository.

use crate::print::colors::to_terminal_color;
use crate::settings::{BranchOrder, BranchSettings, MergePatterns, Settings};
use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
use itertools::Itertools;
use regex::Regex;
use std::collections::{HashMap, HashSet, VecDeque};

const ORIGIN: &str = "origin/";

/// Represents a git history graph.
pub struct GitGraph {
    pub repository: Repository,
    pub commits: Vec<CommitInfo>,
    pub indices: HashMap<Oid, usize>,
    pub branches: Vec<BranchInfo>,
    pub head: HeadInfo,
}

[2025-09-21T21:04:01] tokens used: 7,634

[2025-09-21T21:04:04] thinking

**Continuing to explore column assignment functions**
[2025-09-21T21:04:04] exec bash -lc "sed -n '160,360p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:04:04] bash -lc "sed -n '160,360p' src/graph.rs" succeeded in 18ms:
        };
        Ok(h)
    }
}

/// Represents a commit.
pub struct CommitInfo {
    pub oid: Oid,
    pub is_merge: bool,
    pub parents: [Option<Oid>; 2],
    pub children: Vec<Oid>,
    pub branches: Vec<usize>,
    pub tags: Vec<usize>,
    pub branch_trace: Option<usize>,
}

impl CommitInfo {
    fn new(commit: &Commit) -> Self {
        CommitInfo {
            oid: commit.id(),
[2025-09-21T21:04:04] tokens used: 9,140

[2025-09-21T21:04:07] thinking

**Skipping non-essential functions**
[2025-09-21T21:04:08] exec bash -lc "sed -n '360,720p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:04:08] bash -lc "sed -n '360,720p' src/graph.rs" succeeded in 9ms:

/// Extracts (real or derived from merge summary) and assigns basic properties.
fn extract_branches(
    repository: &Repository,
    commits: &[CommitInfo],
    indices: &HashMap<Oid, usize>,
    settings: &Settings,
) -> Result<Vec<BranchInfo>, String> {
    let filter = if settings.include_remote {
        None
    } else {
        Some(BranchType::Local)
    };
    let actual_branches = repository
        .branches(filter)
        .map_err(|err| err.message().to_string())?
        .collect::<Result<Vec<_>, Error>>()
        .map_err(|err| err.message().to_string())?;

    let mut counter = 0;
[2025-09-21T21:04:08] tokens used: 10,889

[2025-09-21T21:04:10] thinking

**Proceeding with next steps**
[2025-09-21T21:04:10] exec bash -lc "sed -n '720,1080p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:04:10] bash -lc "sed -n '720,1080p' src/graph.rs" succeeded in 9ms:
            *acc += group.len();
            Some(*acc)
        })
        .collect();

    for branch in branches {
        if let Some(column) = branch.visual.column {
            let offset = if branch.visual.order_group == 0 {
                0
            } else {
                group_offset[branch.visual.order_group - 1]
            };
            branch.visual.column = Some(column + offset);
        }
    }
}

/// Sorts branches into columns for visualization, that all branches can be
/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
fn assign_branch_columns_branch_length(
[2025-09-21T21:04:10] tokens used: 13,118

[2025-09-21T21:04:12] thinking

**Reviewing main.rs for updates**
[2025-09-21T21:04:13] exec bash -lc "sed -n '460,560p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:04:13] bash -lc "sed -n '460,560p' src/main.rs" succeeded in 7ms:
fn set_model(repository: &Repository, model: &str) -> Result<(), String> {
    let models = get_available_models()?;

    if !models.contains(&model.to_string()) {
        let app_dir = AppDirs::new(Some("git-graph"), false).unwrap().config_dir;
        let mut models_dir = app_dir;
        models_dir.push("models");
        return Err(format!(
            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
            model,
            models_dir.display(),
            itertools::join(models, ", ")
        ));
    }

    let mut config_path = PathBuf::from(repository.path());
    config_path.push("git-graph.toml");

    let config = RepoSettings {
        model: model.to_string(),
[2025-09-21T21:04:13] tokens used: 14,948

[2025-09-21T21:04:15] thinking

**Checking debug output formatting**
[2025-09-21T21:04:16] exec bash -lc "sed -n '1,200p' src/print/format.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:04:16] bash -lc "sed -n '1,200p' src/print/format.rs" succeeded in 11ms:
//! Formatting of commits.

use chrono::{FixedOffset, Local, TimeZone};
use git2::{Commit, Time};
use lazy_static::lazy_static;
use std::fmt::Write;
use std::str::FromStr;
use textwrap::{HyphenSplitter, Options};
use yansi::Paint;

/// Commit formatting options.
pub enum CommitFormat {
    OneLine,
    Short,
    Medium,
    Full,
    Format(String),
}

impl FromStr for CommitFormat {
[2025-09-21T21:04:16] tokens used: 16,031

[2025-09-21T21:04:26] thinking

**Reconstructing commit changes in format.rs**

I’m thinking through how to accurately recreate the commit’s changes based on the report—removing a variant from BranchOrder, adding new fields and functions in BranchVis, and adjusting branch column assignment logic. Since I can’t fetch the commit directly, I’ll reason through related structs and functions in the codebase, especially focusing on where `order_group` is used, to avoid breaking functionality. I plan to search for usages of `order_group` to understand its roles before extending BranchVis.
[2025-09-21T21:04:27] exec bash -lc 'rg "order_group" -n' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src
[2025-09-21T21:04:27] bash -lc 'rg "order_group" -n' succeeded in 13ms:
graph.rs:232:    pub order_group: usize,
graph.rs:242:    fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
graph.rs:244:            order_group,
graph.rs:677:                    let group = &mut occupied[branch.visual.order_group];
graph.rs:703:                    let group = &mut occupied[branch.visual.order_group];
graph.rs:727:            let offset = if branch.visual.order_group == 0 {
graph.rs:730:                group_offset[branch.visual.order_group - 1]
graph.rs:773:        let group = branch.visual.order_group;
graph.rs:792:                    if merge_branch.visual.order_group == branch.visual.order_group {
graph.rs:824:            let offset = if branch.visual.order_group == 0 {
graph.rs:827:                group_offset[branch.visual.order_group - 1]
[2025-09-21T21:04:27] tokens used: 33,258

[2025-09-21T21:04:33] thinking

**Reviewing branch and settings updates**
[2025-09-21T21:04:33] exec bash -lc 'rg "FirstComeFirstServed" -n' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:04:33] bash -lc 'rg "FirstComeFirstServed" -n' succeeded in 10ms:
src/settings.rs:31:    FirstComeFirstServed(bool),
src/graph.rs:71:            BranchOrder::FirstComeFirstServed(forward) => {
[2025-09-21T21:04:33] tokens used: 33,816

[2025-09-21T21:04:36] thinking

**Preparing to update BranchOrder usage**
[2025-09-21T21:04:36] exec bash -lc 'rg "BranchOrder" -n' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:04:36] bash -lc 'rg "BranchOrder" -n' succeeded in 12ms:
src/settings.rs:17:pub enum BranchOrder {
src/settings.rs:51:    pub branch_order: BranchOrder,
src/main.rs:13:    BranchOrder, BranchSettings, BranchSettingsDef, Characters, MergePatterns, RepoSettings,
src/main.rs:356:        branch_order: BranchOrder::ShortestFirst(true),
src/graph.rs:4:use crate::settings::{BranchOrder, BranchSettings, MergePatterns, Settings};
src/graph.rs:71:            BranchOrder::FirstComeFirstServed(forward) => {
src/graph.rs:74:            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
src/graph.rs:82:            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
[2025-09-21T21:04:36] tokens used: 34,021

[2025-09-21T21:04:39] thinking

**Searching configuration for BranchOrder**
[2025-09-21T21:04:39] exec bash -lc 'rg "ShortestFirst" -n src/settings.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:04:39] bash -lc 'rg "ShortestFirst" -n src/settings.rs' succeeded in 11ms:
22:    ShortestFirst(bool),
[2025-09-21T21:04:39] tokens used: 34,407

[2025-09-21T21:04:42] thinking

**Searching for branch_order usage**
[2025-09-21T21:04:42] exec bash -lc 'rg -n "branch_order" src/settings.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:04:42] bash -lc 'rg -n "branch_order" src/settings.rs' succeeded in 12ms:
51:    pub branch_order: BranchOrder,
[2025-09-21T21:04:42] tokens used: 34,656

[2025-09-21T21:04:45] thinking

**Searching for branch_order parsing functions**
[2025-09-21T21:04:45] exec bash -lc "sed -n '200,400p' src/settings.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:04:45] bash -lc "sed -n '200,400p' src/settings.rs" succeeded in 9ms:
                ],
            },
        }
    }
}

/// Settings defining branching models
pub struct BranchSettings {
    /// Branch persistence
    pub persistence: Vec<Regex>,
    /// Branch ordering
    pub order: Vec<Regex>,
    /// Branch colors
    pub terminal_colors: Vec<(Regex, Vec<String>)>,
    /// Colors for branches not matching any of `colors`
    pub terminal_colors_unknown: Vec<String>,
    /// Branch colors for SVG output
    pub svg_colors: Vec<(Regex, Vec<String>)>,
    /// Colors for branches not matching any of `colors` for SVG output
    pub svg_colors_unknown: Vec<String>,
[2025-09-21T21:04:45] tokens used: 34,909

[2025-09-21T21:04:48] thinking

**Searching for branch order parsing**
[2025-09-21T21:04:48] exec bash -lc 'rg "fcfs" -n src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:04:48] bash -lc 'rg "fcfs" -n src/main.rs' exited 1 in 11ms:

[2025-09-21T21:04:48] tokens used: 36,360

[2025-09-21T21:04:51] thinking

**Searching for ShortestFirst**
[2025-09-21T21:04:52] exec bash -lc 'rg "ShortestFirst" -n src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:04:52] bash -lc 'rg "ShortestFirst" -n src/main.rs' succeeded in 10ms:
356:        branch_order: BranchOrder::ShortestFirst(true),
[2025-09-21T21:04:52] tokens used: 36,523

[2025-09-21T21:04:54] thinking

**Searching for branch order parsing function**
[2025-09-21T21:04:55] exec bash -lc 'rg "branch-order" -n src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:04:55] bash -lc 'rg "branch-order" -n src/main.rs' exited 1 in 13ms:

[2025-09-21T21:04:55] tokens used: 36,796

[2025-09-21T21:04:58] thinking

**Investigating CLI argument parsing**
[2025-09-21T21:04:58] exec bash -lc 'rg "Shortest first" -n src' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:04:58] bash -lc 'rg "Shortest first" -n src' exited 1 in 11ms:

[2025-09-21T21:04:58] tokens used: 37,046

[2025-09-21T21:05:02] thinking

**Reviewing earlier main files**
[2025-09-21T21:05:03] exec bash -lc "sed -n '240,420p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:05:03] bash -lc "sed -n '240,420p' src/main.rs" succeeded in 9ms:
                }
            }
            Some(model) => set_model(&repository, model)?,
        };
        return Ok(());
    }

    let commit_limit = match matches.value_of("max-count") {
        None => None,
        Some(str) => match str.parse::<usize>() {
            Ok(val) => Some(val),
            Err(_) => {
                return Err(format![
                    "Option max-count must be a positive number, but got '{}'",
                    str
                ])
            }
        },
    };

[2025-09-21T21:05:03] tokens used: 37,292

[2025-09-21T21:05:12] thinking

**Planning branch column assignment updates**
[2025-09-21T21:05:12] exec bash -lc 'rg --files --iglob "*075-e956827*" -g"*.diff"' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T21:05:12] bash -lc 'rg --files --iglob "*075-e956827*" -g"*.diff"' succeeded in 26ms:
todolist/todolist-075-e956827.tex
[2025-09-21T21:05:12] tokens used: 39,466

[2025-09-21T21:05:20] thinking

**Analyzing branch assignment logic**
[2025-09-21T21:05:21] exec bash -lc 'rg "trace_branch" -n src/graph.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:05:21] bash -lc 'rg "trace_branch" -n src/graph.rs' succeeded in 21ms:
300:                    trace_branch(repository, commits, &indices, &mut branches, oid, old_idx)
533:fn trace_branch<'repo>(
[2025-09-21T21:05:21] tokens used: 40,089

[2025-09-21T21:05:23] thinking

**Reviewing trace_branch function location**
[2025-09-21T21:05:23] exec bash -lc "sed -n '520,700p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:05:23] bash -lc "sed -n '520,700p' src/graph.rs" succeeded in 19ms:
                    BranchVis::new(pos, term_col, svg_col),
                    Some(*target_index),
                );
                valid_branches.push(tag_info);
            }
        }
    }

    Ok(valid_branches)
}

/// Traces back branches by following 1st commit parent,
/// until a commit is reached that already has a trace.
fn trace_branch<'repo>(
    repository: &'repo Repository,
    commits: &mut [CommitInfo],
    indices: &HashMap<Oid, usize>,
    branches: &mut [BranchInfo],
    oid: Oid,
    branch_index: usize,
[2025-09-21T21:05:23] tokens used: 40,349

[2025-09-21T21:05:41] thinking

**Clarifying branch range semantics**
[2025-09-21T21:05:41] exec bash -lc 'rg "merge_target" -n src' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:05:41] bash -lc 'rg "merge_target" -n src' succeeded in 12ms:
src/graph.rs:193:    pub merge_target: Option<Oid>,
src/graph.rs:206:        merge_target: Option<Oid>,
src/graph.rs:217:            merge_target,
src/graph.rs:787:                    .merge_target
[2025-09-21T21:05:41] tokens used: 43,371

[2025-09-21T21:05:54] thinking

**Analyzing branch metadata and commit tracing**

I'm piecing together how branches mark merge commits and track source commits via indices and traces, considering both actual and derived branches. It’s tricky without network access or full repo history, but I’m planning to inspect commit logs and ranges to approximate how source and target order groups derive from branch commit traces.
[2025-09-21T21:05:55] exec bash -lc 'git log --oneline --reverse | head' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:05:55] bash -lc 'git log --oneline --reverse | head' succeeded in 19ms:
fe06d25 001-84a2fb2：复现提交代码内容。
705b5c1 002-e2f4768：复现提交代码内容。
e0b8b49 003-2ea0b53：复现提交代码内容。
b8614e0 004-2c4b178：复现提交代码内容。
c9e2c51 005-19d4a97：复现提交代码内容。
56152eb 006-a228ea1：复现提交代码内容。
d8503ed 007-5a3081c：复现提交代码内容。
9e4215d 008-04596c3：复现提交代码内容。
1849528 009-b88a557：复现提交代码内容。
e5a53d6 011-25f2a73：复现提交代码内容。
[2025-09-21T21:05:55] tokens used: 55,042

[2025-09-21T21:07:07] thinking

**Designing branch assignment algorithm**

I’m working out how to update the branch ordering and column assignment logic to align with the new algorithm described. This involves adding source and target order groups to each branch’s visual data, computing these via parent commits and merge targets, then sorting and assigning columns accordingly while respecting these groups to avoid collisions. It’s a complex task since I have to replicate the intended behavior solely from the detailed description and ensure the new functions integrate smoothly with existing data structures.
**Drafting detailed source and target assignment**

I’m outlining a concrete implementation for assigning source and target order groups to branches by analyzing parent and child commits, setting defaults to the branch’s own group, and planning how to handle merges and heuristics when explicit data is missing. This includes carefully iterating commits to find earliest and latest branch commits, checking their relations, and preparing to sort branches by the maximum of these groups for column assignment—building a solid base to replicate the intended behavior from description alone.
[2025-09-21T21:08:02] codex
**Drafting detailed source and target assignment**

I’m outlining a concrete implementation for assigning source and target order groups to branches by analyzing parent and child commits, setting defaults to the branch’s own group, and planning how to handle merges and heuristics when explicit data is missing. This includes carefully iterating commits to find earliest and latest branch commits, checking their relations, and preparing to sort branches by the maximum of these groups for column assignment—building a solid base to replicate the intended behavior from description alone.
[2025-09-21T21:08:02] exec bash -lc 'rg "assign_sources_targets" -n' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T21:08:02] bash -lc 'rg "assign_sources_targets" -n' succeeded in 37ms:
todolist/figs/algorithm_flow.puml:9::assign_sources_targets(commits, indices, branches);\n// 计算每个分支的 source/target 列提示;
todolist/figs/architecture.puml:19:  component "graph.rs\nassign_sources_targets()" <<added>> as ST_AF
codex_output.txt:563638:[2025-09-21T21:08:02] exec bash -lc 'rg "assign_sources_targets" -n' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T21:08:02] tokens used: 62,617

[2025-09-21T21:08:06] thinking

**Exploring PlantUML diagram file**
[2025-09-21T21:08:07] exec bash -lc 'cat todolist/figs/075-e956827/algorithm_flow.puml' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T21:08:07] bash -lc 'cat todolist/figs/075-e956827/algorithm_flow.puml' exited 1 in 21ms:
cat: todolist/figs/075-e956827/algorithm_flow.puml: No such file or directory
[2025-09-21T21:08:07] tokens used: 62,903

[2025-09-21T21:08:10] thinking

**Checking directory structure for symlinks**
[2025-09-21T21:08:10] exec bash -lc 'ls todolist/figs' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T21:08:10] bash -lc 'ls todolist/figs' succeeded in 22ms:
algorithm_flow.puml
architecture.puml
[2025-09-21T21:08:10] tokens used: 63,091

[2025-09-21T21:08:14] thinking

**Opening PlantUML files**
[2025-09-21T21:08:15] exec bash -lc 'cat todolist/figs/algorithm_flow.puml' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T21:08:15] bash -lc 'cat todolist/figs/algorithm_flow.puml' succeeded in 14ms:
@startuml
title 算法流程：分支列分配（075-e956827）
skinparam dpi 180
skinparam shadowing false
start
:GitGraph::new();
:revwalk + assign_children();
:assign_branches(repo, commits, indices, settings);
:assign_sources_targets(commits, indices, branches);\n// 计算每个分支的 source/target 列提示;
if (branch_order == ShortestFirst?) then (是)
  :length_sort_factor = +1;
else (否)
  :length_sort_factor = -1;
endif
if (forward?) then (true)
  :start_sort_factor = +1;
else (false)
  :start_sort_factor = -1;
endif
:构造排序键 = (max(source_group, target_group),\n  长度*length_sort_factor, 起点*start_sort_factor);
[2025-09-21T21:08:15] tokens used: 63,280

[2025-09-21T21:08:20] thinking

**Analyzing PlantUML sorting algorithm**
[2025-09-21T21:08:20] exec bash -lc 'cat todolist/figs/architecture.puml' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T21:08:20] bash -lc 'cat todolist/figs/architecture.puml' succeeded in 22ms:
@startuml
title 架构变化：尊重源/目标分支进行列分配，移除 FCFS（075-e956827）
skinparam dpi 180
skinparam shadowing false
skinparam ArrowColor #555
skinparam RectangleBorderColor #777
skinparam RectangleBackgroundColor #F8F8F8

rectangle "before" {
  component "settings.rs\nBranchOrder {\n  ShortestFirst,\n  LongestFirst,\n  FirstComeFirstServed\n}" as BO_BE
  component "graph.rs\nassign_branch_columns_branch_length()" as BL_BE
  component "graph.rs\nassign_branch_columns_fcfs()" <<removed>> as FCFS_BE
  component "graph.rs\nBranchVis{ order_group, term_color, svg_color, column }" as VIS_BE
  component "main.rs\ndebug: name, col, range, merged" as DBG_BE
}

rectangle "after" {
  component "settings.rs\nBranchOrder {\n  ShortestFirst,\n  LongestFirst\n}" <<changed>> as BO_AF
  component "graph.rs\nassign_sources_targets()" <<added>> as ST_AF
  component "graph.rs\nassign_branch_columns()\n(基于最短/最长 + 源/目标列提示)" <<changed>> as BL_AF
[2025-09-21T21:08:20] tokens used: 63,747

[2025-09-21T21:09:12] thinking

**Designing branch order grouping and column assignment logic**

I'm planning to add optional `source_order_group` and `target_order_group` fields to `BranchVis` and implement an `assign_sources_targets` function that computes these by analyzing commit-parent relationships. Then, I’ll create a unified `assign_branch_columns` function using these hints to assign branch columns while respecting sorting preferences and avoiding overlaps, updating the branch ordering logic and removing older separate assignment functions accordingly.
[2025-09-21T21:09:13] exec bash -lc 'rg "VecDeque" -n src/graph.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:09:13] bash -lc 'rg "VecDeque" -n src/graph.rs' succeeded in 23ms:
8:use std::collections::{HashMap, HashSet, VecDeque};
648:    let mut start_queue: VecDeque<_> = branches
656:    let mut end_queue: VecDeque<_> = branches
752:    let branches_sort: VecDeque<_> = branches
[2025-09-21T21:09:13] tokens used: 68,529

[2025-09-21T21:10:10] thinking

**Updating branch column assignment logic**

I'm working through refactoring the `assign_branch_columns` function to use a new sorting key based on source and target groups, removing `VecDeque` usage, and managing Rust borrow rules carefully while tracking occupied columns and merge target conflicts. Also updating debug output and cleaning up related imports and settings accordingly.
**Designing source and target assignment function**

I’m outlining how to set the `source_order_group` and `target_order_group` fields for branches by analyzing commit parents and merges, handling edge cases where data may be missing or alignments are ambiguous, and ensuring these assignments happen before column calculation. Also noting related cleanup and debug output updates needed.
[2025-09-21T21:10:28] codex
**Designing source and target assignment function**

I’m outlining how to set the `source_order_group` and `target_order_group` fields for branches by analyzing commit parents and merges, handling edge cases where data may be missing or alignments are ambiguous, and ensuring these assignments happen before column calculation. Also noting related cleanup and debug output updates needed.
[2025-09-21T21:10:28] exec bash -lc "rg \"allow\\(dead_code\\)\" src/print/format.rs -n" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:10:28] bash -lc "rg \"allow\\(dead_code\\)\" src/print/format.rs -n" succeeded in 11ms:
76:#[allow(dead_code)]
[2025-09-21T21:10:28] tokens used: 74,610

[2025-09-21T21:10:38] thinking

**Planning coordinated code modifications**
[2025-09-21T21:10:39] exec bash -lc 'rg "BranchVis::new" -n' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src
[2025-09-21T21:10:39] bash -lc 'rg "BranchVis::new" -n' succeeded in 11ms:
graph.rs:414:                        BranchVis::new(
graph.rs:472:                    BranchVis::new(pos, term_col, svg_col),
graph.rs:520:                    BranchVis::new(pos, term_col, svg_col),
[2025-09-21T21:10:39] tokens used: 75,362

[2025-09-21T21:10:45] thinking

**Planning function signature update and code cleanup**
[2025-09-21T21:10:48] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/settings.rs
@@ -27,6 +27,2 @@
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
[2025-09-21T21:10:48] apply_patch(auto_approved=true) exited 0 in 23ms:
Success. Updated the following files:
M src/settings.rs
[2025-09-21T21:10:48] turn diff:
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings

[2025-09-21T21:10:48] tokens used: 75,870
[2025-09-21T21:10:48] turn diff:
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:10:55] thinking

**Preparing to update imports in graph.rs**
[2025-09-21T21:10:56] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -7,3 +7,4 @@
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
[2025-09-21T21:10:56] apply_patch(auto_approved=true) exited 0 in 21ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T21:10:56] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..cdf42b93a87f7004318d3592e2ffe17ae143b946
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings

[2025-09-21T21:10:56] tokens used: 76,441
[2025-09-21T21:10:56] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..cdf42b93a87f7004318d3592e2ffe17ae143b946
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:11:02] thinking

**Updating BranchVis structure**
[2025-09-21T21:11:05] tokens used: 77,095
[2025-09-21T21:11:05] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..cdf42b93a87f7004318d3592e2ffe17ae143b946
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:11:10] thinking

**Correcting patch working directory**
[2025-09-21T21:11:12] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -233,2 +233,6 @@
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
@@ -245,2 +249,4 @@
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
[2025-09-21T21:11:12] apply_patch(auto_approved=true) exited 0 in 37ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T21:11:12] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..9b940cda33ff4bc93666f936ffb96e45a796bff8
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -230,6 +231,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +247,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings

[2025-09-21T21:11:12] tokens used: 78,065
[2025-09-21T21:11:12] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..9b940cda33ff4bc93666f936ffb96e45a796bff8
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -230,6 +231,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +247,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:11:19] thinking

**Planning GitGraph assignment update**
[2025-09-21T21:11:22] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -70,7 +70,6 @@
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
@@ -82,3 +81,3 @@
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
[2025-09-21T21:11:22] apply_patch(auto_approved=true) exited 0 in 37ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T21:11:22] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..02e4b88a51c43168b096dd657691255edec7ab4a
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings

[2025-09-21T21:11:22] tokens used: 79,176
[2025-09-21T21:11:22] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..02e4b88a51c43168b096dd657691255edec7ab4a
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:12:13] thinking

**Replacing branch assignment functions**
[2025-09-21T21:12:13] exec bash -lc "sed -n '640,860p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:12:13] bash -lc "sed -n '640,860p' src/graph.rs" succeeded in 7ms:
}

/// Sorts branches into columns for visualization, that all branches can be
/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
fn assign_branch_columns_fcfs(
    commits: &[CommitInfo],
    branches: &mut [BranchInfo],
    settings: &BranchSettings,
    forward: bool,
) {
    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];

    let sort_factor = if forward { 1 } else { -1 };

    let mut start_queue: VecDeque<_> = branches
        .iter()
        .enumerate()
        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
[2025-09-21T21:12:13] tokens used: 83,290
[2025-09-21T21:12:13] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..02e4b88a51c43168b096dd657691255edec7ab4a
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:12:17] thinking

**Preparing to replace branch assignment functions**
[2025-09-21T21:12:39] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -641,79 +641,12 @@
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
@@ -722,19 +655,48 @@
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| {
+                                branches[parent_branch_idx].visual.order_group
+                            })
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| {
+                        branches[target_branch_idx].visual.order_group
+                    })
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| commits[*head_idx].children.iter().find_map(|child| {
+                        indices
+                            .get(child)
+                            .and_then(|child_idx| commits[*child_idx].branch_trace)
+                            .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                            .map(|child_branch_idx| {
+                                branches[child_branch_idx].visual.order_group
+                            })
+                    }))
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
@@ -742,5 +704,4 @@
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
@@ -756,19 +717,29 @@
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
@@ -776,27 +747,38 @@
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
+
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ
+                    .iter()
+                    .any(|(s, e)| start <= *e && end >= *s);
+
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
@@ -805,14 +787,17 @@
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
+
+            group_occ[selected_column].push((start, end));
         }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
-        }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
@@ -827,3 +812,3 @@
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
[2025-09-21T21:12:39] apply_patch(auto_approved=true) exited 0 in 39ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-21T21:12:39] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..63cba7a6b2448184d28b004dbd358473c8f729ba
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,71 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| {
+                                branches[parent_branch_idx].visual.order_group
+                            })
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| {
+                        branches[target_branch_idx].visual.order_group
+                    })
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| commits[*head_idx].children.iter().find_map(|child| {
+                        indices
+                            .get(child)
+                            .and_then(|child_idx| commits[*child_idx].branch_trace)
+                            .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                            .map(|child_branch_idx| {
+                                branches[child_branch_idx].visual.order_group
+                            })
+                    }))
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +715,91 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
+
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ
+                    .iter()
+                    .any(|(s, e)| start <= *e && end >= *s);
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +810,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings

[2025-09-21T21:12:39] tokens used: 89,003
[2025-09-21T21:12:39] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..63cba7a6b2448184d28b004dbd358473c8f729ba
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,71 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| {
+                                branches[parent_branch_idx].visual.order_group
+                            })
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| {
+                        branches[target_branch_idx].visual.order_group
+                    })
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| commits[*head_idx].children.iter().find_map(|child| {
+                        indices
+                            .get(child)
+                            .and_then(|child_idx| commits[*child_idx].branch_trace)
+                            .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                            .map(|child_branch_idx| {
+                                branches[child_branch_idx].visual.order_group
+                            })
+                    }))
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +715,91 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
+
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ
+                    .iter()
+                    .any(|(s, e)| start <= *e && end >= *s);
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +810,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:12:48] thinking

**Verifying index safety and itertools usage**
[2025-09-21T21:12:48] exec bash -lc 'rg "sorted_by_key" src/graph.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:12:48] bash -lc 'rg "sorted_by_key" src/graph.rs' exited 1 in 24ms:

[2025-09-21T21:12:48] tokens used: 92,936
[2025-09-21T21:12:48] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..63cba7a6b2448184d28b004dbd358473c8f729ba
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,71 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| {
+                                branches[parent_branch_idx].visual.order_group
+                            })
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| {
+                        branches[target_branch_idx].visual.order_group
+                    })
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| commits[*head_idx].children.iter().find_map(|child| {
+                        indices
+                            .get(child)
+                            .and_then(|child_idx| commits[*child_idx].branch_trace)
+                            .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                            .map(|child_branch_idx| {
+                                branches[child_branch_idx].visual.order_group
+                            })
+                    }))
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +715,91 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
+
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ
+                    .iter()
+                    .any(|(s, e)| start <= *e && end >= *s);
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +810,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:12:54] thinking

**Continuing search for itertools usage**
[2025-09-21T21:12:54] exec bash -lc 'rg "find_position" src/graph.rs' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T21:12:54] bash -lc 'rg "find_position" src/graph.rs' exited 2 in 9ms:
src/graph.rs: No such file or directory (os error 2)
[2025-09-21T21:12:54] tokens used: 93,121
[2025-09-21T21:12:54] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..63cba7a6b2448184d28b004dbd358473c8f729ba
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,71 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| {
+                                branches[parent_branch_idx].visual.order_group
+                            })
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| {
+                        branches[target_branch_idx].visual.order_group
+                    })
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| commits[*head_idx].children.iter().find_map(|child| {
+                        indices
+                            .get(child)
+                            .and_then(|child_idx| commits[*child_idx].branch_trace)
+                            .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                            .map(|child_branch_idx| {
+                                branches[child_branch_idx].visual.order_group
+                            })
+                    }))
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +715,91 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
+
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ
+                    .iter()
+                    .any(|(s, e)| start <= *e && end >= *s);
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +810,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:12:58] thinking

**Setting working directory**
[2025-09-21T21:12:58] exec bash -lc 'rg "find_position" src/graph.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:12:58] bash -lc 'rg "find_position" src/graph.rs' succeeded in 20ms:
        .find_position(|(b, _)| {
[2025-09-21T21:12:58] tokens used: 93,315
[2025-09-21T21:12:58] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..63cba7a6b2448184d28b004dbd358473c8f729ba
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,71 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| {
+                                branches[parent_branch_idx].visual.order_group
+                            })
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| {
+                        branches[target_branch_idx].visual.order_group
+                    })
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| commits[*head_idx].children.iter().find_map(|child| {
+                        indices
+                            .get(child)
+                            .and_then(|child_idx| commits[*child_idx].branch_trace)
+                            .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                            .map(|child_branch_idx| {
+                                branches[child_branch_idx].visual.order_group
+                            })
+                    }))
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +715,91 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
+
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ
+                    .iter()
+                    .any(|(s, e)| start <= *e && end >= *s);
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +810,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:13:04] thinking

**Checking usage of sorted_by_key**
[2025-09-21T21:13:04] exec bash -lc 'rg "sorted_by" src/graph.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:13:04] bash -lc 'rg "sorted_by" src/graph.rs' exited 1 in 20ms:

[2025-09-21T21:13:04] tokens used: 93,494
[2025-09-21T21:13:04] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..63cba7a6b2448184d28b004dbd358473c8f729ba
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,71 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| {
+                                branches[parent_branch_idx].visual.order_group
+                            })
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| {
+                        branches[target_branch_idx].visual.order_group
+                    })
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| commits[*head_idx].children.iter().find_map(|child| {
+                        indices
+                            .get(child)
+                            .and_then(|child_idx| commits[*child_idx].branch_trace)
+                            .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                            .map(|child_branch_idx| {
+                                branches[child_branch_idx].visual.order_group
+                            })
+                    }))
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +715,91 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
+
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ
+                    .iter()
+                    .any(|(s, e)| start <= *e && end >= *s);
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +810,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:13:17] thinking

**Updating debug output with source and target hints**
[2025-09-21T21:13:20] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -529,4 +529,14 @@
         for branch in &graph.branches {
+            let source_hint = branch
+                .visual
+                .source_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            let target_hint = branch
+                .visual
+                .target_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
             eprintln!(
-                "{} (col {}) ({:?}) {}",
+                "{} (col {}) ({:?}) {} s:{} t:{}",
                 branch.name,
@@ -534,3 +544,5 @@
                 branch.range,
-                if branch.is_merged { "m" } else { "" }
+                if branch.is_merged { "m" } else { "" },
+                source_hint,
+                target_hint,
             );
[2025-09-21T21:13:20] apply_patch(auto_approved=true) exited 0 in 24ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T21:13:20] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..63cba7a6b2448184d28b004dbd358473c8f729ba
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,71 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| {
+                                branches[parent_branch_idx].visual.order_group
+                            })
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| {
+                        branches[target_branch_idx].visual.order_group
+                    })
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| commits[*head_idx].children.iter().find_map(|child| {
+                        indices
+                            .get(child)
+                            .and_then(|child_idx| commits[*child_idx].branch_trace)
+                            .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                            .map(|child_branch_idx| {
+                                branches[child_branch_idx].visual.order_group
+                            })
+                    }))
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +715,91 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
+
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ
+                    .iter()
+                    .any(|(s, e)| start <= *e && end >= *s);
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +810,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/main.rs b/src/main.rs
index 8ab0613ec89b237b1e4b97bad578c1a7a577dca4..16d75d796b70804e01fd7d5f6726f60c817483fd
--- a/src/main.rs
+++ b/src/main.rs
@@ -527,12 +527,24 @@
 
     if settings.debug {
         for branch in &graph.branches {
+            let source_hint = branch
+                .visual
+                .source_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            let target_hint = branch
+                .visual
+                .target_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
             eprintln!(
-                "{} (col {}) ({:?}) {}",
+                "{} (col {}) ({:?}) {} s:{} t:{}",
                 branch.name,
                 branch.visual.column.unwrap_or(99),
                 branch.range,
-                if branch.is_merged { "m" } else { "" }
+                if branch.is_merged { "m" } else { "" },
+                source_hint,
+                target_hint,
             );
         }
     }
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings

[2025-09-21T21:13:20] tokens used: 94,504
[2025-09-21T21:13:20] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..63cba7a6b2448184d28b004dbd358473c8f729ba
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,71 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| {
+                                branches[parent_branch_idx].visual.order_group
+                            })
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| {
+                        branches[target_branch_idx].visual.order_group
+                    })
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| commits[*head_idx].children.iter().find_map(|child| {
+                        indices
+                            .get(child)
+                            .and_then(|child_idx| commits[*child_idx].branch_trace)
+                            .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                            .map(|child_branch_idx| {
+                                branches[child_branch_idx].visual.order_group
+                            })
+                    }))
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +715,91 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
+
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ
+                    .iter()
+                    .any(|(s, e)| start <= *e && end >= *s);
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +810,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/main.rs b/src/main.rs
index 8ab0613ec89b237b1e4b97bad578c1a7a577dca4..16d75d796b70804e01fd7d5f6726f60c817483fd
--- a/src/main.rs
+++ b/src/main.rs
@@ -527,12 +527,24 @@
 
     if settings.debug {
         for branch in &graph.branches {
+            let source_hint = branch
+                .visual
+                .source_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            let target_hint = branch
+                .visual
+                .target_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
             eprintln!(
-                "{} (col {}) ({:?}) {}",
+                "{} (col {}) ({:?}) {} s:{} t:{}",
                 branch.name,
                 branch.visual.column.unwrap_or(99),
                 branch.range,
-                if branch.is_merged { "m" } else { "" }
+                if branch.is_merged { "m" } else { "" },
+                source_hint,
+                target_hint,
             );
         }
     }
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:13:27] thinking

**Updating dead_code allowance in format.rs**
[2025-09-21T21:13:28] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/print/format.rs
@@ -75,3 +75,2 @@
 /// Format a commit for `CommitFormat::Format(String)`.
-#[allow(dead_code)]
 pub fn format_commit(
[2025-09-21T21:13:28] apply_patch(auto_approved=true) exited 0 in 37ms:
Success. Updated the following files:
M src/print/format.rs
[2025-09-21T21:13:28] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..63cba7a6b2448184d28b004dbd358473c8f729ba
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,71 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| {
+                                branches[parent_branch_idx].visual.order_group
+                            })
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| {
+                        branches[target_branch_idx].visual.order_group
+                    })
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| commits[*head_idx].children.iter().find_map(|child| {
+                        indices
+                            .get(child)
+                            .and_then(|child_idx| commits[*child_idx].branch_trace)
+                            .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                            .map(|child_branch_idx| {
+                                branches[child_branch_idx].visual.order_group
+                            })
+                    }))
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +715,91 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
+
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ
+                    .iter()
+                    .any(|(s, e)| start <= *e && end >= *s);
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +810,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/main.rs b/src/main.rs
index 8ab0613ec89b237b1e4b97bad578c1a7a577dca4..16d75d796b70804e01fd7d5f6726f60c817483fd
--- a/src/main.rs
+++ b/src/main.rs
@@ -527,12 +527,24 @@
 
     if settings.debug {
         for branch in &graph.branches {
+            let source_hint = branch
+                .visual
+                .source_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            let target_hint = branch
+                .visual
+                .target_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
             eprintln!(
-                "{} (col {}) ({:?}) {}",
+                "{} (col {}) ({:?}) {} s:{} t:{}",
                 branch.name,
                 branch.visual.column.unwrap_or(99),
                 branch.range,
-                if branch.is_merged { "m" } else { "" }
+                if branch.is_merged { "m" } else { "" },
+                source_hint,
+                target_hint,
             );
         }
     }
diff --git a/src/print/format.rs b/src/print/format.rs
index 3fc0a6d4e5784e588cb4525e8b35de967e7d26be..32827beb7bebe2d6a874f65e20cc2a170430d4e1
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -73,7 +73,6 @@
 }
 
 /// Format a commit for `CommitFormat::Format(String)`.
-#[allow(dead_code)]
 pub fn format_commit(
     format: &str,
     commit: &Commit,
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings

[2025-09-21T21:13:28] tokens used: 95,045
[2025-09-21T21:13:28] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..63cba7a6b2448184d28b004dbd358473c8f729ba
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,71 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| {
+                                branches[parent_branch_idx].visual.order_group
+                            })
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| {
+                        branches[target_branch_idx].visual.order_group
+                    })
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| commits[*head_idx].children.iter().find_map(|child| {
+                        indices
+                            .get(child)
+                            .and_then(|child_idx| commits[*child_idx].branch_trace)
+                            .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                            .map(|child_branch_idx| {
+                                branches[child_branch_idx].visual.order_group
+                            })
+                    }))
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +715,91 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
+
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ
+                    .iter()
+                    .any(|(s, e)| start <= *e && end >= *s);
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +810,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/main.rs b/src/main.rs
index 8ab0613ec89b237b1e4b97bad578c1a7a577dca4..16d75d796b70804e01fd7d5f6726f60c817483fd
--- a/src/main.rs
+++ b/src/main.rs
@@ -527,12 +527,24 @@
 
     if settings.debug {
         for branch in &graph.branches {
+            let source_hint = branch
+                .visual
+                .source_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            let target_hint = branch
+                .visual
+                .target_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
             eprintln!(
-                "{} (col {}) ({:?}) {}",
+                "{} (col {}) ({:?}) {} s:{} t:{}",
                 branch.name,
                 branch.visual.column.unwrap_or(99),
                 branch.range,
-                if branch.is_merged { "m" } else { "" }
+                if branch.is_merged { "m" } else { "" },
+                source_hint,
+                target_hint,
             );
         }
     }
diff --git a/src/print/format.rs b/src/print/format.rs
index 3fc0a6d4e5784e588cb4525e8b35de967e7d26be..32827beb7bebe2d6a874f65e20cc2a170430d4e1
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -73,7 +73,6 @@
 }
 
 /// Format a commit for `CommitFormat::Format(String)`.
-#[allow(dead_code)]
 pub fn format_commit(
     format: &str,
     commit: &Commit,
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:13:38] thinking

**Reviewing code for compilation and formatting**
[2025-09-21T21:13:38] exec bash -lc 'cargo fmt' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:13:38] bash -lc 'cargo fmt' succeeded in 64ms:

[2025-09-21T21:13:38] tokens used: 95,641
[2025-09-21T21:13:38] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..df21cbb684356a38c3e52d9737bd195033529b65
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,69 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| branches[target_branch_idx].visual.order_group)
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| {
+                        commits[*head_idx].children.iter().find_map(|child| {
+                            indices
+                                .get(child)
+                                .and_then(|child_idx| commits[*child_idx].branch_trace)
+                                .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                                .map(|child_branch_idx| {
+                                    branches[child_branch_idx].visual.order_group
+                                })
+                        })
+                    })
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +713,89 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ.iter().any(|(s, e)| start <= *e && end >= *s);
+
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +806,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/main.rs b/src/main.rs
index 8ab0613ec89b237b1e4b97bad578c1a7a577dca4..16d75d796b70804e01fd7d5f6726f60c817483fd
--- a/src/main.rs
+++ b/src/main.rs
@@ -527,12 +527,24 @@
 
     if settings.debug {
         for branch in &graph.branches {
+            let source_hint = branch
+                .visual
+                .source_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            let target_hint = branch
+                .visual
+                .target_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
             eprintln!(
-                "{} (col {}) ({:?}) {}",
+                "{} (col {}) ({:?}) {} s:{} t:{}",
                 branch.name,
                 branch.visual.column.unwrap_or(99),
                 branch.range,
-                if branch.is_merged { "m" } else { "" }
+                if branch.is_merged { "m" } else { "" },
+                source_hint,
+                target_hint,
             );
         }
     }
diff --git a/src/print/format.rs b/src/print/format.rs
index 3fc0a6d4e5784e588cb4525e8b35de967e7d26be..32827beb7bebe2d6a874f65e20cc2a170430d4e1
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -73,7 +73,6 @@
 }
 
 /// Format a commit for `CommitFormat::Format(String)`.
-#[allow(dead_code)]
 pub fn format_commit(
     format: &str,
     commit: &Commit,
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:13:42] thinking

**Checking git diff output**
[2025-09-21T21:13:43] exec bash -lc 'git diff' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:13:43] bash -lc 'git diff' succeeded in 25ms:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e..df21cbb 100644
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@ use crate::settings::{BranchOrder, BranchSettings, MergePatterns, Settings};
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@ impl GitGraph {
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
[2025-09-21T21:13:43] tokens used: 95,843
[2025-09-21T21:13:43] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..df21cbb684356a38c3e52d9737bd195033529b65
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,69 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| branches[target_branch_idx].visual.order_group)
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| {
+                        commits[*head_idx].children.iter().find_map(|child| {
+                            indices
+                                .get(child)
+                                .and_then(|child_idx| commits[*child_idx].branch_trace)
+                                .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                                .map(|child_branch_idx| {
+                                    branches[child_branch_idx].visual.order_group
+                                })
+                        })
+                    })
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +713,89 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ.iter().any(|(s, e)| start <= *e && end >= *s);
+
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +806,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/main.rs b/src/main.rs
index 8ab0613ec89b237b1e4b97bad578c1a7a577dca4..16d75d796b70804e01fd7d5f6726f60c817483fd
--- a/src/main.rs
+++ b/src/main.rs
@@ -527,12 +527,24 @@
 
     if settings.debug {
         for branch in &graph.branches {
+            let source_hint = branch
+                .visual
+                .source_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            let target_hint = branch
+                .visual
+                .target_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
             eprintln!(
-                "{} (col {}) ({:?}) {}",
+                "{} (col {}) ({:?}) {} s:{} t:{}",
                 branch.name,
                 branch.visual.column.unwrap_or(99),
                 branch.range,
-                if branch.is_merged { "m" } else { "" }
+                if branch.is_merged { "m" } else { "" },
+                source_hint,
+                target_hint,
             );
         }
     }
diff --git a/src/print/format.rs b/src/print/format.rs
index 3fc0a6d4e5784e588cb4525e8b35de967e7d26be..32827beb7bebe2d6a874f65e20cc2a170430d4e1
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -73,7 +73,6 @@
 }
 
 /// Format a commit for `CommitFormat::Format(String)`.
-#[allow(dead_code)]
 pub fn format_commit(
     format: &str,
     commit: &Commit,
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:13:54] thinking

**Verifying code changes and edge cases**
[2025-09-21T21:13:54] exec bash -lc 'rg "VecDeque" -n src/graph.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:13:54] bash -lc 'rg "VecDeque" -n src/graph.rs' exited 1 in 15ms:

[2025-09-21T21:13:54] tokens used: 98,805
[2025-09-21T21:13:54] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..df21cbb684356a38c3e52d9737bd195033529b65
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,69 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| branches[target_branch_idx].visual.order_group)
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| {
+                        commits[*head_idx].children.iter().find_map(|child| {
+                            indices
+                                .get(child)
+                                .and_then(|child_idx| commits[*child_idx].branch_trace)
+                                .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                                .map(|child_branch_idx| {
+                                    branches[child_branch_idx].visual.order_group
+                                })
+                        })
+                    })
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +713,89 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ.iter().any(|(s, e)| start <= *e && end >= *s);
+
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +806,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/main.rs b/src/main.rs
index 8ab0613ec89b237b1e4b97bad578c1a7a577dca4..16d75d796b70804e01fd7d5f6726f60c817483fd
--- a/src/main.rs
+++ b/src/main.rs
@@ -527,12 +527,24 @@
 
     if settings.debug {
         for branch in &graph.branches {
+            let source_hint = branch
+                .visual
+                .source_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            let target_hint = branch
+                .visual
+                .target_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
             eprintln!(
-                "{} (col {}) ({:?}) {}",
+                "{} (col {}) ({:?}) {} s:{} t:{}",
                 branch.name,
                 branch.visual.column.unwrap_or(99),
                 branch.range,
-                if branch.is_merged { "m" } else { "" }
+                if branch.is_merged { "m" } else { "" },
+                source_hint,
+                target_hint,
             );
         }
     }
diff --git a/src/print/format.rs b/src/print/format.rs
index 3fc0a6d4e5784e588cb4525e8b35de967e7d26be..32827beb7bebe2d6a874f65e20cc2a170430d4e1
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -73,7 +73,6 @@
 }
 
 /// Format a commit for `CommitFormat::Format(String)`.
-#[allow(dead_code)]
 pub fn format_commit(
     format: &str,
     commit: &Commit,
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:14:01] thinking

**Checking for leftover sorted_by_key calls**
[2025-09-21T21:14:01] exec bash -lc 'rg "sorted_by" -n src/graph.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:14:01] bash -lc 'rg "sorted_by" -n src/graph.rs' exited 1 in 13ms:

[2025-09-21T21:14:01] tokens used: 98,950
[2025-09-21T21:14:01] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..df21cbb684356a38c3e52d9737bd195033529b65
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,69 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| branches[target_branch_idx].visual.order_group)
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| {
+                        commits[*head_idx].children.iter().find_map(|child| {
+                            indices
+                                .get(child)
+                                .and_then(|child_idx| commits[*child_idx].branch_trace)
+                                .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                                .map(|child_branch_idx| {
+                                    branches[child_branch_idx].visual.order_group
+                                })
+                        })
+                    })
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +713,89 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ.iter().any(|(s, e)| start <= *e && end >= *s);
+
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +806,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/main.rs b/src/main.rs
index 8ab0613ec89b237b1e4b97bad578c1a7a577dca4..16d75d796b70804e01fd7d5f6726f60c817483fd
--- a/src/main.rs
+++ b/src/main.rs
@@ -527,12 +527,24 @@
 
     if settings.debug {
         for branch in &graph.branches {
+            let source_hint = branch
+                .visual
+                .source_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            let target_hint = branch
+                .visual
+                .target_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
             eprintln!(
-                "{} (col {}) ({:?}) {}",
+                "{} (col {}) ({:?}) {} s:{} t:{}",
                 branch.name,
                 branch.visual.column.unwrap_or(99),
                 branch.range,
-                if branch.is_merged { "m" } else { "" }
+                if branch.is_merged { "m" } else { "" },
+                source_hint,
+                target_hint,
             );
         }
     }
diff --git a/src/print/format.rs b/src/print/format.rs
index 3fc0a6d4e5784e588cb4525e8b35de967e7d26be..32827beb7bebe2d6a874f65e20cc2a170430d4e1
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -73,7 +73,6 @@
 }
 
 /// Format a commit for `CommitFormat::Format(String)`.
-#[allow(dead_code)]
 pub fn format_commit(
     format: &str,
     commit: &Commit,
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:14:08] thinking

**Confirming imports and preparing tests**
[2025-09-21T21:14:10] exec bash -lc 'cargo test' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:14:20] bash -lc 'cargo test' exited 124 in 10.00s:
    Updating crates.io index
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
[2025-09-21T21:14:20] tokens used: 99,160
[2025-09-21T21:14:20] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..df21cbb684356a38c3e52d9737bd195033529b65
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,69 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| branches[target_branch_idx].visual.order_group)
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| {
+                        commits[*head_idx].children.iter().find_map(|child| {
+                            indices
+                                .get(child)
+                                .and_then(|child_idx| commits[*child_idx].branch_trace)
+                                .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                                .map(|child_branch_idx| {
+                                    branches[child_branch_idx].visual.order_group
+                                })
+                        })
+                    })
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +713,89 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ.iter().any(|(s, e)| start <= *e && end >= *s);
+
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +806,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/main.rs b/src/main.rs
index 8ab0613ec89b237b1e4b97bad578c1a7a577dca4..16d75d796b70804e01fd7d5f6726f60c817483fd
--- a/src/main.rs
+++ b/src/main.rs
@@ -527,12 +527,24 @@
 
     if settings.debug {
         for branch in &graph.branches {
+            let source_hint = branch
+                .visual
+                .source_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            let target_hint = branch
+                .visual
+                .target_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
             eprintln!(
-                "{} (col {}) ({:?}) {}",
+                "{} (col {}) ({:?}) {} s:{} t:{}",
                 branch.name,
                 branch.visual.column.unwrap_or(99),
                 branch.range,
-                if branch.is_merged { "m" } else { "" }
+                if branch.is_merged { "m" } else { "" },
+                source_hint,
+                target_hint,
             );
         }
     }
diff --git a/src/print/format.rs b/src/print/format.rs
index 3fc0a6d4e5784e588cb4525e8b35de967e7d26be..32827beb7bebe2d6a874f65e20cc2a170430d4e1
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -73,7 +73,6 @@
 }
 
 /// Format a commit for `CommitFormat::Format(String)`.
-#[allow(dead_code)]
 pub fn format_commit(
     format: &str,
     commit: &Commit,
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:14:25] thinking

**Retrying tests offline**
[2025-09-21T21:14:25] exec bash -lc 'cargo test --offline' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:14:26] bash -lc 'cargo test --offline' exited -1 in 0ms:
error: no matching package named `matches` found
location searched: crates.io index
required by package `url v2.2.0`
    ... which satisfies dependency `url = "^2.0"` (locked to 2.2.0) of package `git2 v0.13.12`
    ... which satisfies dependency `git2 = "^0.13"` (locked to 0.13.12) of package `git-graph v0.1.6 (/Users/jqwang/104-CommitLens-codex/.workspace/rust-project)`
As a reminder, you're using offline mode (--offline) which can sometimes cause surprising resolution failures, if this error is too confusing you may wish to retry without `--offline`.
[2025-09-21T21:14:26] tokens used: 99,897
[2025-09-21T21:14:26] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..df21cbb684356a38c3e52d9737bd195033529b65
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,69 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| branches[target_branch_idx].visual.order_group)
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| {
+                        commits[*head_idx].children.iter().find_map(|child| {
+                            indices
+                                .get(child)
+                                .and_then(|child_idx| commits[*child_idx].branch_trace)
+                                .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                                .map(|child_branch_idx| {
+                                    branches[child_branch_idx].visual.order_group
+                                })
+                        })
+                    })
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +713,89 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ.iter().any(|(s, e)| start <= *e && end >= *s);
+
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +806,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/main.rs b/src/main.rs
index 8ab0613ec89b237b1e4b97bad578c1a7a577dca4..16d75d796b70804e01fd7d5f6726f60c817483fd
--- a/src/main.rs
+++ b/src/main.rs
@@ -527,12 +527,24 @@
 
     if settings.debug {
         for branch in &graph.branches {
+            let source_hint = branch
+                .visual
+                .source_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            let target_hint = branch
+                .visual
+                .target_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
             eprintln!(
-                "{} (col {}) ({:?}) {}",
+                "{} (col {}) ({:?}) {} s:{} t:{}",
                 branch.name,
                 branch.visual.column.unwrap_or(99),
                 branch.range,
-                if branch.is_merged { "m" } else { "" }
+                if branch.is_merged { "m" } else { "" },
+                source_hint,
+                target_hint,
             );
         }
     }
diff --git a/src/print/format.rs b/src/print/format.rs
index 3fc0a6d4e5784e588cb4525e8b35de967e7d26be..32827beb7bebe2d6a874f65e20cc2a170430d4e1
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -73,7 +73,6 @@
 }
 
 /// Format a commit for `CommitFormat::Format(String)`.
-#[allow(dead_code)]
 pub fn format_commit(
     format: &str,
     commit: &Commit,
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:14:31] thinking

**Checking git status after offline failure**
[2025-09-21T21:14:31] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:14:31] bash -lc 'git status -sb' succeeded in 35ms:
## main
 M src/graph.rs
 M src/main.rs
 M src/print/format.rs
 M src/settings.rs
[2025-09-21T21:14:31] tokens used: 100,312
[2025-09-21T21:14:31] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..df21cbb684356a38c3e52d9737bd195033529b65
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,69 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| branches[target_branch_idx].visual.order_group)
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| {
+                        commits[*head_idx].children.iter().find_map(|child| {
+                            indices
+                                .get(child)
+                                .and_then(|child_idx| commits[*child_idx].branch_trace)
+                                .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                                .map(|child_branch_idx| {
+                                    branches[child_branch_idx].visual.order_group
+                                })
+                        })
+                    })
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +713,89 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ.iter().any(|(s, e)| start <= *e && end >= *s);
+
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +806,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/main.rs b/src/main.rs
index 8ab0613ec89b237b1e4b97bad578c1a7a577dca4..16d75d796b70804e01fd7d5f6726f60c817483fd
--- a/src/main.rs
+++ b/src/main.rs
@@ -527,12 +527,24 @@
 
     if settings.debug {
         for branch in &graph.branches {
+            let source_hint = branch
+                .visual
+                .source_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            let target_hint = branch
+                .visual
+                .target_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
             eprintln!(
-                "{} (col {}) ({:?}) {}",
+                "{} (col {}) ({:?}) {} s:{} t:{}",
                 branch.name,
                 branch.visual.column.unwrap_or(99),
                 branch.range,
-                if branch.is_merged { "m" } else { "" }
+                if branch.is_merged { "m" } else { "" },
+                source_hint,
+                target_hint,
             );
         }
     }
diff --git a/src/print/format.rs b/src/print/format.rs
index 3fc0a6d4e5784e588cb4525e8b35de967e7d26be..32827beb7bebe2d6a874f65e20cc2a170430d4e1
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -73,7 +73,6 @@
 }
 
 /// Format a commit for `CommitFormat::Format(String)`.
-#[allow(dead_code)]
 pub fn format_commit(
     format: &str,
     commit: &Commit,
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:14:44] thinking

**Reviewing function details before commit**

I'm carefully verifying the `assign_sources_targets` function to confirm vector sizes and safe indexing, checking the use of `cmp` and `VecDeque` removals, and making sure all imports are correct. I'll note some test failures caused by missing offline crates and prepare to stage all changes before committing.
[2025-09-21T21:14:45] exec bash -lc 'git add -A' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:14:45] bash -lc 'git add -A' succeeded in 31ms:

[2025-09-21T21:14:45] tokens used: 101,091
[2025-09-21T21:14:45] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..df21cbb684356a38c3e52d9737bd195033529b65
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,69 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| branches[target_branch_idx].visual.order_group)
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| {
+                        commits[*head_idx].children.iter().find_map(|child| {
+                            indices
+                                .get(child)
+                                .and_then(|child_idx| commits[*child_idx].branch_trace)
+                                .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                                .map(|child_branch_idx| {
+                                    branches[child_branch_idx].visual.order_group
+                                })
+                        })
+                    })
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +713,89 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ.iter().any(|(s, e)| start <= *e && end >= *s);
+
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +806,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/main.rs b/src/main.rs
index 8ab0613ec89b237b1e4b97bad578c1a7a577dca4..16d75d796b70804e01fd7d5f6726f60c817483fd
--- a/src/main.rs
+++ b/src/main.rs
@@ -527,12 +527,24 @@
 
     if settings.debug {
         for branch in &graph.branches {
+            let source_hint = branch
+                .visual
+                .source_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            let target_hint = branch
+                .visual
+                .target_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
             eprintln!(
-                "{} (col {}) ({:?}) {}",
+                "{} (col {}) ({:?}) {} s:{} t:{}",
                 branch.name,
                 branch.visual.column.unwrap_or(99),
                 branch.range,
-                if branch.is_merged { "m" } else { "" }
+                if branch.is_merged { "m" } else { "" },
+                source_hint,
+                target_hint,
             );
         }
     }
diff --git a/src/print/format.rs b/src/print/format.rs
index 3fc0a6d4e5784e588cb4525e8b35de967e7d26be..32827beb7bebe2d6a874f65e20cc2a170430d4e1
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -73,7 +73,6 @@
 }
 
 /// Format a commit for `CommitFormat::Format(String)`.
-#[allow(dead_code)]
 pub fn format_commit(
     format: &str,
     commit: &Commit,
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings

[2025-09-21T21:14:51] exec bash -lc "git commit -m '075-e956827：复现提交代码内容。'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:14:51] bash -lc "git commit -m '075-e956827：复现提交代码内容。'" succeeded in 49ms:
[main 9baba6f] 075-e956827：复现提交代码内容。
 4 files changed, 150 insertions(+), 156 deletions(-)
[2025-09-21T21:14:51] tokens used: 101,338
[2025-09-21T21:14:51] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..df21cbb684356a38c3e52d9737bd195033529b65
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,69 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| branches[target_branch_idx].visual.order_group)
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| {
+                        commits[*head_idx].children.iter().find_map(|child| {
+                            indices
+                                .get(child)
+                                .and_then(|child_idx| commits[*child_idx].branch_trace)
+                                .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                                .map(|child_branch_idx| {
+                                    branches[child_branch_idx].visual.order_group
+                                })
+                        })
+                    })
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +713,89 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ.iter().any(|(s, e)| start <= *e && end >= *s);
+
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +806,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/main.rs b/src/main.rs
index 8ab0613ec89b237b1e4b97bad578c1a7a577dca4..16d75d796b70804e01fd7d5f6726f60c817483fd
--- a/src/main.rs
+++ b/src/main.rs
@@ -527,12 +527,24 @@
 
     if settings.debug {
         for branch in &graph.branches {
+            let source_hint = branch
+                .visual
+                .source_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            let target_hint = branch
+                .visual
+                .target_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
             eprintln!(
-                "{} (col {}) ({:?}) {}",
+                "{} (col {}) ({:?}) {} s:{} t:{}",
                 branch.name,
                 branch.visual.column.unwrap_or(99),
                 branch.range,
-                if branch.is_merged { "m" } else { "" }
+                if branch.is_merged { "m" } else { "" },
+                source_hint,
+                target_hint,
             );
         }
     }
diff --git a/src/print/format.rs b/src/print/format.rs
index 3fc0a6d4e5784e588cb4525e8b35de967e7d26be..32827beb7bebe2d6a874f65e20cc2a170430d4e1
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -73,7 +73,6 @@
 }
 
 /// Format a commit for `CommitFormat::Format(String)`.
-#[allow(dead_code)]
 pub fn format_commit(
     format: &str,
     commit: &Commit,
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:14:57] thinking

**Checking repository cleanliness**
[2025-09-21T21:14:57] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:14:57] bash -lc 'git status -sb' succeeded in 31ms:
## main
[2025-09-21T21:14:57] tokens used: 101,593
[2025-09-21T21:14:57] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..df21cbb684356a38c3e52d9737bd195033529b65
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,69 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| branches[target_branch_idx].visual.order_group)
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| {
+                        commits[*head_idx].children.iter().find_map(|child| {
+                            indices
+                                .get(child)
+                                .and_then(|child_idx| commits[*child_idx].branch_trace)
+                                .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                                .map(|child_branch_idx| {
+                                    branches[child_branch_idx].visual.order_group
+                                })
+                        })
+                    })
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +713,89 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ.iter().any(|(s, e)| start <= *e && end >= *s);
+
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +806,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/main.rs b/src/main.rs
index 8ab0613ec89b237b1e4b97bad578c1a7a577dca4..16d75d796b70804e01fd7d5f6726f60c817483fd
--- a/src/main.rs
+++ b/src/main.rs
@@ -527,12 +527,24 @@
 
     if settings.debug {
         for branch in &graph.branches {
+            let source_hint = branch
+                .visual
+                .source_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            let target_hint = branch
+                .visual
+                .target_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
             eprintln!(
-                "{} (col {}) ({:?}) {}",
+                "{} (col {}) ({:?}) {} s:{} t:{}",
                 branch.name,
                 branch.visual.column.unwrap_or(99),
                 branch.range,
-                if branch.is_merged { "m" } else { "" }
+                if branch.is_merged { "m" } else { "" },
+                source_hint,
+                target_hint,
             );
         }
     }
diff --git a/src/print/format.rs b/src/print/format.rs
index 3fc0a6d4e5784e588cb4525e8b35de967e7d26be..32827beb7bebe2d6a874f65e20cc2a170430d4e1
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -73,7 +73,6 @@
 }
 
 /// Format a commit for `CommitFormat::Format(String)`.
-#[allow(dead_code)]
 pub fn format_commit(
     format: &str,
     commit: &Commit,
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:15:11] thinking

**Organizing final response details**
[2025-09-21T21:15:12] exec bash -lc "nl -ba src/graph.rs | sed -n '220,320p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:15:12] bash -lc "nl -ba src/graph.rs | sed -n '220,320p'" succeeded in 27ms:
   220	            is_remote,
   221	            is_merged,
   222	            is_tag,
   223	            visual,
   224	            range: (end_index, None),
   225	        }
   226	    }
   227	}
   228	
   229	/// Branch properties for visualization.
   230	pub struct BranchVis {
   231	    /// The branch's column group (left to right)
   232	    pub order_group: usize,
   233	    /// The order group of the merge target (if available)
   234	    pub target_order_group: Option<usize>,
   235	    /// The order group of the branch this branch originates from (if available)
   236	    pub source_order_group: Option<usize>,
   237	    /// The branch's terminal color (index in 256-color palette)
   238	    pub term_color: u8,
   239	    /// SVG color (name or RGB in hex annotation)
[2025-09-21T21:15:12] tokens used: 102,205
[2025-09-21T21:15:12] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..df21cbb684356a38c3e52d9737bd195033529b65
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,69 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| branches[target_branch_idx].visual.order_group)
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| {
+                        commits[*head_idx].children.iter().find_map(|child| {
+                            indices
+                                .get(child)
+                                .and_then(|child_idx| commits[*child_idx].branch_trace)
+                                .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                                .map(|child_branch_idx| {
+                                    branches[child_branch_idx].visual.order_group
+                                })
+                        })
+                    })
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +713,89 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ.iter().any(|(s, e)| start <= *e && end >= *s);
+
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +806,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/main.rs b/src/main.rs
index 8ab0613ec89b237b1e4b97bad578c1a7a577dca4..16d75d796b70804e01fd7d5f6726f60c817483fd
--- a/src/main.rs
+++ b/src/main.rs
@@ -527,12 +527,24 @@
 
     if settings.debug {
         for branch in &graph.branches {
+            let source_hint = branch
+                .visual
+                .source_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            let target_hint = branch
+                .visual
+                .target_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
             eprintln!(
-                "{} (col {}) ({:?}) {}",
+                "{} (col {}) ({:?}) {} s:{} t:{}",
                 branch.name,
                 branch.visual.column.unwrap_or(99),
                 branch.range,
-                if branch.is_merged { "m" } else { "" }
+                if branch.is_merged { "m" } else { "" },
+                source_hint,
+                target_hint,
             );
         }
     }
diff --git a/src/print/format.rs b/src/print/format.rs
index 3fc0a6d4e5784e588cb4525e8b35de967e7d26be..32827beb7bebe2d6a874f65e20cc2a170430d4e1
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -73,7 +73,6 @@
 }
 
 /// Format a commit for `CommitFormat::Format(String)`.
-#[allow(dead_code)]
 pub fn format_commit(
     format: &str,
     commit: &Commit,
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:15:17] thinking

**Locating new function definitions**
[2025-09-21T21:15:18] exec bash -lc "nl -ba src/graph.rs | sed -n '620,760p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:15:18] bash -lc "nl -ba src/graph.rs | sed -n '620,760p'" succeeded in 14ms:
   620	            }
   621	        }
   622	    }
   623	
   624	    let branch = &mut branches[branch_index];
   625	    if let Some(end) = branch.range.0 {
   626	        if let Some(start_index) = start_index {
   627	            if start_index < end as i32 {
   628	                // TODO: find a better solution (bool field?) to identify non-deleted branches that were not assigned to any commits, and thus should not occupy a column.
   629	                branch.range = (None, None);
   630	            } else {
   631	                branch.range = (branch.range.0, Some(start_index as usize));
   632	            }
   633	        } else {
   634	            branch.range = (branch.range.0, None);
   635	        }
   636	    } else {
   637	        branch.range = (branch.range.0, start_index.map(|si| si as usize));
   638	    }
   639	    Ok(any_assigned)
[2025-09-21T21:15:18] tokens used: 103,667
[2025-09-21T21:15:18] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..df21cbb684356a38c3e52d9737bd195033529b65
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,69 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| branches[target_branch_idx].visual.order_group)
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| {
+                        commits[*head_idx].children.iter().find_map(|child| {
+                            indices
+                                .get(child)
+                                .and_then(|child_idx| commits[*child_idx].branch_trace)
+                                .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                                .map(|child_branch_idx| {
+                                    branches[child_branch_idx].visual.order_group
+                                })
+                        })
+                    })
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +713,89 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ.iter().any(|(s, e)| start <= *e && end >= *s);
+
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +806,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/main.rs b/src/main.rs
index 8ab0613ec89b237b1e4b97bad578c1a7a577dca4..16d75d796b70804e01fd7d5f6726f60c817483fd
--- a/src/main.rs
+++ b/src/main.rs
@@ -527,12 +527,24 @@
 
     if settings.debug {
         for branch in &graph.branches {
+            let source_hint = branch
+                .visual
+                .source_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            let target_hint = branch
+                .visual
+                .target_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
             eprintln!(
-                "{} (col {}) ({:?}) {}",
+                "{} (col {}) ({:?}) {} s:{} t:{}",
                 branch.name,
                 branch.visual.column.unwrap_or(99),
                 branch.range,
-                if branch.is_merged { "m" } else { "" }
+                if branch.is_merged { "m" } else { "" },
+                source_hint,
+                target_hint,
             );
         }
     }
diff --git a/src/print/format.rs b/src/print/format.rs
index 3fc0a6d4e5784e588cb4525e8b35de967e7d26be..32827beb7bebe2d6a874f65e20cc2a170430d4e1
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -73,7 +73,6 @@
 }
 
 /// Format a commit for `CommitFormat::Format(String)`.
-#[allow(dead_code)]
 pub fn format_commit(
     format: &str,
     commit: &Commit,
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:15:25] thinking

**Tracking line numbers for debugging**
[2025-09-21T21:15:26] exec bash -lc "nl -ba src/main.rs | sed -n '500,560p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:15:26] bash -lc "nl -ba src/main.rs | sed -n '500,560p'" succeeded in 14ms:
   500	        let models = [
   501	            (BranchSettingsDef::git_flow(), "git-flow.toml"),
   502	            (BranchSettingsDef::simple(), "simple.toml"),
   503	            (BranchSettingsDef::none(), "none.toml"),
   504	        ];
   505	        for (model, file) in &models {
   506	            let mut path = PathBuf::from(&models_dir);
   507	            path.push(file);
   508	            let str = toml::to_string_pretty(&model).map_err(|err| err.to_string())?;
   509	            std::fs::write(&path, str).map_err(|err| err.to_string())?;
   510	        }
   511	    }
   512	
   513	    Ok(())
   514	}
   515	
   516	fn run(
   517	    repository: Repository,
   518	    settings: &Settings,
   519	    svg: bool,
[2025-09-21T21:15:26] tokens used: 105,718
[2025-09-21T21:15:26] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..df21cbb684356a38c3e52d9737bd195033529b65
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,69 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| branches[target_branch_idx].visual.order_group)
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| {
+                        commits[*head_idx].children.iter().find_map(|child| {
+                            indices
+                                .get(child)
+                                .and_then(|child_idx| commits[*child_idx].branch_trace)
+                                .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                                .map(|child_branch_idx| {
+                                    branches[child_branch_idx].visual.order_group
+                                })
+                        })
+                    })
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +713,89 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ.iter().any(|(s, e)| start <= *e && end >= *s);
+
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +806,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/main.rs b/src/main.rs
index 8ab0613ec89b237b1e4b97bad578c1a7a577dca4..16d75d796b70804e01fd7d5f6726f60c817483fd
--- a/src/main.rs
+++ b/src/main.rs
@@ -527,12 +527,24 @@
 
     if settings.debug {
         for branch in &graph.branches {
+            let source_hint = branch
+                .visual
+                .source_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            let target_hint = branch
+                .visual
+                .target_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
             eprintln!(
-                "{} (col {}) ({:?}) {}",
+                "{} (col {}) ({:?}) {} s:{} t:{}",
                 branch.name,
                 branch.visual.column.unwrap_or(99),
                 branch.range,
-                if branch.is_merged { "m" } else { "" }
+                if branch.is_merged { "m" } else { "" },
+                source_hint,
+                target_hint,
             );
         }
     }
diff --git a/src/print/format.rs b/src/print/format.rs
index 3fc0a6d4e5784e588cb4525e8b35de967e7d26be..32827beb7bebe2d6a874f65e20cc2a170430d4e1
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -73,7 +73,6 @@
 }
 
 /// Format a commit for `CommitFormat::Format(String)`.
-#[allow(dead_code)]
 pub fn format_commit(
     format: &str,
     commit: &Commit,
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:15:31] thinking

**Checking line numbers in settings.rs**
[2025-09-21T21:15:31] exec bash -lc "nl -ba src/settings.rs | sed -n '10,80p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:15:31] bash -lc "nl -ba src/settings.rs | sed -n '10,80p'" succeeded in 31ms:
    10	#[derive(Serialize, Deserialize)]
    11	pub struct RepoSettings {
    12	    /// The repository's branching model
    13	    pub model: String,
    14	}
    15	
    16	/// Ordering policy for branches in visual columns.
    17	pub enum BranchOrder {
    18	    /// Recommended! Shortest branches are inserted left-most.
    19	    ///
    20	    /// For branches with equal length, branches ending last are inserted first.
    21	    /// Reverse (arg = false): Branches ending first are inserted first.
    22	    ShortestFirst(bool),
    23	    /// Longest branches are inserted left-most.
    24	    ///
    25	    /// For branches with equal length, branches ending last are inserted first.
    26	    /// Reverse (arg = false): Branches ending first are inserted first.
    27	    LongestFirst(bool),
    28	}
    29	
[2025-09-21T21:15:31] tokens used: 106,734
[2025-09-21T21:15:31] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..df21cbb684356a38c3e52d9737bd195033529b65
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,69 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| branches[target_branch_idx].visual.order_group)
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| {
+                        commits[*head_idx].children.iter().find_map(|child| {
+                            indices
+                                .get(child)
+                                .and_then(|child_idx| commits[*child_idx].branch_trace)
+                                .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                                .map(|child_branch_idx| {
+                                    branches[child_branch_idx].visual.order_group
+                                })
+                        })
+                    })
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +713,89 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ.iter().any(|(s, e)| start <= *e && end >= *s);
+
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +806,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/main.rs b/src/main.rs
index 8ab0613ec89b237b1e4b97bad578c1a7a577dca4..16d75d796b70804e01fd7d5f6726f60c817483fd
--- a/src/main.rs
+++ b/src/main.rs
@@ -527,12 +527,24 @@
 
     if settings.debug {
         for branch in &graph.branches {
+            let source_hint = branch
+                .visual
+                .source_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            let target_hint = branch
+                .visual
+                .target_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
             eprintln!(
-                "{} (col {}) ({:?}) {}",
+                "{} (col {}) ({:?}) {} s:{} t:{}",
                 branch.name,
                 branch.visual.column.unwrap_or(99),
                 branch.range,
-                if branch.is_merged { "m" } else { "" }
+                if branch.is_merged { "m" } else { "" },
+                source_hint,
+                target_hint,
             );
         }
     }
diff --git a/src/print/format.rs b/src/print/format.rs
index 3fc0a6d4e5784e588cb4525e8b35de967e7d26be..32827beb7bebe2d6a874f65e20cc2a170430d4e1
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -73,7 +73,6 @@
 }
 
 /// Format a commit for `CommitFormat::Format(String)`.
-#[allow(dead_code)]
 pub fn format_commit(
     format: &str,
     commit: &Commit,
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:15:39] thinking

**Locating attribute removal in format.rs**
[2025-09-21T21:15:40] exec bash -lc "nl -ba src/print/format.rs | sed -n '60,120p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:15:40] bash -lc "nl -ba src/print/format.rs | sed -n '60,120p'" succeeded in 24ms:
    60	            "B",
    61	        ];
    62	        base.iter()
    63	            .map(|b| {
    64	                [
    65	                    format!("%{}", b),
    66	                    format!("% {}", b),
    67	                    format!("%+{}", b),
    68	                    format!("%-{}", b),
    69	                ]
    70	            })
    71	            .collect()
    72	    };
    73	}
    74	
    75	/// Format a commit for `CommitFormat::Format(String)`.
    76	pub fn format_commit(
    77	    format: &str,
    78	    commit: &Commit,
    79	    branches: String,
[2025-09-21T21:15:40] tokens used: 107,799
[2025-09-21T21:15:40] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..df21cbb684356a38c3e52d9737bd195033529b65
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,69 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| branches[target_branch_idx].visual.order_group)
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| {
+                        commits[*head_idx].children.iter().find_map(|child| {
+                            indices
+                                .get(child)
+                                .and_then(|child_idx| commits[*child_idx].branch_trace)
+                                .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                                .map(|child_branch_idx| {
+                                    branches[child_branch_idx].visual.order_group
+                                })
+                        })
+                    })
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +713,89 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ.iter().any(|(s, e)| start <= *e && end >= *s);
+
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +806,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/main.rs b/src/main.rs
index 8ab0613ec89b237b1e4b97bad578c1a7a577dca4..16d75d796b70804e01fd7d5f6726f60c817483fd
--- a/src/main.rs
+++ b/src/main.rs
@@ -527,12 +527,24 @@
 
     if settings.debug {
         for branch in &graph.branches {
+            let source_hint = branch
+                .visual
+                .source_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            let target_hint = branch
+                .visual
+                .target_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
             eprintln!(
-                "{} (col {}) ({:?}) {}",
+                "{} (col {}) ({:?}) {} s:{} t:{}",
                 branch.name,
                 branch.visual.column.unwrap_or(99),
                 branch.range,
-                if branch.is_merged { "m" } else { "" }
+                if branch.is_merged { "m" } else { "" },
+                source_hint,
+                target_hint,
             );
         }
     }
diff --git a/src/print/format.rs b/src/print/format.rs
index 3fc0a6d4e5784e588cb4525e8b35de967e7d26be..32827beb7bebe2d6a874f65e20cc2a170430d4e1
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -73,7 +73,6 @@
 }
 
 /// Format a commit for `CommitFormat::Format(String)`.
-#[allow(dead_code)]
 pub fn format_commit(
     format: &str,
     commit: &Commit,
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


[2025-09-21T21:16:04] thinking

**Structuring final response and test notes**

I’m organizing the final summary with clear sections referencing specific lines like `src/graph.rs:230` and including test attempts that failed offline due to missing cached dependencies. I want to provide a bullet list of key modifications, explain testing limitations, and note that the commit is done—all following the user’s detailed formatting instructions.
[2025-09-21T21:16:05] codex

已根据报告复现列分配策略改动，关键点如下：
- 扩展 `BranchVis` 以记录源/目标列组提示并在构造器中默认初始化为空，供后续排序使用（src/graph.rs:230, src/graph.rs:246）。
- 新增 `assign_sources_targets` 统计每个分支的源/目标组并重写 `assign_branch_columns`，以 `max(source_group, target_group)`、长度与起点为排序键，同时保持与 merge 目标的列冲突规避（src/graph.rs:642, src/graph.rs:703）。
- 调试输出补充 `s:`/`t:` 字段，便于核对列提示；默认配置枚举移除 FCFS 选项（src/main.rs:528, src/settings.rs:17）。
- 移除 `format_commit` 上的冗余 `#[allow(dead_code)]` 标注以贴合原提交（src/print/format.rs:75）。

假设与验证：
- `cargo test` 因无法访问 crates.io 而超时，`cargo test --offline` 也在缺少缓存依赖 `matches` 时失败；需在可联网或已缓存依赖的环境中重新执行构建验证。

已按要求完成提交：`075-e956827：复现提交代码内容。` 建议在网络可用时补跑 `cargo test` 以确认构建通过。
[2025-09-21T21:16:10] tokens used: 109,994
[2025-09-21T21:16:10] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index 549575e6de805e6fc251aeef319e25cef3feedf3..df21cbb684356a38c3e52d9737bd195033529b65
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -5,7 +5,8 @@
 use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
 use itertools::Itertools;
 use regex::Regex;
-use std::collections::{HashMap, HashSet, VecDeque};
+use std::cmp;
+use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
 
@@ -67,11 +68,10 @@
 
         let mut branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        assign_sources_targets(&commits, &indices, &mut branches);
+
         match settings.branch_order {
-            BranchOrder::FirstComeFirstServed(forward) => {
-                assign_branch_columns_fcfs(&commits, &mut branches, &settings.branches, forward)
-            }
-            BranchOrder::ShortestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -79,7 +79,7 @@
                 true,
                 forward,
             ),
-            BranchOrder::LongestFirst(forward) => assign_branch_columns_branch_length(
+            BranchOrder::LongestFirst(forward) => assign_branch_columns(
                 &commits,
                 &indices,
                 &mut branches,
@@ -230,6 +230,10 @@
 pub struct BranchVis {
     /// The branch's column group (left to right)
     pub order_group: usize,
+    /// The order group of the merge target (if available)
+    pub target_order_group: Option<usize>,
+    /// The order group of the branch this branch originates from (if available)
+    pub source_order_group: Option<usize>,
     /// The branch's terminal color (index in 256-color palette)
     pub term_color: u8,
     /// SVG color (name or RGB in hex annotation)
@@ -242,6 +246,8 @@
     fn new(order_group: usize, term_color: u8, svg_color: String) -> Self {
         BranchVis {
             order_group,
+            target_order_group: None,
+            source_order_group: None,
             term_color,
             svg_color,
             column: None,
@@ -633,110 +639,69 @@
     Ok(any_assigned)
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses First-Come First-Served scheduling.
-fn assign_branch_columns_fcfs(
+fn assign_sources_targets(
     commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
-    settings: &BranchSettings,
-    forward: bool,
 ) {
-    let mut occupied: Vec<Vec<bool>> = vec![vec![]; settings.order.len() + 1];
-
-    let sort_factor = if forward { 1 } else { -1 };
-
-    let mut start_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.0.unwrap_or(0)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    let mut end_queue: VecDeque<_> = branches
-        .iter()
-        .enumerate()
-        .filter(|br| br.1.range.0.is_some() || br.1.range.1.is_some())
-        .map(|(idx, br)| (idx, br.range.1.unwrap_or(branches.len() - 1)))
-        .sorted_by_key(|tup| tup.1 as i32 * sort_factor)
-        .collect();
-
-    if !forward {
-        std::mem::swap(&mut start_queue, &mut end_queue);
-    }
-
-    for i in 0..commits.len() {
-        let idx = if forward { i } else { commits.len() - 1 - i };
-
-        loop {
-            let start = start_queue.pop_front();
-
-            if let Some(start) = start {
-                if start.1 == idx {
-                    let branch = &mut branches[start.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    let column = group
-                        .iter()
-                        .find_position(|val| !**val)
-                        .unwrap_or_else(|| (group.len(), &false))
-                        .0;
-                    branch.visual.column = Some(column);
-                    if column < group.len() {
-                        group[column] = true;
-                    } else {
-                        group.push(true);
-                    }
-                } else {
-                    start_queue.push_front(start);
-                    break;
-                }
-            } else {
-                break;
-            }
-        }
-
-        loop {
-            let end = end_queue.pop_front();
-            if let Some(end) = end {
-                if end.1 == idx {
-                    let branch = &mut branches[end.0];
-                    let group = &mut occupied[branch.visual.order_group];
-                    if let Some(column) = branch.visual.column {
-                        group[column] = false;
-                    }
-                } else {
-                    end_queue.push_front(end);
-                    break;
-                }
-            } else {
-                break;
+    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
+    for (commit_idx, info) in commits.iter().enumerate() {
+        if let Some(branch_idx) = info.branch_trace {
+            if let Some(entries) = branch_commits.get_mut(branch_idx) {
+                entries.push(commit_idx);
             }
         }
     }
 
-    let group_offset: Vec<usize> = occupied
-        .iter()
-        .scan(0, |acc, group| {
-            *acc += group.len();
-            Some(*acc)
-        })
-        .collect();
+    for branch_idx in 0..branches.len() {
+        let source_group = branch_commits
+            .get(branch_idx)
+            .and_then(|indices_for_branch| {
+                indices_for_branch.iter().rev().find_map(|commit_idx| {
+                    let info = &commits[*commit_idx];
+                    info.parents.iter().flatten().find_map(|parent_oid| {
+                        indices
+                            .get(parent_oid)
+                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
+                    })
+                })
+            });
 
-    for branch in branches {
-        if let Some(column) = branch.visual.column {
-            let offset = if branch.visual.order_group == 0 {
-                0
-            } else {
-                group_offset[branch.visual.order_group - 1]
-            };
-            branch.visual.column = Some(column + offset);
-        }
+        let target_group = branches[branch_idx]
+            .merge_target
+            .and_then(|target_oid| {
+                indices
+                    .get(&target_oid)
+                    .and_then(|target_idx| commits[*target_idx].branch_trace)
+                    .filter(|target_branch_idx| *target_branch_idx != branch_idx)
+                    .map(|target_branch_idx| branches[target_branch_idx].visual.order_group)
+            })
+            .or_else(|| {
+                branch_commits
+                    .get(branch_idx)
+                    .and_then(|indices_for_branch| indices_for_branch.first())
+                    .and_then(|head_idx| {
+                        commits[*head_idx].children.iter().find_map(|child| {
+                            indices
+                                .get(child)
+                                .and_then(|child_idx| commits[*child_idx].branch_trace)
+                                .filter(|child_branch_idx| *child_branch_idx != branch_idx)
+                                .map(|child_branch_idx| {
+                                    branches[child_branch_idx].visual.order_group
+                                })
+                        })
+                    })
+            });
+
+        branches[branch_idx].visual.source_order_group = source_group;
+        branches[branch_idx].visual.target_order_group = target_group;
     }
 }
 
-/// Sorts branches into columns for visualization, that all branches can be
-/// visualizes linearly and without overlaps. Uses Shortest-First scheduling.
-fn assign_branch_columns_branch_length(
+/// Sorts branches into columns for visualization without overlaps.
+fn assign_branch_columns(
     commits: &[CommitInfo],
     indices: &HashMap<Oid, usize>,
     branches: &mut [BranchInfo],
@@ -748,67 +713,89 @@
 
     let length_sort_factor = if shortest_first { 1 } else { -1 };
     let start_sort_factor = if forward { 1 } else { -1 };
+    let default_end = commits.len().saturating_sub(1);
 
-    let branches_sort: VecDeque<_> = branches
+    let mut branches_sort: Vec<(usize, usize, usize, usize, i32, i32)> = branches
         .iter()
         .enumerate()
-        .filter(|(_idx, br)| br.range.0.is_some() || br.range.1.is_some())
-        .map(|(idx, br)| {
-            (
-                idx,
-                br.range.0.unwrap_or(0),
-                br.range.1.unwrap_or(branches.len() - 1),
-            )
-        })
-        .sorted_by_key(|tup| {
-            (
-                (tup.2 as i32 - tup.1 as i32) * length_sort_factor,
-                tup.1 as i32 * start_sort_factor,
-            )
+        .filter_map(|(idx, br)| {
+            if br.range.0.is_none() && br.range.1.is_none() {
+                return None;
+            }
+
+            let start = br.range.0.unwrap_or(0);
+            let end = br.range.1.unwrap_or(default_end);
+            let start_i32 = start as i32;
+            let end_i32 = end as i32;
+            let source_group = br
+                .visual
+                .source_order_group
+                .unwrap_or(br.visual.order_group);
+            let target_group = br
+                .visual
+                .target_order_group
+                .unwrap_or(br.visual.order_group);
+            let group_hint = cmp::max(source_group, target_group);
+            let length_key = (end_i32 - start_i32) * length_sort_factor;
+            let start_key = start_i32 * start_sort_factor;
+
+            Some((idx, start, end, group_hint, length_key, start_key))
         })
         .collect();
 
-    for (branch_idx, start, end) in branches_sort {
-        let branch = &branches[branch_idx];
-        let group = branch.visual.order_group;
-        let group_occ = &mut occupied[group];
+    branches_sort.sort_by(|a, b| {
+        a.3.cmp(&b.3)
+            .then_with(|| a.4.cmp(&b.4))
+            .then_with(|| a.5.cmp(&b.5))
+    });
+
+    for (branch_idx, start, end, _, _, _) in branches_sort {
+        let branch_group = branches[branch_idx].visual.order_group;
+        let merge_target = branches[branch_idx].merge_target;
+
+        let mut selected_column;
+        {
+            let group_occ = &mut occupied[branch_group];
+            selected_column = group_occ.len();
 
-        let mut found = group_occ.len();
-        for (i, column_occ) in group_occ.iter().enumerate() {
-            let mut occ = false;
-            for (s, e) in column_occ {
-                if start <= *e && end >= *s {
-                    occ = true;
-                    break;
-                }
-            }
-            if !occ {
-                if let Some(merge_trace) = branch
-                    .merge_target
-                    .and_then(|t| indices.get(&t))
-                    .and_then(|t_idx| commits[*t_idx].branch_trace)
-                {
-                    let merge_branch = &branches[merge_trace];
-                    if merge_branch.visual.order_group == branch.visual.order_group {
-                        if let Some(merge_column) = merge_branch.visual.column {
-                            if merge_column == i {
-                                occ = true;
+            for (i, column_occ) in group_occ.iter().enumerate() {
+                let mut conflict = column_occ.iter().any(|(s, e)| start <= *e && end >= *s);
+
+                if !conflict {
+                    if let Some(target_oid) = merge_target {
+                        if let Some(conflict_column) = indices
+                            .get(&target_oid)
+                            .and_then(|target_idx| commits[*target_idx].branch_trace)
+                            .and_then(|target_branch_idx| {
+                                let merge_branch = &branches[target_branch_idx];
+                                if merge_branch.visual.order_group == branch_group {
+                                    merge_branch.visual.column
+                                } else {
+                                    None
+                                }
+                            })
+                        {
+                            if conflict_column == i {
+                                conflict = true;
                             }
                         }
                     }
                 }
+
+                if !conflict {
+                    selected_column = i;
+                    break;
+                }
             }
-            if !occ {
-                found = i;
-                break;
+
+            if selected_column == group_occ.len() {
+                group_occ.push(vec![]);
             }
-        }
-        let branch = &mut branches[branch_idx];
-        branch.visual.column = Some(found);
-        if found == group_occ.len() {
-            group_occ.push(vec![]);
+
+            group_occ[selected_column].push((start, end));
         }
-        group_occ[found].push((start, end));
+
+        branches[branch_idx].visual.column = Some(selected_column);
     }
 
     let group_offset: Vec<usize> = occupied
@@ -819,7 +806,7 @@
         })
         .collect();
 
-    for branch in branches {
+    for branch in branches.iter_mut() {
         if let Some(column) = branch.visual.column {
             let offset = if branch.visual.order_group == 0 {
                 0
diff --git a/src/main.rs b/src/main.rs
index 8ab0613ec89b237b1e4b97bad578c1a7a577dca4..16d75d796b70804e01fd7d5f6726f60c817483fd
--- a/src/main.rs
+++ b/src/main.rs
@@ -527,12 +527,24 @@
 
     if settings.debug {
         for branch in &graph.branches {
+            let source_hint = branch
+                .visual
+                .source_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
+            let target_hint = branch
+                .visual
+                .target_order_group
+                .map(|group| group.to_string())
+                .unwrap_or_else(|| "-".to_string());
             eprintln!(
-                "{} (col {}) ({:?}) {}",
+                "{} (col {}) ({:?}) {} s:{} t:{}",
                 branch.name,
                 branch.visual.column.unwrap_or(99),
                 branch.range,
-                if branch.is_merged { "m" } else { "" }
+                if branch.is_merged { "m" } else { "" },
+                source_hint,
+                target_hint,
             );
         }
     }
diff --git a/src/print/format.rs b/src/print/format.rs
index 3fc0a6d4e5784e588cb4525e8b35de967e7d26be..32827beb7bebe2d6a874f65e20cc2a170430d4e1
--- a/src/print/format.rs
+++ b/src/print/format.rs
@@ -73,7 +73,6 @@
 }
 
 /// Format a commit for `CommitFormat::Format(String)`.
-#[allow(dead_code)]
 pub fn format_commit(
     format: &str,
     commit: &Commit,
diff --git a/src/settings.rs b/src/settings.rs
index 0f7d704ba21e7da0edc386e341e94ad0a4dc1925..d99077d5835873fdb5e45164bc152b4d2811df77
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -25,10 +25,6 @@
     /// For branches with equal length, branches ending last are inserted first.
     /// Reverse (arg = false): Branches ending first are inserted first.
     LongestFirst(bool),
-    /// Branches ending last are inserted left-most.
-    ///
-    /// Reverse (arg = false): Branches starting first are inserted left-most.
-    FirstComeFirstServed(bool),
 }
 
 /// Top-level settings


=== 错误 ===
2025-09-21T21:03:24.430716Z ERROR codex_core::exec: exec error: No such file or directory (os error 2)

=== 最终状态 ===
返回码: 0
状态: ✅ 执行成功
