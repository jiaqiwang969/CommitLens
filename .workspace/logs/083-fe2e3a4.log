=== 任务 083-fe2e3a4 执行日志 ===
时间: 2025-09-22 05:55:17.586741
Prompt:
请在 .workspace 内，依据 .workspace/todolist/todolist-083-fe2e3a4.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/083-fe2e3a4/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："083-fe2e3a4：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 083-fe2e3a4

=== 输出 ===
[2025-09-21T21:52:16] OpenAI Codex v0.39.0 (research preview)
--------
workdir: /Users/jqwang/104-CommitLens-codex/.workspace
model: gpt-5-codex-high
provider: codex
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
--------
[2025-09-21T21:52:16] User instructions:
请在 .workspace 内，依据 .workspace/todolist/todolist-083-fe2e3a4.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/083-fe2e3a4/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："083-fe2e3a4：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 083-fe2e3a4

[2025-09-21T21:52:21] thinking

**Analyzing planning constraints and environment**
[2025-09-21T21:52:21] exec bash -lc 'ls -la' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T21:52:21] bash -lc 'ls -la' succeeded in 13ms:
total 43032
drwxr-xr-x@  9 jqwang  staff       288 Sep 21 15:57 .
drwxr-xr-x@ 29 jqwang  staff       928 Sep 21 07:49 ..
-rw-r--r--@  1 jqwang  staff         0 Sep 22 05:52 codex_error.txt
-rw-r--r--@  1 jqwang  staff  21778209 Sep 22 05:52 codex_output.txt
-rw-r--r--@  1 jqwang  staff         7 Sep 22 05:52 codex_status.txt
drwxr-xr-x@ 84 jqwang  staff      2688 Sep 22 05:52 logs
drwxr-xr-x@ 12 jqwang  staff       384 Sep 18 13:06 rust-project
-rw-r--r--@  1 jqwang  staff      1710 Sep 22 05:52 task_status.json
drwxr-xr-x@  5 jqwang  staff       160 Sep 22 05:52 todolist
[2025-09-21T21:52:21] tokens used: 992

[2025-09-21T21:52:23] thinking

**Choosing tool to read tex file**
[2025-09-21T21:52:23] exec bash -lc 'cat todolist/todolist-083-fe2e3a4.tex' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T21:52:23] bash -lc 'cat todolist/todolist-083-fe2e3a4.tex' succeeded in 19ms:
\section{提交考古：083-fe2e3a4}

\subsection*{Commit 元信息}
\begin{itemize}
  \item 标题：moved functions for reading/writing models to separate module
  \item 作者：Martin Lange <martin\_lange\_@gmx.net>
  \item 日期：2021-01-04T13:26:01+01:00
\end{itemize}

\subsection*{变更摘要（阅读提示）}
\begin{verbatim}
HEAD:   src/config.rs | 156 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
        src/lib.rs    |   1 +
        src/main.rs   | 162 ++--------------------------------------------------------
        3 files changed, 161 insertions(+), 158 deletions(-)
HEAD-1: src/main.rs          | 103 +++++++++++++++++++++++++++++----------------------
        src/print/unicode.rs |   9 ++++-
        2 files changed, 66 insertions(+), 46 deletions(-)
HEAD-2: README.md      | 21 ++++-----------------
        docs/manual.md | 10 +++++-----
[2025-09-21T21:52:23] tokens used: 1,480

[2025-09-21T21:52:27] thinking

**Preparing to reconstruct code from description**
[2025-09-21T21:52:27] exec bash -lc ls in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:52:27] bash -lc ls succeeded in 9ms:
Cargo.lock
Cargo.toml
docs
LICENSE
README.md
scripts
src
[2025-09-21T21:52:27] tokens used: 3,371

[2025-09-21T21:52:29] thinking

**Reviewing source files for code consistency**
[2025-09-21T21:52:29] exec bash -lc "sed -n '1,200p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:52:29] bash -lc "sed -n '1,200p' src/main.rs" succeeded in 7ms:
use clap::{crate_version, App, Arg, SubCommand};
use crossterm::cursor::MoveToColumn;
use crossterm::event::{Event, KeyCode, KeyModifiers};
use crossterm::style::Print;
use crossterm::terminal::{Clear, ClearType};
use crossterm::{ErrorKind, ExecutableCommand};
use git2::Repository;
use git_graph::graph::GitGraph;
use git_graph::print::format::CommitFormat;
use git_graph::print::svg::print_svg;
use git_graph::print::unicode::print_unicode;
use git_graph::settings::{
    BranchOrder, BranchSettings, BranchSettingsDef, Characters, MergePatterns, RepoSettings,
    Settings,
};
use platform_dirs::AppDirs;
use std::io::stdout;
use std::path::{Path, PathBuf};
use std::str::FromStr;
use std::time::Instant;
[2025-09-21T21:52:29] tokens used: 3,671

[2025-09-21T21:52:31] thinking

**Searching for configuration functions**
[2025-09-21T21:52:31] exec bash -lc 'rg "fn create_config" -n src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:52:31] bash -lc 'rg "fn create_config" -n src/main.rs' succeeded in 9ms:
517:fn create_config(app_model_path: &Path) -> Result<(), String> {
[2025-09-21T21:52:31] tokens used: 6,093

[2025-09-21T21:52:35] thinking

**Preparing to refactor config functions**
[2025-09-21T21:52:35] exec bash -lc "sed -n '500,680p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:52:35] bash -lc "sed -n '500,680p' src/main.rs" succeeded in 13ms:
    let mut config_path = PathBuf::from(repository.path());
    config_path.push(repo_config_file);

    let config = RepoSettings {
        model: model.to_string(),
    };

    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;

    eprint!("Branching model set to '{}'", model);

    Ok(())
}

/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
/// and writes the files for built-in branching models there.
fn create_config(app_model_path: &Path) -> Result<(), String> {
    if !app_model_path.exists() {
        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
[2025-09-21T21:52:35] tokens used: 6,531

[2025-09-21T21:52:37] thinking

**Searching earlier config function definitions**
[2025-09-21T21:52:37] exec bash -lc 'rg "fn get_model" -n src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:52:37] bash -lc 'rg "fn get_model" -n src/main.rs' succeeded in 11ms:
383:fn get_model_name(repository: &Repository, repo_config_file: &str) -> Result<Option<String>, String> {
433:fn get_model(
[2025-09-21T21:52:37] tokens used: 8,197
[2025-09-21T21:52:40] exec bash -lc "sed -n '360,520p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:52:40] bash -lc "sed -n '360,520p' src/main.rs" succeeded in 19ms:
            }
        }
    } else {
        Some((None, Some(0), Some(8)))
    };

    let settings = Settings {
        debug,
        colored,
        compact,
        include_remote,
        format,
        wrapping,
        characters: style,
        branch_order: BranchOrder::ShortestFirst(true),
        branches: BranchSettings::from(model).map_err(|err| err.to_string())?,
        merge_patterns: MergePatterns::default(),
    };

    run(repository, &settings, svg, commit_limit, pager)
[2025-09-21T21:52:40] tokens used: 8,471

[2025-09-21T21:52:58] thinking

**Planning config module extraction**

I'm organizing model-related functions into a new `config` library module with proper imports and adjusting `main.rs` to use these functions from `git_graph::config`. I need to carefully replicate the functions and their dependencies, including types from `settings` and external crates like `git2` and `itertools`, while deciding where constants like `REPO_CONFIG_FILE` belong.
[2025-09-21T21:52:59] exec bash -lc 'rg "get_available_models" -n src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:52:59] bash -lc 'rg "get_available_models" -n src/main.rs' succeeded in 15ms:
236:                itertools::join(get_available_models(&app_model_path)?, "\n")
399:fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
472:        let models = get_available_models(app_model_path)?;
489:    let models = get_available_models(app_model_path)?;
[2025-09-21T21:52:59] tokens used: 20,929

[2025-09-21T21:53:02] thinking

**Checking function usage and removal plan**
[2025-09-21T21:53:02] exec bash -lc 'rg "set_model" -n src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:53:02] bash -lc 'rg "set_model" -n src/main.rs' succeeded in 9ms:
255:            Some(model) => set_model(&repository, model, REPO_CONFIG_FILE, &app_model_path)?,
483:fn set_model(
[2025-09-21T21:53:02] tokens used: 23,699

[2025-09-21T21:53:04] thinking

**Checking get_model usage**
[2025-09-21T21:53:04] exec bash -lc 'rg "get_model(" -n src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:53:04] bash -lc 'rg "get_model(" -n src/main.rs' exited 2 in 11ms:
regex parse error:
    get_model(
             ^
error: unclosed group
[2025-09-21T21:53:04] tokens used: 23,927

[2025-09-21T21:53:06] thinking

**Considering search pattern escaping**
[2025-09-21T21:53:06] exec bash -lc "rg \"get_model\\(\" -n src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-21T21:53:06] bash -lc "rg \"get_model\\(\" -n src/main.rs" exited 2 in 22ms:
src/main.rs: No such file or directory (os error 2)
[2025-09-21T21:53:06] tokens used: 24,136

[2025-09-21T21:53:08] thinking

**Correcting work directory for Rust project**
[2025-09-21T21:53:08] exec bash -lc "rg \"get_model\\(\" -n src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:53:08] bash -lc "rg \"get_model\\(\" -n src/main.rs" succeeded in 10ms:
284:    let model = get_model(
433:fn get_model(
[2025-09-21T21:53:08] tokens used: 24,333

[2025-09-21T21:53:10] thinking

**Checking usage of `read_model`**
[2025-09-21T21:53:11] exec bash -lc 'rg "read_model" -n src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:53:11] bash -lc 'rg "read_model" -n src/main.rs' succeeded in 9ms:
440:        Some(model) => read_model(model, app_model_path),
451:                read_model(&repo_config.model, app_model_path)
454:                    read_model("git-flow", app_model_path)
463:fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
[2025-09-21T21:53:11] tokens used: 24,524

[2025-09-21T21:53:14] thinking

**Searching usage of get_model_name**
[2025-09-21T21:53:14] exec bash -lc 'rg "get_model_name" -n src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:53:14] bash -lc 'rg "get_model_name" -n src/main.rs' succeeded in 11ms:
249:                let curr_model = get_model_name(&repository, REPO_CONFIG_FILE)?;
383:fn get_model_name(repository: &Repository, repo_config_file: &str) -> Result<Option<String>, String> {
[2025-09-21T21:53:14] tokens used: 24,758

[2025-09-21T21:53:16] thinking

**Preparing to update module imports**
[2025-09-21T21:53:16] exec bash -lc 'cat src/lib.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:53:16] bash -lc 'cat src/lib.rs' succeeded in 7ms:
//! Command line tool to show clear git graphs arranged for your branching model.

pub mod graph;
pub mod print;
pub mod settings;
[2025-09-21T21:53:16] tokens used: 24,999

[2025-09-21T21:53:19] thinking

**Preparing to add configuration module**
[2025-09-21T21:53:19] exec bash -lc 'ls src' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:53:19] bash -lc 'ls src' succeeded in 7ms:
graph.rs
lib.rs
main.rs
print
settings.rs
[2025-09-21T21:53:19] tokens used: 25,260

[2025-09-21T21:53:36] thinking

**Detailing refactor plan for config module**
[2025-09-21T21:53:36] exec bash -lc "sed -n '1,120p' src/main.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:53:36] bash -lc "sed -n '1,120p' src/main.rs" succeeded in 14ms:
use clap::{crate_version, App, Arg, SubCommand};
use crossterm::cursor::MoveToColumn;
use crossterm::event::{Event, KeyCode, KeyModifiers};
use crossterm::style::Print;
use crossterm::terminal::{Clear, ClearType};
use crossterm::{ErrorKind, ExecutableCommand};
use git2::Repository;
use git_graph::graph::GitGraph;
use git_graph::print::format::CommitFormat;
use git_graph::print::svg::print_svg;
use git_graph::print::unicode::print_unicode;
use git_graph::settings::{
    BranchOrder, BranchSettings, BranchSettingsDef, Characters, MergePatterns, RepoSettings,
    Settings,
};
use platform_dirs::AppDirs;
use std::io::stdout;
use std::path::{Path, PathBuf};
use std::str::FromStr;
use std::time::Instant;
[2025-09-21T21:53:36] tokens used: 26,933

[2025-09-21T21:53:40] thinking

**Examining imports for pruning**
[2025-09-21T21:53:40] exec bash -lc 'rg "RepoSettings" src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:53:40] bash -lc 'rg "RepoSettings" src/main.rs' succeeded in 10ms:
    BranchOrder, BranchSettings, BranchSettingsDef, Characters, MergePatterns, RepoSettings,
        let repo_config: RepoSettings =
                let repo_config: RepoSettings = toml::from_str(
    let config = RepoSettings {
[2025-09-21T21:53:40] tokens used: 28,382

[2025-09-21T21:53:44] thinking

**Preparing import cleanup and usage check**
[2025-09-21T21:53:44] exec bash -lc 'rg "BranchSettingsDef" src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:53:44] bash -lc 'rg "BranchSettingsDef" src/main.rs' succeeded in 12ms:
    BranchOrder, BranchSettings, BranchSettingsDef, Characters, MergePatterns, RepoSettings,
) -> Result<BranchSettingsDef, String> {
                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
        toml::from_str::<BranchSettingsDef>(
            (BranchSettingsDef::git_flow(), "git-flow.toml"),
            (BranchSettingsDef::simple(), "simple.toml"),
            (BranchSettingsDef::none(), "none.toml"),
[2025-09-21T21:53:44] tokens used: 28,654

[2025-09-21T21:53:51] thinking

**Planning module extraction and refactoring**

I'm preparing to move several functions from main to a new `config.rs` module, making them public and keeping their doc comments for clarity. I want to carefully adjust imports and references like `BranchSettingsDef` and `RepoSettings` to ensure everything stays consistent and functional after the move.
[2025-09-21T21:53:57] apply_patch auto_approved=true:
A /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/config.rs
use git2::Repository;
use std::path::{Path, PathBuf};

use crate::settings::{BranchSettingsDef, RepoSettings};

/// Get the currently set branching model for a repo.
pub fn get_model_name(
    repository: &Repository,
    repo_config_file: &str,
) -> Result<Option<String>, String> {
    let mut config_path = PathBuf::from(repository.path());
    config_path.push(repo_config_file);

    if config_path.exists() {
        let repo_config: RepoSettings = toml::from_str(
            &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
        )
        .map_err(|err| err.to_string())?;

        Ok(Some(repo_config.model))
    } else {
        Ok(None)
    }
}

/// Get models available in `APP_DATA/git-graph/models`.
pub fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
    let models = std::fs::read_dir(app_model_path)
        .map_err(|err| {
            format!(
                "ERROR: Cannot read models from {}: {}",
                app_model_path.display(),
                err
            )
        })?
        .filter_map(|e| match e {
            Ok(e) => {
                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
                    if ext == "toml" {
                        if let Some(name) = name.to_str() {
                            Some((&name[..(name.len() - 5)]).to_string())
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                } else {
                    None
                }
            }
            Err(_) => None,
        })
        .collect::<Vec<_>>();

    Ok(models)
}

/// Try to get the branch settings for a given model.
/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
pub fn get_model(
    repository: &Repository,
    model: Option<&str>,
    repo_config_file: &str,
    app_model_path: &Path,
) -> Result<BranchSettingsDef, String> {
    match model {
        Some(model) => read_model(model, app_model_path),
        None => {
            let mut config_path = PathBuf::from(repository.path());
            config_path.push(repo_config_file);

            if config_path.exists() {
                let repo_config: RepoSettings = toml::from_str(
                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
                )
                .map_err(|err| err.to_string())?;

                read_model(&repo_config.model, app_model_path)
            } else {
                Ok(
                    read_model("git-flow", app_model_path)
                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
                )
            }
        }
    }
}

/// Read a branching model file.
pub fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
    let model_file = app_model_path.join(format!("{}.toml", model));

    if model_file.exists() {
        toml::from_str::<BranchSettingsDef>(
            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
        )
        .map_err(|err| err.to_string())
    } else {
        let models = get_available_models(app_model_path)?;
        Err(format!(
            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
            model,
            app_model_path.display(),
            itertools::join(models, ", ")
        ))
    }
}

/// Permanently sets the branching model for a repository
pub fn set_model(
    repository: &Repository,
    model: &str,
    repo_config_file: &str,
    app_model_path: &Path,
) -> Result<(), String> {
    let models = get_available_models(app_model_path)?;

    if !models.contains(&model.to_string()) {
        return Err(format!(
            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
            model,
            app_model_path.display(),
            itertools::join(models, ", ")
        ));
    }

    let mut config_path = PathBuf::from(repository.path());
    config_path.push(repo_config_file);

    let config = RepoSettings {
        model: model.to_string(),
    };

    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;

    eprint!("Branching model set to '{}'", model);

    Ok(())
}

/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
/// and writes the files for built-in branching models there.
pub fn create_config(app_model_path: &Path) -> Result<(), String> {
    if !app_model_path.exists() {
        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;

        let models = [
            (BranchSettingsDef::git_flow(), "git-flow.toml"),
            (BranchSettingsDef::simple(), "simple.toml"),
            (BranchSettingsDef::none(), "none.toml"),
        ];
        for (model, file) in &models {
            let path = app_model_path.join(file);
            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
            std::fs::write(&path, str).map_err(|err| err.to_string())?;
        }
    }

    Ok(())
}
[2025-09-21T21:53:57] apply_patch(auto_approved=true) exited 0 in 20ms:
Success. Updated the following files:
A src/config.rs
[2025-09-21T21:53:57] turn diff:
diff --git a/src/config.rs b/src/config.rs
new file mode 100644
index 0000000000000000000000000000000000000000..b1e8a4d410369dbb616686df2de64f1ce49ceffc
--- /dev/null
+++ b/src/config.rs
@@ -0,0 +1,162 @@
+use git2::Repository;
+use std::path::{Path, PathBuf};
+
+use crate::settings::{BranchSettingsDef, RepoSettings};
+
+/// Get the currently set branching model for a repo.
+pub fn get_model_name(
+    repository: &Repository,
+    repo_config_file: &str,
+) -> Result<Option<String>, String> {
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    if config_path.exists() {
+        let repo_config: RepoSettings = toml::from_str(
+            &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())?;
+
+        Ok(Some(repo_config.model))
+    } else {
+        Ok(None)
+    }
+}
+
+/// Get models available in `APP_DATA/git-graph/models`.
+pub fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
+    let models = std::fs::read_dir(app_model_path)
+        .map_err(|err| {
+            format!(
+                "ERROR: Cannot read models from {}: {}",
+                app_model_path.display(),
+                err
+            )
+        })?
+        .filter_map(|e| match e {
+            Ok(e) => {
+                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
+                    if ext == "toml" {
+                        if let Some(name) = name.to_str() {
+                            Some((&name[..(name.len() - 5)]).to_string())
+                        } else {
+                            None
+                        }
+                    } else {
+                        None
+                    }
+                } else {
+                    None
+                }
+            }
+            Err(_) => None,
+        })
+        .collect::<Vec<_>>();
+
+    Ok(models)
+}
+
+/// Try to get the branch settings for a given model.
+/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
+pub fn get_model(
+    repository: &Repository,
+    model: Option<&str>,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<BranchSettingsDef, String> {
+    match model {
+        Some(model) => read_model(model, app_model_path),
+        None => {
+            let mut config_path = PathBuf::from(repository.path());
+            config_path.push(repo_config_file);
+
+            if config_path.exists() {
+                let repo_config: RepoSettings = toml::from_str(
+                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+                )
+                .map_err(|err| err.to_string())?;
+
+                read_model(&repo_config.model, app_model_path)
+            } else {
+                Ok(
+                    read_model("git-flow", app_model_path)
+                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
+                )
+            }
+        }
+    }
+}
+
+/// Read a branching model file.
+pub fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
+    let model_file = app_model_path.join(format!("{}.toml", model));
+
+    if model_file.exists() {
+        toml::from_str::<BranchSettingsDef>(
+            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())
+    } else {
+        let models = get_available_models(app_model_path)?;
+        Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ))
+    }
+}
+
+/// Permanently sets the branching model for a repository
+pub fn set_model(
+    repository: &Repository,
+    model: &str,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<(), String> {
+    let models = get_available_models(app_model_path)?;
+
+    if !models.contains(&model.to_string()) {
+        return Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ));
+    }
+
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    let config = RepoSettings {
+        model: model.to_string(),
+    };
+
+    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
+    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
+
+    eprint!("Branching model set to '{}'", model);
+
+    Ok(())
+}
+
+/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
+/// and writes the files for built-in branching models there.
+pub fn create_config(app_model_path: &Path) -> Result<(), String> {
+    if !app_model_path.exists() {
+        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
+
+        let models = [
+            (BranchSettingsDef::git_flow(), "git-flow.toml"),
+            (BranchSettingsDef::simple(), "simple.toml"),
+            (BranchSettingsDef::none(), "none.toml"),
+        ];
+        for (model, file) in &models {
+            let path = app_model_path.join(file);
+            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
+            std::fs::write(&path, str).map_err(|err| err.to_string())?;
+        }
+    }
+
+    Ok(())
+}

[2025-09-21T21:53:57] tokens used: 30,962
[2025-09-21T21:53:57] turn diff:
diff --git a/src/config.rs b/src/config.rs
new file mode 100644
index 0000000000000000000000000000000000000000..b1e8a4d410369dbb616686df2de64f1ce49ceffc
--- /dev/null
+++ b/src/config.rs
@@ -0,0 +1,162 @@
+use git2::Repository;
+use std::path::{Path, PathBuf};
+
+use crate::settings::{BranchSettingsDef, RepoSettings};
+
+/// Get the currently set branching model for a repo.
+pub fn get_model_name(
+    repository: &Repository,
+    repo_config_file: &str,
+) -> Result<Option<String>, String> {
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    if config_path.exists() {
+        let repo_config: RepoSettings = toml::from_str(
+            &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())?;
+
+        Ok(Some(repo_config.model))
+    } else {
+        Ok(None)
+    }
+}
+
+/// Get models available in `APP_DATA/git-graph/models`.
+pub fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
+    let models = std::fs::read_dir(app_model_path)
+        .map_err(|err| {
+            format!(
+                "ERROR: Cannot read models from {}: {}",
+                app_model_path.display(),
+                err
+            )
+        })?
+        .filter_map(|e| match e {
+            Ok(e) => {
+                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
+                    if ext == "toml" {
+                        if let Some(name) = name.to_str() {
+                            Some((&name[..(name.len() - 5)]).to_string())
+                        } else {
+                            None
+                        }
+                    } else {
+                        None
+                    }
+                } else {
+                    None
+                }
+            }
+            Err(_) => None,
+        })
+        .collect::<Vec<_>>();
+
+    Ok(models)
+}
+
+/// Try to get the branch settings for a given model.
+/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
+pub fn get_model(
+    repository: &Repository,
+    model: Option<&str>,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<BranchSettingsDef, String> {
+    match model {
+        Some(model) => read_model(model, app_model_path),
+        None => {
+            let mut config_path = PathBuf::from(repository.path());
+            config_path.push(repo_config_file);
+
+            if config_path.exists() {
+                let repo_config: RepoSettings = toml::from_str(
+                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+                )
+                .map_err(|err| err.to_string())?;
+
+                read_model(&repo_config.model, app_model_path)
+            } else {
+                Ok(
+                    read_model("git-flow", app_model_path)
+                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
+                )
+            }
+        }
+    }
+}
+
+/// Read a branching model file.
+pub fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
+    let model_file = app_model_path.join(format!("{}.toml", model));
+
+    if model_file.exists() {
+        toml::from_str::<BranchSettingsDef>(
+            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())
+    } else {
+        let models = get_available_models(app_model_path)?;
+        Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ))
+    }
+}
+
+/// Permanently sets the branching model for a repository
+pub fn set_model(
+    repository: &Repository,
+    model: &str,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<(), String> {
+    let models = get_available_models(app_model_path)?;
+
+    if !models.contains(&model.to_string()) {
+        return Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ));
+    }
+
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    let config = RepoSettings {
+        model: model.to_string(),
+    };
+
+    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
+    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
+
+    eprint!("Branching model set to '{}'", model);
+
+    Ok(())
+}
+
+/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
+/// and writes the files for built-in branching models there.
+pub fn create_config(app_model_path: &Path) -> Result<(), String> {
+    if !app_model_path.exists() {
+        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
+
+        let models = [
+            (BranchSettingsDef::git_flow(), "git-flow.toml"),
+            (BranchSettingsDef::simple(), "simple.toml"),
+            (BranchSettingsDef::none(), "none.toml"),
+        ];
+        for (model, file) in &models {
+            let path = app_model_path.join(file);
+            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
+            std::fs::write(&path, str).map_err(|err| err.to_string())?;
+        }
+    }
+
+    Ok(())
+}


[2025-09-21T21:54:01] thinking

**Modifying src/lib.rs to add config module**
[2025-09-21T21:54:01] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/lib.rs
@@ -2,2 +2,3 @@
 
+pub mod config;
 pub mod graph;
[2025-09-21T21:54:01] apply_patch(auto_approved=true) exited 0 in 20ms:
Success. Updated the following files:
M src/lib.rs
[2025-09-21T21:54:01] turn diff:
diff --git a/src/config.rs b/src/config.rs
new file mode 100644
index 0000000000000000000000000000000000000000..b1e8a4d410369dbb616686df2de64f1ce49ceffc
--- /dev/null
+++ b/src/config.rs
@@ -0,0 +1,162 @@
+use git2::Repository;
+use std::path::{Path, PathBuf};
+
+use crate::settings::{BranchSettingsDef, RepoSettings};
+
+/// Get the currently set branching model for a repo.
+pub fn get_model_name(
+    repository: &Repository,
+    repo_config_file: &str,
+) -> Result<Option<String>, String> {
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    if config_path.exists() {
+        let repo_config: RepoSettings = toml::from_str(
+            &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())?;
+
+        Ok(Some(repo_config.model))
+    } else {
+        Ok(None)
+    }
+}
+
+/// Get models available in `APP_DATA/git-graph/models`.
+pub fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
+    let models = std::fs::read_dir(app_model_path)
+        .map_err(|err| {
+            format!(
+                "ERROR: Cannot read models from {}: {}",
+                app_model_path.display(),
+                err
+            )
+        })?
+        .filter_map(|e| match e {
+            Ok(e) => {
+                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
+                    if ext == "toml" {
+                        if let Some(name) = name.to_str() {
+                            Some((&name[..(name.len() - 5)]).to_string())
+                        } else {
+                            None
+                        }
+                    } else {
+                        None
+                    }
+                } else {
+                    None
+                }
+            }
+            Err(_) => None,
+        })
+        .collect::<Vec<_>>();
+
+    Ok(models)
+}
+
+/// Try to get the branch settings for a given model.
+/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
+pub fn get_model(
+    repository: &Repository,
+    model: Option<&str>,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<BranchSettingsDef, String> {
+    match model {
+        Some(model) => read_model(model, app_model_path),
+        None => {
+            let mut config_path = PathBuf::from(repository.path());
+            config_path.push(repo_config_file);
+
+            if config_path.exists() {
+                let repo_config: RepoSettings = toml::from_str(
+                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+                )
+                .map_err(|err| err.to_string())?;
+
+                read_model(&repo_config.model, app_model_path)
+            } else {
+                Ok(
+                    read_model("git-flow", app_model_path)
+                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
+                )
+            }
+        }
+    }
+}
+
+/// Read a branching model file.
+pub fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
+    let model_file = app_model_path.join(format!("{}.toml", model));
+
+    if model_file.exists() {
+        toml::from_str::<BranchSettingsDef>(
+            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())
+    } else {
+        let models = get_available_models(app_model_path)?;
+        Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ))
+    }
+}
+
+/// Permanently sets the branching model for a repository
+pub fn set_model(
+    repository: &Repository,
+    model: &str,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<(), String> {
+    let models = get_available_models(app_model_path)?;
+
+    if !models.contains(&model.to_string()) {
+        return Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ));
+    }
+
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    let config = RepoSettings {
+        model: model.to_string(),
+    };
+
+    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
+    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
+
+    eprint!("Branching model set to '{}'", model);
+
+    Ok(())
+}
+
+/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
+/// and writes the files for built-in branching models there.
+pub fn create_config(app_model_path: &Path) -> Result<(), String> {
+    if !app_model_path.exists() {
+        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
+
+        let models = [
+            (BranchSettingsDef::git_flow(), "git-flow.toml"),
+            (BranchSettingsDef::simple(), "simple.toml"),
+            (BranchSettingsDef::none(), "none.toml"),
+        ];
+        for (model, file) in &models {
+            let path = app_model_path.join(file);
+            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
+            std::fs::write(&path, str).map_err(|err| err.to_string())?;
+        }
+    }
+
+    Ok(())
+}
diff --git a/src/lib.rs b/src/lib.rs
index 47bcbc3c6eb3d05bb2376c3189d87a9d0068dac4..36c784c4cd69e7f84ddfaeeded8925ff08085b09
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,5 +1,6 @@
 //! Command line tool to show clear git graphs arranged for your branching model.
 
+pub mod config;
 pub mod graph;
 pub mod print;
 pub mod settings;

[2025-09-21T21:54:01] tokens used: 32,773
[2025-09-21T21:54:01] turn diff:
diff --git a/src/config.rs b/src/config.rs
new file mode 100644
index 0000000000000000000000000000000000000000..b1e8a4d410369dbb616686df2de64f1ce49ceffc
--- /dev/null
+++ b/src/config.rs
@@ -0,0 +1,162 @@
+use git2::Repository;
+use std::path::{Path, PathBuf};
+
+use crate::settings::{BranchSettingsDef, RepoSettings};
+
+/// Get the currently set branching model for a repo.
+pub fn get_model_name(
+    repository: &Repository,
+    repo_config_file: &str,
+) -> Result<Option<String>, String> {
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    if config_path.exists() {
+        let repo_config: RepoSettings = toml::from_str(
+            &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())?;
+
+        Ok(Some(repo_config.model))
+    } else {
+        Ok(None)
+    }
+}
+
+/// Get models available in `APP_DATA/git-graph/models`.
+pub fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
+    let models = std::fs::read_dir(app_model_path)
+        .map_err(|err| {
+            format!(
+                "ERROR: Cannot read models from {}: {}",
+                app_model_path.display(),
+                err
+            )
+        })?
+        .filter_map(|e| match e {
+            Ok(e) => {
+                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
+                    if ext == "toml" {
+                        if let Some(name) = name.to_str() {
+                            Some((&name[..(name.len() - 5)]).to_string())
+                        } else {
+                            None
+                        }
+                    } else {
+                        None
+                    }
+                } else {
+                    None
+                }
+            }
+            Err(_) => None,
+        })
+        .collect::<Vec<_>>();
+
+    Ok(models)
+}
+
+/// Try to get the branch settings for a given model.
+/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
+pub fn get_model(
+    repository: &Repository,
+    model: Option<&str>,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<BranchSettingsDef, String> {
+    match model {
+        Some(model) => read_model(model, app_model_path),
+        None => {
+            let mut config_path = PathBuf::from(repository.path());
+            config_path.push(repo_config_file);
+
+            if config_path.exists() {
+                let repo_config: RepoSettings = toml::from_str(
+                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+                )
+                .map_err(|err| err.to_string())?;
+
+                read_model(&repo_config.model, app_model_path)
+            } else {
+                Ok(
+                    read_model("git-flow", app_model_path)
+                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
+                )
+            }
+        }
+    }
+}
+
+/// Read a branching model file.
+pub fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
+    let model_file = app_model_path.join(format!("{}.toml", model));
+
+    if model_file.exists() {
+        toml::from_str::<BranchSettingsDef>(
+            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())
+    } else {
+        let models = get_available_models(app_model_path)?;
+        Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ))
+    }
+}
+
+/// Permanently sets the branching model for a repository
+pub fn set_model(
+    repository: &Repository,
+    model: &str,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<(), String> {
+    let models = get_available_models(app_model_path)?;
+
+    if !models.contains(&model.to_string()) {
+        return Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ));
+    }
+
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    let config = RepoSettings {
+        model: model.to_string(),
+    };
+
+    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
+    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
+
+    eprint!("Branching model set to '{}'", model);
+
+    Ok(())
+}
+
+/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
+/// and writes the files for built-in branching models there.
+pub fn create_config(app_model_path: &Path) -> Result<(), String> {
+    if !app_model_path.exists() {
+        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
+
+        let models = [
+            (BranchSettingsDef::git_flow(), "git-flow.toml"),
+            (BranchSettingsDef::simple(), "simple.toml"),
+            (BranchSettingsDef::none(), "none.toml"),
+        ];
+        for (model, file) in &models {
+            let path = app_model_path.join(file);
+            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
+            std::fs::write(&path, str).map_err(|err| err.to_string())?;
+        }
+    }
+
+    Ok(())
+}
diff --git a/src/lib.rs b/src/lib.rs
index 47bcbc3c6eb3d05bb2376c3189d87a9d0068dac4..36c784c4cd69e7f84ddfaeeded8925ff08085b09
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,5 +1,6 @@
 //! Command line tool to show clear git graphs arranged for your branching model.
 
+pub mod config;
 pub mod graph;
 pub mod print;
 pub mod settings;


[2025-09-21T21:54:14] thinking

**Refining imports and cleaning functions in main.rs**
[2025-09-21T21:54:18] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -7,2 +7,5 @@
 use git2::Repository;
+use git_graph::config::{
+    create_config, get_available_models, get_model, get_model_name, set_model,
+};
 use git_graph::graph::GitGraph;
@@ -11,9 +14,6 @@
 use git_graph::print::unicode::print_unicode;
-use git_graph::settings::{
-    BranchOrder, BranchSettings, BranchSettingsDef, Characters, MergePatterns, RepoSettings,
-    Settings,
-};
+use git_graph::settings::{BranchOrder, BranchSettings, Characters, MergePatterns, Settings};
 use platform_dirs::AppDirs;
 use std::io::stdout;
-use std::path::{Path, PathBuf};
+use std::path::PathBuf;
 use std::str::FromStr;
[2025-09-21T21:54:18] apply_patch(auto_approved=true) exited 0 in 30ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T21:54:18] turn diff:
diff --git a/src/config.rs b/src/config.rs
new file mode 100644
index 0000000000000000000000000000000000000000..b1e8a4d410369dbb616686df2de64f1ce49ceffc
--- /dev/null
+++ b/src/config.rs
@@ -0,0 +1,162 @@
+use git2::Repository;
+use std::path::{Path, PathBuf};
+
+use crate::settings::{BranchSettingsDef, RepoSettings};
+
+/// Get the currently set branching model for a repo.
+pub fn get_model_name(
+    repository: &Repository,
+    repo_config_file: &str,
+) -> Result<Option<String>, String> {
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    if config_path.exists() {
+        let repo_config: RepoSettings = toml::from_str(
+            &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())?;
+
+        Ok(Some(repo_config.model))
+    } else {
+        Ok(None)
+    }
+}
+
+/// Get models available in `APP_DATA/git-graph/models`.
+pub fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
+    let models = std::fs::read_dir(app_model_path)
+        .map_err(|err| {
+            format!(
+                "ERROR: Cannot read models from {}: {}",
+                app_model_path.display(),
+                err
+            )
+        })?
+        .filter_map(|e| match e {
+            Ok(e) => {
+                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
+                    if ext == "toml" {
+                        if let Some(name) = name.to_str() {
+                            Some((&name[..(name.len() - 5)]).to_string())
+                        } else {
+                            None
+                        }
+                    } else {
+                        None
+                    }
+                } else {
+                    None
+                }
+            }
+            Err(_) => None,
+        })
+        .collect::<Vec<_>>();
+
+    Ok(models)
+}
+
+/// Try to get the branch settings for a given model.
+/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
+pub fn get_model(
+    repository: &Repository,
+    model: Option<&str>,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<BranchSettingsDef, String> {
+    match model {
+        Some(model) => read_model(model, app_model_path),
+        None => {
+            let mut config_path = PathBuf::from(repository.path());
+            config_path.push(repo_config_file);
+
+            if config_path.exists() {
+                let repo_config: RepoSettings = toml::from_str(
+                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+                )
+                .map_err(|err| err.to_string())?;
+
+                read_model(&repo_config.model, app_model_path)
+            } else {
+                Ok(
+                    read_model("git-flow", app_model_path)
+                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
+                )
+            }
+        }
+    }
+}
+
+/// Read a branching model file.
+pub fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
+    let model_file = app_model_path.join(format!("{}.toml", model));
+
+    if model_file.exists() {
+        toml::from_str::<BranchSettingsDef>(
+            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())
+    } else {
+        let models = get_available_models(app_model_path)?;
+        Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ))
+    }
+}
+
+/// Permanently sets the branching model for a repository
+pub fn set_model(
+    repository: &Repository,
+    model: &str,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<(), String> {
+    let models = get_available_models(app_model_path)?;
+
+    if !models.contains(&model.to_string()) {
+        return Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ));
+    }
+
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    let config = RepoSettings {
+        model: model.to_string(),
+    };
+
+    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
+    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
+
+    eprint!("Branching model set to '{}'", model);
+
+    Ok(())
+}
+
+/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
+/// and writes the files for built-in branching models there.
+pub fn create_config(app_model_path: &Path) -> Result<(), String> {
+    if !app_model_path.exists() {
+        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
+
+        let models = [
+            (BranchSettingsDef::git_flow(), "git-flow.toml"),
+            (BranchSettingsDef::simple(), "simple.toml"),
+            (BranchSettingsDef::none(), "none.toml"),
+        ];
+        for (model, file) in &models {
+            let path = app_model_path.join(file);
+            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
+            std::fs::write(&path, str).map_err(|err| err.to_string())?;
+        }
+    }
+
+    Ok(())
+}
diff --git a/src/lib.rs b/src/lib.rs
index 47bcbc3c6eb3d05bb2376c3189d87a9d0068dac4..36c784c4cd69e7f84ddfaeeded8925ff08085b09
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,5 +1,6 @@
 //! Command line tool to show clear git graphs arranged for your branching model.
 
+pub mod config;
 pub mod graph;
 pub mod print;
 pub mod settings;
diff --git a/src/main.rs b/src/main.rs
index 49d62f30ab7d002cd2824e7236627b7594bd0b66..c3b5753f64c6c9108bdcf41fb155616a2ad45408
--- a/src/main.rs
+++ b/src/main.rs
@@ -5,17 +5,17 @@
 use crossterm::terminal::{Clear, ClearType};
 use crossterm::{ErrorKind, ExecutableCommand};
 use git2::Repository;
+use git_graph::config::{
+    create_config, get_available_models, get_model, get_model_name, set_model,
+};
 use git_graph::graph::GitGraph;
 use git_graph::print::format::CommitFormat;
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
-use git_graph::settings::{
-    BranchOrder, BranchSettings, BranchSettingsDef, Characters, MergePatterns, RepoSettings,
-    Settings,
-};
+use git_graph::settings::{BranchOrder, BranchSettings, Characters, MergePatterns, Settings};
 use platform_dirs::AppDirs;
 use std::io::stdout;
-use std::path::{Path, PathBuf};
+use std::path::PathBuf;
 use std::str::FromStr;
 use std::time::Instant;
 

[2025-09-21T21:54:18] tokens used: 40,368
[2025-09-21T21:54:18] turn diff:
diff --git a/src/config.rs b/src/config.rs
new file mode 100644
index 0000000000000000000000000000000000000000..b1e8a4d410369dbb616686df2de64f1ce49ceffc
--- /dev/null
+++ b/src/config.rs
@@ -0,0 +1,162 @@
+use git2::Repository;
+use std::path::{Path, PathBuf};
+
+use crate::settings::{BranchSettingsDef, RepoSettings};
+
+/// Get the currently set branching model for a repo.
+pub fn get_model_name(
+    repository: &Repository,
+    repo_config_file: &str,
+) -> Result<Option<String>, String> {
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    if config_path.exists() {
+        let repo_config: RepoSettings = toml::from_str(
+            &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())?;
+
+        Ok(Some(repo_config.model))
+    } else {
+        Ok(None)
+    }
+}
+
+/// Get models available in `APP_DATA/git-graph/models`.
+pub fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
+    let models = std::fs::read_dir(app_model_path)
+        .map_err(|err| {
+            format!(
+                "ERROR: Cannot read models from {}: {}",
+                app_model_path.display(),
+                err
+            )
+        })?
+        .filter_map(|e| match e {
+            Ok(e) => {
+                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
+                    if ext == "toml" {
+                        if let Some(name) = name.to_str() {
+                            Some((&name[..(name.len() - 5)]).to_string())
+                        } else {
+                            None
+                        }
+                    } else {
+                        None
+                    }
+                } else {
+                    None
+                }
+            }
+            Err(_) => None,
+        })
+        .collect::<Vec<_>>();
+
+    Ok(models)
+}
+
+/// Try to get the branch settings for a given model.
+/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
+pub fn get_model(
+    repository: &Repository,
+    model: Option<&str>,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<BranchSettingsDef, String> {
+    match model {
+        Some(model) => read_model(model, app_model_path),
+        None => {
+            let mut config_path = PathBuf::from(repository.path());
+            config_path.push(repo_config_file);
+
+            if config_path.exists() {
+                let repo_config: RepoSettings = toml::from_str(
+                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+                )
+                .map_err(|err| err.to_string())?;
+
+                read_model(&repo_config.model, app_model_path)
+            } else {
+                Ok(
+                    read_model("git-flow", app_model_path)
+                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
+                )
+            }
+        }
+    }
+}
+
+/// Read a branching model file.
+pub fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
+    let model_file = app_model_path.join(format!("{}.toml", model));
+
+    if model_file.exists() {
+        toml::from_str::<BranchSettingsDef>(
+            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())
+    } else {
+        let models = get_available_models(app_model_path)?;
+        Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ))
+    }
+}
+
+/// Permanently sets the branching model for a repository
+pub fn set_model(
+    repository: &Repository,
+    model: &str,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<(), String> {
+    let models = get_available_models(app_model_path)?;
+
+    if !models.contains(&model.to_string()) {
+        return Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ));
+    }
+
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    let config = RepoSettings {
+        model: model.to_string(),
+    };
+
+    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
+    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
+
+    eprint!("Branching model set to '{}'", model);
+
+    Ok(())
+}
+
+/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
+/// and writes the files for built-in branching models there.
+pub fn create_config(app_model_path: &Path) -> Result<(), String> {
+    if !app_model_path.exists() {
+        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
+
+        let models = [
+            (BranchSettingsDef::git_flow(), "git-flow.toml"),
+            (BranchSettingsDef::simple(), "simple.toml"),
+            (BranchSettingsDef::none(), "none.toml"),
+        ];
+        for (model, file) in &models {
+            let path = app_model_path.join(file);
+            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
+            std::fs::write(&path, str).map_err(|err| err.to_string())?;
+        }
+    }
+
+    Ok(())
+}
diff --git a/src/lib.rs b/src/lib.rs
index 47bcbc3c6eb3d05bb2376c3189d87a9d0068dac4..36c784c4cd69e7f84ddfaeeded8925ff08085b09
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,5 +1,6 @@
 //! Command line tool to show clear git graphs arranged for your branching model.
 
+pub mod config;
 pub mod graph;
 pub mod print;
 pub mod settings;
diff --git a/src/main.rs b/src/main.rs
index 49d62f30ab7d002cd2824e7236627b7594bd0b66..c3b5753f64c6c9108bdcf41fb155616a2ad45408
--- a/src/main.rs
+++ b/src/main.rs
@@ -5,17 +5,17 @@
 use crossterm::terminal::{Clear, ClearType};
 use crossterm::{ErrorKind, ExecutableCommand};
 use git2::Repository;
+use git_graph::config::{
+    create_config, get_available_models, get_model, get_model_name, set_model,
+};
 use git_graph::graph::GitGraph;
 use git_graph::print::format::CommitFormat;
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
-use git_graph::settings::{
-    BranchOrder, BranchSettings, BranchSettingsDef, Characters, MergePatterns, RepoSettings,
-    Settings,
-};
+use git_graph::settings::{BranchOrder, BranchSettings, Characters, MergePatterns, Settings};
 use platform_dirs::AppDirs;
 use std::io::stdout;
-use std::path::{Path, PathBuf};
+use std::path::PathBuf;
 use std::str::FromStr;
 use std::time::Instant;
 


[2025-09-21T21:54:21] thinking

**Preparing patch to remove old functions**
[2025-09-21T21:54:28] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/main.rs
@@ -381,156 +381,2 @@
 
-/// Get the currently set branching model for a repo.
-fn get_model_name(repository: &Repository, repo_config_file: &str) -> Result<Option<String>, String> {
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    if config_path.exists() {
-        let repo_config: RepoSettings =
-            toml::from_str(&std::fs::read_to_string(config_path).map_err(|err| err.to_string())?)
-                .map_err(|err| err.to_string())?;
-
-        Ok(Some(repo_config.model))
-    } else {
-        Ok(None)
-    }
-}
-
-/// Get models available in `APP_DATA/git-graph/models`.
-fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
-    let models = std::fs::read_dir(app_model_path)
-        .map_err(|err| {
-            format!(
-                "ERROR: Cannot read models from {}: {}",
-                app_model_path.display(),
-                err
-            )
-        })?
-        .filter_map(|e| match e {
-            Ok(e) => {
-                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
-                    if ext == "toml" {
-                        if let Some(name) = name.to_str() {
-                            Some((&name[..(name.len() - 5)]).to_string())
-                        } else {
-                            None
-                        }
-                    } else {
-                        None
-                    }
-                } else {
-                    None
-                }
-            }
-            Err(_) => None,
-        })
-        .collect::<Vec<_>>();
-
-    Ok(models)
-}
-
-/// Try to get the branch settings for a given model.
-/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
-fn get_model(
-    repository: &Repository,
-    model: Option<&str>,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<BranchSettingsDef, String> {
-    match model {
-        Some(model) => read_model(model, app_model_path),
-        None => {
-            let mut config_path = PathBuf::from(repository.path());
-            config_path.push(repo_config_file);
-
-            if config_path.exists() {
-                let repo_config: RepoSettings = toml::from_str(
-                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
-                )
-                .map_err(|err| err.to_string())?;
-
-                read_model(&repo_config.model, app_model_path)
-            } else {
-                Ok(
-                    read_model("git-flow", app_model_path)
-                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
-                )
-            }
-        }
-    }
-}
-
-/// Read a branching model file.
-fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
-    let model_file = app_model_path.join(format!("{}.toml", model));
-
-    if model_file.exists() {
-        toml::from_str::<BranchSettingsDef>(
-            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
-        )
-        .map_err(|err| err.to_string())
-    } else {
-        let models = get_available_models(app_model_path)?;
-        Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ))
-    }
-}
-
-/// Permanently sets the branching model for a repository
-fn set_model(
-    repository: &Repository,
-    model: &str,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<(), String> {
-    let models = get_available_models(app_model_path)?;
-
-    if !models.contains(&model.to_string()) {
-        return Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ));
-    }
-
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    let config = RepoSettings {
-        model: model.to_string(),
-    };
-
-    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
-    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
-
-    eprint!("Branching model set to '{}'", model);
-
-    Ok(())
-}
-
-/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
-/// and writes the files for built-in branching models there.
-fn create_config(app_model_path: &Path) -> Result<(), String> {
-    if !app_model_path.exists() {
-        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
-
-        let models = [
-            (BranchSettingsDef::git_flow(), "git-flow.toml"),
-            (BranchSettingsDef::simple(), "simple.toml"),
-            (BranchSettingsDef::none(), "none.toml"),
-        ];
-        for (model, file) in &models {
-            let path = app_model_path.join(file);
-            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
-            std::fs::write(&path, str).map_err(|err| err.to_string())?;
-        }
-    }
-
-    Ok(())
-}
-
 fn run(
[2025-09-21T21:54:28] apply_patch(auto_approved=true) exited 0 in 40ms:
Success. Updated the following files:
M src/main.rs
[2025-09-21T21:54:28] turn diff:
diff --git a/src/config.rs b/src/config.rs
new file mode 100644
index 0000000000000000000000000000000000000000..b1e8a4d410369dbb616686df2de64f1ce49ceffc
--- /dev/null
+++ b/src/config.rs
@@ -0,0 +1,162 @@
+use git2::Repository;
+use std::path::{Path, PathBuf};
+
+use crate::settings::{BranchSettingsDef, RepoSettings};
+
+/// Get the currently set branching model for a repo.
+pub fn get_model_name(
+    repository: &Repository,
+    repo_config_file: &str,
+) -> Result<Option<String>, String> {
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    if config_path.exists() {
+        let repo_config: RepoSettings = toml::from_str(
+            &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())?;
+
+        Ok(Some(repo_config.model))
+    } else {
+        Ok(None)
+    }
+}
+
+/// Get models available in `APP_DATA/git-graph/models`.
+pub fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
+    let models = std::fs::read_dir(app_model_path)
+        .map_err(|err| {
+            format!(
+                "ERROR: Cannot read models from {}: {}",
+                app_model_path.display(),
+                err
+            )
+        })?
+        .filter_map(|e| match e {
+            Ok(e) => {
+                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
+                    if ext == "toml" {
+                        if let Some(name) = name.to_str() {
+                            Some((&name[..(name.len() - 5)]).to_string())
+                        } else {
+                            None
+                        }
+                    } else {
+                        None
+                    }
+                } else {
+                    None
+                }
+            }
+            Err(_) => None,
+        })
+        .collect::<Vec<_>>();
+
+    Ok(models)
+}
+
+/// Try to get the branch settings for a given model.
+/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
+pub fn get_model(
+    repository: &Repository,
+    model: Option<&str>,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<BranchSettingsDef, String> {
+    match model {
+        Some(model) => read_model(model, app_model_path),
+        None => {
+            let mut config_path = PathBuf::from(repository.path());
+            config_path.push(repo_config_file);
+
+            if config_path.exists() {
+                let repo_config: RepoSettings = toml::from_str(
+                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+                )
+                .map_err(|err| err.to_string())?;
+
+                read_model(&repo_config.model, app_model_path)
+            } else {
+                Ok(
+                    read_model("git-flow", app_model_path)
+                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
+                )
+            }
+        }
+    }
+}
+
+/// Read a branching model file.
+pub fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
+    let model_file = app_model_path.join(format!("{}.toml", model));
+
+    if model_file.exists() {
+        toml::from_str::<BranchSettingsDef>(
+            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())
+    } else {
+        let models = get_available_models(app_model_path)?;
+        Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ))
+    }
+}
+
+/// Permanently sets the branching model for a repository
+pub fn set_model(
+    repository: &Repository,
+    model: &str,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<(), String> {
+    let models = get_available_models(app_model_path)?;
+
+    if !models.contains(&model.to_string()) {
+        return Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ));
+    }
+
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    let config = RepoSettings {
+        model: model.to_string(),
+    };
+
+    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
+    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
+
+    eprint!("Branching model set to '{}'", model);
+
+    Ok(())
+}
+
+/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
+/// and writes the files for built-in branching models there.
+pub fn create_config(app_model_path: &Path) -> Result<(), String> {
+    if !app_model_path.exists() {
+        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
+
+        let models = [
+            (BranchSettingsDef::git_flow(), "git-flow.toml"),
+            (BranchSettingsDef::simple(), "simple.toml"),
+            (BranchSettingsDef::none(), "none.toml"),
+        ];
+        for (model, file) in &models {
+            let path = app_model_path.join(file);
+            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
+            std::fs::write(&path, str).map_err(|err| err.to_string())?;
+        }
+    }
+
+    Ok(())
+}
diff --git a/src/lib.rs b/src/lib.rs
index 47bcbc3c6eb3d05bb2376c3189d87a9d0068dac4..36c784c4cd69e7f84ddfaeeded8925ff08085b09
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,5 +1,6 @@
 //! Command line tool to show clear git graphs arranged for your branching model.
 
+pub mod config;
 pub mod graph;
 pub mod print;
 pub mod settings;
diff --git a/src/main.rs b/src/main.rs
index 49d62f30ab7d002cd2824e7236627b7594bd0b66..b8f5f046822766e99a6c7a0896deedb821062373
--- a/src/main.rs
+++ b/src/main.rs
@@ -5,17 +5,17 @@
 use crossterm::terminal::{Clear, ClearType};
 use crossterm::{ErrorKind, ExecutableCommand};
 use git2::Repository;
+use git_graph::config::{
+    create_config, get_available_models, get_model, get_model_name, set_model,
+};
 use git_graph::graph::GitGraph;
 use git_graph::print::format::CommitFormat;
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
-use git_graph::settings::{
-    BranchOrder, BranchSettings, BranchSettingsDef, Characters, MergePatterns, RepoSettings,
-    Settings,
-};
+use git_graph::settings::{BranchOrder, BranchSettings, Characters, MergePatterns, Settings};
 use platform_dirs::AppDirs;
 use std::io::stdout;
-use std::path::{Path, PathBuf};
+use std::path::PathBuf;
 use std::str::FromStr;
 use std::time::Instant;
 
@@ -377,160 +377,6 @@
     };
 
     run(repository, &settings, svg, commit_limit, pager)
-}
-
-/// Get the currently set branching model for a repo.
-fn get_model_name(repository: &Repository, repo_config_file: &str) -> Result<Option<String>, String> {
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    if config_path.exists() {
-        let repo_config: RepoSettings =
-            toml::from_str(&std::fs::read_to_string(config_path).map_err(|err| err.to_string())?)
-                .map_err(|err| err.to_string())?;
-
-        Ok(Some(repo_config.model))
-    } else {
-        Ok(None)
-    }
-}
-
-/// Get models available in `APP_DATA/git-graph/models`.
-fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
-    let models = std::fs::read_dir(app_model_path)
-        .map_err(|err| {
-            format!(
-                "ERROR: Cannot read models from {}: {}",
-                app_model_path.display(),
-                err
-            )
-        })?
-        .filter_map(|e| match e {
-            Ok(e) => {
-                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
-                    if ext == "toml" {
-                        if let Some(name) = name.to_str() {
-                            Some((&name[..(name.len() - 5)]).to_string())
-                        } else {
-                            None
-                        }
-                    } else {
-                        None
-                    }
-                } else {
-                    None
-                }
-            }
-            Err(_) => None,
-        })
-        .collect::<Vec<_>>();
-
-    Ok(models)
-}
-
-/// Try to get the branch settings for a given model.
-/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
-fn get_model(
-    repository: &Repository,
-    model: Option<&str>,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<BranchSettingsDef, String> {
-    match model {
-        Some(model) => read_model(model, app_model_path),
-        None => {
-            let mut config_path = PathBuf::from(repository.path());
-            config_path.push(repo_config_file);
-
-            if config_path.exists() {
-                let repo_config: RepoSettings = toml::from_str(
-                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
-                )
-                .map_err(|err| err.to_string())?;
-
-                read_model(&repo_config.model, app_model_path)
-            } else {
-                Ok(
-                    read_model("git-flow", app_model_path)
-                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
-                )
-            }
-        }
-    }
-}
-
-/// Read a branching model file.
-fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
-    let model_file = app_model_path.join(format!("{}.toml", model));
-
-    if model_file.exists() {
-        toml::from_str::<BranchSettingsDef>(
-            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
-        )
-        .map_err(|err| err.to_string())
-    } else {
-        let models = get_available_models(app_model_path)?;
-        Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ))
-    }
-}
-
-/// Permanently sets the branching model for a repository
-fn set_model(
-    repository: &Repository,
-    model: &str,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<(), String> {
-    let models = get_available_models(app_model_path)?;
-
-    if !models.contains(&model.to_string()) {
-        return Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ));
-    }
-
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    let config = RepoSettings {
-        model: model.to_string(),
-    };
-
-    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
-    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
-
-    eprint!("Branching model set to '{}'", model);
-
-    Ok(())
-}
-
-/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
-/// and writes the files for built-in branching models there.
-fn create_config(app_model_path: &Path) -> Result<(), String> {
-    if !app_model_path.exists() {
-        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
-
-        let models = [
-            (BranchSettingsDef::git_flow(), "git-flow.toml"),
-            (BranchSettingsDef::simple(), "simple.toml"),
-            (BranchSettingsDef::none(), "none.toml"),
-        ];
-        for (model, file) in &models {
-            let path = app_model_path.join(file);
-            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
-            std::fs::write(&path, str).map_err(|err| err.to_string())?;
-        }
-    }
-
-    Ok(())
 }
 
 fn run(

[2025-09-21T21:54:28] tokens used: 43,305
[2025-09-21T21:54:28] turn diff:
diff --git a/src/config.rs b/src/config.rs
new file mode 100644
index 0000000000000000000000000000000000000000..b1e8a4d410369dbb616686df2de64f1ce49ceffc
--- /dev/null
+++ b/src/config.rs
@@ -0,0 +1,162 @@
+use git2::Repository;
+use std::path::{Path, PathBuf};
+
+use crate::settings::{BranchSettingsDef, RepoSettings};
+
+/// Get the currently set branching model for a repo.
+pub fn get_model_name(
+    repository: &Repository,
+    repo_config_file: &str,
+) -> Result<Option<String>, String> {
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    if config_path.exists() {
+        let repo_config: RepoSettings = toml::from_str(
+            &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())?;
+
+        Ok(Some(repo_config.model))
+    } else {
+        Ok(None)
+    }
+}
+
+/// Get models available in `APP_DATA/git-graph/models`.
+pub fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
+    let models = std::fs::read_dir(app_model_path)
+        .map_err(|err| {
+            format!(
+                "ERROR: Cannot read models from {}: {}",
+                app_model_path.display(),
+                err
+            )
+        })?
+        .filter_map(|e| match e {
+            Ok(e) => {
+                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
+                    if ext == "toml" {
+                        if let Some(name) = name.to_str() {
+                            Some((&name[..(name.len() - 5)]).to_string())
+                        } else {
+                            None
+                        }
+                    } else {
+                        None
+                    }
+                } else {
+                    None
+                }
+            }
+            Err(_) => None,
+        })
+        .collect::<Vec<_>>();
+
+    Ok(models)
+}
+
+/// Try to get the branch settings for a given model.
+/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
+pub fn get_model(
+    repository: &Repository,
+    model: Option<&str>,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<BranchSettingsDef, String> {
+    match model {
+        Some(model) => read_model(model, app_model_path),
+        None => {
+            let mut config_path = PathBuf::from(repository.path());
+            config_path.push(repo_config_file);
+
+            if config_path.exists() {
+                let repo_config: RepoSettings = toml::from_str(
+                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+                )
+                .map_err(|err| err.to_string())?;
+
+                read_model(&repo_config.model, app_model_path)
+            } else {
+                Ok(
+                    read_model("git-flow", app_model_path)
+                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
+                )
+            }
+        }
+    }
+}
+
+/// Read a branching model file.
+pub fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
+    let model_file = app_model_path.join(format!("{}.toml", model));
+
+    if model_file.exists() {
+        toml::from_str::<BranchSettingsDef>(
+            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())
+    } else {
+        let models = get_available_models(app_model_path)?;
+        Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ))
+    }
+}
+
+/// Permanently sets the branching model for a repository
+pub fn set_model(
+    repository: &Repository,
+    model: &str,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<(), String> {
+    let models = get_available_models(app_model_path)?;
+
+    if !models.contains(&model.to_string()) {
+        return Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ));
+    }
+
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    let config = RepoSettings {
+        model: model.to_string(),
+    };
+
+    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
+    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
+
+    eprint!("Branching model set to '{}'", model);
+
+    Ok(())
+}
+
+/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
+/// and writes the files for built-in branching models there.
+pub fn create_config(app_model_path: &Path) -> Result<(), String> {
+    if !app_model_path.exists() {
+        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
+
+        let models = [
+            (BranchSettingsDef::git_flow(), "git-flow.toml"),
+            (BranchSettingsDef::simple(), "simple.toml"),
+            (BranchSettingsDef::none(), "none.toml"),
+        ];
+        for (model, file) in &models {
+            let path = app_model_path.join(file);
+            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
+            std::fs::write(&path, str).map_err(|err| err.to_string())?;
+        }
+    }
+
+    Ok(())
+}
diff --git a/src/lib.rs b/src/lib.rs
index 47bcbc3c6eb3d05bb2376c3189d87a9d0068dac4..36c784c4cd69e7f84ddfaeeded8925ff08085b09
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,5 +1,6 @@
 //! Command line tool to show clear git graphs arranged for your branching model.
 
+pub mod config;
 pub mod graph;
 pub mod print;
 pub mod settings;
diff --git a/src/main.rs b/src/main.rs
index 49d62f30ab7d002cd2824e7236627b7594bd0b66..b8f5f046822766e99a6c7a0896deedb821062373
--- a/src/main.rs
+++ b/src/main.rs
@@ -5,17 +5,17 @@
 use crossterm::terminal::{Clear, ClearType};
 use crossterm::{ErrorKind, ExecutableCommand};
 use git2::Repository;
+use git_graph::config::{
+    create_config, get_available_models, get_model, get_model_name, set_model,
+};
 use git_graph::graph::GitGraph;
 use git_graph::print::format::CommitFormat;
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
-use git_graph::settings::{
-    BranchOrder, BranchSettings, BranchSettingsDef, Characters, MergePatterns, RepoSettings,
-    Settings,
-};
+use git_graph::settings::{BranchOrder, BranchSettings, Characters, MergePatterns, Settings};
 use platform_dirs::AppDirs;
 use std::io::stdout;
-use std::path::{Path, PathBuf};
+use std::path::PathBuf;
 use std::str::FromStr;
 use std::time::Instant;
 
@@ -377,160 +377,6 @@
     };
 
     run(repository, &settings, svg, commit_limit, pager)
-}
-
-/// Get the currently set branching model for a repo.
-fn get_model_name(repository: &Repository, repo_config_file: &str) -> Result<Option<String>, String> {
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    if config_path.exists() {
-        let repo_config: RepoSettings =
-            toml::from_str(&std::fs::read_to_string(config_path).map_err(|err| err.to_string())?)
-                .map_err(|err| err.to_string())?;
-
-        Ok(Some(repo_config.model))
-    } else {
-        Ok(None)
-    }
-}
-
-/// Get models available in `APP_DATA/git-graph/models`.
-fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
-    let models = std::fs::read_dir(app_model_path)
-        .map_err(|err| {
-            format!(
-                "ERROR: Cannot read models from {}: {}",
-                app_model_path.display(),
-                err
-            )
-        })?
-        .filter_map(|e| match e {
-            Ok(e) => {
-                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
-                    if ext == "toml" {
-                        if let Some(name) = name.to_str() {
-                            Some((&name[..(name.len() - 5)]).to_string())
-                        } else {
-                            None
-                        }
-                    } else {
-                        None
-                    }
-                } else {
-                    None
-                }
-            }
-            Err(_) => None,
-        })
-        .collect::<Vec<_>>();
-
-    Ok(models)
-}
-
-/// Try to get the branch settings for a given model.
-/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
-fn get_model(
-    repository: &Repository,
-    model: Option<&str>,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<BranchSettingsDef, String> {
-    match model {
-        Some(model) => read_model(model, app_model_path),
-        None => {
-            let mut config_path = PathBuf::from(repository.path());
-            config_path.push(repo_config_file);
-
-            if config_path.exists() {
-                let repo_config: RepoSettings = toml::from_str(
-                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
-                )
-                .map_err(|err| err.to_string())?;
-
-                read_model(&repo_config.model, app_model_path)
-            } else {
-                Ok(
-                    read_model("git-flow", app_model_path)
-                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
-                )
-            }
-        }
-    }
-}
-
-/// Read a branching model file.
-fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
-    let model_file = app_model_path.join(format!("{}.toml", model));
-
-    if model_file.exists() {
-        toml::from_str::<BranchSettingsDef>(
-            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
-        )
-        .map_err(|err| err.to_string())
-    } else {
-        let models = get_available_models(app_model_path)?;
-        Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ))
-    }
-}
-
-/// Permanently sets the branching model for a repository
-fn set_model(
-    repository: &Repository,
-    model: &str,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<(), String> {
-    let models = get_available_models(app_model_path)?;
-
-    if !models.contains(&model.to_string()) {
-        return Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ));
-    }
-
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    let config = RepoSettings {
-        model: model.to_string(),
-    };
-
-    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
-    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
-
-    eprint!("Branching model set to '{}'", model);
-
-    Ok(())
-}
-
-/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
-/// and writes the files for built-in branching models there.
-fn create_config(app_model_path: &Path) -> Result<(), String> {
-    if !app_model_path.exists() {
-        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
-
-        let models = [
-            (BranchSettingsDef::git_flow(), "git-flow.toml"),
-            (BranchSettingsDef::simple(), "simple.toml"),
-            (BranchSettingsDef::none(), "none.toml"),
-        ];
-        for (model, file) in &models {
-            let path = app_model_path.join(file);
-            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
-            std::fs::write(&path, str).map_err(|err| err.to_string())?;
-        }
-    }
-
-    Ok(())
 }
 
 fn run(


[2025-09-21T21:54:31] thinking

**Checking for leftover type references**
[2025-09-21T21:54:31] exec bash -lc 'rg "BranchSettingsDef" src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:54:31] bash -lc 'rg "BranchSettingsDef" src/main.rs' exited 1 in 8ms:

[2025-09-21T21:54:31] tokens used: 45,063
[2025-09-21T21:54:31] turn diff:
diff --git a/src/config.rs b/src/config.rs
new file mode 100644
index 0000000000000000000000000000000000000000..b1e8a4d410369dbb616686df2de64f1ce49ceffc
--- /dev/null
+++ b/src/config.rs
@@ -0,0 +1,162 @@
+use git2::Repository;
+use std::path::{Path, PathBuf};
+
+use crate::settings::{BranchSettingsDef, RepoSettings};
+
+/// Get the currently set branching model for a repo.
+pub fn get_model_name(
+    repository: &Repository,
+    repo_config_file: &str,
+) -> Result<Option<String>, String> {
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    if config_path.exists() {
+        let repo_config: RepoSettings = toml::from_str(
+            &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())?;
+
+        Ok(Some(repo_config.model))
+    } else {
+        Ok(None)
+    }
+}
+
+/// Get models available in `APP_DATA/git-graph/models`.
+pub fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
+    let models = std::fs::read_dir(app_model_path)
+        .map_err(|err| {
+            format!(
+                "ERROR: Cannot read models from {}: {}",
+                app_model_path.display(),
+                err
+            )
+        })?
+        .filter_map(|e| match e {
+            Ok(e) => {
+                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
+                    if ext == "toml" {
+                        if let Some(name) = name.to_str() {
+                            Some((&name[..(name.len() - 5)]).to_string())
+                        } else {
+                            None
+                        }
+                    } else {
+                        None
+                    }
+                } else {
+                    None
+                }
+            }
+            Err(_) => None,
+        })
+        .collect::<Vec<_>>();
+
+    Ok(models)
+}
+
+/// Try to get the branch settings for a given model.
+/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
+pub fn get_model(
+    repository: &Repository,
+    model: Option<&str>,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<BranchSettingsDef, String> {
+    match model {
+        Some(model) => read_model(model, app_model_path),
+        None => {
+            let mut config_path = PathBuf::from(repository.path());
+            config_path.push(repo_config_file);
+
+            if config_path.exists() {
+                let repo_config: RepoSettings = toml::from_str(
+                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+                )
+                .map_err(|err| err.to_string())?;
+
+                read_model(&repo_config.model, app_model_path)
+            } else {
+                Ok(
+                    read_model("git-flow", app_model_path)
+                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
+                )
+            }
+        }
+    }
+}
+
+/// Read a branching model file.
+pub fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
+    let model_file = app_model_path.join(format!("{}.toml", model));
+
+    if model_file.exists() {
+        toml::from_str::<BranchSettingsDef>(
+            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())
+    } else {
+        let models = get_available_models(app_model_path)?;
+        Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ))
+    }
+}
+
+/// Permanently sets the branching model for a repository
+pub fn set_model(
+    repository: &Repository,
+    model: &str,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<(), String> {
+    let models = get_available_models(app_model_path)?;
+
+    if !models.contains(&model.to_string()) {
+        return Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ));
+    }
+
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    let config = RepoSettings {
+        model: model.to_string(),
+    };
+
+    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
+    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
+
+    eprint!("Branching model set to '{}'", model);
+
+    Ok(())
+}
+
+/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
+/// and writes the files for built-in branching models there.
+pub fn create_config(app_model_path: &Path) -> Result<(), String> {
+    if !app_model_path.exists() {
+        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
+
+        let models = [
+            (BranchSettingsDef::git_flow(), "git-flow.toml"),
+            (BranchSettingsDef::simple(), "simple.toml"),
+            (BranchSettingsDef::none(), "none.toml"),
+        ];
+        for (model, file) in &models {
+            let path = app_model_path.join(file);
+            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
+            std::fs::write(&path, str).map_err(|err| err.to_string())?;
+        }
+    }
+
+    Ok(())
+}
diff --git a/src/lib.rs b/src/lib.rs
index 47bcbc3c6eb3d05bb2376c3189d87a9d0068dac4..36c784c4cd69e7f84ddfaeeded8925ff08085b09
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,5 +1,6 @@
 //! Command line tool to show clear git graphs arranged for your branching model.
 
+pub mod config;
 pub mod graph;
 pub mod print;
 pub mod settings;
diff --git a/src/main.rs b/src/main.rs
index 49d62f30ab7d002cd2824e7236627b7594bd0b66..b8f5f046822766e99a6c7a0896deedb821062373
--- a/src/main.rs
+++ b/src/main.rs
@@ -5,17 +5,17 @@
 use crossterm::terminal::{Clear, ClearType};
 use crossterm::{ErrorKind, ExecutableCommand};
 use git2::Repository;
+use git_graph::config::{
+    create_config, get_available_models, get_model, get_model_name, set_model,
+};
 use git_graph::graph::GitGraph;
 use git_graph::print::format::CommitFormat;
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
-use git_graph::settings::{
-    BranchOrder, BranchSettings, BranchSettingsDef, Characters, MergePatterns, RepoSettings,
-    Settings,
-};
+use git_graph::settings::{BranchOrder, BranchSettings, Characters, MergePatterns, Settings};
 use platform_dirs::AppDirs;
 use std::io::stdout;
-use std::path::{Path, PathBuf};
+use std::path::PathBuf;
 use std::str::FromStr;
 use std::time::Instant;
 
@@ -377,160 +377,6 @@
     };
 
     run(repository, &settings, svg, commit_limit, pager)
-}
-
-/// Get the currently set branching model for a repo.
-fn get_model_name(repository: &Repository, repo_config_file: &str) -> Result<Option<String>, String> {
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    if config_path.exists() {
-        let repo_config: RepoSettings =
-            toml::from_str(&std::fs::read_to_string(config_path).map_err(|err| err.to_string())?)
-                .map_err(|err| err.to_string())?;
-
-        Ok(Some(repo_config.model))
-    } else {
-        Ok(None)
-    }
-}
-
-/// Get models available in `APP_DATA/git-graph/models`.
-fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
-    let models = std::fs::read_dir(app_model_path)
-        .map_err(|err| {
-            format!(
-                "ERROR: Cannot read models from {}: {}",
-                app_model_path.display(),
-                err
-            )
-        })?
-        .filter_map(|e| match e {
-            Ok(e) => {
-                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
-                    if ext == "toml" {
-                        if let Some(name) = name.to_str() {
-                            Some((&name[..(name.len() - 5)]).to_string())
-                        } else {
-                            None
-                        }
-                    } else {
-                        None
-                    }
-                } else {
-                    None
-                }
-            }
-            Err(_) => None,
-        })
-        .collect::<Vec<_>>();
-
-    Ok(models)
-}
-
-/// Try to get the branch settings for a given model.
-/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
-fn get_model(
-    repository: &Repository,
-    model: Option<&str>,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<BranchSettingsDef, String> {
-    match model {
-        Some(model) => read_model(model, app_model_path),
-        None => {
-            let mut config_path = PathBuf::from(repository.path());
-            config_path.push(repo_config_file);
-
-            if config_path.exists() {
-                let repo_config: RepoSettings = toml::from_str(
-                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
-                )
-                .map_err(|err| err.to_string())?;
-
-                read_model(&repo_config.model, app_model_path)
-            } else {
-                Ok(
-                    read_model("git-flow", app_model_path)
-                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
-                )
-            }
-        }
-    }
-}
-
-/// Read a branching model file.
-fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
-    let model_file = app_model_path.join(format!("{}.toml", model));
-
-    if model_file.exists() {
-        toml::from_str::<BranchSettingsDef>(
-            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
-        )
-        .map_err(|err| err.to_string())
-    } else {
-        let models = get_available_models(app_model_path)?;
-        Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ))
-    }
-}
-
-/// Permanently sets the branching model for a repository
-fn set_model(
-    repository: &Repository,
-    model: &str,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<(), String> {
-    let models = get_available_models(app_model_path)?;
-
-    if !models.contains(&model.to_string()) {
-        return Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ));
-    }
-
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    let config = RepoSettings {
-        model: model.to_string(),
-    };
-
-    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
-    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
-
-    eprint!("Branching model set to '{}'", model);
-
-    Ok(())
-}
-
-/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
-/// and writes the files for built-in branching models there.
-fn create_config(app_model_path: &Path) -> Result<(), String> {
-    if !app_model_path.exists() {
-        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
-
-        let models = [
-            (BranchSettingsDef::git_flow(), "git-flow.toml"),
-            (BranchSettingsDef::simple(), "simple.toml"),
-            (BranchSettingsDef::none(), "none.toml"),
-        ];
-        for (model, file) in &models {
-            let path = app_model_path.join(file);
-            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
-            std::fs::write(&path, str).map_err(|err| err.to_string())?;
-        }
-    }
-
-    Ok(())
 }
 
 fn run(


[2025-09-21T21:54:33] thinking

**Searching for RepoSettings**
[2025-09-21T21:54:34] exec bash -lc 'rg "RepoSettings" src/main.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:54:34] bash -lc 'rg "RepoSettings" src/main.rs' exited 1 in 10ms:

[2025-09-21T21:54:34] tokens used: 45,275
[2025-09-21T21:54:34] turn diff:
diff --git a/src/config.rs b/src/config.rs
new file mode 100644
index 0000000000000000000000000000000000000000..b1e8a4d410369dbb616686df2de64f1ce49ceffc
--- /dev/null
+++ b/src/config.rs
@@ -0,0 +1,162 @@
+use git2::Repository;
+use std::path::{Path, PathBuf};
+
+use crate::settings::{BranchSettingsDef, RepoSettings};
+
+/// Get the currently set branching model for a repo.
+pub fn get_model_name(
+    repository: &Repository,
+    repo_config_file: &str,
+) -> Result<Option<String>, String> {
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    if config_path.exists() {
+        let repo_config: RepoSettings = toml::from_str(
+            &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())?;
+
+        Ok(Some(repo_config.model))
+    } else {
+        Ok(None)
+    }
+}
+
+/// Get models available in `APP_DATA/git-graph/models`.
+pub fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
+    let models = std::fs::read_dir(app_model_path)
+        .map_err(|err| {
+            format!(
+                "ERROR: Cannot read models from {}: {}",
+                app_model_path.display(),
+                err
+            )
+        })?
+        .filter_map(|e| match e {
+            Ok(e) => {
+                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
+                    if ext == "toml" {
+                        if let Some(name) = name.to_str() {
+                            Some((&name[..(name.len() - 5)]).to_string())
+                        } else {
+                            None
+                        }
+                    } else {
+                        None
+                    }
+                } else {
+                    None
+                }
+            }
+            Err(_) => None,
+        })
+        .collect::<Vec<_>>();
+
+    Ok(models)
+}
+
+/// Try to get the branch settings for a given model.
+/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
+pub fn get_model(
+    repository: &Repository,
+    model: Option<&str>,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<BranchSettingsDef, String> {
+    match model {
+        Some(model) => read_model(model, app_model_path),
+        None => {
+            let mut config_path = PathBuf::from(repository.path());
+            config_path.push(repo_config_file);
+
+            if config_path.exists() {
+                let repo_config: RepoSettings = toml::from_str(
+                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+                )
+                .map_err(|err| err.to_string())?;
+
+                read_model(&repo_config.model, app_model_path)
+            } else {
+                Ok(
+                    read_model("git-flow", app_model_path)
+                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
+                )
+            }
+        }
+    }
+}
+
+/// Read a branching model file.
+pub fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
+    let model_file = app_model_path.join(format!("{}.toml", model));
+
+    if model_file.exists() {
+        toml::from_str::<BranchSettingsDef>(
+            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())
+    } else {
+        let models = get_available_models(app_model_path)?;
+        Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ))
+    }
+}
+
+/// Permanently sets the branching model for a repository
+pub fn set_model(
+    repository: &Repository,
+    model: &str,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<(), String> {
+    let models = get_available_models(app_model_path)?;
+
+    if !models.contains(&model.to_string()) {
+        return Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ));
+    }
+
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    let config = RepoSettings {
+        model: model.to_string(),
+    };
+
+    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
+    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
+
+    eprint!("Branching model set to '{}'", model);
+
+    Ok(())
+}
+
+/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
+/// and writes the files for built-in branching models there.
+pub fn create_config(app_model_path: &Path) -> Result<(), String> {
+    if !app_model_path.exists() {
+        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
+
+        let models = [
+            (BranchSettingsDef::git_flow(), "git-flow.toml"),
+            (BranchSettingsDef::simple(), "simple.toml"),
+            (BranchSettingsDef::none(), "none.toml"),
+        ];
+        for (model, file) in &models {
+            let path = app_model_path.join(file);
+            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
+            std::fs::write(&path, str).map_err(|err| err.to_string())?;
+        }
+    }
+
+    Ok(())
+}
diff --git a/src/lib.rs b/src/lib.rs
index 47bcbc3c6eb3d05bb2376c3189d87a9d0068dac4..36c784c4cd69e7f84ddfaeeded8925ff08085b09
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,5 +1,6 @@
 //! Command line tool to show clear git graphs arranged for your branching model.
 
+pub mod config;
 pub mod graph;
 pub mod print;
 pub mod settings;
diff --git a/src/main.rs b/src/main.rs
index 49d62f30ab7d002cd2824e7236627b7594bd0b66..b8f5f046822766e99a6c7a0896deedb821062373
--- a/src/main.rs
+++ b/src/main.rs
@@ -5,17 +5,17 @@
 use crossterm::terminal::{Clear, ClearType};
 use crossterm::{ErrorKind, ExecutableCommand};
 use git2::Repository;
+use git_graph::config::{
+    create_config, get_available_models, get_model, get_model_name, set_model,
+};
 use git_graph::graph::GitGraph;
 use git_graph::print::format::CommitFormat;
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
-use git_graph::settings::{
-    BranchOrder, BranchSettings, BranchSettingsDef, Characters, MergePatterns, RepoSettings,
-    Settings,
-};
+use git_graph::settings::{BranchOrder, BranchSettings, Characters, MergePatterns, Settings};
 use platform_dirs::AppDirs;
 use std::io::stdout;
-use std::path::{Path, PathBuf};
+use std::path::PathBuf;
 use std::str::FromStr;
 use std::time::Instant;
 
@@ -377,160 +377,6 @@
     };
 
     run(repository, &settings, svg, commit_limit, pager)
-}
-
-/// Get the currently set branching model for a repo.
-fn get_model_name(repository: &Repository, repo_config_file: &str) -> Result<Option<String>, String> {
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    if config_path.exists() {
-        let repo_config: RepoSettings =
-            toml::from_str(&std::fs::read_to_string(config_path).map_err(|err| err.to_string())?)
-                .map_err(|err| err.to_string())?;
-
-        Ok(Some(repo_config.model))
-    } else {
-        Ok(None)
-    }
-}
-
-/// Get models available in `APP_DATA/git-graph/models`.
-fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
-    let models = std::fs::read_dir(app_model_path)
-        .map_err(|err| {
-            format!(
-                "ERROR: Cannot read models from {}: {}",
-                app_model_path.display(),
-                err
-            )
-        })?
-        .filter_map(|e| match e {
-            Ok(e) => {
-                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
-                    if ext == "toml" {
-                        if let Some(name) = name.to_str() {
-                            Some((&name[..(name.len() - 5)]).to_string())
-                        } else {
-                            None
-                        }
-                    } else {
-                        None
-                    }
-                } else {
-                    None
-                }
-            }
-            Err(_) => None,
-        })
-        .collect::<Vec<_>>();
-
-    Ok(models)
-}
-
-/// Try to get the branch settings for a given model.
-/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
-fn get_model(
-    repository: &Repository,
-    model: Option<&str>,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<BranchSettingsDef, String> {
-    match model {
-        Some(model) => read_model(model, app_model_path),
-        None => {
-            let mut config_path = PathBuf::from(repository.path());
-            config_path.push(repo_config_file);
-
-            if config_path.exists() {
-                let repo_config: RepoSettings = toml::from_str(
-                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
-                )
-                .map_err(|err| err.to_string())?;
-
-                read_model(&repo_config.model, app_model_path)
-            } else {
-                Ok(
-                    read_model("git-flow", app_model_path)
-                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
-                )
-            }
-        }
-    }
-}
-
-/// Read a branching model file.
-fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
-    let model_file = app_model_path.join(format!("{}.toml", model));
-
-    if model_file.exists() {
-        toml::from_str::<BranchSettingsDef>(
-            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
-        )
-        .map_err(|err| err.to_string())
-    } else {
-        let models = get_available_models(app_model_path)?;
-        Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ))
-    }
-}
-
-/// Permanently sets the branching model for a repository
-fn set_model(
-    repository: &Repository,
-    model: &str,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<(), String> {
-    let models = get_available_models(app_model_path)?;
-
-    if !models.contains(&model.to_string()) {
-        return Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ));
-    }
-
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    let config = RepoSettings {
-        model: model.to_string(),
-    };
-
-    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
-    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
-
-    eprint!("Branching model set to '{}'", model);
-
-    Ok(())
-}
-
-/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
-/// and writes the files for built-in branching models there.
-fn create_config(app_model_path: &Path) -> Result<(), String> {
-    if !app_model_path.exists() {
-        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
-
-        let models = [
-            (BranchSettingsDef::git_flow(), "git-flow.toml"),
-            (BranchSettingsDef::simple(), "simple.toml"),
-            (BranchSettingsDef::none(), "none.toml"),
-        ];
-        for (model, file) in &models {
-            let path = app_model_path.join(file);
-            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
-            std::fs::write(&path, str).map_err(|err| err.to_string())?;
-        }
-    }
-
-    Ok(())
 }
 
 fn run(


[2025-09-21T21:54:37] thinking

**Verifying code changes and formatting**
[2025-09-21T21:54:37] exec bash -lc 'cargo fmt' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:54:37] bash -lc 'cargo fmt' succeeded in 78ms:

[2025-09-21T21:54:37] tokens used: 45,509
[2025-09-21T21:54:37] turn diff:
diff --git a/src/config.rs b/src/config.rs
new file mode 100644
index 0000000000000000000000000000000000000000..81325effb46e9b0d8a6518c23c8f31970ba2140e
--- /dev/null
+++ b/src/config.rs
@@ -0,0 +1,159 @@
+use git2::Repository;
+use std::path::{Path, PathBuf};
+
+use crate::settings::{BranchSettingsDef, RepoSettings};
+
+/// Get the currently set branching model for a repo.
+pub fn get_model_name(
+    repository: &Repository,
+    repo_config_file: &str,
+) -> Result<Option<String>, String> {
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    if config_path.exists() {
+        let repo_config: RepoSettings =
+            toml::from_str(&std::fs::read_to_string(config_path).map_err(|err| err.to_string())?)
+                .map_err(|err| err.to_string())?;
+
+        Ok(Some(repo_config.model))
+    } else {
+        Ok(None)
+    }
+}
+
+/// Get models available in `APP_DATA/git-graph/models`.
+pub fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
+    let models = std::fs::read_dir(app_model_path)
+        .map_err(|err| {
+            format!(
+                "ERROR: Cannot read models from {}: {}",
+                app_model_path.display(),
+                err
+            )
+        })?
+        .filter_map(|e| match e {
+            Ok(e) => {
+                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
+                    if ext == "toml" {
+                        if let Some(name) = name.to_str() {
+                            Some((&name[..(name.len() - 5)]).to_string())
+                        } else {
+                            None
+                        }
+                    } else {
+                        None
+                    }
+                } else {
+                    None
+                }
+            }
+            Err(_) => None,
+        })
+        .collect::<Vec<_>>();
+
+    Ok(models)
+}
+
+/// Try to get the branch settings for a given model.
+/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
+pub fn get_model(
+    repository: &Repository,
+    model: Option<&str>,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<BranchSettingsDef, String> {
+    match model {
+        Some(model) => read_model(model, app_model_path),
+        None => {
+            let mut config_path = PathBuf::from(repository.path());
+            config_path.push(repo_config_file);
+
+            if config_path.exists() {
+                let repo_config: RepoSettings = toml::from_str(
+                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+                )
+                .map_err(|err| err.to_string())?;
+
+                read_model(&repo_config.model, app_model_path)
+            } else {
+                Ok(read_model("git-flow", app_model_path)
+                    .unwrap_or_else(|_| BranchSettingsDef::git_flow()))
+            }
+        }
+    }
+}
+
+/// Read a branching model file.
+pub fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
+    let model_file = app_model_path.join(format!("{}.toml", model));
+
+    if model_file.exists() {
+        toml::from_str::<BranchSettingsDef>(
+            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())
+    } else {
+        let models = get_available_models(app_model_path)?;
+        Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ))
+    }
+}
+
+/// Permanently sets the branching model for a repository
+pub fn set_model(
+    repository: &Repository,
+    model: &str,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<(), String> {
+    let models = get_available_models(app_model_path)?;
+
+    if !models.contains(&model.to_string()) {
+        return Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ));
+    }
+
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    let config = RepoSettings {
+        model: model.to_string(),
+    };
+
+    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
+    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
+
+    eprint!("Branching model set to '{}'", model);
+
+    Ok(())
+}
+
+/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
+/// and writes the files for built-in branching models there.
+pub fn create_config(app_model_path: &Path) -> Result<(), String> {
+    if !app_model_path.exists() {
+        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
+
+        let models = [
+            (BranchSettingsDef::git_flow(), "git-flow.toml"),
+            (BranchSettingsDef::simple(), "simple.toml"),
+            (BranchSettingsDef::none(), "none.toml"),
+        ];
+        for (model, file) in &models {
+            let path = app_model_path.join(file);
+            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
+            std::fs::write(&path, str).map_err(|err| err.to_string())?;
+        }
+    }
+
+    Ok(())
+}
diff --git a/src/lib.rs b/src/lib.rs
index 47bcbc3c6eb3d05bb2376c3189d87a9d0068dac4..36c784c4cd69e7f84ddfaeeded8925ff08085b09
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,5 +1,6 @@
 //! Command line tool to show clear git graphs arranged for your branching model.
 
+pub mod config;
 pub mod graph;
 pub mod print;
 pub mod settings;
diff --git a/src/main.rs b/src/main.rs
index 49d62f30ab7d002cd2824e7236627b7594bd0b66..47351b780c0c4bb2946be1fb86c750f83aaa7279
--- a/src/main.rs
+++ b/src/main.rs
@@ -5,17 +5,17 @@
 use crossterm::terminal::{Clear, ClearType};
 use crossterm::{ErrorKind, ExecutableCommand};
 use git2::Repository;
+use git_graph::config::{
+    create_config, get_available_models, get_model, get_model_name, set_model,
+};
 use git_graph::graph::GitGraph;
 use git_graph::print::format::CommitFormat;
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
-use git_graph::settings::{
-    BranchOrder, BranchSettings, BranchSettingsDef, Characters, MergePatterns, RepoSettings,
-    Settings,
-};
+use git_graph::settings::{BranchOrder, BranchSettings, Characters, MergePatterns, Settings};
 use platform_dirs::AppDirs;
 use std::io::stdout;
-use std::path::{Path, PathBuf};
+use std::path::PathBuf;
 use std::str::FromStr;
 use std::time::Instant;
 
@@ -32,9 +32,7 @@
 }
 
 fn from_args() -> Result<(), String> {
-    let mut app_model_path = AppDirs::new(Some("git-graph"), false)
-        .unwrap()
-        .config_dir;
+    let mut app_model_path = AppDirs::new(Some("git-graph"), false).unwrap().config_dir;
     app_model_path.push("models");
 
     create_config(&app_model_path)?;
@@ -377,160 +375,6 @@
     };
 
     run(repository, &settings, svg, commit_limit, pager)
-}
-
-/// Get the currently set branching model for a repo.
-fn get_model_name(repository: &Repository, repo_config_file: &str) -> Result<Option<String>, String> {
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    if config_path.exists() {
-        let repo_config: RepoSettings =
-            toml::from_str(&std::fs::read_to_string(config_path).map_err(|err| err.to_string())?)
-                .map_err(|err| err.to_string())?;
-
-        Ok(Some(repo_config.model))
-    } else {
-        Ok(None)
-    }
-}
-
-/// Get models available in `APP_DATA/git-graph/models`.
-fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
-    let models = std::fs::read_dir(app_model_path)
-        .map_err(|err| {
-            format!(
-                "ERROR: Cannot read models from {}: {}",
-                app_model_path.display(),
-                err
-            )
-        })?
-        .filter_map(|e| match e {
-            Ok(e) => {
-                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
-                    if ext == "toml" {
-                        if let Some(name) = name.to_str() {
-                            Some((&name[..(name.len() - 5)]).to_string())
-                        } else {
-                            None
-                        }
-                    } else {
-                        None
-                    }
-                } else {
-                    None
-                }
-            }
-            Err(_) => None,
-        })
-        .collect::<Vec<_>>();
-
-    Ok(models)
-}
-
-/// Try to get the branch settings for a given model.
-/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
-fn get_model(
-    repository: &Repository,
-    model: Option<&str>,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<BranchSettingsDef, String> {
-    match model {
-        Some(model) => read_model(model, app_model_path),
-        None => {
-            let mut config_path = PathBuf::from(repository.path());
-            config_path.push(repo_config_file);
-
-            if config_path.exists() {
-                let repo_config: RepoSettings = toml::from_str(
-                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
-                )
-                .map_err(|err| err.to_string())?;
-
-                read_model(&repo_config.model, app_model_path)
-            } else {
-                Ok(
-                    read_model("git-flow", app_model_path)
-                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
-                )
-            }
-        }
-    }
-}
-
-/// Read a branching model file.
-fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
-    let model_file = app_model_path.join(format!("{}.toml", model));
-
-    if model_file.exists() {
-        toml::from_str::<BranchSettingsDef>(
-            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
-        )
-        .map_err(|err| err.to_string())
-    } else {
-        let models = get_available_models(app_model_path)?;
-        Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ))
-    }
-}
-
-/// Permanently sets the branching model for a repository
-fn set_model(
-    repository: &Repository,
-    model: &str,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<(), String> {
-    let models = get_available_models(app_model_path)?;
-
-    if !models.contains(&model.to_string()) {
-        return Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ));
-    }
-
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    let config = RepoSettings {
-        model: model.to_string(),
-    };
-
-    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
-    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
-
-    eprint!("Branching model set to '{}'", model);
-
-    Ok(())
-}
-
-/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
-/// and writes the files for built-in branching models there.
-fn create_config(app_model_path: &Path) -> Result<(), String> {
-    if !app_model_path.exists() {
-        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
-
-        let models = [
-            (BranchSettingsDef::git_flow(), "git-flow.toml"),
-            (BranchSettingsDef::simple(), "simple.toml"),
-            (BranchSettingsDef::none(), "none.toml"),
-        ];
-        for (model, file) in &models {
-            let path = app_model_path.join(file);
-            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
-            std::fs::write(&path, str).map_err(|err| err.to_string())?;
-        }
-    }
-
-    Ok(())
 }
 
 fn run(


[2025-09-21T21:54:40] thinking

**Building project for verification**
[2025-09-21T21:54:40] exec bash -lc 'cargo build' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:54:50] bash -lc 'cargo build' exited 124 in 10.00s:
    Updating crates.io index
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (3 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (2 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
warning: spurious network error (1 tries remaining): [6] Couldn't resolve host name (Could not resolve host: index.crates.io)
[2025-09-21T21:54:50] tokens used: 65,563
[2025-09-21T21:54:50] turn diff:
diff --git a/src/config.rs b/src/config.rs
new file mode 100644
index 0000000000000000000000000000000000000000..81325effb46e9b0d8a6518c23c8f31970ba2140e
--- /dev/null
+++ b/src/config.rs
@@ -0,0 +1,159 @@
+use git2::Repository;
+use std::path::{Path, PathBuf};
+
+use crate::settings::{BranchSettingsDef, RepoSettings};
+
+/// Get the currently set branching model for a repo.
+pub fn get_model_name(
+    repository: &Repository,
+    repo_config_file: &str,
+) -> Result<Option<String>, String> {
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    if config_path.exists() {
+        let repo_config: RepoSettings =
+            toml::from_str(&std::fs::read_to_string(config_path).map_err(|err| err.to_string())?)
+                .map_err(|err| err.to_string())?;
+
+        Ok(Some(repo_config.model))
+    } else {
+        Ok(None)
+    }
+}
+
+/// Get models available in `APP_DATA/git-graph/models`.
+pub fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
+    let models = std::fs::read_dir(app_model_path)
+        .map_err(|err| {
+            format!(
+                "ERROR: Cannot read models from {}: {}",
+                app_model_path.display(),
+                err
+            )
+        })?
+        .filter_map(|e| match e {
+            Ok(e) => {
+                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
+                    if ext == "toml" {
+                        if let Some(name) = name.to_str() {
+                            Some((&name[..(name.len() - 5)]).to_string())
+                        } else {
+                            None
+                        }
+                    } else {
+                        None
+                    }
+                } else {
+                    None
+                }
+            }
+            Err(_) => None,
+        })
+        .collect::<Vec<_>>();
+
+    Ok(models)
+}
+
+/// Try to get the branch settings for a given model.
+/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
+pub fn get_model(
+    repository: &Repository,
+    model: Option<&str>,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<BranchSettingsDef, String> {
+    match model {
+        Some(model) => read_model(model, app_model_path),
+        None => {
+            let mut config_path = PathBuf::from(repository.path());
+            config_path.push(repo_config_file);
+
+            if config_path.exists() {
+                let repo_config: RepoSettings = toml::from_str(
+                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+                )
+                .map_err(|err| err.to_string())?;
+
+                read_model(&repo_config.model, app_model_path)
+            } else {
+                Ok(read_model("git-flow", app_model_path)
+                    .unwrap_or_else(|_| BranchSettingsDef::git_flow()))
+            }
+        }
+    }
+}
+
+/// Read a branching model file.
+pub fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
+    let model_file = app_model_path.join(format!("{}.toml", model));
+
+    if model_file.exists() {
+        toml::from_str::<BranchSettingsDef>(
+            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())
+    } else {
+        let models = get_available_models(app_model_path)?;
+        Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ))
+    }
+}
+
+/// Permanently sets the branching model for a repository
+pub fn set_model(
+    repository: &Repository,
+    model: &str,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<(), String> {
+    let models = get_available_models(app_model_path)?;
+
+    if !models.contains(&model.to_string()) {
+        return Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ));
+    }
+
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    let config = RepoSettings {
+        model: model.to_string(),
+    };
+
+    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
+    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
+
+    eprint!("Branching model set to '{}'", model);
+
+    Ok(())
+}
+
+/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
+/// and writes the files for built-in branching models there.
+pub fn create_config(app_model_path: &Path) -> Result<(), String> {
+    if !app_model_path.exists() {
+        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
+
+        let models = [
+            (BranchSettingsDef::git_flow(), "git-flow.toml"),
+            (BranchSettingsDef::simple(), "simple.toml"),
+            (BranchSettingsDef::none(), "none.toml"),
+        ];
+        for (model, file) in &models {
+            let path = app_model_path.join(file);
+            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
+            std::fs::write(&path, str).map_err(|err| err.to_string())?;
+        }
+    }
+
+    Ok(())
+}
diff --git a/src/lib.rs b/src/lib.rs
index 47bcbc3c6eb3d05bb2376c3189d87a9d0068dac4..36c784c4cd69e7f84ddfaeeded8925ff08085b09
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,5 +1,6 @@
 //! Command line tool to show clear git graphs arranged for your branching model.
 
+pub mod config;
 pub mod graph;
 pub mod print;
 pub mod settings;
diff --git a/src/main.rs b/src/main.rs
index 49d62f30ab7d002cd2824e7236627b7594bd0b66..47351b780c0c4bb2946be1fb86c750f83aaa7279
--- a/src/main.rs
+++ b/src/main.rs
@@ -5,17 +5,17 @@
 use crossterm::terminal::{Clear, ClearType};
 use crossterm::{ErrorKind, ExecutableCommand};
 use git2::Repository;
+use git_graph::config::{
+    create_config, get_available_models, get_model, get_model_name, set_model,
+};
 use git_graph::graph::GitGraph;
 use git_graph::print::format::CommitFormat;
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
-use git_graph::settings::{
-    BranchOrder, BranchSettings, BranchSettingsDef, Characters, MergePatterns, RepoSettings,
-    Settings,
-};
+use git_graph::settings::{BranchOrder, BranchSettings, Characters, MergePatterns, Settings};
 use platform_dirs::AppDirs;
 use std::io::stdout;
-use std::path::{Path, PathBuf};
+use std::path::PathBuf;
 use std::str::FromStr;
 use std::time::Instant;
 
@@ -32,9 +32,7 @@
 }
 
 fn from_args() -> Result<(), String> {
-    let mut app_model_path = AppDirs::new(Some("git-graph"), false)
-        .unwrap()
-        .config_dir;
+    let mut app_model_path = AppDirs::new(Some("git-graph"), false).unwrap().config_dir;
     app_model_path.push("models");
 
     create_config(&app_model_path)?;
@@ -377,160 +375,6 @@
     };
 
     run(repository, &settings, svg, commit_limit, pager)
-}
-
-/// Get the currently set branching model for a repo.
-fn get_model_name(repository: &Repository, repo_config_file: &str) -> Result<Option<String>, String> {
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    if config_path.exists() {
-        let repo_config: RepoSettings =
-            toml::from_str(&std::fs::read_to_string(config_path).map_err(|err| err.to_string())?)
-                .map_err(|err| err.to_string())?;
-
-        Ok(Some(repo_config.model))
-    } else {
-        Ok(None)
-    }
-}
-
-/// Get models available in `APP_DATA/git-graph/models`.
-fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
-    let models = std::fs::read_dir(app_model_path)
-        .map_err(|err| {
-            format!(
-                "ERROR: Cannot read models from {}: {}",
-                app_model_path.display(),
-                err
-            )
-        })?
-        .filter_map(|e| match e {
-            Ok(e) => {
-                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
-                    if ext == "toml" {
-                        if let Some(name) = name.to_str() {
-                            Some((&name[..(name.len() - 5)]).to_string())
-                        } else {
-                            None
-                        }
-                    } else {
-                        None
-                    }
-                } else {
-                    None
-                }
-            }
-            Err(_) => None,
-        })
-        .collect::<Vec<_>>();
-
-    Ok(models)
-}
-
-/// Try to get the branch settings for a given model.
-/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
-fn get_model(
-    repository: &Repository,
-    model: Option<&str>,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<BranchSettingsDef, String> {
-    match model {
-        Some(model) => read_model(model, app_model_path),
-        None => {
-            let mut config_path = PathBuf::from(repository.path());
-            config_path.push(repo_config_file);
-
-            if config_path.exists() {
-                let repo_config: RepoSettings = toml::from_str(
-                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
-                )
-                .map_err(|err| err.to_string())?;
-
-                read_model(&repo_config.model, app_model_path)
-            } else {
-                Ok(
-                    read_model("git-flow", app_model_path)
-                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
-                )
-            }
-        }
-    }
-}
-
-/// Read a branching model file.
-fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
-    let model_file = app_model_path.join(format!("{}.toml", model));
-
-    if model_file.exists() {
-        toml::from_str::<BranchSettingsDef>(
-            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
-        )
-        .map_err(|err| err.to_string())
-    } else {
-        let models = get_available_models(app_model_path)?;
-        Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ))
-    }
-}
-
-/// Permanently sets the branching model for a repository
-fn set_model(
-    repository: &Repository,
-    model: &str,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<(), String> {
-    let models = get_available_models(app_model_path)?;
-
-    if !models.contains(&model.to_string()) {
-        return Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ));
-    }
-
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    let config = RepoSettings {
-        model: model.to_string(),
-    };
-
-    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
-    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
-
-    eprint!("Branching model set to '{}'", model);
-
-    Ok(())
-}
-
-/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
-/// and writes the files for built-in branching models there.
-fn create_config(app_model_path: &Path) -> Result<(), String> {
-    if !app_model_path.exists() {
-        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
-
-        let models = [
-            (BranchSettingsDef::git_flow(), "git-flow.toml"),
-            (BranchSettingsDef::simple(), "simple.toml"),
-            (BranchSettingsDef::none(), "none.toml"),
-        ];
-        for (model, file) in &models {
-            let path = app_model_path.join(file);
-            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
-            std::fs::write(&path, str).map_err(|err| err.to_string())?;
-        }
-    }
-
-    Ok(())
 }
 
 fn run(


[2025-09-21T21:54:56] thinking

**Handling cargo build without network**
[2025-09-21T21:54:56] exec bash -lc 'cargo build --offline' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:54:56] bash -lc 'cargo build --offline' exited -1 in 0ms:
error: no matching package named `matches` found
location searched: crates.io index
required by package `url v2.2.0`
    ... which satisfies dependency `url = "^2.0"` (locked to 2.2.0) of package `git2 v0.13.12`
    ... which satisfies dependency `git2 = "^0.13"` (locked to 0.13.12) of package `git-graph v0.1.7 (/Users/jqwang/104-CommitLens-codex/.workspace/rust-project)`
As a reminder, you're using offline mode (--offline) which can sometimes cause surprising resolution failures, if this error is too confusing you may wish to retry without `--offline`.
[2025-09-21T21:54:56] tokens used: 66,466
[2025-09-21T21:54:56] turn diff:
diff --git a/src/config.rs b/src/config.rs
new file mode 100644
index 0000000000000000000000000000000000000000..81325effb46e9b0d8a6518c23c8f31970ba2140e
--- /dev/null
+++ b/src/config.rs
@@ -0,0 +1,159 @@
+use git2::Repository;
+use std::path::{Path, PathBuf};
+
+use crate::settings::{BranchSettingsDef, RepoSettings};
+
+/// Get the currently set branching model for a repo.
+pub fn get_model_name(
+    repository: &Repository,
+    repo_config_file: &str,
+) -> Result<Option<String>, String> {
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    if config_path.exists() {
+        let repo_config: RepoSettings =
+            toml::from_str(&std::fs::read_to_string(config_path).map_err(|err| err.to_string())?)
+                .map_err(|err| err.to_string())?;
+
+        Ok(Some(repo_config.model))
+    } else {
+        Ok(None)
+    }
+}
+
+/// Get models available in `APP_DATA/git-graph/models`.
+pub fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
+    let models = std::fs::read_dir(app_model_path)
+        .map_err(|err| {
+            format!(
+                "ERROR: Cannot read models from {}: {}",
+                app_model_path.display(),
+                err
+            )
+        })?
+        .filter_map(|e| match e {
+            Ok(e) => {
+                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
+                    if ext == "toml" {
+                        if let Some(name) = name.to_str() {
+                            Some((&name[..(name.len() - 5)]).to_string())
+                        } else {
+                            None
+                        }
+                    } else {
+                        None
+                    }
+                } else {
+                    None
+                }
+            }
+            Err(_) => None,
+        })
+        .collect::<Vec<_>>();
+
+    Ok(models)
+}
+
+/// Try to get the branch settings for a given model.
+/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
+pub fn get_model(
+    repository: &Repository,
+    model: Option<&str>,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<BranchSettingsDef, String> {
+    match model {
+        Some(model) => read_model(model, app_model_path),
+        None => {
+            let mut config_path = PathBuf::from(repository.path());
+            config_path.push(repo_config_file);
+
+            if config_path.exists() {
+                let repo_config: RepoSettings = toml::from_str(
+                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+                )
+                .map_err(|err| err.to_string())?;
+
+                read_model(&repo_config.model, app_model_path)
+            } else {
+                Ok(read_model("git-flow", app_model_path)
+                    .unwrap_or_else(|_| BranchSettingsDef::git_flow()))
+            }
+        }
+    }
+}
+
+/// Read a branching model file.
+pub fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
+    let model_file = app_model_path.join(format!("{}.toml", model));
+
+    if model_file.exists() {
+        toml::from_str::<BranchSettingsDef>(
+            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())
+    } else {
+        let models = get_available_models(app_model_path)?;
+        Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ))
+    }
+}
+
+/// Permanently sets the branching model for a repository
+pub fn set_model(
+    repository: &Repository,
+    model: &str,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<(), String> {
+    let models = get_available_models(app_model_path)?;
+
+    if !models.contains(&model.to_string()) {
+        return Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ));
+    }
+
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    let config = RepoSettings {
+        model: model.to_string(),
+    };
+
+    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
+    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
+
+    eprint!("Branching model set to '{}'", model);
+
+    Ok(())
+}
+
+/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
+/// and writes the files for built-in branching models there.
+pub fn create_config(app_model_path: &Path) -> Result<(), String> {
+    if !app_model_path.exists() {
+        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
+
+        let models = [
+            (BranchSettingsDef::git_flow(), "git-flow.toml"),
+            (BranchSettingsDef::simple(), "simple.toml"),
+            (BranchSettingsDef::none(), "none.toml"),
+        ];
+        for (model, file) in &models {
+            let path = app_model_path.join(file);
+            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
+            std::fs::write(&path, str).map_err(|err| err.to_string())?;
+        }
+    }
+
+    Ok(())
+}
diff --git a/src/lib.rs b/src/lib.rs
index 47bcbc3c6eb3d05bb2376c3189d87a9d0068dac4..36c784c4cd69e7f84ddfaeeded8925ff08085b09
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,5 +1,6 @@
 //! Command line tool to show clear git graphs arranged for your branching model.
 
+pub mod config;
 pub mod graph;
 pub mod print;
 pub mod settings;
diff --git a/src/main.rs b/src/main.rs
index 49d62f30ab7d002cd2824e7236627b7594bd0b66..47351b780c0c4bb2946be1fb86c750f83aaa7279
--- a/src/main.rs
+++ b/src/main.rs
@@ -5,17 +5,17 @@
 use crossterm::terminal::{Clear, ClearType};
 use crossterm::{ErrorKind, ExecutableCommand};
 use git2::Repository;
+use git_graph::config::{
+    create_config, get_available_models, get_model, get_model_name, set_model,
+};
 use git_graph::graph::GitGraph;
 use git_graph::print::format::CommitFormat;
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
-use git_graph::settings::{
-    BranchOrder, BranchSettings, BranchSettingsDef, Characters, MergePatterns, RepoSettings,
-    Settings,
-};
+use git_graph::settings::{BranchOrder, BranchSettings, Characters, MergePatterns, Settings};
 use platform_dirs::AppDirs;
 use std::io::stdout;
-use std::path::{Path, PathBuf};
+use std::path::PathBuf;
 use std::str::FromStr;
 use std::time::Instant;
 
@@ -32,9 +32,7 @@
 }
 
 fn from_args() -> Result<(), String> {
-    let mut app_model_path = AppDirs::new(Some("git-graph"), false)
-        .unwrap()
-        .config_dir;
+    let mut app_model_path = AppDirs::new(Some("git-graph"), false).unwrap().config_dir;
     app_model_path.push("models");
 
     create_config(&app_model_path)?;
@@ -377,160 +375,6 @@
     };
 
     run(repository, &settings, svg, commit_limit, pager)
-}
-
-/// Get the currently set branching model for a repo.
-fn get_model_name(repository: &Repository, repo_config_file: &str) -> Result<Option<String>, String> {
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    if config_path.exists() {
-        let repo_config: RepoSettings =
-            toml::from_str(&std::fs::read_to_string(config_path).map_err(|err| err.to_string())?)
-                .map_err(|err| err.to_string())?;
-
-        Ok(Some(repo_config.model))
-    } else {
-        Ok(None)
-    }
-}
-
-/// Get models available in `APP_DATA/git-graph/models`.
-fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
-    let models = std::fs::read_dir(app_model_path)
-        .map_err(|err| {
-            format!(
-                "ERROR: Cannot read models from {}: {}",
-                app_model_path.display(),
-                err
-            )
-        })?
-        .filter_map(|e| match e {
-            Ok(e) => {
-                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
-                    if ext == "toml" {
-                        if let Some(name) = name.to_str() {
-                            Some((&name[..(name.len() - 5)]).to_string())
-                        } else {
-                            None
-                        }
-                    } else {
-                        None
-                    }
-                } else {
-                    None
-                }
-            }
-            Err(_) => None,
-        })
-        .collect::<Vec<_>>();
-
-    Ok(models)
-}
-
-/// Try to get the branch settings for a given model.
-/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
-fn get_model(
-    repository: &Repository,
-    model: Option<&str>,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<BranchSettingsDef, String> {
-    match model {
-        Some(model) => read_model(model, app_model_path),
-        None => {
-            let mut config_path = PathBuf::from(repository.path());
-            config_path.push(repo_config_file);
-
-            if config_path.exists() {
-                let repo_config: RepoSettings = toml::from_str(
-                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
-                )
-                .map_err(|err| err.to_string())?;
-
-                read_model(&repo_config.model, app_model_path)
-            } else {
-                Ok(
-                    read_model("git-flow", app_model_path)
-                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
-                )
-            }
-        }
-    }
-}
-
-/// Read a branching model file.
-fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
-    let model_file = app_model_path.join(format!("{}.toml", model));
-
-    if model_file.exists() {
-        toml::from_str::<BranchSettingsDef>(
-            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
-        )
-        .map_err(|err| err.to_string())
-    } else {
-        let models = get_available_models(app_model_path)?;
-        Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ))
-    }
-}
-
-/// Permanently sets the branching model for a repository
-fn set_model(
-    repository: &Repository,
-    model: &str,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<(), String> {
-    let models = get_available_models(app_model_path)?;
-
-    if !models.contains(&model.to_string()) {
-        return Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ));
-    }
-
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    let config = RepoSettings {
-        model: model.to_string(),
-    };
-
-    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
-    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
-
-    eprint!("Branching model set to '{}'", model);
-
-    Ok(())
-}
-
-/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
-/// and writes the files for built-in branching models there.
-fn create_config(app_model_path: &Path) -> Result<(), String> {
-    if !app_model_path.exists() {
-        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
-
-        let models = [
-            (BranchSettingsDef::git_flow(), "git-flow.toml"),
-            (BranchSettingsDef::simple(), "simple.toml"),
-            (BranchSettingsDef::none(), "none.toml"),
-        ];
-        for (model, file) in &models {
-            let path = app_model_path.join(file);
-            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
-            std::fs::write(&path, str).map_err(|err| err.to_string())?;
-        }
-    }
-
-    Ok(())
 }
 
 fn run(


[2025-09-21T21:54:58] thinking

**Confirming repository state before finalizing**
[2025-09-21T21:54:58] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:54:58] bash -lc 'git status -sb' succeeded in 16ms:
## main
 M src/lib.rs
 M src/main.rs
?? src/config.rs
[2025-09-21T21:54:58] tokens used: 66,763
[2025-09-21T21:54:58] turn diff:
diff --git a/src/config.rs b/src/config.rs
new file mode 100644
index 0000000000000000000000000000000000000000..81325effb46e9b0d8a6518c23c8f31970ba2140e
--- /dev/null
+++ b/src/config.rs
@@ -0,0 +1,159 @@
+use git2::Repository;
+use std::path::{Path, PathBuf};
+
+use crate::settings::{BranchSettingsDef, RepoSettings};
+
+/// Get the currently set branching model for a repo.
+pub fn get_model_name(
+    repository: &Repository,
+    repo_config_file: &str,
+) -> Result<Option<String>, String> {
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    if config_path.exists() {
+        let repo_config: RepoSettings =
+            toml::from_str(&std::fs::read_to_string(config_path).map_err(|err| err.to_string())?)
+                .map_err(|err| err.to_string())?;
+
+        Ok(Some(repo_config.model))
+    } else {
+        Ok(None)
+    }
+}
+
+/// Get models available in `APP_DATA/git-graph/models`.
+pub fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
+    let models = std::fs::read_dir(app_model_path)
+        .map_err(|err| {
+            format!(
+                "ERROR: Cannot read models from {}: {}",
+                app_model_path.display(),
+                err
+            )
+        })?
+        .filter_map(|e| match e {
+            Ok(e) => {
+                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
+                    if ext == "toml" {
+                        if let Some(name) = name.to_str() {
+                            Some((&name[..(name.len() - 5)]).to_string())
+                        } else {
+                            None
+                        }
+                    } else {
+                        None
+                    }
+                } else {
+                    None
+                }
+            }
+            Err(_) => None,
+        })
+        .collect::<Vec<_>>();
+
+    Ok(models)
+}
+
+/// Try to get the branch settings for a given model.
+/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
+pub fn get_model(
+    repository: &Repository,
+    model: Option<&str>,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<BranchSettingsDef, String> {
+    match model {
+        Some(model) => read_model(model, app_model_path),
+        None => {
+            let mut config_path = PathBuf::from(repository.path());
+            config_path.push(repo_config_file);
+
+            if config_path.exists() {
+                let repo_config: RepoSettings = toml::from_str(
+                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+                )
+                .map_err(|err| err.to_string())?;
+
+                read_model(&repo_config.model, app_model_path)
+            } else {
+                Ok(read_model("git-flow", app_model_path)
+                    .unwrap_or_else(|_| BranchSettingsDef::git_flow()))
+            }
+        }
+    }
+}
+
+/// Read a branching model file.
+pub fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
+    let model_file = app_model_path.join(format!("{}.toml", model));
+
+    if model_file.exists() {
+        toml::from_str::<BranchSettingsDef>(
+            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())
+    } else {
+        let models = get_available_models(app_model_path)?;
+        Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ))
+    }
+}
+
+/// Permanently sets the branching model for a repository
+pub fn set_model(
+    repository: &Repository,
+    model: &str,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<(), String> {
+    let models = get_available_models(app_model_path)?;
+
+    if !models.contains(&model.to_string()) {
+        return Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ));
+    }
+
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    let config = RepoSettings {
+        model: model.to_string(),
+    };
+
+    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
+    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
+
+    eprint!("Branching model set to '{}'", model);
+
+    Ok(())
+}
+
+/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
+/// and writes the files for built-in branching models there.
+pub fn create_config(app_model_path: &Path) -> Result<(), String> {
+    if !app_model_path.exists() {
+        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
+
+        let models = [
+            (BranchSettingsDef::git_flow(), "git-flow.toml"),
+            (BranchSettingsDef::simple(), "simple.toml"),
+            (BranchSettingsDef::none(), "none.toml"),
+        ];
+        for (model, file) in &models {
+            let path = app_model_path.join(file);
+            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
+            std::fs::write(&path, str).map_err(|err| err.to_string())?;
+        }
+    }
+
+    Ok(())
+}
diff --git a/src/lib.rs b/src/lib.rs
index 47bcbc3c6eb3d05bb2376c3189d87a9d0068dac4..36c784c4cd69e7f84ddfaeeded8925ff08085b09
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,5 +1,6 @@
 //! Command line tool to show clear git graphs arranged for your branching model.
 
+pub mod config;
 pub mod graph;
 pub mod print;
 pub mod settings;
diff --git a/src/main.rs b/src/main.rs
index 49d62f30ab7d002cd2824e7236627b7594bd0b66..47351b780c0c4bb2946be1fb86c750f83aaa7279
--- a/src/main.rs
+++ b/src/main.rs
@@ -5,17 +5,17 @@
 use crossterm::terminal::{Clear, ClearType};
 use crossterm::{ErrorKind, ExecutableCommand};
 use git2::Repository;
+use git_graph::config::{
+    create_config, get_available_models, get_model, get_model_name, set_model,
+};
 use git_graph::graph::GitGraph;
 use git_graph::print::format::CommitFormat;
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
-use git_graph::settings::{
-    BranchOrder, BranchSettings, BranchSettingsDef, Characters, MergePatterns, RepoSettings,
-    Settings,
-};
+use git_graph::settings::{BranchOrder, BranchSettings, Characters, MergePatterns, Settings};
 use platform_dirs::AppDirs;
 use std::io::stdout;
-use std::path::{Path, PathBuf};
+use std::path::PathBuf;
 use std::str::FromStr;
 use std::time::Instant;
 
@@ -32,9 +32,7 @@
 }
 
 fn from_args() -> Result<(), String> {
-    let mut app_model_path = AppDirs::new(Some("git-graph"), false)
-        .unwrap()
-        .config_dir;
+    let mut app_model_path = AppDirs::new(Some("git-graph"), false).unwrap().config_dir;
     app_model_path.push("models");
 
     create_config(&app_model_path)?;
@@ -377,160 +375,6 @@
     };
 
     run(repository, &settings, svg, commit_limit, pager)
-}
-
-/// Get the currently set branching model for a repo.
-fn get_model_name(repository: &Repository, repo_config_file: &str) -> Result<Option<String>, String> {
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    if config_path.exists() {
-        let repo_config: RepoSettings =
-            toml::from_str(&std::fs::read_to_string(config_path).map_err(|err| err.to_string())?)
-                .map_err(|err| err.to_string())?;
-
-        Ok(Some(repo_config.model))
-    } else {
-        Ok(None)
-    }
-}
-
-/// Get models available in `APP_DATA/git-graph/models`.
-fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
-    let models = std::fs::read_dir(app_model_path)
-        .map_err(|err| {
-            format!(
-                "ERROR: Cannot read models from {}: {}",
-                app_model_path.display(),
-                err
-            )
-        })?
-        .filter_map(|e| match e {
-            Ok(e) => {
-                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
-                    if ext == "toml" {
-                        if let Some(name) = name.to_str() {
-                            Some((&name[..(name.len() - 5)]).to_string())
-                        } else {
-                            None
-                        }
-                    } else {
-                        None
-                    }
-                } else {
-                    None
-                }
-            }
-            Err(_) => None,
-        })
-        .collect::<Vec<_>>();
-
-    Ok(models)
-}
-
-/// Try to get the branch settings for a given model.
-/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
-fn get_model(
-    repository: &Repository,
-    model: Option<&str>,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<BranchSettingsDef, String> {
-    match model {
-        Some(model) => read_model(model, app_model_path),
-        None => {
-            let mut config_path = PathBuf::from(repository.path());
-            config_path.push(repo_config_file);
-
-            if config_path.exists() {
-                let repo_config: RepoSettings = toml::from_str(
-                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
-                )
-                .map_err(|err| err.to_string())?;
-
-                read_model(&repo_config.model, app_model_path)
-            } else {
-                Ok(
-                    read_model("git-flow", app_model_path)
-                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
-                )
-            }
-        }
-    }
-}
-
-/// Read a branching model file.
-fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
-    let model_file = app_model_path.join(format!("{}.toml", model));
-
-    if model_file.exists() {
-        toml::from_str::<BranchSettingsDef>(
-            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
-        )
-        .map_err(|err| err.to_string())
-    } else {
-        let models = get_available_models(app_model_path)?;
-        Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ))
-    }
-}
-
-/// Permanently sets the branching model for a repository
-fn set_model(
-    repository: &Repository,
-    model: &str,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<(), String> {
-    let models = get_available_models(app_model_path)?;
-
-    if !models.contains(&model.to_string()) {
-        return Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ));
-    }
-
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    let config = RepoSettings {
-        model: model.to_string(),
-    };
-
-    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
-    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
-
-    eprint!("Branching model set to '{}'", model);
-
-    Ok(())
-}
-
-/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
-/// and writes the files for built-in branching models there.
-fn create_config(app_model_path: &Path) -> Result<(), String> {
-    if !app_model_path.exists() {
-        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
-
-        let models = [
-            (BranchSettingsDef::git_flow(), "git-flow.toml"),
-            (BranchSettingsDef::simple(), "simple.toml"),
-            (BranchSettingsDef::none(), "none.toml"),
-        ];
-        for (model, file) in &models {
-            let path = app_model_path.join(file);
-            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
-            std::fs::write(&path, str).map_err(|err| err.to_string())?;
-        }
-    }
-
-    Ok(())
 }
 
 fn run(


[2025-09-21T21:55:02] thinking

**Staging and committing changes**
[2025-09-21T21:55:02] exec bash -lc 'git add -A' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:55:02] bash -lc 'git add -A' succeeded in 38ms:

[2025-09-21T21:55:02] tokens used: 66,942
[2025-09-21T21:55:02] turn diff:
diff --git a/src/config.rs b/src/config.rs
new file mode 100644
index 0000000000000000000000000000000000000000..81325effb46e9b0d8a6518c23c8f31970ba2140e
--- /dev/null
+++ b/src/config.rs
@@ -0,0 +1,159 @@
+use git2::Repository;
+use std::path::{Path, PathBuf};
+
+use crate::settings::{BranchSettingsDef, RepoSettings};
+
+/// Get the currently set branching model for a repo.
+pub fn get_model_name(
+    repository: &Repository,
+    repo_config_file: &str,
+) -> Result<Option<String>, String> {
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    if config_path.exists() {
+        let repo_config: RepoSettings =
+            toml::from_str(&std::fs::read_to_string(config_path).map_err(|err| err.to_string())?)
+                .map_err(|err| err.to_string())?;
+
+        Ok(Some(repo_config.model))
+    } else {
+        Ok(None)
+    }
+}
+
+/// Get models available in `APP_DATA/git-graph/models`.
+pub fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
+    let models = std::fs::read_dir(app_model_path)
+        .map_err(|err| {
+            format!(
+                "ERROR: Cannot read models from {}: {}",
+                app_model_path.display(),
+                err
+            )
+        })?
+        .filter_map(|e| match e {
+            Ok(e) => {
+                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
+                    if ext == "toml" {
+                        if let Some(name) = name.to_str() {
+                            Some((&name[..(name.len() - 5)]).to_string())
+                        } else {
+                            None
+                        }
+                    } else {
+                        None
+                    }
+                } else {
+                    None
+                }
+            }
+            Err(_) => None,
+        })
+        .collect::<Vec<_>>();
+
+    Ok(models)
+}
+
+/// Try to get the branch settings for a given model.
+/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
+pub fn get_model(
+    repository: &Repository,
+    model: Option<&str>,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<BranchSettingsDef, String> {
+    match model {
+        Some(model) => read_model(model, app_model_path),
+        None => {
+            let mut config_path = PathBuf::from(repository.path());
+            config_path.push(repo_config_file);
+
+            if config_path.exists() {
+                let repo_config: RepoSettings = toml::from_str(
+                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+                )
+                .map_err(|err| err.to_string())?;
+
+                read_model(&repo_config.model, app_model_path)
+            } else {
+                Ok(read_model("git-flow", app_model_path)
+                    .unwrap_or_else(|_| BranchSettingsDef::git_flow()))
+            }
+        }
+    }
+}
+
+/// Read a branching model file.
+pub fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
+    let model_file = app_model_path.join(format!("{}.toml", model));
+
+    if model_file.exists() {
+        toml::from_str::<BranchSettingsDef>(
+            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())
+    } else {
+        let models = get_available_models(app_model_path)?;
+        Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ))
+    }
+}
+
+/// Permanently sets the branching model for a repository
+pub fn set_model(
+    repository: &Repository,
+    model: &str,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<(), String> {
+    let models = get_available_models(app_model_path)?;
+
+    if !models.contains(&model.to_string()) {
+        return Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ));
+    }
+
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    let config = RepoSettings {
+        model: model.to_string(),
+    };
+
+    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
+    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
+
+    eprint!("Branching model set to '{}'", model);
+
+    Ok(())
+}
+
+/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
+/// and writes the files for built-in branching models there.
+pub fn create_config(app_model_path: &Path) -> Result<(), String> {
+    if !app_model_path.exists() {
+        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
+
+        let models = [
+            (BranchSettingsDef::git_flow(), "git-flow.toml"),
+            (BranchSettingsDef::simple(), "simple.toml"),
+            (BranchSettingsDef::none(), "none.toml"),
+        ];
+        for (model, file) in &models {
+            let path = app_model_path.join(file);
+            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
+            std::fs::write(&path, str).map_err(|err| err.to_string())?;
+        }
+    }
+
+    Ok(())
+}
diff --git a/src/lib.rs b/src/lib.rs
index 47bcbc3c6eb3d05bb2376c3189d87a9d0068dac4..36c784c4cd69e7f84ddfaeeded8925ff08085b09
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,5 +1,6 @@
 //! Command line tool to show clear git graphs arranged for your branching model.
 
+pub mod config;
 pub mod graph;
 pub mod print;
 pub mod settings;
diff --git a/src/main.rs b/src/main.rs
index 49d62f30ab7d002cd2824e7236627b7594bd0b66..47351b780c0c4bb2946be1fb86c750f83aaa7279
--- a/src/main.rs
+++ b/src/main.rs
@@ -5,17 +5,17 @@
 use crossterm::terminal::{Clear, ClearType};
 use crossterm::{ErrorKind, ExecutableCommand};
 use git2::Repository;
+use git_graph::config::{
+    create_config, get_available_models, get_model, get_model_name, set_model,
+};
 use git_graph::graph::GitGraph;
 use git_graph::print::format::CommitFormat;
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
-use git_graph::settings::{
-    BranchOrder, BranchSettings, BranchSettingsDef, Characters, MergePatterns, RepoSettings,
-    Settings,
-};
+use git_graph::settings::{BranchOrder, BranchSettings, Characters, MergePatterns, Settings};
 use platform_dirs::AppDirs;
 use std::io::stdout;
-use std::path::{Path, PathBuf};
+use std::path::PathBuf;
 use std::str::FromStr;
 use std::time::Instant;
 
@@ -32,9 +32,7 @@
 }
 
 fn from_args() -> Result<(), String> {
-    let mut app_model_path = AppDirs::new(Some("git-graph"), false)
-        .unwrap()
-        .config_dir;
+    let mut app_model_path = AppDirs::new(Some("git-graph"), false).unwrap().config_dir;
     app_model_path.push("models");
 
     create_config(&app_model_path)?;
@@ -377,160 +375,6 @@
     };
 
     run(repository, &settings, svg, commit_limit, pager)
-}
-
-/// Get the currently set branching model for a repo.
-fn get_model_name(repository: &Repository, repo_config_file: &str) -> Result<Option<String>, String> {
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    if config_path.exists() {
-        let repo_config: RepoSettings =
-            toml::from_str(&std::fs::read_to_string(config_path).map_err(|err| err.to_string())?)
-                .map_err(|err| err.to_string())?;
-
-        Ok(Some(repo_config.model))
-    } else {
-        Ok(None)
-    }
-}
-
-/// Get models available in `APP_DATA/git-graph/models`.
-fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
-    let models = std::fs::read_dir(app_model_path)
-        .map_err(|err| {
-            format!(
-                "ERROR: Cannot read models from {}: {}",
-                app_model_path.display(),
-                err
-            )
-        })?
-        .filter_map(|e| match e {
-            Ok(e) => {
-                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
-                    if ext == "toml" {
-                        if let Some(name) = name.to_str() {
-                            Some((&name[..(name.len() - 5)]).to_string())
-                        } else {
-                            None
-                        }
-                    } else {
-                        None
-                    }
-                } else {
-                    None
-                }
-            }
-            Err(_) => None,
-        })
-        .collect::<Vec<_>>();
-
-    Ok(models)
-}
-
-/// Try to get the branch settings for a given model.
-/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
-fn get_model(
-    repository: &Repository,
-    model: Option<&str>,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<BranchSettingsDef, String> {
-    match model {
-        Some(model) => read_model(model, app_model_path),
-        None => {
-            let mut config_path = PathBuf::from(repository.path());
-            config_path.push(repo_config_file);
-
-            if config_path.exists() {
-                let repo_config: RepoSettings = toml::from_str(
-                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
-                )
-                .map_err(|err| err.to_string())?;
-
-                read_model(&repo_config.model, app_model_path)
-            } else {
-                Ok(
-                    read_model("git-flow", app_model_path)
-                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
-                )
-            }
-        }
-    }
-}
-
-/// Read a branching model file.
-fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
-    let model_file = app_model_path.join(format!("{}.toml", model));
-
-    if model_file.exists() {
-        toml::from_str::<BranchSettingsDef>(
-            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
-        )
-        .map_err(|err| err.to_string())
-    } else {
-        let models = get_available_models(app_model_path)?;
-        Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ))
-    }
-}
-
-/// Permanently sets the branching model for a repository
-fn set_model(
-    repository: &Repository,
-    model: &str,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<(), String> {
-    let models = get_available_models(app_model_path)?;
-
-    if !models.contains(&model.to_string()) {
-        return Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ));
-    }
-
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    let config = RepoSettings {
-        model: model.to_string(),
-    };
-
-    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
-    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
-
-    eprint!("Branching model set to '{}'", model);
-
-    Ok(())
-}
-
-/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
-/// and writes the files for built-in branching models there.
-fn create_config(app_model_path: &Path) -> Result<(), String> {
-    if !app_model_path.exists() {
-        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
-
-        let models = [
-            (BranchSettingsDef::git_flow(), "git-flow.toml"),
-            (BranchSettingsDef::simple(), "simple.toml"),
-            (BranchSettingsDef::none(), "none.toml"),
-        ];
-        for (model, file) in &models {
-            let path = app_model_path.join(file);
-            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
-            std::fs::write(&path, str).map_err(|err| err.to_string())?;
-        }
-    }
-
-    Ok(())
 }
 
 fn run(


[2025-09-21T21:55:05] thinking

**Committing with specified message**
[2025-09-21T21:55:05] exec bash -lc "git commit -m '083-fe2e3a4：复现提交代码内容。'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-21T21:55:05] bash -lc "git commit -m '083-fe2e3a4：复现提交代码内容。'" succeeded in 39ms:
[main 6799664] 083-fe2e3a4：复现提交代码内容。
 3 files changed, 166 insertions(+), 162 deletions(-)
 create mode 100644 src/config.rs
[2025-09-21T21:55:05] tokens used: 67,206
[2025-09-21T21:55:05] turn diff:
diff --git a/src/config.rs b/src/config.rs
new file mode 100644
index 0000000000000000000000000000000000000000..81325effb46e9b0d8a6518c23c8f31970ba2140e
--- /dev/null
+++ b/src/config.rs
@@ -0,0 +1,159 @@
+use git2::Repository;
+use std::path::{Path, PathBuf};
+
+use crate::settings::{BranchSettingsDef, RepoSettings};
+
+/// Get the currently set branching model for a repo.
+pub fn get_model_name(
+    repository: &Repository,
+    repo_config_file: &str,
+) -> Result<Option<String>, String> {
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    if config_path.exists() {
+        let repo_config: RepoSettings =
+            toml::from_str(&std::fs::read_to_string(config_path).map_err(|err| err.to_string())?)
+                .map_err(|err| err.to_string())?;
+
+        Ok(Some(repo_config.model))
+    } else {
+        Ok(None)
+    }
+}
+
+/// Get models available in `APP_DATA/git-graph/models`.
+pub fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
+    let models = std::fs::read_dir(app_model_path)
+        .map_err(|err| {
+            format!(
+                "ERROR: Cannot read models from {}: {}",
+                app_model_path.display(),
+                err
+            )
+        })?
+        .filter_map(|e| match e {
+            Ok(e) => {
+                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
+                    if ext == "toml" {
+                        if let Some(name) = name.to_str() {
+                            Some((&name[..(name.len() - 5)]).to_string())
+                        } else {
+                            None
+                        }
+                    } else {
+                        None
+                    }
+                } else {
+                    None
+                }
+            }
+            Err(_) => None,
+        })
+        .collect::<Vec<_>>();
+
+    Ok(models)
+}
+
+/// Try to get the branch settings for a given model.
+/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
+pub fn get_model(
+    repository: &Repository,
+    model: Option<&str>,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<BranchSettingsDef, String> {
+    match model {
+        Some(model) => read_model(model, app_model_path),
+        None => {
+            let mut config_path = PathBuf::from(repository.path());
+            config_path.push(repo_config_file);
+
+            if config_path.exists() {
+                let repo_config: RepoSettings = toml::from_str(
+                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+                )
+                .map_err(|err| err.to_string())?;
+
+                read_model(&repo_config.model, app_model_path)
+            } else {
+                Ok(read_model("git-flow", app_model_path)
+                    .unwrap_or_else(|_| BranchSettingsDef::git_flow()))
+            }
+        }
+    }
+}
+
+/// Read a branching model file.
+pub fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
+    let model_file = app_model_path.join(format!("{}.toml", model));
+
+    if model_file.exists() {
+        toml::from_str::<BranchSettingsDef>(
+            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())
+    } else {
+        let models = get_available_models(app_model_path)?;
+        Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ))
+    }
+}
+
+/// Permanently sets the branching model for a repository
+pub fn set_model(
+    repository: &Repository,
+    model: &str,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<(), String> {
+    let models = get_available_models(app_model_path)?;
+
+    if !models.contains(&model.to_string()) {
+        return Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ));
+    }
+
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    let config = RepoSettings {
+        model: model.to_string(),
+    };
+
+    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
+    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
+
+    eprint!("Branching model set to '{}'", model);
+
+    Ok(())
+}
+
+/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
+/// and writes the files for built-in branching models there.
+pub fn create_config(app_model_path: &Path) -> Result<(), String> {
+    if !app_model_path.exists() {
+        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
+
+        let models = [
+            (BranchSettingsDef::git_flow(), "git-flow.toml"),
+            (BranchSettingsDef::simple(), "simple.toml"),
+            (BranchSettingsDef::none(), "none.toml"),
+        ];
+        for (model, file) in &models {
+            let path = app_model_path.join(file);
+            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
+            std::fs::write(&path, str).map_err(|err| err.to_string())?;
+        }
+    }
+
+    Ok(())
+}
diff --git a/src/lib.rs b/src/lib.rs
index 47bcbc3c6eb3d05bb2376c3189d87a9d0068dac4..36c784c4cd69e7f84ddfaeeded8925ff08085b09
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,5 +1,6 @@
 //! Command line tool to show clear git graphs arranged for your branching model.
 
+pub mod config;
 pub mod graph;
 pub mod print;
 pub mod settings;
diff --git a/src/main.rs b/src/main.rs
index 49d62f30ab7d002cd2824e7236627b7594bd0b66..47351b780c0c4bb2946be1fb86c750f83aaa7279
--- a/src/main.rs
+++ b/src/main.rs
@@ -5,17 +5,17 @@
 use crossterm::terminal::{Clear, ClearType};
 use crossterm::{ErrorKind, ExecutableCommand};
 use git2::Repository;
+use git_graph::config::{
+    create_config, get_available_models, get_model, get_model_name, set_model,
+};
 use git_graph::graph::GitGraph;
 use git_graph::print::format::CommitFormat;
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
-use git_graph::settings::{
-    BranchOrder, BranchSettings, BranchSettingsDef, Characters, MergePatterns, RepoSettings,
-    Settings,
-};
+use git_graph::settings::{BranchOrder, BranchSettings, Characters, MergePatterns, Settings};
 use platform_dirs::AppDirs;
 use std::io::stdout;
-use std::path::{Path, PathBuf};
+use std::path::PathBuf;
 use std::str::FromStr;
 use std::time::Instant;
 
@@ -32,9 +32,7 @@
 }
 
 fn from_args() -> Result<(), String> {
-    let mut app_model_path = AppDirs::new(Some("git-graph"), false)
-        .unwrap()
-        .config_dir;
+    let mut app_model_path = AppDirs::new(Some("git-graph"), false).unwrap().config_dir;
     app_model_path.push("models");
 
     create_config(&app_model_path)?;
@@ -377,160 +375,6 @@
     };
 
     run(repository, &settings, svg, commit_limit, pager)
-}
-
-/// Get the currently set branching model for a repo.
-fn get_model_name(repository: &Repository, repo_config_file: &str) -> Result<Option<String>, String> {
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    if config_path.exists() {
-        let repo_config: RepoSettings =
-            toml::from_str(&std::fs::read_to_string(config_path).map_err(|err| err.to_string())?)
-                .map_err(|err| err.to_string())?;
-
-        Ok(Some(repo_config.model))
-    } else {
-        Ok(None)
-    }
-}
-
-/// Get models available in `APP_DATA/git-graph/models`.
-fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
-    let models = std::fs::read_dir(app_model_path)
-        .map_err(|err| {
-            format!(
-                "ERROR: Cannot read models from {}: {}",
-                app_model_path.display(),
-                err
-            )
-        })?
-        .filter_map(|e| match e {
-            Ok(e) => {
-                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
-                    if ext == "toml" {
-                        if let Some(name) = name.to_str() {
-                            Some((&name[..(name.len() - 5)]).to_string())
-                        } else {
-                            None
-                        }
-                    } else {
-                        None
-                    }
-                } else {
-                    None
-                }
-            }
-            Err(_) => None,
-        })
-        .collect::<Vec<_>>();
-
-    Ok(models)
-}
-
-/// Try to get the branch settings for a given model.
-/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
-fn get_model(
-    repository: &Repository,
-    model: Option<&str>,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<BranchSettingsDef, String> {
-    match model {
-        Some(model) => read_model(model, app_model_path),
-        None => {
-            let mut config_path = PathBuf::from(repository.path());
-            config_path.push(repo_config_file);
-
-            if config_path.exists() {
-                let repo_config: RepoSettings = toml::from_str(
-                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
-                )
-                .map_err(|err| err.to_string())?;
-
-                read_model(&repo_config.model, app_model_path)
-            } else {
-                Ok(
-                    read_model("git-flow", app_model_path)
-                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
-                )
-            }
-        }
-    }
-}
-
-/// Read a branching model file.
-fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
-    let model_file = app_model_path.join(format!("{}.toml", model));
-
-    if model_file.exists() {
-        toml::from_str::<BranchSettingsDef>(
-            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
-        )
-        .map_err(|err| err.to_string())
-    } else {
-        let models = get_available_models(app_model_path)?;
-        Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ))
-    }
-}
-
-/// Permanently sets the branching model for a repository
-fn set_model(
-    repository: &Repository,
-    model: &str,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<(), String> {
-    let models = get_available_models(app_model_path)?;
-
-    if !models.contains(&model.to_string()) {
-        return Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ));
-    }
-
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    let config = RepoSettings {
-        model: model.to_string(),
-    };
-
-    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
-    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
-
-    eprint!("Branching model set to '{}'", model);
-
-    Ok(())
-}
-
-/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
-/// and writes the files for built-in branching models there.
-fn create_config(app_model_path: &Path) -> Result<(), String> {
-    if !app_model_path.exists() {
-        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
-
-        let models = [
-            (BranchSettingsDef::git_flow(), "git-flow.toml"),
-            (BranchSettingsDef::simple(), "simple.toml"),
-            (BranchSettingsDef::none(), "none.toml"),
-        ];
-        for (model, file) in &models {
-            let path = app_model_path.join(file);
-            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
-            std::fs::write(&path, str).map_err(|err| err.to_string())?;
-        }
-    }
-
-    Ok(())
 }
 
 fn run(


[2025-09-21T21:55:16] thinking

**Preparing final summary**

I'm organizing the final message with clear sections for changes, verification steps including the failed build due to network issues, and logical next steps for the user to try when online. I'll reference modified files with line numbers and note assumptions accordingly.
[2025-09-21T21:55:16] codex

**Changes**
- src/config.rs:1 新增 `config` 模块，封装原先 `main.rs` 内的模型读取/写入函数以便复用。
- src/lib.rs:3 导出 `pub mod config;`，让二进制入口通过 `git_graph::config` 访问配置 API。
- src/main.rs:1 更新引用至新模块并移除内联实现，同时清理已无用的设置类型与 `Path` 导入。

**Verification**
- `cargo fmt`
- `cargo build`（失败：无法解析 `index.crates.io`，离线编译亦因缺少 `matches` crate 缓存而中止；需联机重试）

**Next Steps**
1. 联网后重新执行 `cargo build`/`cargo test`，确保依赖完整并通过构建。
[2025-09-21T21:55:17] tokens used: 68,310
[2025-09-21T21:55:17] turn diff:
diff --git a/src/config.rs b/src/config.rs
new file mode 100644
index 0000000000000000000000000000000000000000..81325effb46e9b0d8a6518c23c8f31970ba2140e
--- /dev/null
+++ b/src/config.rs
@@ -0,0 +1,159 @@
+use git2::Repository;
+use std::path::{Path, PathBuf};
+
+use crate::settings::{BranchSettingsDef, RepoSettings};
+
+/// Get the currently set branching model for a repo.
+pub fn get_model_name(
+    repository: &Repository,
+    repo_config_file: &str,
+) -> Result<Option<String>, String> {
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    if config_path.exists() {
+        let repo_config: RepoSettings =
+            toml::from_str(&std::fs::read_to_string(config_path).map_err(|err| err.to_string())?)
+                .map_err(|err| err.to_string())?;
+
+        Ok(Some(repo_config.model))
+    } else {
+        Ok(None)
+    }
+}
+
+/// Get models available in `APP_DATA/git-graph/models`.
+pub fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
+    let models = std::fs::read_dir(app_model_path)
+        .map_err(|err| {
+            format!(
+                "ERROR: Cannot read models from {}: {}",
+                app_model_path.display(),
+                err
+            )
+        })?
+        .filter_map(|e| match e {
+            Ok(e) => {
+                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
+                    if ext == "toml" {
+                        if let Some(name) = name.to_str() {
+                            Some((&name[..(name.len() - 5)]).to_string())
+                        } else {
+                            None
+                        }
+                    } else {
+                        None
+                    }
+                } else {
+                    None
+                }
+            }
+            Err(_) => None,
+        })
+        .collect::<Vec<_>>();
+
+    Ok(models)
+}
+
+/// Try to get the branch settings for a given model.
+/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
+pub fn get_model(
+    repository: &Repository,
+    model: Option<&str>,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<BranchSettingsDef, String> {
+    match model {
+        Some(model) => read_model(model, app_model_path),
+        None => {
+            let mut config_path = PathBuf::from(repository.path());
+            config_path.push(repo_config_file);
+
+            if config_path.exists() {
+                let repo_config: RepoSettings = toml::from_str(
+                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
+                )
+                .map_err(|err| err.to_string())?;
+
+                read_model(&repo_config.model, app_model_path)
+            } else {
+                Ok(read_model("git-flow", app_model_path)
+                    .unwrap_or_else(|_| BranchSettingsDef::git_flow()))
+            }
+        }
+    }
+}
+
+/// Read a branching model file.
+pub fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
+    let model_file = app_model_path.join(format!("{}.toml", model));
+
+    if model_file.exists() {
+        toml::from_str::<BranchSettingsDef>(
+            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
+        )
+        .map_err(|err| err.to_string())
+    } else {
+        let models = get_available_models(app_model_path)?;
+        Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ))
+    }
+}
+
+/// Permanently sets the branching model for a repository
+pub fn set_model(
+    repository: &Repository,
+    model: &str,
+    repo_config_file: &str,
+    app_model_path: &Path,
+) -> Result<(), String> {
+    let models = get_available_models(app_model_path)?;
+
+    if !models.contains(&model.to_string()) {
+        return Err(format!(
+            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
+            model,
+            app_model_path.display(),
+            itertools::join(models, ", ")
+        ));
+    }
+
+    let mut config_path = PathBuf::from(repository.path());
+    config_path.push(repo_config_file);
+
+    let config = RepoSettings {
+        model: model.to_string(),
+    };
+
+    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
+    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
+
+    eprint!("Branching model set to '{}'", model);
+
+    Ok(())
+}
+
+/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
+/// and writes the files for built-in branching models there.
+pub fn create_config(app_model_path: &Path) -> Result<(), String> {
+    if !app_model_path.exists() {
+        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
+
+        let models = [
+            (BranchSettingsDef::git_flow(), "git-flow.toml"),
+            (BranchSettingsDef::simple(), "simple.toml"),
+            (BranchSettingsDef::none(), "none.toml"),
+        ];
+        for (model, file) in &models {
+            let path = app_model_path.join(file);
+            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
+            std::fs::write(&path, str).map_err(|err| err.to_string())?;
+        }
+    }
+
+    Ok(())
+}
diff --git a/src/lib.rs b/src/lib.rs
index 47bcbc3c6eb3d05bb2376c3189d87a9d0068dac4..36c784c4cd69e7f84ddfaeeded8925ff08085b09
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,5 +1,6 @@
 //! Command line tool to show clear git graphs arranged for your branching model.
 
+pub mod config;
 pub mod graph;
 pub mod print;
 pub mod settings;
diff --git a/src/main.rs b/src/main.rs
index 49d62f30ab7d002cd2824e7236627b7594bd0b66..47351b780c0c4bb2946be1fb86c750f83aaa7279
--- a/src/main.rs
+++ b/src/main.rs
@@ -5,17 +5,17 @@
 use crossterm::terminal::{Clear, ClearType};
 use crossterm::{ErrorKind, ExecutableCommand};
 use git2::Repository;
+use git_graph::config::{
+    create_config, get_available_models, get_model, get_model_name, set_model,
+};
 use git_graph::graph::GitGraph;
 use git_graph::print::format::CommitFormat;
 use git_graph::print::svg::print_svg;
 use git_graph::print::unicode::print_unicode;
-use git_graph::settings::{
-    BranchOrder, BranchSettings, BranchSettingsDef, Characters, MergePatterns, RepoSettings,
-    Settings,
-};
+use git_graph::settings::{BranchOrder, BranchSettings, Characters, MergePatterns, Settings};
 use platform_dirs::AppDirs;
 use std::io::stdout;
-use std::path::{Path, PathBuf};
+use std::path::PathBuf;
 use std::str::FromStr;
 use std::time::Instant;
 
@@ -32,9 +32,7 @@
 }
 
 fn from_args() -> Result<(), String> {
-    let mut app_model_path = AppDirs::new(Some("git-graph"), false)
-        .unwrap()
-        .config_dir;
+    let mut app_model_path = AppDirs::new(Some("git-graph"), false).unwrap().config_dir;
     app_model_path.push("models");
 
     create_config(&app_model_path)?;
@@ -377,160 +375,6 @@
     };
 
     run(repository, &settings, svg, commit_limit, pager)
-}
-
-/// Get the currently set branching model for a repo.
-fn get_model_name(repository: &Repository, repo_config_file: &str) -> Result<Option<String>, String> {
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    if config_path.exists() {
-        let repo_config: RepoSettings =
-            toml::from_str(&std::fs::read_to_string(config_path).map_err(|err| err.to_string())?)
-                .map_err(|err| err.to_string())?;
-
-        Ok(Some(repo_config.model))
-    } else {
-        Ok(None)
-    }
-}
-
-/// Get models available in `APP_DATA/git-graph/models`.
-fn get_available_models(app_model_path: &Path) -> Result<Vec<String>, String> {
-    let models = std::fs::read_dir(app_model_path)
-        .map_err(|err| {
-            format!(
-                "ERROR: Cannot read models from {}: {}",
-                app_model_path.display(),
-                err
-            )
-        })?
-        .filter_map(|e| match e {
-            Ok(e) => {
-                if let (Some(name), Some(ext)) = (e.path().file_name(), e.path().extension()) {
-                    if ext == "toml" {
-                        if let Some(name) = name.to_str() {
-                            Some((&name[..(name.len() - 5)]).to_string())
-                        } else {
-                            None
-                        }
-                    } else {
-                        None
-                    }
-                } else {
-                    None
-                }
-            }
-            Err(_) => None,
-        })
-        .collect::<Vec<_>>();
-
-    Ok(models)
-}
-
-/// Try to get the branch settings for a given model.
-/// If no model name is given, returns the branch settings set fot the repo, or the default otherwise.
-fn get_model(
-    repository: &Repository,
-    model: Option<&str>,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<BranchSettingsDef, String> {
-    match model {
-        Some(model) => read_model(model, app_model_path),
-        None => {
-            let mut config_path = PathBuf::from(repository.path());
-            config_path.push(repo_config_file);
-
-            if config_path.exists() {
-                let repo_config: RepoSettings = toml::from_str(
-                    &std::fs::read_to_string(config_path).map_err(|err| err.to_string())?,
-                )
-                .map_err(|err| err.to_string())?;
-
-                read_model(&repo_config.model, app_model_path)
-            } else {
-                Ok(
-                    read_model("git-flow", app_model_path)
-                        .unwrap_or_else(|_| BranchSettingsDef::git_flow()),
-                )
-            }
-        }
-    }
-}
-
-/// Read a branching model file.
-fn read_model(model: &str, app_model_path: &Path) -> Result<BranchSettingsDef, String> {
-    let model_file = app_model_path.join(format!("{}.toml", model));
-
-    if model_file.exists() {
-        toml::from_str::<BranchSettingsDef>(
-            &std::fs::read_to_string(model_file).map_err(|err| err.to_string())?,
-        )
-        .map_err(|err| err.to_string())
-    } else {
-        let models = get_available_models(app_model_path)?;
-        Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ))
-    }
-}
-
-/// Permanently sets the branching model for a repository
-fn set_model(
-    repository: &Repository,
-    model: &str,
-    repo_config_file: &str,
-    app_model_path: &Path,
-) -> Result<(), String> {
-    let models = get_available_models(app_model_path)?;
-
-    if !models.contains(&model.to_string()) {
-        return Err(format!(
-            "ERROR: No branching model named '{}' found in {}\n       Available models are: {}",
-            model,
-            app_model_path.display(),
-            itertools::join(models, ", ")
-        ));
-    }
-
-    let mut config_path = PathBuf::from(repository.path());
-    config_path.push(repo_config_file);
-
-    let config = RepoSettings {
-        model: model.to_string(),
-    };
-
-    let str = toml::to_string_pretty(&config).map_err(|err| err.to_string())?;
-    std::fs::write(&config_path, str).map_err(|err| err.to_string())?;
-
-    eprint!("Branching model set to '{}'", model);
-
-    Ok(())
-}
-
-/// Creates the directory `APP_DATA/git-graph/models` if it does not exist,
-/// and writes the files for built-in branching models there.
-fn create_config(app_model_path: &Path) -> Result<(), String> {
-    if !app_model_path.exists() {
-        std::fs::create_dir_all(app_model_path).map_err(|err| err.to_string())?;
-
-        let models = [
-            (BranchSettingsDef::git_flow(), "git-flow.toml"),
-            (BranchSettingsDef::simple(), "simple.toml"),
-            (BranchSettingsDef::none(), "none.toml"),
-        ];
-        for (model, file) in &models {
-            let path = app_model_path.join(file);
-            let str = toml::to_string_pretty(model).map_err(|err| err.to_string())?;
-            std::fs::write(&path, str).map_err(|err| err.to_string())?;
-        }
-    }
-
-    Ok(())
 }
 
 fn run(


=== 最终状态 ===
返回码: 0
状态: ✅ 执行成功
