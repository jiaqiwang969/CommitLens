=== 任务 090-fedbabf 执行日志 ===
时间: 2025-09-22 09:09:49.597653
Prompt:
请在 .workspace 内，依据 .workspace/todolist/todolist-090-fedbabf.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/090-fedbabf/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："090-fedbabf：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 090-fedbabf

=== 输出 ===
[2025-09-22T01:01:48] OpenAI Codex v0.39.0 (research preview)
--------
workdir: /Users/jqwang/104-CommitLens-codex/.workspace
model: gpt-5-codex-high
provider: codex
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
--------
[2025-09-22T01:01:48] User instructions:
请在 .workspace 内，依据 .workspace/todolist/todolist-090-fedbabf.tex 的提交报告，忠实复现该提交（以 HEAD 为准）的代码内容，并将结果写入固定目录 .workspace/rust-project。

提示：当前已在 .workspace（通常为 .workspace）。可先执行 `ls -la` 查看顶层目录，确认存在 .workspace/todolist 与 .workspace/rust-project。

一、信息收集
- 打开 tex 报告；如有，参考 .workspace/todolist/figs/090-fedbabf/ 下的图示（类图/序列图/流程图/状态图）
- 提取报告中出现的文件路径、模块/类名、代码片段、配置与命令；识别应新增/修改/删除的文件集合

二、代码复现
- 在 .workspace/rust-project 内按报告还原最终文件内容：逐项创建/修改/删除文件；代码以报告中的完整片段为准
- 若片段缺失或上下文不全，填充最小可行的占位内容，并以 TODO 标注依据与缺失
- 若报告包含非 Rust 片段且已明确语言/框架，则按原语言复现；否则以 Rust 项目做最小演示，并将非 Rust 片段以资源/注释方式保存

三、构建校验
- 优先使用报告中给出的构建/运行命令；否则（若为 Rust 项目）执行 cargo build/test，并补齐必要样例

四、提交
- 在 .workspace/rust-project 中 `git add -A` 并提交，提交信息格式："090-fedbabf：复现提交代码内容。"

五、复现说明
- 输出简要说明：列出复现的文件、依据的片段或图示、关键假设/妥协与验证结果

注意
- 目标是“复现报告中的代码状态”，避免超出报告范围的重构或新增设计

限制（禁止修改）
- 禁止修改以下路径/文件（它们由系统管理）：
  - .workspace/codex_error.txt
  - .workspace/codex_status.txt
  - .workspace/codex_output.txt
  - .workspace/logs/
  - .workspace/task_status.json
  - .workspace/todolist/
- 仅允许在 .workspace/rust-project/ 目录内创建/修改/删除代码与配置。

任务ID: 090-fedbabf

[2025-09-22T01:01:53] thinking

**Determining shell and initial command approach**
[2025-09-22T01:01:53] exec bash -lc 'ls -la' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-22T01:01:53] bash -lc 'ls -la' succeeded in 13ms:
total 45080
drwxr-xr-x@  9 jqwang  staff       288 Sep 21 15:57 .
drwxr-xr-x@ 29 jqwang  staff       928 Sep 21 07:49 ..
-rw-r--r--@  1 jqwang  staff         0 Sep 22 09:01 codex_error.txt
-rw-r--r--@  1 jqwang  staff  22706510 Sep 22 09:01 codex_output.txt
-rw-r--r--@  1 jqwang  staff         7 Sep 22 09:01 codex_status.txt
drwxr-xr-x@ 92 jqwang  staff      2944 Sep 22 06:24 logs
drwxr-xr-x@ 12 jqwang  staff       384 Sep 18 13:06 rust-project
-rw-r--r--@  1 jqwang  staff      1886 Sep 22 09:01 task_status.json
drwxr-xr-x@  5 jqwang  staff       160 Sep 22 09:01 todolist
[2025-09-22T01:01:53] tokens used: 1,044

[2025-09-22T01:01:55] thinking

**Opening report file for reading**
[2025-09-22T01:01:55] exec bash -lc 'cat todolist/todolist-090-fedbabf.tex' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-22T01:01:55] bash -lc 'cat todolist/todolist-090-fedbabf.tex' succeeded in 35ms:
% 明确说明（非常重要），tex必须以\section开头，不能有其他内容，不能使用begin「document」
\section{提交考古：090-fedbabf}

\subsection*{Commit 元信息}
\begin{itemize}
  \item 标题：correct names for branches merged fom forks, handle in settings
  \item 作者：Martin Lange <martin\_lange\_@gmx.net>
  \item 日期：2021-01-13T12:09:36+01:00
\end{itemize}

\subsection*{变更摘要（阅读提示）}
\begin{verbatim}
HEAD:   docs/manual.md  |  5 +++--
        src/graph.rs    | 47 +++++++++++++++++++++++++++++++++++++++++++++--
        src/settings.rs |  4 ++--
        3 files changed, 50 insertions(+), 6 deletions(-)
HEAD-1: Cargo.lock | 2 +-
        Cargo.toml | 2 +-
HEAD-2: src/graph.rs         | 42 +++++++++++++++++++++++++++++++++++++-----
        src/main.rs          |  2 +-
[2025-09-22T01:01:55] tokens used: 1,528

[2025-09-22T01:01:58] thinking

**Inspecting rust-project directory**
[2025-09-22T01:01:58] exec bash -lc 'ls -la rust-project' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-22T01:01:58] bash -lc 'ls -la rust-project' succeeded in 38ms:
total 80
drwxr-xr-x@ 12 jqwang  staff    384 Sep 18 13:06 .
drwxr-xr-x@  9 jqwang  staff    288 Sep 21 15:57 ..
drwxr-xr-x@ 12 jqwang  staff    384 Sep 22 06:23 .git
-rw-r--r--@  1 jqwang  staff     14 Sep 18 08:01 .gitignore
-rw-r--r--@  1 jqwang  staff   1875 Sep 18 08:01 .travis.yml
-rw-r--r--@  1 jqwang  staff  17154 Sep 22 06:21 Cargo.lock
-rw-r--r--@  1 jqwang  staff   1077 Sep 22 06:21 Cargo.toml
drwxr-xr-x@  3 jqwang  staff     96 Sep 18 13:06 docs
-rw-r--r--@  1 jqwang  staff   1069 Sep 18 08:01 LICENSE
-rw-r--r--@  1 jqwang  staff   3616 Sep 22 06:11 README.md
drwxr-xr-x@  3 jqwang  staff     96 Sep 18 13:06 scripts
drwxr-xr-x@  8 jqwang  staff    256 Sep 22 05:53 src
[2025-09-22T01:01:58] tokens used: 4,933

[2025-09-22T01:02:00] thinking

**Checking documentation location**
[2025-09-22T01:02:00] exec bash -lc 'ls rust-project/docs' in /Users/jqwang/104-CommitLens-codex/.workspace
[2025-09-22T01:02:00] bash -lc 'ls rust-project/docs' succeeded in 32ms:
manual.md
[2025-09-22T01:02:00] tokens used: 5,419

[2025-09-22T01:02:03] thinking

**Reviewing graph.rs for alignment**
[2025-09-22T01:02:03] exec bash -lc "sed -n '1,200p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:02:03] bash -lc "sed -n '1,200p' src/graph.rs" succeeded in 30ms:
//! A graph structure representing the history of a Git repository.

use crate::print::colors::to_terminal_color;
use crate::settings::{BranchOrder, BranchSettings, MergePatterns, Settings};
use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
use itertools::Itertools;
use regex::Regex;
use std::cmp;
use std::collections::{HashMap, HashSet};

const ORIGIN: &str = "origin/";

/// Represents a git history graph.
pub struct GitGraph {
    pub repository: Repository,
    pub commits: Vec<CommitInfo>,
    pub indices: HashMap<Oid, usize>,
    pub all_branches: Vec<BranchInfo>,
    pub branches: Vec<usize>,
    pub tags: Vec<usize>,
[2025-09-22T01:02:03] tokens used: 5,623

[2025-09-22T01:02:05] thinking

**Searching for relevant constants**
[2025-09-22T01:02:05] exec bash -lc 'rg "FORK" -n' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:02:05] bash -lc 'rg "FORK" -n' exited 1 in 39ms:

[2025-09-22T01:02:05] tokens used: 7,400

[2025-09-22T01:02:09] thinking

**Examining graph.rs contents**
[2025-09-22T01:02:09] exec bash -lc "sed -n '200,400p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:02:09] bash -lc "sed -n '200,400p' src/graph.rs" succeeded in 21ms:
            is_merge: commit.parent_count() > 1,
            parents: [commit.parent_id(0).ok(), commit.parent_id(1).ok()],
            children: Vec::new(),
            branches: Vec::new(),
            tags: Vec::new(),
            branch_trace: None,
        }
    }
}

/// Represents a branch (real or derived from merge summary).
pub struct BranchInfo {
    pub target: Oid,
    pub merge_target: Option<Oid>,
    pub name: String,
    pub persistence: u8,
    pub is_remote: bool,
    pub is_merged: bool,
    pub is_tag: bool,
    pub visual: BranchVis,
[2025-09-22T01:02:09] tokens used: 7,707

[2025-09-22T01:02:11] thinking

**Continuing to review file**
[2025-09-22T01:02:11] exec bash -lc "sed -n '400,800p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:02:11] bash -lc "sed -n '400,800p' src/graph.rs" succeeded in 8ms:
        .collect::<Result<Vec<_>, Error>>()
        .map_err(|err| err.message().to_string())?;

    let mut counter = 0;

    let mut valid_branches = actual_branches
        .iter()
        .filter_map(|(br, tp)| {
            br.get().name().and_then(|n| {
                br.get().target().map(|t| {
                    counter += 1;
                    let start_index = match tp {
                        BranchType::Local => 11,
                        BranchType::Remote => 13,
                    };
                    let name = &n[start_index..];
                    let end_index = indices.get(&t).cloned();

                    let term_color = match to_terminal_color(
                        &branch_color(
[2025-09-22T01:02:11] tokens used: 9,483

[2025-09-22T01:02:14] thinking

**Reviewing function modification requirements**
[2025-09-22T01:02:14] exec bash -lc 'rg "assign_sources_targets" -n' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:02:14] bash -lc 'rg "assign_sources_targets" -n' succeeded in 12ms:
src/graph.rs:73:        assign_sources_targets(&commits, &indices, &mut all_branches);
src/graph.rs:660:fn assign_sources_targets(
[2025-09-22T01:02:14] tokens used: 11,927
[2025-09-22T01:02:17] exec bash -lc "sed -n '640,760p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:02:17] bash -lc "sed -n '640,760p' src/graph.rs" succeeded in 19ms:
    }

    let branch = &mut branches[branch_index];
    if let Some(end) = branch.range.0 {
        if let Some(start_index) = start_index {
            if start_index < end as i32 {
                // TODO: find a better solution (bool field?) to identify non-deleted branches that were not assigned to any commits, and thus should not occupy a column.
                branch.range = (None, None);
            } else {
                branch.range = (branch.range.0, Some(start_index as usize));
            }
        } else {
            branch.range = (branch.range.0, None);
        }
    } else {
        branch.range = (branch.range.0, start_index.map(|si| si as usize));
    }
    Ok(any_assigned)
}

[2025-09-22T01:02:17] tokens used: 12,201

[2025-09-22T01:02:20] thinking

**Reviewing source_order_group assignment**
[2025-09-22T01:02:20] exec bash -lc "sed -n '1,200p' src/settings.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:02:20] bash -lc "sed -n '1,200p' src/settings.rs" succeeded in 21ms:
//! Graph generation settings.

use crate::print::format::CommitFormat;
use regex::{Error, Regex};
use serde_derive::{Deserialize, Serialize};
use std::str::FromStr;

/// Repository settings for the branching model.
/// Used to read repo's git-graph.toml
#[derive(Serialize, Deserialize)]
pub struct RepoSettings {
    /// The repository's branching model
    pub model: String,
}

/// Ordering policy for branches in visual columns.
pub enum BranchOrder {
    /// Recommended! Shortest branches are inserted left-most.
    ///
    /// For branches with equal length, branches ending last are inserted first.
[2025-09-22T01:02:20] tokens used: 13,719

[2025-09-22T01:02:32] thinking

**Planning regex and function updates**
[2025-09-22T01:02:32] exec bash -lc "sed -n '380,520p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:02:32] bash -lc "sed -n '380,520p' src/graph.rs" succeeded in 29ms:
        .collect();

    Ok(branches)
}

/// Extracts (real or derived from merge summary) and assigns basic properties.
fn extract_branches(
    repository: &Repository,
    commits: &[CommitInfo],
    indices: &HashMap<Oid, usize>,
    settings: &Settings,
) -> Result<Vec<BranchInfo>, String> {
    let filter = if settings.include_remote {
        None
    } else {
        Some(BranchType::Local)
    };
    let actual_branches = repository
        .branches(filter)
        .map_err(|err| err.message().to_string())?
[2025-09-22T01:02:32] tokens used: 16,520

[2025-09-22T01:02:34] thinking

**Looking for branch_color function**
[2025-09-22T01:02:34] exec bash -lc 'rg "fn branch_color" -n' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:02:34] bash -lc 'rg "fn branch_color" -n' succeeded in 30ms:
src/graph.rs:846:fn branch_color<T: Clone>(
[2025-09-22T01:02:34] tokens used: 17,822
[2025-09-22T01:02:36] exec bash -lc "sed -n '820,900p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:02:36] bash -lc "sed -n '820,900p' src/graph.rs" succeeded in 28ms:
        })
        .collect();

    for branch in branches.iter_mut() {
        if let Some(column) = branch.visual.column {
            let offset = if branch.visual.order_group == 0 {
                0
            } else {
                group_offset[branch.visual.order_group - 1]
            };
            branch.visual.column = Some(column + offset);
        }
    }
}

/// Finds the index for a branch name from a slice of prefixes
fn branch_order(name: &str, order: &[Regex]) -> usize {
    order
        .iter()
        .position(|b| {
[2025-09-22T01:02:36] tokens used: 17,975

[2025-09-22T01:02:53] thinking

**Analyzing branch fork handling and Option fixes**

I'm piecing together how forked branches get renamed with a `fork/` prefix and how `branch_order` functions adapt to that. I’m also carefully parsing the fix around assigning `source_order_group` using nested Options to handle presence correctly, trying to replicate the logic without the original patch. The goal is to keep consistent parsing in branch metadata while ensuring robust handling of merges from forks and avoiding improper Option assignments.
[2025-09-22T01:02:54] exec bash -lc 'rg "merge_target" -n src/graph.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:02:54] bash -lc 'rg "merge_target" -n src/graph.rs' succeeded in 37ms:
213:    pub merge_target: Option<Oid>,
226:        merge_target: Option<Oid>,
237:            merge_target,
691:            .merge_target
768:        let merge_target = branches[branch_idx].merge_target;
779:                    if let Some(target_oid) = merge_target {
[2025-09-22T01:02:54] tokens used: 19,987

[2025-09-22T01:03:23] thinking

**Analyzing fork merge renaming logic**
[2025-09-22T01:03:23] exec bash -lc "sed -n '250,320p' docs/manual.md" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:03:23] bash -lc "sed -n '250,320p' docs/manual.md" succeeded in 8ms:
    '^bugfix.*$',
]

# RegEx patterns for visual ordering of branches, from left to right.
# Here, `master` or `main` are shown left-most, followed by branches
# starting with `hotfix` or `release`, followed by `develop` or `dev`.
# Branches not matching any pattern (e.g. starting with `feature`)
# are displayed further to the right.
order = [
    '^(master|main)$',      # Matches exactly `master` or `main`
    '^(hotfix|release).*$', # Matches everything starting with `hotfix` or `release`
    '^(develop|dev)$',      # Matches exactly `develop` or `dev`
]

# Colors of branches in terminal output. 
# For supported colors, see section Colors (below this listing).
[terminal_colors]
# Each entry is composed of a RegEx pattern and a list of colors that
# will be used alternating (see e.g. `feature...`).
matches = [
[2025-09-22T01:03:23] tokens used: 22,573

[2025-09-22T01:03:34] thinking

**Planning modification steps**
[2025-09-22T01:03:34] exec bash -lc "rg -n \"\\"'^feature" src/settings.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:03:34] bash -lc "rg -n \"\\"'^feature" src/settings.rs' succeeded in 17ms:
81:                r"^feature.*$".to_string(),
102:                        r"^feature.*$".to_string(),
120:                        r"^feature.*$".to_string(),
[2025-09-22T01:03:34] tokens used: 23,926

[2025-09-22T01:04:14] thinking

**Designing fork merge correction function**
[2025-09-22T01:04:15] exec bash -lc 'rg "struct BranchSettings" -n src/settings.rs' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:04:15] bash -lc 'rg "struct BranchSettings" -n src/settings.rs' succeeded in 20ms:
56:pub struct BranchSettingsDef {
203:pub struct BranchSettings {
[2025-09-22T01:04:15] tokens used: 27,453
[2025-09-22T01:04:18] exec bash -lc "sed -n '200,320p' src/settings.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:04:18] bash -lc "sed -n '200,320p' src/settings.rs" succeeded in 34ms:
}

/// Settings defining branching models
pub struct BranchSettings {
    /// Branch persistence
    pub persistence: Vec<Regex>,
    /// Branch ordering
    pub order: Vec<Regex>,
    /// Branch colors
    pub terminal_colors: Vec<(Regex, Vec<String>)>,
    /// Colors for branches not matching any of `colors`
    pub terminal_colors_unknown: Vec<String>,
    /// Branch colors for SVG output
    pub svg_colors: Vec<(Regex, Vec<String>)>,
    /// Colors for branches not matching any of `colors` for SVG output
    pub svg_colors_unknown: Vec<String>,
}

impl BranchSettings {
    pub fn from(def: BranchSettingsDef) -> Result<Self, Error> {
[2025-09-22T01:04:18] tokens used: 27,626

[2025-09-22T01:04:21] thinking

**Investigating terminal color functions**
[2025-09-22T01:04:21] exec bash -lc 'rg "pub fn to_terminal_color" -n' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:04:21] bash -lc 'rg "pub fn to_terminal_color" -n' succeeded in 13ms:
src/print/colors.rs:7:pub fn to_terminal_color(color: &str) -> Result<u8, String> {
[2025-09-22T01:04:21] tokens used: 28,972
[2025-09-22T01:04:23] exec bash -lc "sed -n '1,120p' src/print/colors.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:04:23] bash -lc "sed -n '1,120p' src/print/colors.rs" succeeded in 32ms:
//! ANSI terminal color handling.

use lazy_static::lazy_static;
use std::collections::HashMap;

/// Converts a color name to the index in the 256-color palette.
pub fn to_terminal_color(color: &str) -> Result<u8, String> {
    match NAMED_COLORS.get(color) {
        None => match color.parse::<u8>() {
            Ok(col) => Ok(col),
            Err(_) => Err(format!("Color {} not found", color)),
        },
        Some(rgb) => Ok(*rgb),
    }
}

macro_rules! hashmap {
    ($( $key: expr => $val: expr ),*) => {{
         let mut map = ::std::collections::HashMap::new();
         $( map.insert($key, $val); )*
[2025-09-22T01:04:23] tokens used: 29,170

[2025-09-22T01:05:27] thinking

**Refactoring fork merge correction logic**
**Detailing fork prefix handling and preparation for code edits**

I'll clarify how to safely format the renamed branches with the fork prefix, ensure color and order recalculations handle the new prefix properly, and prepare for edits in graph.rs, settings.rs, and manual.md to support this functionality.
[2025-09-22T01:05:27] codex
**Detailing fork prefix handling and preparation for code edits**

I'll clarify how to safely format the renamed branches with the fork prefix, ensure color and order recalculations handle the new prefix properly, and prepare for edits in graph.rs, settings.rs, and manual.md to support this functionality.
[2025-09-22T01:05:27] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -11,2 +11,3 @@
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
[2025-09-22T01:05:27] apply_patch(auto_approved=true) exited 0 in 31ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-22T01:05:27] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..709fb58df4a4c4ec5c8da602a45c6e64f5f71539
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {

[2025-09-22T01:05:27] tokens used: 35,660
[2025-09-22T01:05:27] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..709fb58df4a4c4ec5c8da602a45c6e64f5f71539
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {


[2025-09-22T01:05:31] thinking

**Integrating fork merge correction**
[2025-09-22T01:05:32] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -73,2 +73,4 @@
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
[2025-09-22T01:05:32] apply_patch(auto_approved=true) exited 0 in 40ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-22T01:05:32] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..0ff0d761786459019689d30019963c15d325613e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {

[2025-09-22T01:05:32] tokens used: 36,195
[2025-09-22T01:05:32] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..0ff0d761786459019689d30019963c15d325613e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {


[2025-09-22T01:05:37] thinking

**Planning placement for new function**
[2025-09-22T01:05:43] tokens used: 37,284
[2025-09-22T01:05:43] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..0ff0d761786459019689d30019963c15d325613e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {


[2025-09-22T01:05:50] thinking

**Troubleshooting incorrect working directory**

I see the patch apply failed because the working directory was set incorrectly to `.workspace` instead of `.workspace/rust-project`. The patch paths need to be relative to `rust-project`, so I’m going to re-run the patch application with the correct `workdir` to fix the file path errors.
[2025-09-22T01:05:54] tokens used: 39,121
[2025-09-22T01:05:54] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..0ff0d761786459019689d30019963c15d325613e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {


[2025-09-22T01:05:59] thinking

**Verifying workdir usage in apply_patch**
[2025-09-22T01:06:02] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -387,2 +387,65 @@
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
[2025-09-22T01:06:02] apply_patch(auto_approved=true) exited 0 in 43ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-22T01:06:02] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..e15bc19b3f4e0b374b25238ac35cb9ae65aee5e3
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,

[2025-09-22T01:06:02] tokens used: 40,755
[2025-09-22T01:06:02] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..e15bc19b3f4e0b374b25238ac35cb9ae65aee5e3
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,


[2025-09-22T01:06:13] thinking

**Reworking source and target assignment logic**
[2025-09-22T01:06:19] tokens used: 43,403
[2025-09-22T01:06:19] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..e15bc19b3f4e0b374b25238ac35cb9ae65aee5e3
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,


[2025-09-22T01:06:21] thinking

**Noticing missing working directory**
[2025-09-22T01:06:26] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -742,3 +742,3 @@
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
@@ -757,3 +757,3 @@
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
@@ -768,3 +768,3 @@
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
@@ -781,4 +781,11 @@
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
[2025-09-22T01:06:26] apply_patch(auto_approved=true) exited 0 in 32ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-22T01:06:26] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..8cf175957d8829ed9943de4d68ecf7e10dfb1a2e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +740,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +755,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +766,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +779,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 

[2025-09-22T01:06:26] tokens used: 45,648
[2025-09-22T01:06:26] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..8cf175957d8829ed9943de4d68ecf7e10dfb1a2e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +740,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +755,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +766,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +779,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 


[2025-09-22T01:06:29] thinking

**Updating regex patterns in settings.rs**
[2025-09-22T01:06:31] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/settings.rs
@@ -80,3 +80,3 @@
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
@@ -101,3 +101,3 @@
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
@@ -119,3 +119,3 @@
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
[2025-09-22T01:06:31] apply_patch(auto_approved=true) exited 0 in 43ms:
Success. Updated the following files:
M src/settings.rs
[2025-09-22T01:06:31] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..8cf175957d8829ed9943de4d68ecf7e10dfb1a2e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +740,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +755,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +766,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +779,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),

[2025-09-22T01:06:31] tokens used: 47,164
[2025-09-22T01:06:31] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..8cf175957d8829ed9943de4d68ecf7e10dfb1a2e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +740,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +755,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +766,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +779,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:06:34] thinking

**Updating documentation for new pattern**
[2025-09-22T01:06:34] exec bash -lc "rg \"\\"'^feature" -n docs/manual.md' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:06:34] bash -lc "rg \"\\"'^feature" -n docs/manual.md' succeeded in 37ms:
247:    '^feature.*$',     # Matches everything starting with `feature`
279:        '^feature.*$',
[2025-09-22T01:06:34] tokens used: 47,634
[2025-09-22T01:06:34] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..8cf175957d8829ed9943de4d68ecf7e10dfb1a2e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +740,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +755,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +766,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +779,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:06:38] thinking

**Updating branch pattern and comments**
[2025-09-22T01:06:39] tokens used: 48,112
[2025-09-22T01:06:39] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..8cf175957d8829ed9943de4d68ecf7e10dfb1a2e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +740,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +755,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +766,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +779,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:06:51] thinking

**Preparing precise patch for branch patterns**
[2025-09-22T01:06:51] tokens used: 48,663
[2025-09-22T01:06:51] turn diff:
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..8cf175957d8829ed9943de4d68ecf7e10dfb1a2e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +740,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +755,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +766,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +779,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:06:53] thinking

**Correcting working directory setting**
[2025-09-22T01:06:54] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/docs/manual.md
@@ -246,3 +246,3 @@
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$',(??
     '^release.*$',
[2025-09-22T01:06:54] apply_patch(auto_approved=true) exited 0 in 40ms:
Success. Updated the following files:
M docs/manual.md
[2025-09-22T01:06:54] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..bfaccd9e4b63f7cc8e184a0aae23125b3f937757
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$',(??
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..8cf175957d8829ed9943de4d68ecf7e10dfb1a2e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +740,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +755,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +766,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +779,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),

[2025-09-22T01:06:54] tokens used: 48,986
[2025-09-22T01:06:54] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..bfaccd9e4b63f7cc8e184a0aae23125b3f937757
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$',(??
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..8cf175957d8829ed9943de4d68ecf7e10dfb1a2e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +740,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +755,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +766,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +779,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:06:57] thinking

**Verifying patch string correctness**
[2025-09-22T01:06:57] exec bash -lc "sed -n '240,260p' docs/manual.md" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:06:57] bash -lc "sed -n '240,260p' docs/manual.md" succeeded in 24ms:
```toml
# RegEx patterns for branch groups by persistence, from most persistent
# to most short-leved branches. This is used to back-trace branches.
# Branches not matching any pattern are assumed least persistent.
persistence = [
    '^(master|main)$', # Matches exactly `master` or `main`
    '^(develop|dev)$',
    '^(feature|fork/).*$',(??
    '^release.*$',
    '^hotfix.*$',
    '^bugfix.*$',
]

# RegEx patterns for visual ordering of branches, from left to right.
# Here, `master` or `main` are shown left-most, followed by branches
# starting with `hotfix` or `release`, followed by `develop` or `dev`.
# Branches not matching any pattern (e.g. starting with `feature`)
# are displayed further to the right.
order = [
    '^(master|main)$',      # Matches exactly `master` or `main`
[2025-09-22T01:06:57] tokens used: 49,291
[2025-09-22T01:06:57] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..bfaccd9e4b63f7cc8e184a0aae23125b3f937757
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$',(??
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..8cf175957d8829ed9943de4d68ecf7e10dfb1a2e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +740,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +755,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +766,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +779,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:07:01] thinking

**Fixing regex pattern and comment**
[2025-09-22T01:07:02] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/docs/manual.md
@@ -246,3 +246,3 @@
     '^(develop|dev)$',
-    '^(feature|fork/).*$',(??
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
[2025-09-22T01:07:02] apply_patch(auto_approved=true) exited 0 in 60ms:
Success. Updated the following files:
M docs/manual.md
[2025-09-22T01:07:02] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..539743fd0bd0f1f57088a3b1dce4c0dab2324b93
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..8cf175957d8829ed9943de4d68ecf7e10dfb1a2e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +740,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +755,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +766,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +779,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),

[2025-09-22T01:07:02] tokens used: 49,820
[2025-09-22T01:07:02] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..539743fd0bd0f1f57088a3b1dce4c0dab2324b93
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..8cf175957d8829ed9943de4d68ecf7e10dfb1a2e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +740,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +755,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +766,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +779,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:07:04] thinking

**Reviewing second occurrence for update**
[2025-09-22T01:07:04] exec bash -lc "sed -n '270,310p' docs/manual.md" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:07:04] bash -lc "sed -n '270,310p' docs/manual.md" succeeded in 36ms:
    [
        '^(master|main)$',
        ['bright_blue'],
    ],
    [
        '^(develop|dev)$',
        ['bright_yellow'],
    ],
    [
        '^feature.*$',
        ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
    ],
        [
        '^release.*$',
        ['bright_green'],
    ],
        [
        '^(bugfix|hotfix).*$',
        ['bright_red'],
    ],
[2025-09-22T01:07:04] tokens used: 50,062
[2025-09-22T01:07:04] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..539743fd0bd0f1f57088a3b1dce4c0dab2324b93
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..8cf175957d8829ed9943de4d68ecf7e10dfb1a2e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +740,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +755,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +766,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +779,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:07:08] thinking

**Adjusting regex pattern and formatting**
[2025-09-22T01:07:10] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/docs/manual.md
@@ -278,3 +278,3 @@
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
[2025-09-22T01:07:10] apply_patch(auto_approved=true) exited 0 in 59ms:
Success. Updated the following files:
M docs/manual.md
[2025-09-22T01:07:10] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..8cc230dc32a3d9b9979fe0aa49c78ffaa350d2db
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..8cf175957d8829ed9943de4d68ecf7e10dfb1a2e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +740,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +755,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +766,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +779,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),

[2025-09-22T01:07:10] tokens used: 50,714
[2025-09-22T01:07:10] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..8cc230dc32a3d9b9979fe0aa49c78ffaa350d2db
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..8cf175957d8829ed9943de4d68ecf7e10dfb1a2e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +740,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +755,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +766,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +779,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:07:17] thinking

**Planning documentation update for fork/ prefix**

I'm making sure to update all references and comments about feature branch patterns to include the new `fork/` prefix. Specifically, I’m focusing on enhancing the manual by inserting a clear paragraph right after the existing config snippet that explains how the `fork/` prefix is used for merges from forks, how it affects grouping and coloring, but doesn’t affect the repository itself. This will help clarify the fork branch behavior in the docs.
[2025-09-22T01:07:18] tokens used: 51,485
[2025-09-22T01:07:18] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..8cc230dc32a3d9b9979fe0aa49c78ffaa350d2db
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..8cf175957d8829ed9943de4d68ecf7e10dfb1a2e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +740,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +755,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +766,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +779,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:07:24] thinking

**Noticing missing workdir setting**
[2025-09-22T01:07:25] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/docs/manual.md
@@ -314,2 +314,6 @@
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
[2025-09-22T01:07:25] apply_patch(auto_approved=true) exited 0 in 55ms:
Success. Updated the following files:
M docs/manual.md
[2025-09-22T01:07:25] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..2453e0b3c2932fd5d829fe53a6830f177eda53fd
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..8cf175957d8829ed9943de4d68ecf7e10dfb1a2e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +740,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +755,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +766,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +779,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),

[2025-09-22T01:07:25] tokens used: 51,972
[2025-09-22T01:07:25] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..2453e0b3c2932fd5d829fe53a6830f177eda53fd
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..8cf175957d8829ed9943de4d68ecf7e10dfb1a2e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +740,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +755,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +766,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +779,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:07:29] thinking

**Verifying patch text replacement**
[2025-09-22T01:07:29] exec bash -lc "sed -n '260,320p' docs/manual.md" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:07:29] bash -lc "sed -n '260,320p' docs/manual.md" succeeded in 11ms:
    '^(hotfix|release).*$', # Matches everything starting with `hotfix` or `release`
    '^(develop|dev)$',      # Matches exactly `develop` or `dev`
]

# Colors of branches in terminal output. 
# For supported colors, see section Colors (below this listing).
[terminal_colors]
# Each entry is composed of a RegEx pattern and a list of colors that
# will be used alternating (see e.g. `feature...`).
matches = [
    [
        '^(master|main)$',
        ['bright_blue'],
    ],
    [
        '^(develop|dev)$',
        ['bright_yellow'],
    ],
    [
        '^(feature|fork/).*$',
[2025-09-22T01:07:29] tokens used: 52,391
[2025-09-22T01:07:29] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..2453e0b3c2932fd5d829fe53a6830f177eda53fd
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..8cf175957d8829ed9943de4d68ecf7e10dfb1a2e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +740,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +755,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +766,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +779,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:07:36] thinking

**Updating branch pattern comments**
[2025-09-22T01:07:36] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/docs/manual.md
@@ -255,3 +255,3 @@
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
[2025-09-22T01:07:36] apply_patch(auto_approved=true) exited 0 in 58ms:
Success. Updated the following files:
M docs/manual.md
[2025-09-22T01:07:36] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..8cf175957d8829ed9943de4d68ecf7e10dfb1a2e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +740,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +755,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +766,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +779,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),

[2025-09-22T01:07:36] tokens used: 53,531
[2025-09-22T01:07:36] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..8cf175957d8829ed9943de4d68ecf7e10dfb1a2e
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +740,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +755,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +766,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +779,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:07:43] thinking

**Preparing final formatting and comments**
[2025-09-22T01:07:44] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -387,2 +387,3 @@
 
+/// Adds a `fork/` prefix to merged branches whose names match their merge targets.
 fn correct_fork_merges(
[2025-09-22T01:07:44] apply_patch(auto_approved=true) exited 0 in 56ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-22T01:07:44] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..3dda3a0f10e628c1bb176bf6b98140fd1cc115cc
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,70 @@
     Ok(branches)
 }
 
+/// Adds a `fork/` prefix to merged branches whose names match their merge targets.
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +741,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +756,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +767,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +780,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),

[2025-09-22T01:07:44] tokens used: 54,153
[2025-09-22T01:07:44] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..3dda3a0f10e628c1bb176bf6b98140fd1cc115cc
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,70 @@
     Ok(branches)
 }
 
+/// Adds a `fork/` prefix to merged branches whose names match their merge targets.
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +741,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +756,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +767,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +780,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:07:50] thinking

**Optimizing error handling in result propagation**
[2025-09-22T01:07:52] tokens used: 54,634
[2025-09-22T01:07:52] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..3dda3a0f10e628c1bb176bf6b98140fd1cc115cc
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,70 @@
     Ok(branches)
 }
 
+/// Adds a `fork/` prefix to merged branches whose names match their merge targets.
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color =
+            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +741,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +756,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +767,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +780,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:07:55] thinking

**Adding missing working directory**
[2025-09-22T01:07:56] apply_patch auto_approved=true:
M /Users/jqwang/104-CommitLens-codex/.workspace/rust-project/src/graph.rs
@@ -438,4 +438,3 @@
 
-        branch.visual.term_color =
-            to_terminal_color(&terminal_color).map_err(|err| err.to_string())?;
+        branch.visual.term_color = to_terminal_color(&terminal_color)?;
         branch.visual.svg_color = branch_color(
[2025-09-22T01:07:56] apply_patch(auto_approved=true) exited 0 in 57ms:
Success. Updated the following files:
M src/graph.rs
[2025-09-22T01:07:56] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..f974411f103148181cb03da09b3aebdc5ad776e7
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+/// Adds a `fork/` prefix to merged branches whose names match their merge targets.
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color = to_terminal_color(&terminal_color)?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +740,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +755,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +766,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +779,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),

[2025-09-22T01:07:56] tokens used: 54,940
[2025-09-22T01:07:56] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..f974411f103148181cb03da09b3aebdc5ad776e7
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,69 @@
     Ok(branches)
 }
 
+/// Adds a `fork/` prefix to merged branches whose names match their merge targets.
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx = commits[merge_commit_idx]
+            .branches
+            .iter()
+            .copied()
+            .find(|target_idx| {
+                *target_idx != branch_idx
+                    && branches
+                        .get(*target_idx)
+                        .map(|target_branch| target_branch.name == original_name)
+                        .unwrap_or(false)
+            });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color = to_terminal_color(&terminal_color)?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -674,7 +740,7 @@
     for branch_idx in 0..branches.len() {
         let source_group = branch_commits
             .get(branch_idx)
-            .and_then(|indices_for_branch| {
+            .map(|indices_for_branch| {
                 indices_for_branch.iter().rev().find_map(|commit_idx| {
                     let info = &commits[*commit_idx];
                     info.parents.iter().flatten().find_map(|parent_oid| {
@@ -689,7 +755,7 @@
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +766,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +779,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:08:11] thinking

**Verifying code adjustments and formatting**

I'm double-checking function return types, borrow scopes, and logic flow in `correct_fork_merges` and related functions, ensuring error handling with `Result` works smoothly and comments align with changes. I'll also run `cargo fmt` to keep the code style consistent before moving forward.
[2025-09-22T01:08:12] exec bash -lc 'cargo fmt' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:08:12] bash -lc 'cargo fmt' succeeded in 107ms:

[2025-09-22T01:08:12] tokens used: 56,114
[2025-09-22T01:08:12] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..47ff01ec0cf34813a9ba2e6549199a43e239d98d
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,70 @@
     Ok(branches)
 }
 
+/// Adds a `fork/` prefix to merged branches whose names match their merge targets.
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx =
+            commits[merge_commit_idx]
+                .branches
+                .iter()
+                .copied()
+                .find(|target_idx| {
+                    *target_idx != branch_idx
+                        && branches
+                            .get(*target_idx)
+                            .map(|target_branch| target_branch.name == original_name)
+                            .unwrap_or(false)
+                });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color = to_terminal_color(&terminal_color)?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -672,24 +739,22 @@
     }
 
     for branch_idx in 0..branches.len() {
-        let source_group = branch_commits
-            .get(branch_idx)
-            .and_then(|indices_for_branch| {
-                indices_for_branch.iter().rev().find_map(|commit_idx| {
-                    let info = &commits[*commit_idx];
-                    info.parents.iter().flatten().find_map(|parent_oid| {
-                        indices
-                            .get(parent_oid)
-                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
-                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
-                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
-                    })
+        let source_group = branch_commits.get(branch_idx).map(|indices_for_branch| {
+            indices_for_branch.iter().rev().find_map(|commit_idx| {
+                let info = &commits[*commit_idx];
+                info.parents.iter().flatten().find_map(|parent_oid| {
+                    indices
+                        .get(parent_oid)
+                        .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                        .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                        .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
                 })
-            });
+            })
+        });
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +765,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +778,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:08:16] thinking

**Checking formatting in graph.rs**
[2025-09-22T01:08:16] exec bash -lc "sed -n '360,460p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:08:16] bash -lc "sed -n '360,460p' src/graph.rs" succeeded in 9ms:

    for info in commits.iter_mut() {
        if let Some(trace) = info.branch_trace {
            info.branch_trace = index_map[trace];
            for br in info.branches.iter_mut() {
                *br = index_map[*br].unwrap();
            }
            for tag in info.tags.iter_mut() {
                *tag = index_map[*tag].unwrap();
            }
        }
    }

    let branches: Vec<_> = branches
        .into_iter()
        .enumerate()
        .filter_map(|(arr_index, branch)| {
            if index_map[arr_index].is_some() {
                Some(branch)
            } else {
[2025-09-22T01:08:16] tokens used: 56,266
[2025-09-22T01:08:16] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..47ff01ec0cf34813a9ba2e6549199a43e239d98d
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,70 @@
     Ok(branches)
 }
 
+/// Adds a `fork/` prefix to merged branches whose names match their merge targets.
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx =
+            commits[merge_commit_idx]
+                .branches
+                .iter()
+                .copied()
+                .find(|target_idx| {
+                    *target_idx != branch_idx
+                        && branches
+                            .get(*target_idx)
+                            .map(|target_branch| target_branch.name == original_name)
+                            .unwrap_or(false)
+                });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color = to_terminal_color(&terminal_color)?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -672,24 +739,22 @@
     }
 
     for branch_idx in 0..branches.len() {
-        let source_group = branch_commits
-            .get(branch_idx)
-            .and_then(|indices_for_branch| {
-                indices_for_branch.iter().rev().find_map(|commit_idx| {
-                    let info = &commits[*commit_idx];
-                    info.parents.iter().flatten().find_map(|parent_oid| {
-                        indices
-                            .get(parent_oid)
-                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
-                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
-                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
-                    })
+        let source_group = branch_commits.get(branch_idx).map(|indices_for_branch| {
+            indices_for_branch.iter().rev().find_map(|commit_idx| {
+                let info = &commits[*commit_idx];
+                info.parents.iter().flatten().find_map(|parent_oid| {
+                    indices
+                        .get(parent_oid)
+                        .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                        .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                        .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
                 })
-            });
+            })
+        });
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +765,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +778,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:08:19] thinking

**Reviewing variable usage and formatting**
[2025-09-22T01:08:20] exec bash -lc "sed -n '640,720p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:08:20] bash -lc "sed -n '640,720p' src/graph.rs" succeeded in 18ms:
                let old_branch = &branches[old_trace];
                (
                    &old_branch.name.clone(),
                    old_branch.visual.term_color,
                    old_branch.visual.svg_color.clone(),
                    old_branch.range,
                )
            };
            let new_name = &branches[branch_index].name;
            let old_end = old_range.0.unwrap_or(0);
            let new_end = branches[branch_index].range.0.unwrap_or(0);
            if new_name == old_name && old_end >= new_end {
                let old_branch = &mut branches[old_trace];
                if let Some(old_end) = old_range.1 {
                    if index > &old_end {
                        old_branch.range = (None, None);
                    } else {
                        old_branch.range = (Some(*index), old_branch.range.1);
                    }
                } else {
[2025-09-22T01:08:20] tokens used: 57,345
[2025-09-22T01:08:20] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..47ff01ec0cf34813a9ba2e6549199a43e239d98d
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,70 @@
     Ok(branches)
 }
 
+/// Adds a `fork/` prefix to merged branches whose names match their merge targets.
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx =
+            commits[merge_commit_idx]
+                .branches
+                .iter()
+                .copied()
+                .find(|target_idx| {
+                    *target_idx != branch_idx
+                        && branches
+                            .get(*target_idx)
+                            .map(|target_branch| target_branch.name == original_name)
+                            .unwrap_or(false)
+                });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color = to_terminal_color(&terminal_color)?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -672,24 +739,22 @@
     }
 
     for branch_idx in 0..branches.len() {
-        let source_group = branch_commits
-            .get(branch_idx)
-            .and_then(|indices_for_branch| {
-                indices_for_branch.iter().rev().find_map(|commit_idx| {
-                    let info = &commits[*commit_idx];
-                    info.parents.iter().flatten().find_map(|parent_oid| {
-                        indices
-                            .get(parent_oid)
-                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
-                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
-                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
-                    })
+        let source_group = branch_commits.get(branch_idx).map(|indices_for_branch| {
+            indices_for_branch.iter().rev().find_map(|commit_idx| {
+                let info = &commits[*commit_idx];
+                info.parents.iter().flatten().find_map(|parent_oid| {
+                    indices
+                        .get(parent_oid)
+                        .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                        .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                        .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
                 })
-            });
+            })
+        });
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +765,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +778,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:08:24] thinking

**Searching for assign_sources_targets function**
[2025-09-22T01:08:24] exec bash -lc "sed -n '720,780p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:08:24] bash -lc "sed -n '720,780p' src/graph.rs" succeeded in 9ms:
        }
    } else {
        branch.range = (branch.range.0, start_index.map(|si| si as usize));
    }
    Ok(any_assigned)
}

fn assign_sources_targets(
    commits: &[CommitInfo],
    indices: &HashMap<Oid, usize>,
    branches: &mut [BranchInfo],
) {
    let mut branch_commits: Vec<Vec<usize>> = vec![Vec::new(); branches.len()];
    for (commit_idx, info) in commits.iter().enumerate() {
        if let Some(branch_idx) = info.branch_trace {
            if let Some(entries) = branch_commits.get_mut(branch_idx) {
                entries.push(commit_idx);
            }
        }
    }
[2025-09-22T01:08:24] tokens used: 58,222
[2025-09-22T01:08:24] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..47ff01ec0cf34813a9ba2e6549199a43e239d98d
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,70 @@
     Ok(branches)
 }
 
+/// Adds a `fork/` prefix to merged branches whose names match their merge targets.
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx =
+            commits[merge_commit_idx]
+                .branches
+                .iter()
+                .copied()
+                .find(|target_idx| {
+                    *target_idx != branch_idx
+                        && branches
+                            .get(*target_idx)
+                            .map(|target_branch| target_branch.name == original_name)
+                            .unwrap_or(false)
+                });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color = to_terminal_color(&terminal_color)?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -672,24 +739,22 @@
     }
 
     for branch_idx in 0..branches.len() {
-        let source_group = branch_commits
-            .get(branch_idx)
-            .and_then(|indices_for_branch| {
-                indices_for_branch.iter().rev().find_map(|commit_idx| {
-                    let info = &commits[*commit_idx];
-                    info.parents.iter().flatten().find_map(|parent_oid| {
-                        indices
-                            .get(parent_oid)
-                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
-                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
-                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
-                    })
+        let source_group = branch_commits.get(branch_idx).map(|indices_for_branch| {
+            indices_for_branch.iter().rev().find_map(|commit_idx| {
+                let info = &commits[*commit_idx];
+                info.parents.iter().flatten().find_map(|parent_oid| {
+                    indices
+                        .get(parent_oid)
+                        .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                        .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                        .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
                 })
-            });
+            })
+        });
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +765,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +778,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:08:26] thinking

**Requesting more content to continue**
[2025-09-22T01:08:26] exec bash -lc "sed -n '780,840p' src/graph.rs" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:08:26] bash -lc "sed -n '780,840p' src/graph.rs" succeeded in 19ms:

        branches[branch_idx].visual.source_order_group = match source_group {
            Some(Some(order)) => Some(order),
            _ => None,
        };

        branches[branch_idx].visual.target_order_group = match target_group {
            Some(Some(order)) => Some(order),
            _ => None,
        };
    }
}

/// Sorts branches into columns for visualization without overlaps.
fn assign_branch_columns(
    commits: &[CommitInfo],
    indices: &HashMap<Oid, usize>,
    branches: &mut [BranchInfo],
    settings: &BranchSettings,
    shortest_first: bool,
[2025-09-22T01:08:26] tokens used: 58,997
[2025-09-22T01:08:26] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..47ff01ec0cf34813a9ba2e6549199a43e239d98d
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,70 @@
     Ok(branches)
 }
 
+/// Adds a `fork/` prefix to merged branches whose names match their merge targets.
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx =
+            commits[merge_commit_idx]
+                .branches
+                .iter()
+                .copied()
+                .find(|target_idx| {
+                    *target_idx != branch_idx
+                        && branches
+                            .get(*target_idx)
+                            .map(|target_branch| target_branch.name == original_name)
+                            .unwrap_or(false)
+                });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color = to_terminal_color(&terminal_color)?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -672,24 +739,22 @@
     }
 
     for branch_idx in 0..branches.len() {
-        let source_group = branch_commits
-            .get(branch_idx)
-            .and_then(|indices_for_branch| {
-                indices_for_branch.iter().rev().find_map(|commit_idx| {
-                    let info = &commits[*commit_idx];
-                    info.parents.iter().flatten().find_map(|parent_oid| {
-                        indices
-                            .get(parent_oid)
-                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
-                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
-                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
-                    })
+        let source_group = branch_commits.get(branch_idx).map(|indices_for_branch| {
+            indices_for_branch.iter().rev().find_map(|commit_idx| {
+                let info = &commits[*commit_idx];
+                info.parents.iter().flatten().find_map(|parent_oid| {
+                    indices
+                        .get(parent_oid)
+                        .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                        .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                        .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
                 })
-            });
+            })
+        });
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +765,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +778,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:08:31] thinking

**Updating documentation and imports**
[2025-09-22T01:08:31] exec bash -lc 'cargo build' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:08:38] bash -lc 'cargo build' exited -1 in 0ms:
   Compiling libc v0.2.80
   Compiling autocfg v1.0.1
   Compiling pkg-config v0.3.19
   Compiling log v0.4.11
   Compiling cfg-if v1.0.0
   Compiling proc-macro2 v1.0.24
   Compiling tinyvec_macros v0.1.0
   Compiling bitflags v1.2.1
   Compiling matches v0.1.8
   Compiling cfg-if v0.1.10
   Compiling unicode-xid v0.2.1
   Compiling scopeguard v1.1.0
   Compiling serde v1.0.118
   Compiling smallvec v1.5.1
   Compiling syn v1.0.55
   Compiling percent-encoding v2.1.0
   Compiling tinyvec v1.1.0
   Compiling instant v0.1.9
   Compiling unicode-bidi v0.3.4
   Compiling unicode-width v0.1.8
[2025-09-22T01:08:38] tokens used: 59,926
[2025-09-22T01:08:38] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..47ff01ec0cf34813a9ba2e6549199a43e239d98d
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,70 @@
     Ok(branches)
 }
 
+/// Adds a `fork/` prefix to merged branches whose names match their merge targets.
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx =
+            commits[merge_commit_idx]
+                .branches
+                .iter()
+                .copied()
+                .find(|target_idx| {
+                    *target_idx != branch_idx
+                        && branches
+                            .get(*target_idx)
+                            .map(|target_branch| target_branch.name == original_name)
+                            .unwrap_or(false)
+                });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color = to_terminal_color(&terminal_color)?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -672,24 +739,22 @@
     }
 
     for branch_idx in 0..branches.len() {
-        let source_group = branch_commits
-            .get(branch_idx)
-            .and_then(|indices_for_branch| {
-                indices_for_branch.iter().rev().find_map(|commit_idx| {
-                    let info = &commits[*commit_idx];
-                    info.parents.iter().flatten().find_map(|parent_oid| {
-                        indices
-                            .get(parent_oid)
-                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
-                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
-                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
-                    })
+        let source_group = branch_commits.get(branch_idx).map(|indices_for_branch| {
+            indices_for_branch.iter().rev().find_map(|commit_idx| {
+                let info = &commits[*commit_idx];
+                info.parents.iter().flatten().find_map(|parent_oid| {
+                    indices
+                        .get(parent_oid)
+                        .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                        .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                        .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
                 })
-            });
+            })
+        });
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +765,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +778,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:08:48] thinking

**Noting build failure and gathering status**
[2025-09-22T01:08:48] exec bash -lc 'git status -sb' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:08:48] bash -lc 'git status -sb' succeeded in 21ms:
## main
 M docs/manual.md
 M src/graph.rs
 M src/settings.rs
[2025-09-22T01:08:48] tokens used: 61,310
[2025-09-22T01:08:48] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..47ff01ec0cf34813a9ba2e6549199a43e239d98d
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,70 @@
     Ok(branches)
 }
 
+/// Adds a `fork/` prefix to merged branches whose names match their merge targets.
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx =
+            commits[merge_commit_idx]
+                .branches
+                .iter()
+                .copied()
+                .find(|target_idx| {
+                    *target_idx != branch_idx
+                        && branches
+                            .get(*target_idx)
+                            .map(|target_branch| target_branch.name == original_name)
+                            .unwrap_or(false)
+                });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color = to_terminal_color(&terminal_color)?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -672,24 +739,22 @@
     }
 
     for branch_idx in 0..branches.len() {
-        let source_group = branch_commits
-            .get(branch_idx)
-            .and_then(|indices_for_branch| {
-                indices_for_branch.iter().rev().find_map(|commit_idx| {
-                    let info = &commits[*commit_idx];
-                    info.parents.iter().flatten().find_map(|parent_oid| {
-                        indices
-                            .get(parent_oid)
-                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
-                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
-                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
-                    })
+        let source_group = branch_commits.get(branch_idx).map(|indices_for_branch| {
+            indices_for_branch.iter().rev().find_map(|commit_idx| {
+                let info = &commits[*commit_idx];
+                info.parents.iter().flatten().find_map(|parent_oid| {
+                    indices
+                        .get(parent_oid)
+                        .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                        .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                        .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
                 })
-            });
+            })
+        });
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +765,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +778,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:08:54] thinking

**Preparing commit and verifying changes**
[2025-09-22T01:08:55] exec bash -lc 'git add -A' in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:08:55] bash -lc 'git add -A' succeeded in 45ms:

[2025-09-22T01:08:55] tokens used: 61,830
[2025-09-22T01:08:55] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..47ff01ec0cf34813a9ba2e6549199a43e239d98d
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,70 @@
     Ok(branches)
 }
 
+/// Adds a `fork/` prefix to merged branches whose names match their merge targets.
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx =
+            commits[merge_commit_idx]
+                .branches
+                .iter()
+                .copied()
+                .find(|target_idx| {
+                    *target_idx != branch_idx
+                        && branches
+                            .get(*target_idx)
+                            .map(|target_branch| target_branch.name == original_name)
+                            .unwrap_or(false)
+                });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color = to_terminal_color(&terminal_color)?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -672,24 +739,22 @@
     }
 
     for branch_idx in 0..branches.len() {
-        let source_group = branch_commits
-            .get(branch_idx)
-            .and_then(|indices_for_branch| {
-                indices_for_branch.iter().rev().find_map(|commit_idx| {
-                    let info = &commits[*commit_idx];
-                    info.parents.iter().flatten().find_map(|parent_oid| {
-                        indices
-                            .get(parent_oid)
-                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
-                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
-                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
-                    })
+        let source_group = branch_commits.get(branch_idx).map(|indices_for_branch| {
+            indices_for_branch.iter().rev().find_map(|commit_idx| {
+                let info = &commits[*commit_idx];
+                info.parents.iter().flatten().find_map(|parent_oid| {
+                    indices
+                        .get(parent_oid)
+                        .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                        .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                        .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
                 })
-            });
+            })
+        });
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +765,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +778,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:08:57] thinking

**Committing code changes**
[2025-09-22T01:08:58] exec bash -lc "git commit -m '090-fedbabf：复现提交代码内容。'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:08:58] bash -lc "git commit -m '090-fedbabf：复现提交代码内容。'" succeeded in 33ms:
[main 17f1682] 090-fedbabf：复现提交代码内容。
 3 files changed, 99 insertions(+), 23 deletions(-)
[2025-09-22T01:08:58] tokens used: 62,089
[2025-09-22T01:08:58] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..47ff01ec0cf34813a9ba2e6549199a43e239d98d
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,70 @@
     Ok(branches)
 }
 
+/// Adds a `fork/` prefix to merged branches whose names match their merge targets.
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx =
+            commits[merge_commit_idx]
+                .branches
+                .iter()
+                .copied()
+                .find(|target_idx| {
+                    *target_idx != branch_idx
+                        && branches
+                            .get(*target_idx)
+                            .map(|target_branch| target_branch.name == original_name)
+                            .unwrap_or(false)
+                });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color = to_terminal_color(&terminal_color)?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -672,24 +739,22 @@
     }
 
     for branch_idx in 0..branches.len() {
-        let source_group = branch_commits
-            .get(branch_idx)
-            .and_then(|indices_for_branch| {
-                indices_for_branch.iter().rev().find_map(|commit_idx| {
-                    let info = &commits[*commit_idx];
-                    info.parents.iter().flatten().find_map(|parent_oid| {
-                        indices
-                            .get(parent_oid)
-                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
-                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
-                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
-                    })
+        let source_group = branch_commits.get(branch_idx).map(|indices_for_branch| {
+            indices_for_branch.iter().rev().find_map(|commit_idx| {
+                let info = &commits[*commit_idx];
+                info.parents.iter().flatten().find_map(|parent_oid| {
+                    indices
+                        .get(parent_oid)
+                        .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                        .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                        .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
                 })
-            });
+            })
+        });
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +765,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +778,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:09:07] thinking

**Preparing detailed modification summary**

I’m gathering exact line numbers from changed files to clearly reference where I introduced constants and functions, noting the `cargo build` issue near line 506 in `src/print/unicode.rs`. I want to create a precise final summary that flags the build failure, lists key edits with file paths and line numbers, and confirms formatting with `cargo fmt`, even if some lines shift slightly. This should help the user verify exactly what changed.
[2025-09-22T01:09:08] exec bash -lc "nl -ba src/graph.rs | sed -n '1,40p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:09:08] bash -lc "nl -ba src/graph.rs | sed -n '1,40p'" succeeded in 28ms:
     1	//! A graph structure representing the history of a Git repository.
     2	
     3	use crate::print::colors::to_terminal_color;
     4	use crate::settings::{BranchOrder, BranchSettings, MergePatterns, Settings};
     5	use git2::{BranchType, Commit, Error, Oid, Reference, Repository};
     6	use itertools::Itertools;
     7	use regex::Regex;
     8	use std::cmp;
     9	use std::collections::{HashMap, HashSet};
    10	
    11	const ORIGIN: &str = "origin/";
    12	const FORK: &str = "fork/";
    13	
    14	/// Represents a git history graph.
    15	pub struct GitGraph {
    16	    pub repository: Repository,
    17	    pub commits: Vec<CommitInfo>,
    18	    pub indices: HashMap<Oid, usize>,
    19	    pub all_branches: Vec<BranchInfo>,
    20	    pub branches: Vec<usize>,
[2025-09-22T01:09:08] tokens used: 62,560
[2025-09-22T01:09:08] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..47ff01ec0cf34813a9ba2e6549199a43e239d98d
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,70 @@
     Ok(branches)
 }
 
+/// Adds a `fork/` prefix to merged branches whose names match their merge targets.
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx =
+            commits[merge_commit_idx]
+                .branches
+                .iter()
+                .copied()
+                .find(|target_idx| {
+                    *target_idx != branch_idx
+                        && branches
+                            .get(*target_idx)
+                            .map(|target_branch| target_branch.name == original_name)
+                            .unwrap_or(false)
+                });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color = to_terminal_color(&terminal_color)?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -672,24 +739,22 @@
     }
 
     for branch_idx in 0..branches.len() {
-        let source_group = branch_commits
-            .get(branch_idx)
-            .and_then(|indices_for_branch| {
-                indices_for_branch.iter().rev().find_map(|commit_idx| {
-                    let info = &commits[*commit_idx];
-                    info.parents.iter().flatten().find_map(|parent_oid| {
-                        indices
-                            .get(parent_oid)
-                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
-                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
-                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
-                    })
+        let source_group = branch_commits.get(branch_idx).map(|indices_for_branch| {
+            indices_for_branch.iter().rev().find_map(|commit_idx| {
+                let info = &commits[*commit_idx];
+                info.parents.iter().flatten().find_map(|parent_oid| {
+                    indices
+                        .get(parent_oid)
+                        .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                        .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                        .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
                 })
-            });
+            })
+        });
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +765,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +778,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:09:12] thinking

**Identifying function call locations**
[2025-09-22T01:09:12] exec bash -lc "nl -ba src/graph.rs | sed -n '60,120p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:09:12] bash -lc "nl -ba src/graph.rs | sed -n '60,120p'" succeeded in 20ms:
    60	            let oid = oid.map_err(|err| err.message().to_string())?;
    61	
    62	            if !stashes.contains(&oid) {
    63	                let commit = repository.find_commit(oid).unwrap();
    64	
    65	                commits.push(CommitInfo::new(&commit));
    66	                indices.insert(oid, idx);
    67	                idx += 1;
    68	            }
    69	        }
    70	        assign_children(&mut commits, &indices);
    71	
    72	        let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
    73	
    74	        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
    75	
    76	        assign_sources_targets(&commits, &indices, &mut all_branches);
    77	
    78	        match settings.branch_order {
    79	            BranchOrder::ShortestFirst(forward) => assign_branch_columns(
[2025-09-22T01:09:12] tokens used: 63,254
[2025-09-22T01:09:12] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..47ff01ec0cf34813a9ba2e6549199a43e239d98d
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,70 @@
     Ok(branches)
 }
 
+/// Adds a `fork/` prefix to merged branches whose names match their merge targets.
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx =
+            commits[merge_commit_idx]
+                .branches
+                .iter()
+                .copied()
+                .find(|target_idx| {
+                    *target_idx != branch_idx
+                        && branches
+                            .get(*target_idx)
+                            .map(|target_branch| target_branch.name == original_name)
+                            .unwrap_or(false)
+                });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color = to_terminal_color(&terminal_color)?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -672,24 +739,22 @@
     }
 
     for branch_idx in 0..branches.len() {
-        let source_group = branch_commits
-            .get(branch_idx)
-            .and_then(|indices_for_branch| {
-                indices_for_branch.iter().rev().find_map(|commit_idx| {
-                    let info = &commits[*commit_idx];
-                    info.parents.iter().flatten().find_map(|parent_oid| {
-                        indices
-                            .get(parent_oid)
-                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
-                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
-                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
-                    })
+        let source_group = branch_commits.get(branch_idx).map(|indices_for_branch| {
+            indices_for_branch.iter().rev().find_map(|commit_idx| {
+                let info = &commits[*commit_idx];
+                info.parents.iter().flatten().find_map(|parent_oid| {
+                    indices
+                        .get(parent_oid)
+                        .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                        .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                        .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
                 })
-            });
+            })
+        });
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +765,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +778,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:09:16] thinking

**Verifying function location details**
[2025-09-22T01:09:16] exec bash -lc "nl -ba src/graph.rs | sed -n '320,420p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:09:16] bash -lc "nl -ba src/graph.rs | sed -n '320,420p'" succeeded in 31ms:
   320	                if is_tag {
   321	                    info.tags.push(old_idx);
   322	                } else if !is_merged {
   323	                    info.branches.push(old_idx);
   324	                }
   325	                let oid = info.oid;
   326	                let any_assigned =
   327	                    trace_branch(repository, commits, &indices, &mut branches, oid, old_idx)
   328	                        .unwrap_or(false);
   329	
   330	                if any_assigned || !is_merged {
   331	                    branch_idx += 1;
   332	                    Some(branch_idx - 1)
   333	                } else {
   334	                    None
   335	                }
   336	            } else {
   337	                None
   338	            }
   339	        })
[2025-09-22T01:09:16] tokens used: 64,245
[2025-09-22T01:09:16] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..47ff01ec0cf34813a9ba2e6549199a43e239d98d
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,70 @@
     Ok(branches)
 }
 
+/// Adds a `fork/` prefix to merged branches whose names match their merge targets.
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx =
+            commits[merge_commit_idx]
+                .branches
+                .iter()
+                .copied()
+                .find(|target_idx| {
+                    *target_idx != branch_idx
+                        && branches
+                            .get(*target_idx)
+                            .map(|target_branch| target_branch.name == original_name)
+                            .unwrap_or(false)
+                });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color = to_terminal_color(&terminal_color)?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -672,24 +739,22 @@
     }
 
     for branch_idx in 0..branches.len() {
-        let source_group = branch_commits
-            .get(branch_idx)
-            .and_then(|indices_for_branch| {
-                indices_for_branch.iter().rev().find_map(|commit_idx| {
-                    let info = &commits[*commit_idx];
-                    info.parents.iter().flatten().find_map(|parent_oid| {
-                        indices
-                            .get(parent_oid)
-                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
-                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
-                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
-                    })
+        let source_group = branch_commits.get(branch_idx).map(|indices_for_branch| {
+            indices_for_branch.iter().rev().find_map(|commit_idx| {
+                let info = &commits[*commit_idx];
+                info.parents.iter().flatten().find_map(|parent_oid| {
+                    indices
+                        .get(parent_oid)
+                        .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                        .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                        .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
                 })
-            });
+            })
+        });
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +765,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +778,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:09:20] thinking

**Fetching more lines for context**
[2025-09-22T01:09:20] exec bash -lc "nl -ba src/graph.rs | sed -n '420,480p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:09:20] bash -lc "nl -ba src/graph.rs | sed -n '420,480p'" succeeded in 28ms:
   420	                            .map(|target_branch| target_branch.name == original_name)
   421	                            .unwrap_or(false)
   422	                });
   423	
   424	        if conflicting_branch_idx.is_none() {
   425	            continue;
   426	        }
   427	
   428	        let branch = &mut branches[branch_idx];
   429	        branch.name = format!("{}{}", FORK, original_name);
   430	        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
   431	        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
   432	
   433	        let terminal_color = branch_color(
   434	            &branch.name,
   435	            &settings.branches.terminal_colors[..],
   436	            &settings.branches.terminal_colors_unknown,
   437	            branch_idx + 1,
   438	        );
   439	
[2025-09-22T01:09:20] tokens used: 65,589
[2025-09-22T01:09:20] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..47ff01ec0cf34813a9ba2e6549199a43e239d98d
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,70 @@
     Ok(branches)
 }
 
+/// Adds a `fork/` prefix to merged branches whose names match their merge targets.
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx =
+            commits[merge_commit_idx]
+                .branches
+                .iter()
+                .copied()
+                .find(|target_idx| {
+                    *target_idx != branch_idx
+                        && branches
+                            .get(*target_idx)
+                            .map(|target_branch| target_branch.name == original_name)
+                            .unwrap_or(false)
+                });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color = to_terminal_color(&terminal_color)?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -672,24 +739,22 @@
     }
 
     for branch_idx in 0..branches.len() {
-        let source_group = branch_commits
-            .get(branch_idx)
-            .and_then(|indices_for_branch| {
-                indices_for_branch.iter().rev().find_map(|commit_idx| {
-                    let info = &commits[*commit_idx];
-                    info.parents.iter().flatten().find_map(|parent_oid| {
-                        indices
-                            .get(parent_oid)
-                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
-                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
-                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
-                    })
+        let source_group = branch_commits.get(branch_idx).map(|indices_for_branch| {
+            indices_for_branch.iter().rev().find_map(|commit_idx| {
+                let info = &commits[*commit_idx];
+                info.parents.iter().flatten().find_map(|parent_oid| {
+                    indices
+                        .get(parent_oid)
+                        .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                        .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                        .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
                 })
-            });
+            })
+        });
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +765,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +778,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:09:23] thinking

**Noting need for line numbers**
[2025-09-22T01:09:23] exec bash -lc "nl -ba src/graph.rs | sed -n '700,820p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:09:23] bash -lc "nl -ba src/graph.rs | sed -n '700,820p'" succeeded in 33ms:
   700	                break;
   701	            }
   702	            _ => {
   703	                prev_index = Some(*index);
   704	                curr_oid = commit.parent_id(0)?;
   705	            }
   706	        }
   707	    }
   708	
   709	    let branch = &mut branches[branch_index];
   710	    if let Some(end) = branch.range.0 {
   711	        if let Some(start_index) = start_index {
   712	            if start_index < end as i32 {
   713	                // TODO: find a better solution (bool field?) to identify non-deleted branches that were not assigned to any commits, and thus should not occupy a column.
   714	                branch.range = (None, None);
   715	            } else {
   716	                branch.range = (branch.range.0, Some(start_index as usize));
   717	            }
   718	        } else {
   719	            branch.range = (branch.range.0, None);
[2025-09-22T01:09:23] tokens used: 66,498
[2025-09-22T01:09:23] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..47ff01ec0cf34813a9ba2e6549199a43e239d98d
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,70 @@
     Ok(branches)
 }
 
+/// Adds a `fork/` prefix to merged branches whose names match their merge targets.
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx =
+            commits[merge_commit_idx]
+                .branches
+                .iter()
+                .copied()
+                .find(|target_idx| {
+                    *target_idx != branch_idx
+                        && branches
+                            .get(*target_idx)
+                            .map(|target_branch| target_branch.name == original_name)
+                            .unwrap_or(false)
+                });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color = to_terminal_color(&terminal_color)?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -672,24 +739,22 @@
     }
 
     for branch_idx in 0..branches.len() {
-        let source_group = branch_commits
-            .get(branch_idx)
-            .and_then(|indices_for_branch| {
-                indices_for_branch.iter().rev().find_map(|commit_idx| {
-                    let info = &commits[*commit_idx];
-                    info.parents.iter().flatten().find_map(|parent_oid| {
-                        indices
-                            .get(parent_oid)
-                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
-                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
-                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
-                    })
+        let source_group = branch_commits.get(branch_idx).map(|indices_for_branch| {
+            indices_for_branch.iter().rev().find_map(|commit_idx| {
+                let info = &commits[*commit_idx];
+                info.parents.iter().flatten().find_map(|parent_oid| {
+                    indices
+                        .get(parent_oid)
+                        .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                        .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                        .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
                 })
-            });
+            })
+        });
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +765,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +778,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:09:26] thinking

**Tracking manual modifications with line numbers**
[2025-09-22T01:09:27] exec bash -lc "nl -ba docs/manual.md | sed -n '240,320p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:09:27] bash -lc "nl -ba docs/manual.md | sed -n '240,320p'" succeeded in 26ms:
   240	```toml
   241	# RegEx patterns for branch groups by persistence, from most persistent
   242	# to most short-leved branches. This is used to back-trace branches.
   243	# Branches not matching any pattern are assumed least persistent.
   244	persistence = [
   245	    '^(master|main)$', # Matches exactly `master` or `main`
   246	    '^(develop|dev)$',
   247	    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
   248	    '^release.*$',
   249	    '^hotfix.*$',
   250	    '^bugfix.*$',
   251	]
   252	
   253	# RegEx patterns for visual ordering of branches, from left to right.
   254	# Here, `master` or `main` are shown left-most, followed by branches
   255	# starting with `hotfix` or `release`, followed by `develop` or `dev`.
   256	# Branches not matching any pattern (e.g. starting with `topic`)
   257	# are displayed further to the right.
   258	order = [
   259	    '^(master|main)$',      # Matches exactly `master` or `main`
[2025-09-22T01:09:27] tokens used: 68,344
[2025-09-22T01:09:27] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..47ff01ec0cf34813a9ba2e6549199a43e239d98d
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,70 @@
     Ok(branches)
 }
 
+/// Adds a `fork/` prefix to merged branches whose names match their merge targets.
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx =
+            commits[merge_commit_idx]
+                .branches
+                .iter()
+                .copied()
+                .find(|target_idx| {
+                    *target_idx != branch_idx
+                        && branches
+                            .get(*target_idx)
+                            .map(|target_branch| target_branch.name == original_name)
+                            .unwrap_or(false)
+                });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color = to_terminal_color(&terminal_color)?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -672,24 +739,22 @@
     }
 
     for branch_idx in 0..branches.len() {
-        let source_group = branch_commits
-            .get(branch_idx)
-            .and_then(|indices_for_branch| {
-                indices_for_branch.iter().rev().find_map(|commit_idx| {
-                    let info = &commits[*commit_idx];
-                    info.parents.iter().flatten().find_map(|parent_oid| {
-                        indices
-                            .get(parent_oid)
-                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
-                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
-                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
-                    })
+        let source_group = branch_commits.get(branch_idx).map(|indices_for_branch| {
+            indices_for_branch.iter().rev().find_map(|commit_idx| {
+                let info = &commits[*commit_idx];
+                info.parents.iter().flatten().find_map(|parent_oid| {
+                    indices
+                        .get(parent_oid)
+                        .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                        .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                        .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
                 })
-            });
+            })
+        });
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +765,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +778,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:09:31] thinking

**Preparing to reference line numbers**
[2025-09-22T01:09:31] exec bash -lc "nl -ba src/settings.rs | sed -n '70,130p'" in /Users/jqwang/104-CommitLens-codex/.workspace/rust-project
[2025-09-22T01:09:31] bash -lc "nl -ba src/settings.rs | sed -n '70,130p'" succeeded in 27ms:
    70	    matches: Vec<(String, Vec<String>)>,
    71	    unknown: Vec<String>,
    72	}
    73	
    74	impl BranchSettingsDef {
    75	    /// The Git-Flow model.
    76	    pub fn git_flow() -> Self {
    77	        BranchSettingsDef {
    78	            persistence: vec![
    79	                r"^(master|main)$".to_string(),
    80	                r"^(develop|dev)$".to_string(),
    81	                r"^(feature|fork/).*$".to_string(),
    82	                r"^release.*$".to_string(),
    83	                r"^hotfix.*$".to_string(),
    84	                r"^bugfix.*$".to_string(),
    85	            ],
    86	            order: vec![
    87	                r"^(master|main)$".to_string(),
    88	                r"^(hotfix|release).*$".to_string(),
    89	                r"^(develop|dev)$".to_string(),
[2025-09-22T01:09:31] tokens used: 69,535
[2025-09-22T01:09:31] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..47ff01ec0cf34813a9ba2e6549199a43e239d98d
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,70 @@
     Ok(branches)
 }
 
+/// Adds a `fork/` prefix to merged branches whose names match their merge targets.
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx =
+            commits[merge_commit_idx]
+                .branches
+                .iter()
+                .copied()
+                .find(|target_idx| {
+                    *target_idx != branch_idx
+                        && branches
+                            .get(*target_idx)
+                            .map(|target_branch| target_branch.name == original_name)
+                            .unwrap_or(false)
+                });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color = to_terminal_color(&terminal_color)?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -672,24 +739,22 @@
     }
 
     for branch_idx in 0..branches.len() {
-        let source_group = branch_commits
-            .get(branch_idx)
-            .and_then(|indices_for_branch| {
-                indices_for_branch.iter().rev().find_map(|commit_idx| {
-                    let info = &commits[*commit_idx];
-                    info.parents.iter().flatten().find_map(|parent_oid| {
-                        indices
-                            .get(parent_oid)
-                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
-                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
-                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
-                    })
+        let source_group = branch_commits.get(branch_idx).map(|indices_for_branch| {
+            indices_for_branch.iter().rev().find_map(|commit_idx| {
+                let info = &commits[*commit_idx];
+                info.parents.iter().flatten().find_map(|parent_oid| {
+                    indices
+                        .get(parent_oid)
+                        .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                        .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                        .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
                 })
-            });
+            })
+        });
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +765,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +778,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


[2025-09-22T01:09:46] thinking

**Preparing final response with detailed modifications**

I'll organize the final message into clear sections highlighting the key code changes with line references, note the cargo build failure at `src/print/unicode.rs:506`, mention running `cargo fmt`, and suggest next steps for verification. I'll keep the tone friendly and concise using bullet points and appropriate headers.
[2025-09-22T01:09:46] codex

**修改**
- `src/graph.rs:11` 引入 `FORK` 前缀常量，并在 `GitGraph::new` 中调用新的 `correct_fork_merges`（`src/graph.rs:74`）；`correct_fork_merges`（`src/graph.rs:388`）会在检测到与合并目标同名的分支时加上 `fork/` 前缀并重算排序/配色；`assign_sources_targets` 的赋值改为双重 `Option` 校验（`src/graph.rs:742`）以避免无效写入。
- `src/settings.rs:81`、`src/settings.rs:102`、`src/settings.rs:120` 更新 Git-Flow 默认正则，使 `fork/` 前缀与 `feature` 一起归类并继承颜色设置。
- `docs/manual.md:247`、`docs/manual.md:279` 调整示例配置，同时补充说明 `fork/` 仅影响可视化的排序与配色，不会写回 Git 引用（`docs/manual.md:315`）。

**验证**
- `cargo fmt`
- `cargo build` 仍因既有生命周期错误失败：`src/print/unicode.rs:506` 报 `missing lifetime specifier`（未在本提交范围内修复）。

**后续**
1. 修正 `src/print/unicode.rs:506` 的生命周期签名后，再次执行 `cargo build` 验证。
[2025-09-22T01:09:49] tokens used: 71,710
[2025-09-22T01:09:49] turn diff:
diff --git a/docs/manual.md b/docs/manual.md
index 55683b231db672c69278de75a41f152bff7495fb..3f5dcf814664dc27f1369f9b615d2e13d4eb2d6d
--- a/docs/manual.md
+++ b/docs/manual.md
@@ -244,7 +244,7 @@
 persistence = [
     '^(master|main)$', # Matches exactly `master` or `main`
     '^(develop|dev)$',
-    '^feature.*$',     # Matches everything starting with `feature`
+    '^(feature|fork/).*$', # Matches branches starting with `feature` or `fork/`
     '^release.*$',
     '^hotfix.*$',
     '^bugfix.*$',
@@ -253,7 +253,7 @@
 # RegEx patterns for visual ordering of branches, from left to right.
 # Here, `master` or `main` are shown left-most, followed by branches
 # starting with `hotfix` or `release`, followed by `develop` or `dev`.
-# Branches not matching any pattern (e.g. starting with `feature`)
+# Branches not matching any pattern (e.g. starting with `topic`)
 # are displayed further to the right.
 order = [
     '^(master|main)$',      # Matches exactly `master` or `main`
@@ -276,7 +276,7 @@
         ['bright_yellow'],
     ],
     [
-        '^feature.*$',
+        '^(feature|fork/).*$',
         ['bright_magenta', 'bright_cyan'], # Multiple colors for alternating use
     ],
         [
@@ -312,6 +312,10 @@
 unknown = ['gray']
 ```
 
+Branches merged from forks that share the same name as the target branch are
+prefixed with `fork/`. The prefix influences ordering and coloring only inside
+git-graph and is not written back to Git references.
+
 **Tags**
 
 Internally, all tags start with `tag/`. To match Git tags, use RegEx patterns like `^tags/.*$`. However, only tags that are not on any branch are ordered and colored separately.
diff --git a/src/graph.rs b/src/graph.rs
index f983d2cff6f6a4d368c2aea3cf8396c59468d4cc..47ff01ec0cf34813a9ba2e6549199a43e239d98d
--- a/src/graph.rs
+++ b/src/graph.rs
@@ -9,6 +9,7 @@
 use std::collections::{HashMap, HashSet};
 
 const ORIGIN: &str = "origin/";
+const FORK: &str = "fork/";
 
 /// Represents a git history graph.
 pub struct GitGraph {
@@ -70,6 +71,8 @@
 
         let mut all_branches = assign_branches(&repository, &mut commits, &indices, &settings)?;
 
+        correct_fork_merges(&commits, &indices, &mut all_branches, &settings)?;
+
         assign_sources_targets(&commits, &indices, &mut all_branches);
 
         match settings.branch_order {
@@ -382,6 +385,70 @@
     Ok(branches)
 }
 
+/// Adds a `fork/` prefix to merged branches whose names match their merge targets.
+fn correct_fork_merges(
+    commits: &[CommitInfo],
+    indices: &HashMap<Oid, usize>,
+    branches: &mut [BranchInfo],
+    settings: &Settings,
+) -> Result<(), String> {
+    for branch_idx in 0..branches.len() {
+        let merge_target = match branches[branch_idx].merge_target {
+            Some(target) => target,
+            None => continue,
+        };
+
+        let original_name = branches[branch_idx].name.clone();
+        if original_name.starts_with(FORK) {
+            continue;
+        }
+
+        let merge_commit_idx = match indices.get(&merge_target).copied() {
+            Some(idx) => idx,
+            None => continue,
+        };
+
+        let conflicting_branch_idx =
+            commits[merge_commit_idx]
+                .branches
+                .iter()
+                .copied()
+                .find(|target_idx| {
+                    *target_idx != branch_idx
+                        && branches
+                            .get(*target_idx)
+                            .map(|target_branch| target_branch.name == original_name)
+                            .unwrap_or(false)
+                });
+
+        if conflicting_branch_idx.is_none() {
+            continue;
+        }
+
+        let branch = &mut branches[branch_idx];
+        branch.name = format!("{}{}", FORK, original_name);
+        branch.persistence = branch_order(&branch.name, &settings.branches.persistence) as u8;
+        branch.visual.order_group = branch_order(&branch.name, &settings.branches.order);
+
+        let terminal_color = branch_color(
+            &branch.name,
+            &settings.branches.terminal_colors[..],
+            &settings.branches.terminal_colors_unknown,
+            branch_idx + 1,
+        );
+
+        branch.visual.term_color = to_terminal_color(&terminal_color)?;
+        branch.visual.svg_color = branch_color(
+            &branch.name,
+            &settings.branches.svg_colors,
+            &settings.branches.svg_colors_unknown,
+            branch_idx + 1,
+        );
+    }
+
+    Ok(())
+}
+
 /// Extracts (real or derived from merge summary) and assigns basic properties.
 fn extract_branches(
     repository: &Repository,
@@ -672,24 +739,22 @@
     }
 
     for branch_idx in 0..branches.len() {
-        let source_group = branch_commits
-            .get(branch_idx)
-            .and_then(|indices_for_branch| {
-                indices_for_branch.iter().rev().find_map(|commit_idx| {
-                    let info = &commits[*commit_idx];
-                    info.parents.iter().flatten().find_map(|parent_oid| {
-                        indices
-                            .get(parent_oid)
-                            .and_then(|parent_idx| commits[*parent_idx].branch_trace)
-                            .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
-                            .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
-                    })
+        let source_group = branch_commits.get(branch_idx).map(|indices_for_branch| {
+            indices_for_branch.iter().rev().find_map(|commit_idx| {
+                let info = &commits[*commit_idx];
+                info.parents.iter().flatten().find_map(|parent_oid| {
+                    indices
+                        .get(parent_oid)
+                        .and_then(|parent_idx| commits[*parent_idx].branch_trace)
+                        .filter(|parent_branch_idx| *parent_branch_idx != branch_idx)
+                        .map(|parent_branch_idx| branches[parent_branch_idx].visual.order_group)
                 })
-            });
+            })
+        });
 
         let target_group = branches[branch_idx]
             .merge_target
-            .and_then(|target_oid| {
+            .map(|target_oid| {
                 indices
                     .get(&target_oid)
                     .and_then(|target_idx| commits[*target_idx].branch_trace)
@@ -700,7 +765,7 @@
                 branch_commits
                     .get(branch_idx)
                     .and_then(|indices_for_branch| indices_for_branch.first())
-                    .and_then(|head_idx| {
+                    .map(|head_idx| {
                         commits[*head_idx].children.iter().find_map(|child| {
                             indices
                                 .get(child)
@@ -713,8 +778,15 @@
                     })
             });
 
-        branches[branch_idx].visual.source_order_group = source_group;
-        branches[branch_idx].visual.target_order_group = target_group;
+        branches[branch_idx].visual.source_order_group = match source_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
+
+        branches[branch_idx].visual.target_order_group = match target_group {
+            Some(Some(order)) => Some(order),
+            _ => None,
+        };
     }
 }
 
diff --git a/src/settings.rs b/src/settings.rs
index 7ea4188feb608c6a3738472d96dd79b1a5e1495b..2bd74c35869095dbdbd7857aca4813c26b474a61
--- a/src/settings.rs
+++ b/src/settings.rs
@@ -78,7 +78,7 @@
             persistence: vec![
                 r"^(master|main)$".to_string(),
                 r"^(develop|dev)$".to_string(),
-                r"^feature.*$".to_string(),
+                r"^(feature|fork/).*$".to_string(),
                 r"^release.*$".to_string(),
                 r"^hotfix.*$".to_string(),
                 r"^bugfix.*$".to_string(),
@@ -99,7 +99,7 @@
                         vec!["bright_yellow".to_string()],
                     ),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["bright_magenta".to_string(), "bright_cyan".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["bright_green".to_string()]),
@@ -117,7 +117,7 @@
                     (r"^(master|main)$".to_string(), vec!["blue".to_string()]),
                     (r"^(develop|dev)$".to_string(), vec!["orange".to_string()]),
                     (
-                        r"^feature.*$".to_string(),
+                        r"^(feature|fork/).*$".to_string(),
                         vec!["purple".to_string(), "turquoise".to_string()],
                     ),
                     (r"^release.*$".to_string(), vec!["green".to_string()]),


=== 最终状态 ===
返回码: 0
状态: ✅ 执行成功
